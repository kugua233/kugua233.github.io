<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2019年终总结：成为大海，刻不容缓</title>
    <url>/2020/01/04/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/2019%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93%EF%BC%9A%E6%88%90%E4%B8%BA%E5%A4%A7%E6%B5%B7%EF%BC%8C%E5%88%BB%E4%B8%8D%E5%AE%B9%E7%BC%93/</url>
    <content><![CDATA[<p><img src="/2020/01/04/年终总结/2019年终总结：成为大海，刻不容缓/00.jpg" alt></p>
<hr>
<p>​        2019，被大多数温暖环绕，偶尔一些人生瞬间变得冰冷和坚硬，无法躲避。但还好，一切终将过去。总的来说，2019并不简单，生活频繁出拳（胖虎的300斤铁拳，直立对打，凭着经验和运气躲过一些，另外一些结结实实地砸在脸上。可以说每一拳都不含糊，一击重拳，甚至可以感受到在脸上凝固停滞的拳气。不过今年也算是和生活对过几招了，本想着步步清风认真生活，凭阅历自撰一本《人间攻略》，大摇大摆地走上建设社会的征途，没想到生活反手甩一本《人间骚浪贱指南》，害，2019全线崩溃，2020推倒重来，希望今年和生活再次交手能从容一些了。</p>
<blockquote>
<p> 「说真的，你将来打算怎么办呢？」「我打算喝完这一杯」</p>
</blockquote>
<h2 id="研究生毕业失与得"><a href="#研究生毕业失与得" class="headerlink" title="研究生毕业失与得"></a>研究生毕业失与得</h2><ol>
<li><strong>毕业</strong> </li>
</ol>
<p>研究生三年，形象地说， 从一个小池塘跳到另外一个小池塘中，激起一朵Information Sciences期刊论文小浪花，然后扑通入水无踪影，从二十几岁精壮小伙想掏空世界的功利心来看，不值当。很难想象，这朵靠着身体抽搐翻腾出来小破花有多艰难，为啥别人的象牙塔是导师领进豪华直升电梯，直通塔顶，而我们要一步一爬，唉哟连特么象牙塔都是自己垒起来的，还好最后实验室人手一篇领域(次)顶刊，纷纷告别科研学术，有着不错的工作落脚处，也算是纯粹地感受了一把学术上知其然也知其所以然过程，人生历程多了一份体验，虽然不符预期，但也感激经历。</p>
<p>学校这几年忙忙忙，感觉也没忙出啥东西来，没发展别的兴趣，甜甜的恋爱还是没轮到我，好像蓝色大门里说的「 夏天就要过去了，我们好像什么都没做」「 是啊，就这样跑来跑去，什么都没做 」「那总会留下些什么吧，留下了什么，我们就会成为怎么样的大人 」</p>
<p>真要说有哪些值得关注的改变话，觉得还是有一些：</p>
<ul>
<li>喜欢上了摇滚乐</li>
<li>性格从怂包变得小型社恐（到今天似乎消除了，大家都一样，五五开）</li>
<li>资源搜索能力加强，有需要的东西可以独立自学</li>
<li>处理感情还是一塌糊涂，不能成熟表达爱与索取爱</li>
<li>总在试探，都在权衡，消散热爱的能力</li>
</ul>
<p>毕业的话，希望自己的期刊论文每年多一次引用吧，谷歌学术搜索排名能前一点，这个新年学术愿望不过分吧。</p>
<ol>
<li><strong>就业</strong></li>
</ol>
<p>面试造火箭，上班拧螺丝的故事早有耳闻，人力小姐姐萝莉外表杀人诛心可不含糊，论实力与面试的迷一样的相关函数，求职路上太多有意思的故事了，这一路也不容易。</p>
<p>忙着论文错过了秋招，磕磕碰碰地走上春招这条血路，太难了呀，简直比沥青未干的蜀道还难！一场场大型面试崩溃招聘现场， 黑压压一片学生，排着队递简历，精神上首先就完了。投了简历石沉大海，回来路上，真的是天空突然一道光打在你身上，自我怀疑的高光时刻。二十五岁这场人生三分之一考试，每次到交答卷才发现真的准备的不够充分。春招凭着发表的论文和一些算法竞赛的获奖，获得较多的面试机会，磕磕碰碰，沉舟侧畔，最后也算成功上岸了，有两个比较有印象的故事：</p>
<p> 1）投了一些大厂算法类的岗位无果后，参加了一个猎头帮改简历的招聘会，那天去的早， 现场没啥人，改完简历后和猎头大叔聊了起来，咔咔咔一顿哭诉当代年轻人的不容易，委屈大王，心酸2019，为啥生活不如意都落我这个失意年轻人的大头上！（那段时间感情状态、生活状态各方面真的是DOWN到深海几万里）。猎头大叔当时说啥我忘记了，总之谈了很久，他让我加油坚持，不要放低要求去小企业得以慰藉，年轻人要有年轻人的样子！我心中一顿爆暖，离开的时候还喊了我回来，握了握手，说很开心和我谈话。</p>
<p>2）一家基金公司，总裁面，到了给offer阶段，我说还有另外一家在考虑，她说来不来她这里没关系，年轻人找工作要好好考虑，要选对行业和团队，不要盯着一个岗位就上，并给了很多中肯的年轻人意见。我是很信仰人生经验攻略的，这些年一路过来，可太缺参考物了，最后没去还是很谢谢这些不给年轻人画饼，并愿意指导年轻人意见的大佬。</p>
<p>给毕业求职的同学一些建议：</p>
<ol>
<li>不要错过秋春招</li>
<li>清楚自己的满意和愿意接受的岗位</li>
<li>校招不像做饭，不需要等万事俱备才开始</li>
<li>每次多总结复盘，打铁还需自身硬</li>
<li>小心人力大姐</li>
</ol>
<blockquote>
<p>以上其实都是废话，多面几次自己就有谱了</p>
</blockquote>
<p>不管怎样，还是顺利毕业了嘿！</p>
<p><img src="/2020/01/04/年终总结/2019年终总结：成为大海，刻不容缓/02.jpg" alt></p>
<h2 id="自我管理"><a href="#自我管理" class="headerlink" title="自我管理"></a>自我管理</h2><p>​        <strong>1.睡眠</strong></p>
<p><img src="/2020/01/04/年终总结/2019年终总结：成为大海，刻不容缓/03.jpg" alt></p>
<p>出来搬砖以来，睡眠变得规律很多，七点起床，十点半准时雇人敲晕自己。睡眠时间大概维持在七个半小时，午休半小时，持续搬砖问题不大。周末一般会把一周攒起来的抖音刷一遍，看看天地之间的沙雕，安心睡去。</p>
<ol>
<li><strong>记账</strong></li>
</ol>
<p><img src="/2020/01/04/年终总结/2019年终总结：成为大海，刻不容缓/05.jpg" alt></p>
<p>​        不得不说，当代年轻人独立买房还是很艰难，看着每项支出其实也还好，但是汇到一起每月支出都会比想象的多，要是活动多一些也存不了几个钱。今年出来搬砖后，把银行和朋友借的钱都还清，自己日常支出也能稳定下来，这个感觉还是很棒的！</p>
<p>​        定投指数基金，3000点入场，做一颗茁壮成长的韭菜！</p>
<ol>
<li><strong>健康</strong></li>
</ol>
<p><img src="/2020/01/04/年终总结/2019年终总结：成为大海，刻不容缓/07.jpg" alt></p>
<p>​        今年做了个手术，还确诊了过敏性鼻炎，是要提醒自己该更加注意身体健康这一方面了。另外鼻炎应该是学校宿舍那台旧空调造成的，风口对着床吹，还滴水，每次在宿舍鼻子难受的不行，去到实验室马上就好了，弄到这个不治的毛病还是很痛苦的。目前的策略是上班走路走路走路！枸杞枸杞枸杞！泡脚泡脚泡脚！ 健身是没戏了，在学校都没能坚持下来，希望明年能坚持去游个泳吧。</p>
<h2 id="关于书影音"><a href="#关于书影音" class="headerlink" title="关于书影音"></a>关于书影音</h2><p>​        <img src="/2020/01/04/年终总结/2019年终总结：成为大海，刻不容缓/09.jpg" alt></p>
<p>五星电影：</p>
<ul>
<li>极限职业（韩）</li>
<li>调音师（印度）</li>
<li>海蒂和爷爷（德）</li>
<li>复仇者联盟4（美）</li>
<li>摇摆狂潮（韩）</li>
</ul>
<p>书籍：</p>
<ul>
<li>《代码整洁之道—程序员的职业素养》</li>
<li>《代码整洁之道—Clean》</li>
<li>《黑客与画家》</li>
<li>《交换梦想》</li>
<li>《宇宙超度指南》</li>
<li>《如何成为一个厉害的人》</li>
</ul>
<p>音乐演出</p>
<ul>
<li>陈知游园惊梦 2019避雨屋檐巡演</li>
<li>Brett乐队 2019巡演</li>
<li>文雀乐队 2019她从来不唱我们的歌巡演</li>
</ul>
<p><img src="/2020/01/04/年终总结/2019年终总结：成为大海，刻不容缓/10.png" alt></p>
<p>今年观影70+，还为观影事业买了个投影仪，每个周末的夜晚，100寸电子辐射的快乐，碳水化合物乐园，灵魂像膨化食品被打开时一样开心的裂开。听歌方面依然是摇滚为主，流行和民谣听一些，没想到居然Andrew Applepie成为了年度歌手，一度认为人类必须牵着手才能听Applepie，哎呀哎呀摇滚死了呀。</p>
<p>今年看书希望多看些编程类的工具书，数据库、理解框架是目前搬砖进阶的目标。</p>
<blockquote>
<p>不要为今年读书太少而难过，去年你也没读多少</p>
</blockquote>
<h2 id="Flag！Flag！Flag！"><a href="#Flag！Flag！Flag！" class="headerlink" title="Flag！Flag！Flag！"></a>Flag！Flag！Flag！</h2><ul>
<li><p>希望今年可以更自信地表达自己</p>
</li>
<li><p>搬出来一个人住，养条狗，或养个女朋友</p>
</li>
<li><p>尝试视频内容创作</p>
</li>
<li><p>开源一个自己感兴趣的工程项目</p>
</li>
<li><p>逛一逛动物园，打卡深圳所有公园</p>
</li>
<li><p>存钱买老婆</p>
</li>
</ul>
<p>总的来说，2019并不值得被总结，是经历当中最难的一年，有很多至暗时刻不愿提及，没必要铭记些什么，2019过去了就过去了。用一些不太恰当又很冗长的比喻就是， 就像聊了18个月的心理医生突然告诉你，我不能再给你做咨询了，因为我已经爱上你了； 就像一个易碎的老年人正盯着你并且缓缓插队，而你只好故作无睹 ；就像班上倒数第二辅导倒数第一课后习题，并且给出详细的解题思路 。2020不敢说万事顺利，希望新一年遇到的问题都是不太复杂自己慢慢能处理好的，新年加油！</p>
<p>新的一年，就不祝一帆风顺了，祝大家乘风破浪吧！</p>
<p>以上</p>
]]></content>
      <categories>
        <category>年终总结</category>
      </categories>
      <tags>
        <tag>年终总结</tag>
      </tags>
  </entry>
  <entry>
    <title>java入门基础（二）</title>
    <url>/2019/01/24/java/java%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>下面是一个异常处理块的通常形式： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// block of code to monitor for errors</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ExceptionType1 exOb) &#123;</span><br><span class="line">    <span class="comment">// exception handler for ExceptionType1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ExceptionType2 exOb) &#123; <span class="comment">//构造catch子句的目的是解决异常情况并且像错误没有发生一样继续运行。</span></span><br><span class="line">    <span class="comment">// exception handler for ExceptionType2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// block of code to be executed before try block ends</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，ExceptionType 是发生异常的类型。</p>
<h2 id="未被捕获的异常"><a href="#未被捕获的异常" class="headerlink" title="未被捕获的异常"></a>未被捕获的异常</h2><p>在你学习在程序中处理异常之前，看一看如果你不处理它们会有什么情况发生是很有好处的。下面的小程序包括一个故意导致被零除错误的表达式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Exc0</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> d = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">42</span> / d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当Java运行时系统检查到被零除的情况，它构造一个新的异常对象然后抛出该异常。这导致Exc0的执行停止，<strong>因为一旦一个异常被抛出，它必须被一个异常处理程序捕获并且被立即处理</strong>。该例中，<strong>我们没有提供任何我们自己的异常处理程序，所以异常被Java运行时系统的默认处理程序捕获。任何不是被你程序捕获的异常最终都会被该默认处理程序处理</strong>。默认处理程序显示一个描述异常的字符串，打印异常发生处的堆栈轨迹并且终止程序。</p>
<h2 id="throws子句"><a href="#throws子句" class="headerlink" title="throws子句"></a>throws子句</h2><p><strong>throws的作用是如果一个方法可以引发异常，而它本身并不对该异常处理，那么它必须将这个异常抛给调用它的方法。让容器、框架等更高层的东东去捕获异常并处理。</strong> </p>
<p>如果一个方法可以导致一个异常但不处理它，它必须指定这种行为以使方法的调用者可以保护它们自己而不发生异常。做到这点你可以在方法声明中包含一个throws子句。一个 throws 子句列举了一个方法可能抛出的所有异常类型。这对于除Error或RuntimeException及它们子类以外类型的所有异常是必要的。一个方法可以抛出的所有其他类型的异常必须在throws子句中声明。如果不这样做，将会导致编译错误。</p>
<p>下面是包含一个throws子句的方法声明的通用形式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">type method-name(parameter-list) <span class="keyword">throws</span> exception-list&#123;</span><br><span class="line">    <span class="comment">// body of method</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，exception-list是该方法可以抛出的以有逗号分割的异常列表。</p>
<h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p>断言用于证明和测试程序的假设，比如“这里的值大于 5”。</p>
<p>断言有两种方法：</p>
<ul>
<li>一种是 assert&lt;&lt;布尔表达式&gt;&gt; ；</li>
<li>另一种是 assert&lt;&lt;布尔表达式&gt;&gt; ：&lt;&lt;细节描述&gt;&gt;。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assert</span> x == <span class="number">10</span> : <span class="string">"Our assertion failed"</span>;</span><br></pre></td></tr></table></figure>
<h1 id="深入理解java异常处理机制"><a href="#深入理解java异常处理机制" class="headerlink" title="深入理解java异常处理机制"></a>深入理解java异常处理机制</h1><p>Java通 过API中Throwable类的众多子类描述各种不同的异常。因而，Java异常都是对象，是Throwable子类的实例，描述了出现在一段编码中的 错误条件。当条件生成时，错误将引发异常。 </p>
<h2 id="Exception（异常）和-Error（错误）"><a href="#Exception（异常）和-Error（错误）" class="headerlink" title="Exception（异常）和 Error（错误）"></a>Exception（异常）和 Error（错误）</h2><p>Throwable： 有两个重要的子类：Exception（异常）和 Error（错误），二者都是 Java 异常处理的重要子类，各自都包含大量子类。 </p>
<ul>
<li>Error（错误）:是程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。例如，Java虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。这些错误表示故障发生于虚拟机自身、或者发生在虚拟机试图执行应用时，如Java虚拟机运行错误（Virtual MachineError）、类定义错误（NoClassDefFoundError）等。这些错误是不可查的，因为它们在应用程序的控制和处理能力之 外，而且绝大多数是程序运行时不允许出现的状况。对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状况。在 Java中，错误通过Error的子类描述。</li>
<li>Exception（异常）:是程序本身可以处理的异常。Exception 类有一个重要的子类 RuntimeException。RuntimeException 类及其子类表示“JVM 常用操作”引发的错误。例如，若试图使用空值对象引用、除数为零或数组越界，则分别引发运行时异常（NullPointerException、ArithmeticException）和 ArrayIndexOutOfBoundException。</li>
</ul>
<p>注意：异常和错误的区别：异常能被程序本身可以处理，错误是无法处理。</p>
<h2 id="可查异常（checked-exceptions）和不可查异常（unchecked-exceptions）"><a href="#可查异常（checked-exceptions）和不可查异常（unchecked-exceptions）" class="headerlink" title="可查异常（checked exceptions）和不可查异常（unchecked exceptions）"></a>可查异常（checked exceptions）和不可查异常（unchecked exceptions）</h2><p>Java的异常(包括Exception和Error)分为可查的异常（checked exceptions）和不可查的异常（unchecked exceptions）。</p>
<blockquote>
<p>可查异常（编译器要求必须处置的异常）：</p>
</blockquote>
<p>正确的程序在运行中，很容易出现的、情理可容的异常状况。可查异常虽然是异常状况，但在一定程度上它的发生是可以预计的，而且一旦发生这种异常状况，就必须采取某种方式进行处理。 除了RuntimeException及其子类以外，其他的Exception类及其子类都属于可查异常。这种异常的特点是Java编译器会检查它，<strong>也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过</strong>。</p>
<blockquote>
<p>不可查异常(编译器不要求强制处置的异常):</p>
</blockquote>
<p>包括运行时异常（RuntimeException与其子类）和错误（Error）。</p>
<h2 id="处理异常机制"><a href="#处理异常机制" class="headerlink" title="处理异常机制"></a>处理异常机制</h2><p>在Java应用程序中，异常处理机制为：抛出异常，捕捉异常。</p>
<p>从方法中抛出的任何异常都必须使用throws子句。</p>
<p>捕捉异常通过try-catch语句或者try-catch-finally语句实现。</p>
<p>总体来说，Java规定，对于可查异常必须捕捉、或者声明抛出。允许忽略不可查的RuntimeException和Error。</p>
<h1 id="常用库类、向量与哈希"><a href="#常用库类、向量与哈希" class="headerlink" title="常用库类、向量与哈希"></a>常用库类、向量与哈希</h1><h2 id="Java基础类库"><a href="#Java基础类库" class="headerlink" title="Java基础类库"></a>Java基础类库</h2><p>Java 常用包的简单介绍如下：</p>
<ul>
<li>java.lang 包：主要含有与语言相关的类。java.lang 包由解释程序自动加载，不需要显示说明。</li>
<li>java.io 包：主要含有与输入/输出相关的类，这些类提供了对不同的输入和输出设备读写数据的支持，这些输入和输出设备包括键盘、显示器、打印机、磁盘文件等。</li>
<li>java.util 包：包括许多具有特定功能的类，有日期、向量、哈希表、堆栈等，其中 Date类支持与时间有关的操作。</li>
<li>java.swing 包和 java.awt 包：提供了创建图形用户界面元素的类。通过这些元素，编程者可以控制所写的 Applet 或 Application 的外观界面。包中包含了窗口、对话框、菜单等类。</li>
<li>java.net 包：含有与网络操作相关的类，如 TCP Scokets、URL 等工具。</li>
<li>java.applet 包：含有控制 HTML 文档格式、应用程序中的声音等资源的类，其中 Applet类是用来创建包含于 HTML 的 Applet 必不可少的类。</li>
<li>java.beans 包：定义了应用程序编程接口（API），Java Beans 是 Java 应用程序环境的中性平台组件结构。</li>
</ul>
<h2 id="Java语言包-java-lang-简介"><a href="#Java语言包-java-lang-简介" class="headerlink" title="Java语言包(java.lang)简介"></a>Java语言包(java.lang)简介</h2><p>Java语言包（java.lang）定义了Java中的大多数基本类，由Java语言自动调用，不需要显示声明。该包中包含了Object类，Object类是整个类层次结构的根结点，同时还定义了基本数据类型的类，如：String、Boolean、Byter、Short等。这些类支持数字类型的转换和字符串的操作等，下面将进行简单介绍。</p>
<p>Math类提供了常用的数学运算方法以及Math.PI和Math.E两个数学常量。该类是final的，不能被继承，类中的方法和属性全部是静态，不允许在类的外部创建Math类的对象。因此，只能使用Math类的方法而不能对其作任何更改。</p>
<h3 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h3><p>包含许多常用数学计算的方法功能</p>
<h3 id="字符串类"><a href="#字符串类" class="headerlink" title="字符串类"></a>字符串类</h3><p>字符串是字符的序列。在 Java 中，字符串无论是常量还是变量都是用类的对象来实现的。java.lang 提供了两种字符串类：String 类和 StringBuffer 类。</p>
<h2 id="日期和时间类"><a href="#日期和时间类" class="headerlink" title="日期和时间类"></a>日期和时间类</h2><p>Java 的日期和时间类位于 java.util 包中。利用日期时间类提供的方法，可以获取当前的日期和时间，创建日期和时间参数，计算和比较时间。</p>
<h3 id="Date-类"><a href="#Date-类" class="headerlink" title="Date 类"></a>Date 类</h3><p>Date 类是 Java 中的日期时间类，其构造方法比较多，下面是常用的两个：</p>
<ul>
<li>Date()：使用当前的日期和时间初始化一个对象。</li>
<li>Date(long millisec)：从1970年01月01日00时（格林威治时间）开始以毫秒计算时间，计算 millisec 毫秒。如果运行 Java 程序的本地时区是北京时区（与格林威治时间相差 8 小时），Date dt1=new Date(1000);，那么对象 dt1 就是1970年01月01日08时00分01秒。</li>
</ul>
<h3 id="Calendar-类"><a href="#Calendar-类" class="headerlink" title="Calendar 类"></a>Calendar 类</h3><p>抽象类 Calendar 提供了一组方法，允许把以毫秒为单位的时间转换成一些有用的时间组成部分。Calendar 不能直接创建对象，但可以使用静态方法 getInstance() 获得代表当前日期的日历对象，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Calendar calendar=Calendar.getInstance();</span><br></pre></td></tr></table></figure>
<p>该对象可以调用下面的方法将日历翻到指定的一个时间：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> year,<span class="keyword">int</span> month,<span class="keyword">int</span> date)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> year,<span class="keyword">int</span> month,<span class="keyword">int</span> date,<span class="keyword">int</span> hour,<span class="keyword">int</span> minute)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> year,<span class="keyword">int</span> month,<span class="keyword">int</span> date,<span class="keyword">int</span> hour,<span class="keyword">int</span> minute,<span class="keyword">int</span> second)</span></span>;</span><br></pre></td></tr></table></figure>
<p>若要调用有关年份、月份、小时、星期等信息，可以通过调用下面的方法实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> field)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中，参数 field 的值由 Calendar 类的静态常量决定。其中：YEAR 代表年，MONTH 代表月，HOUR 代表小时，MINUTE 代表分，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">calendar.get(Calendar.MONTH);</span><br></pre></td></tr></table></figure>
<p>如果返回值为 0 代表当前日历是一月份，如果返回 1 代表二月份，依此类推。</p>
<h3 id="GregorianCalendar-类"><a href="#GregorianCalendar-类" class="headerlink" title="GregorianCalendar 类"></a>GregorianCalendar 类</h3><p>GregorianCalendar 是一个具体实现 Calendar 类的类，该类实现了公历日历。Calendar 类的 getInstance() 方法返回一个 GregorianCalendar，它被初始化为默认的地域和时区下的当前日期和时间。</p>
<h2 id="哈希表及其应用"><a href="#哈希表及其应用" class="headerlink" title="哈希表及其应用"></a>哈希表及其应用</h2><p>哈希表也称为散列表，是用来存储群体对象的集合类结构。</p>
<p>Java 使用哈希表类（Hashtable）来实现哈希表，以下是与哈希表相关的一些概念：</p>
<ul>
<li>容量（Capacity）：Hashtable 的容量不是固定的，随对象的加入其容量也可以自动增长。</li>
<li>关键字（Key）：每个存储的对象都需要有一个关键字，key 可以是对象本身，也可以是对象的一部分（如某个属性）。要求在一个 Hashtable 中的所有关键字都是唯一的。</li>
<li>哈希码（Hash Code）：若要将对象存储到 Hashtable 上，就需要将其关键字 key 映射到一个整型数据，成为 key 的哈希码。</li>
<li>项（Item）：Hashtable 中的每一项都有两个域，分别是关键字域 key 和值域 value（存储的对象）。Key 和 value 都可以是任意的 Object 类型的对象，但不能为空。</li>
<li>装填因子（Load Factor）：装填因子表示为哈希表的装满程度，其值等于元素数比上哈希表的长度。</li>
</ul>
<h3 id="哈希表的使用"><a href="#哈希表的使用" class="headerlink" title="哈希表的使用"></a>哈希表的使用</h3><p>哈希表类主要有三种形式的构造方法：</p>
<ul>
<li>Hashtable(); //默认构造函数，初始容量为 101，最大填充因子 0.75</li>
<li>Hashtable(int capacity);</li>
<li>Hashtable(int capacity,float loadFactor)</li>
</ul>
<h1 id="内部类、抽象类、接口"><a href="#内部类、抽象类、接口" class="headerlink" title="内部类、抽象类、接口"></a>内部类、抽象类、接口</h1><h2 id="Java内部类及其实例化"><a href="#Java内部类及其实例化" class="headerlink" title="Java内部类及其实例化"></a>Java内部类及其实例化</h2><p>首先看看什么是内部类：在类的内部定义另一个类。没错，定义就这么简单。如果在类Outer的内部再定义一个类Inner，此时Inner就称为内部类，而Outer则称为外部类。 </p>
<p>使用内部类有什么好处；</p>
<p>1）实现多重继承; </p>
<p>2）内部类可以很好的实现隐藏：一般的非内部类，是不允许有 private 与protected权限的，但内部类可以</p>
<p> 3）减少了类文件编译后的产生的字节码文件的大小</p>
<p>使用内部类的缺点：使程序结构不清楚。</p>
<p>内部类在编译完成后也会产生.class文件，但文件名称是：外部类名称$内部类名称.class</p>
<h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p>成员内部类也叫实例内部类。应用场合：每一个外部类对象都需要一个内部类的实例，<strong>内部类离不开外部类存在</strong>（相当于心脏对人体）。外部类要想访问内部类的成员变量和方法，则需要通过内部类的对象来获取。 </p>
<p>使用格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Outer outer = <span class="keyword">new</span> Outer(); <span class="comment">// 外部类实例</span></span><br><span class="line">Outer.Inner inner = outer.<span class="keyword">new</span> Inner();</span><br></pre></td></tr></table></figure>
<p>代码演示： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 成员内部类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Body</span> </span>&#123;</span><br><span class="line">    String arm;</span><br><span class="line">    String leg;</span><br><span class="line">    String blood;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Body</span><span class="params">(String arm, String leg, String blood)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.arm = arm;</span><br><span class="line">       <span class="keyword">this</span>.leg = leg;</span><br><span class="line">        <span class="keyword">this</span>.blood = blood;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//内部类Heart</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Heart</span></span>&#123;</span><br><span class="line">        String name;</span><br><span class="line">         <span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"心脏正在给"</span>+arm+leg+<span class="string">"输"</span>+blood);</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;       </span><br><span class="line">        Body body=<span class="keyword">new</span> Body(<span class="string">"两个胳膊"</span>,<span class="string">"两条腿"</span>,<span class="string">"血"</span>);</span><br><span class="line">        Body.Heart  heart=body.<span class="keyword">new</span> Heart();</span><br><span class="line">        heart.work();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>1、内部类如果使用static声明（类共享一份副本，可以直接通过类名调用，不需要实例），则此内部类就称为静态内部类。（其实也相当于外部类）可以通过外部类 . 内部类来访问。</p>
<p>2、静态内部类使用场合：内部类不需要外部类的实例（注意区分成员内部类），静态内部类存在仅仅为外部类提供服务或者逻辑上属于外部类，且逻辑上可以单独存在。</p>
<p>3、静态内部类的特征：</p>
<p>静态内部类不会持有外部类的引用</p>
<p>静态内部类可以访问外部的静态变量，如果访问外部类的成员变量必须通过外部类的实例访问</p>
<p>4、Java中只有内部类才可以是静态的</p>
<p>使用格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Outer.Inner inner = <span class="keyword">new</span> Outer.Inner();</span><br></pre></td></tr></table></figure>
<p>演示代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 静态内部</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Company</span> </span>&#123;</span><br><span class="line">    String companyNam;</span><br><span class="line">    <span class="keyword">static</span> String country;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Clear</span></span>&#123;</span><br><span class="line">        String name;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Clear</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>();</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">            String na=<span class="keyword">new</span> Company().companyNam=<span class="string">"联想"</span>;</span><br><span class="line">            country=<span class="string">"中国"</span>;</span><br><span class="line">            System.out.println(name+<span class="string">"为"</span>+na+<span class="string">"打扫卫生，该公司属于"</span>+country);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Company.Clear zcl=<span class="keyword">new</span> Company.Clear();</span><br><span class="line">        zcl.work(<span class="string">"shen_hua"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>1、如果一个内部类在整个操作中只使用一次的话，就可以定义为匿名内部类。匿名内部类也就是没有名字的内部类，这是java为了方便我们编写程序而设计的一个机制，因为有时候有的内部类只需要创建一个它的对象就可以了，以后再不会用到这个类，这时候使用匿名内部类就比较合适。</p>
<p>2、使用场合：简化内部类的使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> class <span class="title">Father</span><span class="params">()</span></span>&#123;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">   Father f1 = <span class="keyword">new</span> Father()&#123; .... &#125;  <span class="comment">//这里就是有个匿名内部类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="抽象类的概念和使用"><a href="#抽象类的概念和使用" class="headerlink" title="抽象类的概念和使用"></a>抽象类的概念和使用</h2><p>这种只给出方法定义而不具体实现的方法被称为抽象方法，抽象方法是没有方法体的，在代码的表达上就是没有“{}”。包含一个或多个抽象方法的类也必须被声明为抽象类。</p>
<p>使用 abstract 修饰符来表示抽象方法和抽象类。</p>
<p>抽象类除了包含抽象方法外，还可以包含具体的变量和具体的方法。类即使不包含抽象方法，也可以被声明为抽象类，防止被实例化。</p>
<p>抽象类不能被实例化，抽象方法必须在子类中被实现。请看下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Teacher t = <span class="keyword">new</span> Teacher();</span><br><span class="line">        t.setName(<span class="string">"王明"</span>);</span><br><span class="line">        t.work();</span><br><span class="line">       </span><br><span class="line">        Driver d = <span class="keyword">new</span> Driver();</span><br><span class="line">        d.setName(<span class="string">"小陈"</span>);</span><br><span class="line">        d.work();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;  <span class="comment">// 实例变量</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 共有的 setter 和 getter 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">extends</span> <span class="title">People</span></span>&#123;</span><br><span class="line">    <span class="comment">// 必须实现该方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">        out.println(<span class="string">"我的名字叫"</span> + <span class="keyword">this</span>.getName() + <span class="string">"，我正在讲课，请大家不要东张西望..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Driver</span> <span class="keyword">extends</span> <span class="title">People</span></span>&#123;</span><br><span class="line">    <span class="comment">// 必须实现该方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">        out.println(<span class="string">"我的名字叫"</span> + <span class="keyword">this</span>.getName() + <span class="string">"，我正在开车，不能接听电话..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于抽象类的几点说明：</p>
<ul>
<li>抽象类不能直接使用，必须用子类去实现抽象类，然后使用其子类的实例。然而可以创建一个变量，其类型是一个抽象类，并让它指向具体子类的一个实例，也就是可以使用抽象类来充当形参，实际实现类作为实参，也就是多态的应用。</li>
<li>不能有抽象构造方法或抽象静态方法。</li>
</ul>
<h2 id="接口的概念和使用"><a href="#接口的概念和使用" class="headerlink" title="接口的概念和使用"></a>接口的概念和使用</h2><h3 id="接口的概念"><a href="#接口的概念" class="headerlink" title="接口的概念"></a>接口的概念</h3><p>在抽象类中，可以包含一个或多个抽象方法；但在接口(interface)中，所有的方法必须都是抽象的，不能有方法体，它比抽象类更加“抽象”。</p>
<p>接口使用 interface 关键字来声明，可以看做是一种特殊的抽象类，可以指定一个类必须做什么，而不是规定它如何去做。</p>
<blockquote>
<p>注意：接口中声明的成员变量默认都是 public static final 的，必须显式地初始化。因而在常量声明时可以省略这些修饰符。 </p>
</blockquote>
<p>接口是若干常量和抽象方法的集合，目前看来和抽象类差不多。确实如此，接口本就是从抽象类中演化而来的，因而除特别规定，接口享有和类同样的“待遇”。比如，源程序中可以定义多个类或接口，但最多只能有一个public 的类或接口，如果有则源文件必须取和public的类和接口相同的名字。和类的继承格式一样，接口之间也可以继承，子接口可以继承父接口中的常量和抽象方法并添加新的抽象方法等。 </p>
<p>但接口有其自身的一些特性，归纳如下。</p>
<ul>
<li>1) 接口中只能定义抽象方法，这些方法默认为 public abstract 的，因而在声明方法时可以省略这些修饰符。试图在接口中定义实例变量、非抽象的实例方法及静态方法，都是非法的。例如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SataHdd</span></span>&#123;</span><br><span class="line">    <span class="comment">//连接线的数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> connectLine; <span class="comment">//编译出错，connectLine被看做静态常量，必须显式初始化</span></span><br><span class="line">    <span class="comment">//写数据</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">writeData</span><span class="params">(String data)</span></span>; <span class="comment">//编译出错，必须是public类型</span></span><br><span class="line">    <span class="comment">//读数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">readData</span><span class="params">()</span></span>&#123; <span class="comment">//编译出错，接口中不能包含静态方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"数据"</span>; <span class="comment">//编译出错，接口中只能包含抽象方法，</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>2) 接口中没有构造方法，不能被实例化。</li>
<li>3) 一个接口不实现另一个接口，但可以继承多个其他接口。接口的多继承特点弥补了类的单继承。例如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//串行硬盘接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SataHdd</span> <span class="keyword">extends</span> <span class="title">A</span>,<span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="comment">// 连接线的数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONNECT_LINE = <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 写数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeData</span><span class="params">(String data)</span></span>;</span><br><span class="line">    <span class="comment">// 读数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">readData</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="为什么使用接口"><a href="#为什么使用接口" class="headerlink" title="为什么使用接口"></a>为什么使用接口</h3><p>大型项目开发中，可能需要从继承链的中间插入一个类，让它的子类具备某些功能而不影响它们的父类。例如 A -&gt; B -&gt; C -&gt; D -&gt; E，A 是祖先类，如果需要为C、D、E类添加某些通用的功能，最简单的方法是让C类再继承另外一个类。但是问题来了，Java 是一种单继承的语言，不能再让C继承另外一个父类了，只到移动到继承链的最顶端，让A再继承一个父类。这样一来，对C、D、E类的修改，影响到了整个继承链，不具备可插入性的设计。</p>
<p>接口是可插入性的保证。在一个继承链中的任何一个类都可以实现一个接口，这个接口会影响到此类的所有子类，但不会影响到此类的任何父类。此类将不得不实现这个接口所规定的方法，而子类可以从此类自动继承这些方法，这时候，这些子类具有了可插入性。 </p>
<h3 id="接口的使用"><a href="#接口的使用" class="headerlink" title="接口的使用"></a>接口的使用</h3><p>接口的使用与类的使用有些不同。在需要使用类的地方，会直接使用new关键字来构建一个类的实例，但接口不可以这样使用，因为接口不能直接使用 new 关键字来构建实例。</p>
<p>接口必须通过类来实现(implements)它的抽象方法，然后再实例化类。类实现接口的关键字为implements。</p>
<p>如果一个类不能实现该接口的所有抽象方法，那么这个类必须被定义为抽象方法。</p>
<p>不允许创建接口的实例，但允许定义接口类型的引用变量，该变量指向了实现接口的类的实例。</p>
<p>一个类只能继承一个父类，但却可以实现多个接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">实现接口的格式如下：</span><br><span class="line">修饰符 <span class="class"><span class="keyword">class</span> 类名 <span class="keyword">extends</span> 父类 <span class="keyword">implements</span> 多个接口 </span>&#123;</span><br><span class="line">实现方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="headerlink" title="接口和抽象类的区别"></a>接口和抽象类的区别</h3><p>类是对象的模板，抽象类和接口可以看做是具体的类的模板。</p>
<p>由于从某种角度讲，接口是一种特殊的抽象类，它们的渊源颇深，有很大的相似之处，所以在选择使用谁的问题上很容易迷糊。我们首先分析它们具有的相同点。</p>
<ul>
<li>都代表类树形结构的抽象层。在使用引用变量时，尽量使用类结构的抽象层，使方法的定义和实现分离，这样做对于代码有松散耦合的好处。</li>
<li>都不能被实例化。</li>
<li>都能包含抽象方法。抽象方法用来描述系统提供哪些功能，而不必关心具体的实现。</li>
</ul>
<p>下面说一下抽象类和接口的主要区别。</p>
<ul>
<li>1) 抽象类可以为部分方法提供实现，避免了在子类中重复实现这些方法，提高了代码的可重用性，这是抽象类的优势；而接口中只能包含抽象方法，不能包含任何实现。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//A method2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//B method1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//C method1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>抽象类A有两个子类B、C，由于A中有方法method2的实现，子类B、C中不需要重写method2方法，我们就说A为子类提供了公共的功能，或A约束了子类的行为。method2就是代码可重用的例子。A 并没有定义 method1的实现，也就是说B、C 可以根据自己的特点实现method1方法，这又体现了松散耦合的特性。</p>
<p>再换成接口看看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//B method1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//B method2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//C method1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//C method2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口A无法为实现类B、C提供公共的功能，也就是说A无法约束B、C的行为。B、C可以自由地发挥自己的特点现实 method1和 method2方法，接口A毫无掌控能力。</p>
<ul>
<li>2) <strong>一个类只能继承一个直接的父类（可能是抽象类），但一个类可以实现多个接口，这个就是接口的优势</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">A</span>,<span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//C method1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//C method2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可以如此灵活的使用C，并且C还有机会进行扩展，实现其他接口</span></span><br><span class="line">A a=<span class="keyword">new</span> C();</span><br><span class="line">B b=<span class="keyword">new</span> C();</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//C method1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//C method2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于C类，将没有机会继承其他父类了。</p>
<p>综上所述，接口和抽象类各有优缺点，在接口和抽象类的选择上，必须遵守这样一个原则：</p>
<ul>
<li>行为模型应该总是通过接口而不是抽象类定义，所以通常是优先选用接口，尽量少用抽象类。</li>
<li>选择抽象类的时候通常是如下情况：需要定义子类的行为，又要为子类提供通用的功能。</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java入门基础（一）</title>
    <url>/2019/01/20/java/java%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>前言：java在研究生阶段几乎没有再碰，很多都已经忘的差不多了。最近在看一些大数据的知识，需要捡起来一些，所以有了这篇总结文，这里的内容参考Free Will的<a href="https://plushunter.github.io/2017/08/20/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%EF%BC%9A%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/" target="_blank" rel="noopener">java学习笔记系列</a>，这里进行了一些增删查补，算是一个较为系统的回顾把。</p>
<hr>
<h1 id="语法基础"><a href="#语法基础" class="headerlink" title="语法基础"></a>语法基础</h1><p>Java是完全面向对象的语言。通过虚拟机的运行机制，实现“跨平台”的理念。一次编译，永久使用。 </p>
<p>下面两点有关Java的书写方式：</p>
<ul>
<li>Java中的语句要以 ; 结尾 (与C/C++相同)。</li>
<li>用花括号 {} 来整合语句，形成程序块。通过程序块，我们可以知道程序的不同部分的范围，比如类从哪里开始，到哪里结束。</li>
</ul>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>Java和C语言都是静态类型的语言。<strong>在使用变量之前，要声明变量的类型。</strong></p>
<p>变量(variable) 占据一定的内存空间。不同类型的变量占据不同的大小。Java中的变量类型如下：</p>
<p><img src="/2019/01/20/java/java入门基础（一）/01.png" alt></p>
<p>你可以在程序中的任意位置声明变量。 比如: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Declare in the middle:"</span>);</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        a = <span class="number">5</span>;</span><br><span class="line">        System.out.println(a);  <span class="comment">// print an integer</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组包含相同类型的多个数据。我用下面方法来声明一个整数数组: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a;</span><br></pre></td></tr></table></figure>
<p>在声明数组时，数组所需的空间并没有真正分配给数组。我可以在声明的同时，用new来创建数组所需空间:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br></pre></td></tr></table></figure>
<p>这里创建了可以容纳100个整数的数组。相应的内存分配也完成了。</p>
<p>我还可以在声明的同时，给数组赋值。数组的大小也同时确定。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h3><p>你可以在声明数组的同时进行初始化（静态初始化），也可以在声明以后进行初始化（动态初始化）。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 静态初始化</span></span><br><span class="line"><span class="comment">// 静态初始化的同时就为数组元素分配空间并赋值</span></span><br><span class="line"><span class="keyword">int</span> intArray[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">String stringArray[] = &#123;<span class="string">"程序员"</span>, <span class="string">"http://www.baidu.com"</span>, <span class="string">"一切编程语言都是纸老虎"</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态初始化</span></span><br><span class="line"><span class="keyword">float</span> floatArray[] = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">3</span>];</span><br><span class="line">floatArray[<span class="number">0</span>] = <span class="number">1.0f</span>;</span><br><span class="line">floatArray[<span class="number">1</span>] = <span class="number">132.63f</span>;</span><br><span class="line">floatArray[<span class="number">2</span>] = <span class="number">100F</span>;</span><br></pre></td></tr></table></figure>
<h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><p>二维数组的声明、初始化和引用与一维数组相似：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> intArray[ ][ ] = &#123; &#123;<span class="number">1</span>,<span class="number">2</span>&#125;, &#123;<span class="number">2</span>,<span class="number">3</span>&#125;, &#123;<span class="number">4</span>,<span class="number">5</span>&#125; &#125;;</span><br><span class="line"><span class="keyword">int</span> a[ ][ ] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">a[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">12</span>;</span><br><span class="line">a[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">34</span>;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">a[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">93</span>;</span><br></pre></td></tr></table></figure>
<p>Java语言中，由于把二维数组看作是数组的数组，数组空间不是连续分配的，所以不要求二维数组每一维的大小相同。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> intArray[ ][ ] = &#123; &#123;<span class="number">1</span>,<span class="number">2</span>&#125;, &#123;<span class="number">2</span>,<span class="number">3</span>&#125;, &#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125; &#125;;</span><br><span class="line"><span class="keyword">int</span> a[ ][ ] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][ ];</span><br><span class="line">a[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">a[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>几点说明</p>
</blockquote>
<ul>
<li>上面讲的是静态数组。静态数组一旦被声明，它的容量就固定了，不容改变。所以在声明数组时，一定要考虑数组的最大容量，防止容量不够的现象。</li>
<li>如果想在运行程序时改变容量，就需要用到数组列表(ArrayList，也称动态数组)或向量(Vector)。</li>
<li>正是由于静态数组容量固定的缺点，实际开发中使用频率不高，被 ArrayList 或 Vector 代替，因为实际开发中经常需要向数组中添加或删除元素，而它的容量不好预估。</li>
</ul>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>从表面上看，字符串就是双引号之间的数据，例如“java”等。在Java中，可以使用下面的方法定义字符串：<br>String stringName = “string content”;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String webName = <span class="string">"java学习"</span>;</span><br></pre></td></tr></table></figure>
<p><strong>字符串可以通过“+”连接，基本数据类型与字符串进行“+”操作一般也会自动转换为字符串</strong>，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String stuName = <span class="string">"小明"</span>;</span><br><span class="line">        <span class="keyword">int</span> stuAge = <span class="number">17</span>;</span><br><span class="line">        <span class="keyword">float</span> stuScore = <span class="number">92.5f</span>;</span><br><span class="line">       </span><br><span class="line">        String info = stuName + <span class="string">"的年龄是 "</span> + stuAge + <span class="string">"，成绩是 "</span> + stuScore;</span><br><span class="line">        System.out.println(info);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>String字符串与数组有一个共同点，就是它们被初始化后，<strong>长度是不变的，并且内容也不变</strong>。如果要改变它的值，就会产生一个新的字符串 .</p>
<p>实际上，String 是java.lang包下的一个类，按照标准的面向对象的语法，其格式应该为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String stringName = <span class="keyword">new</span> String(<span class="string">"string content"</span>);</span><br></pre></td></tr></table></figure>
<p>例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String url = <span class="keyword">new</span> String(<span class="string">"http://www.baidu.com"</span>);</span><br></pre></td></tr></table></figure>
<p>但是由于String特别常用，所以Java提供了一种简化的语法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String webName = <span class="string">"java学习"</span>;</span><br></pre></td></tr></table></figure>
<h3 id="常用的String对象方法"><a href="#常用的String对象方法" class="headerlink" title="常用的String对象方法"></a>常用的String对象方法</h3><h4 id="length-方法"><a href="#length-方法" class="headerlink" title="length()方法"></a>length()方法</h4><p>length() 返回字符串的长度.</p>
<h4 id="charAt-方法"><a href="#charAt-方法" class="headerlink" title="charAt()方法"></a>charAt()方法</h4><p>charAt() 方法的作用是按照索引值获得字符串中的指定字符。Java规定，字符串中第一个字符的索引值是0，第二个字符的索引值是1，依次类推。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">"123456789"</span>;</span><br><span class="line">System.out.println(str.charAt(<span class="number">0</span>) + <span class="string">"    "</span> + str.charAt(<span class="number">5</span>) + <span class="string">"    "</span> + str.charAt(<span class="number">8</span>))</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>    <span class="number">6</span>    <span class="number">9</span></span><br></pre></td></tr></table></figure>
<h4 id="contain-方法"><a href="#contain-方法" class="headerlink" title="contain()方法"></a>contain()方法</h4><p>contains() 方法用来检测字符串是否包含某个子串，返回布尔值，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">"baidu"</span>;</span><br><span class="line">System.out.println(str.contains(<span class="string">"bai"</span>));</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure>
<h4 id="replace-方法"><a href="#replace-方法" class="headerlink" title="replace()方法"></a>replace()方法</h4><p>字符串替换，用来替换字符串中所有指定的子串，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ring str1 = <span class="string">"The url of baidu is www.google.com!"</span>;</span><br><span class="line">String str2 = str1.replace(<span class="string">"baidu"</span>, <span class="string">"google"</span>);</span><br><span class="line">System.out.println(str1);</span><br><span class="line">System.out.println(str2);</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">The url of baidu is www.google.com!</span><br><span class="line">The url of google is www.google.com!</span><br></pre></td></tr></table></figure>
<p>注意：replace() 方法不会改变原来的字符串，而是生成一个新的字符串。</p>
<h4 id="split-方法"><a href="#split-方法" class="headerlink" title="split()方法"></a>split()方法</h4><p>以指定字符串作为分隔符，对当前字符串进行分割，分割的结果是一个数组，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String str = <span class="string">"wei_xue_yuan_is_good"</span>;</span><br><span class="line">        String strArr[] = str.split(<span class="string">"_"</span>);</span><br><span class="line">        System.out.println(Arrays.toString(strArr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[wei, xue, yuan, is, good]</span><br></pre></td></tr></table></figure>
<p>以上仅仅列举了几个常用的String对象的方法，更多方法和详细解释请参考API文档。</p>
<h3 id="StringBuffer与StringBuider"><a href="#StringBuffer与StringBuider" class="headerlink" title="StringBuffer与StringBuider"></a>StringBuffer与StringBuider</h3><p>String 的值是不可变的，每次对String的操作都会生成新的String对象，不仅效率低，而且耗费大量内存空间。</p>
<p><strong>StringBuffer类和String类一样，也用来表示字符串，但是StringBuffer的内部实现方式和String不同，在进行字符串处理时，不生成新的对象，在内存使用上要优于String。</strong></p>
<p><strong>StringBuffer 默认分配16字节长度的缓冲区，当字符串超过该大小时，会自动增加缓冲区长度，而不是生成新的对象</strong>。</p>
<h4 id="StringBuffer类的主要方法"><a href="#StringBuffer类的主要方法" class="headerlink" title="StringBuffer类的主要方法"></a>StringBuffer类的主要方法</h4><p>StringBuffer类中的方法主要偏重于对于字符串的操作，例如追加、插入和删除等，这个也是StringBuffer类和String类的主要区别。实际开发中，如果需要对一个字符串进行频繁的修改，建议使用 StringBuffer。</p>
<ul>
<li>1) append() 方法</li>
</ul>
<p>append() 方法用于向当前字符串的末尾追加内容，类似于字符串的连接。调用该方法以后，StringBuffer对象的内容也发生改变，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuffer str = <span class="keyword">new</span> StringBuffer(“biancheng100”);</span><br><span class="line">str.append(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>
<p>则对象str的值将变成”biancheng100true”。注意是str指向的内容变了，不是str的指向变了。</p>
<ul>
<li>2) deleteCharAt()</li>
</ul>
<p>deleteCharAt() 方法用来删除指定位置的字符，并将剩余的字符形成新的字符串。</p>
<ul>
<li>3) insert()方法</li>
</ul>
<p>insert() 用来在指定位置插入字符串，可以认为是append()的升级版。</p>
<ul>
<li>4) setCharAt() 方法</li>
</ul>
<p>setCharAt() 方法用来修改指定位置的字符。</p>
<h4 id="String和StringBuffer的效率对比"><a href="#String和StringBuffer的效率对比" class="headerlink" title="String和StringBuffer的效率对比"></a>String和StringBuffer的效率对比</h4><p>建议在涉及大量字符串操作时使用StringBuffer。 </p>
<h4 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h4><p>StringBuilder类和StringBuffer类功能基本相似，方法也差不多，主要区别在于StringBuffer类的方法是多线程安全的，而StringBuilder不是线程安全的，相比而言，StringBuilder类会略微快一点。</p>
<p>总结一下： </p>
<p>线程安全：</p>
<ul>
<li>StringBuffer：线程安全</li>
<li>StringBuilder：线程不安全</li>
</ul>
<p>速度：</p>
<ul>
<li>一般情况下，速度从快到慢为 StringBuilder &gt; StringBuffer &gt; String，当然这是相对的，不是绝对的。</li>
</ul>
<p>使用环境：</p>
<ul>
<li>操作少量的数据使用 String；</li>
<li>单线程操作大量数据使用 StringBuilder；</li>
<li>多线程操作大量数据使用 StringBuffer。</li>
</ul>
<h1 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h1><h2 id="类的定义及其实例化"><a href="#类的定义及其实例化" class="headerlink" title="类的定义及其实例化"></a>类的定义及其实例化</h2><p><strong>类必须先定义才能使用。类是创建对象的模板，创建对象也叫类的实例化</strong>。 </p>
<p><strong>一个类可以包含以下类型变量</strong>：</p>
<ul>
<li>局部变量：在方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。</li>
<li>成员变量：成员变量是定义在类中、方法体之外的变量。这种变量在创建对象的时候实例化（分配内存）。成员变量可以被类中的方法和特定类的语句访问。</li>
<li>类变量：类变量也声明在类中，方法体之外，但必须声明为static类型。</li>
</ul>
<p>在Java中，使用new关键字来创建对象，一般有以下三个步骤：</p>
<ul>
<li>声明：声明一个对象，包括对象名称和对象类型。</li>
<li>实例化：使用关键字new来创建一个对象。</li>
<li>初始化：<strong>使用new创建对象时，会调用构造方法初始化对象</strong>。</li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Dog myDog;  <span class="comment">// 声明一个对象</span></span><br><span class="line">myDog = <span class="keyword">new</span> Dog(<span class="string">"花花"</span>, <span class="number">3</span>);  <span class="comment">// 实例化</span></span><br></pre></td></tr></table></figure>
<p>也可以在声明的同时进行初始化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Dog myDog = <span class="keyword">new</span> Dog(<span class="string">"花花"</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<h2 id="Java访问修饰符"><a href="#Java访问修饰符" class="headerlink" title="Java访问修饰符"></a>Java访问修饰符</h2><p>Java 通过修饰符来控制类、属性和方法的访问权限和其他功能，通常放在语句的最前端.访问控制分为四种级别：</p>
<p>　　（1）<strong>public</strong>： 用public修饰的类、类属变量及方法，包内及包外的任何类（包括子类和普通类）均可以访问；</p>
<p>　　（2）<strong>protected</strong>： 用protected修饰的类、类属变量及方法，包内的任何类及<strong>包外那些继承了该类的子类才能访问（此处稍后解释），protected重点突出继承；</strong></p>
<p>　　（3）<strong>default</strong>： 如果一个类、类属变量及方法没有用任何修饰符（即没有用public、protected及private中任何一种修饰），则其访问权限为default（默认访问权限）。默认访问权限的类、类属变量及方法，包内的任何类（包括继承了此类的子类）都可以访问它，而对于包外的任何类都不能访问它（包括包外继承了此类的子类）。<strong>default重点突出包</strong>；</p>
<p>　　（4）<strong>private</strong>： 用private修饰的类、类属变量及方法，只有本类可以访问，而包内包外的任何类均不能访问它。</p>
<p><img src="/2019/01/20/java/java入门基础（一）/02.png" alt></p>
<p><strong>最终总结，就一句话:</strong>protected修饰符所修饰的类（这句话中指父类）属成员变量和方法，只可以被子类访问，而不管子类是不是和父类位于同一个包中。default修饰符所修饰的类属成员变量和方法，只可被同一个包中的其他类访问，而不管其他类是不是该类的子类。protected属于子类限制修饰符，而default属于包限制修饰符.</p>
<h2 id="访问控制和继承"><a href="#访问控制和继承" class="headerlink" title="访问控制和继承"></a>访问控制和继承</h2><p>请注意以下方法继承的规则：</p>
<ul>
<li>父类中声明为public的方法在子类中也必须为public。</li>
<li>父类中声明为protected的方法在子类中要么声明为protected，要么声明为public。不能声明为private。</li>
<li>父类中默认修饰符声明的方法，能够在子类中声明为private。</li>
<li>父类中声明为private的方法，不能够被继承。</li>
</ul>
<h2 id="Java变量的作用域"><a href="#Java变量的作用域" class="headerlink" title="Java变量的作用域"></a>Java变量的作用域</h2><p>在Java中，变量的作用域分为四个级别：类级、对象实例级、方法级、块级。</p>
<ul>
<li>类级变量：又称全局级变量或静态变量，需要使用static关键字修饰，你可以与 C/C++ 中的 static 变量对比学习。类级变量在类定义后就已经存在，占用内存空间，可以通过类名来访问，不需要实例化。</li>
<li>对象实例级变量：就是成员变量，实例化后才会分配内存空间，才能访问。</li>
<li>方法级变量：就是在方法内部定义的变量，就是局部变量。</li>
<li>块级变量：就是定义在一个块内部的变量，变量的生存周期就是这个块，出了这个块就消失了，比如 if、for 语句的块。块是指由大括号包围的代码</li>
</ul>
<h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h2><p>this 关键字用来表示当前对象本身，或当前类的一个实例 。同样super表示父类对象本身。</p>
<h2 id="基本运行顺序"><a href="#基本运行顺序" class="headerlink" title="基本运行顺序"></a>基本运行顺序</h2><p>我们以下面的类来说明一个基本的 Java 类的运行顺序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Demo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        name = <span class="string">"java学习"</span>;</span><br><span class="line">        age = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Demo obj = <span class="keyword">new</span> Demo();</span><br><span class="line">        System.out.println(obj.name + <span class="string">"的年龄是"</span> + obj.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基本运行顺序是：</p>
<ul>
<li>先运行到第 9 行，这是程序的入口。</li>
<li>然后运行到第 10 行，这里要 new 一个Demo，就要调用 Demo 的构造方法。</li>
<li>就运行到第 5 行，注意：可能很多人觉得接下来就应该运行第 6 行了，错！初始化一个类，必须先初始化它的属性。</li>
<li>因此运行到第 2 行，然后是第 3 行。</li>
<li>属性初始化完过后，才回到构造方法，执行里面的代码，也就是第 6 行、第 7 行。</li>
<li>然后是第8行，表示 new 一个Demo实例完成。</li>
<li>然后回到 main 方法中执行第 11 行。</li>
<li>然后是第 12 行，main方法执行完毕。</li>
</ul>
<h1 id="继承、覆盖、重载"><a href="#继承、覆盖、重载" class="headerlink" title="继承、覆盖、重载"></a>继承、覆盖、重载</h1><h2 id="继承的概念与实现"><a href="#继承的概念与实现" class="headerlink" title="继承的概念与实现"></a>继承的概念与实现</h2><p>继承使用 extends 关键字。 </p>
<p>单继承性：Java 允许一个类仅能继承一个其它类，即一个类只能有一个父类，这个限制被称做单继承性。后面将会学到接口(interface)的概念，接口允许多继承。 </p>
<h2 id="继承中的方法的覆盖和重载"><a href="#继承中的方法的覆盖和重载" class="headerlink" title="继承中的方法的覆盖和重载"></a>继承中的方法的覆盖和重载</h2><p>覆盖和重载的不同：</p>
<ul>
<li>方法覆盖要求参数列表必须一致，而方法重载要求参数列表必须不一致。</li>
<li>方法覆盖要求返回类型必须一致，方法重载对此没有要求。</li>
<li>方法覆盖只能用于子类覆盖父类的方法，方法重载用于同一个类中的所有方法（包括从父类中继承而来的方法）。</li>
<li>方法覆盖对方法的访问权限和抛出的异常有特殊的要求，而方法重载在这方面没有任何限制。</li>
<li>父类的一个方法只能被子类覆盖一次，而一个方法可以在所有的类中可以被重载多次</li>
</ul>
<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>多态存在的三个必要条件：要有继承、要有重写、父类变量引用子类对象。 </p>
<h2 id="instanceof运算符"><a href="#instanceof运算符" class="headerlink" title="instanceof运算符"></a>instanceof运算符</h2><p>Java 使用 instanceof 操作符判断一个变量所实际引用的对象的类型 。，注意是它引用的对象的类型，不是变量的类型。 </p>
<h2 id="强制类型转换、向上转型、向下转型"><a href="#强制类型转换、向上转型、向下转型" class="headerlink" title="强制类型转换、向上转型、向下转型"></a>强制类型转换、向上转型、向下转型</h2><p> 在Java中，之所以需要强制类型转换是为了防止程序员在不知情的情况下把A类型数据错当成B类型的数据。<strong>如果这两种是兼容的，那么Java将执行自动转换</strong>，例如int和long，将int类型赋值给long类型的变量，总是可行的。但不是所有的类型都兼容。例如，没有将double类型转换为byte型的定义。<strong>但是不兼容的类型之间的转换仍然是可能的。达到这个目的，就需要使用强制类型转换。完成两个不兼容类型的强制转换。</strong></p>
<h3 id="自动类型转换和强制类型转换"><a href="#自动类型转换和强制类型转换" class="headerlink" title="自动类型转换和强制类型转换"></a>自动类型转换和强制类型转换</h3><p>在Java中由于继承和向上转型，子类可以非常自然地转换成父类，但是父类转换成子类则需要强制转换。因为子类拥有比父类更多的属性、更强的功能，所以父类转换为子类需要强制。</p>
<p>当我们用一个类型的构造器构造出一个对象时，这个对象的类型就已经确定的，也就说它的本质是不会再发生变化了。在Java中我们可以通过继承、向上转型的关系使用父类类型来引用它，这个时候我们是使用功能较弱的类型引用功能较强的对象，这是可行的。但是将功能较弱的类型强制转功能较强的对象时，就不一定可以行了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Father father = <span class="keyword">new</span> Son();</span><br><span class="line">Son son = (Son)father; <span class="comment">// 强制转换成功</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//编译出错，ClassCastException</span></span><br><span class="line">Father father = <span class="keyword">new</span> Father();</span><br><span class="line">Son son = (Son) father;</span><br></pre></td></tr></table></figure>
<p> <strong>在第一个例子中，father被指向一个子类对象，子类也可以指向子类对象。而第二个例子中，father被传给一个父类对象，子类引用不能指向父类对象。</strong>即很重要的概念是：父类引用指向子类对象。将父类转换为子类之前，应该用instanceof检查。 </p>
<p> <strong>总结</strong>：<strong>父类引用可以指向子类对象，子类引用不能指向父类对象（子类可以指向子类对象）</strong>。<strong>把子类对象直接赋给父类引用叫做向上转型，向上转型不用强制转型</strong>，如Father f1=new Son()，<strong>把指向子类对象的父类引用赋给子类引用叫做向下转型，要强制转型，如Son s1 = (Son)f1</strong>。<strong>向上转型会丢失子类特有的方法，但是子类overriding父类的方法，子类方法有效。</strong> </p>
<h3 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.sheepmu;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class"> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"父类的 eating..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span> <span class="keyword">extends</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class"></span>&#123;	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"子类重写的父类的  eatting..."</span>);</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"子类新方法  flying..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sys</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		Animal b=<span class="keyword">new</span> Bird(); <span class="comment">//向上转型</span></span><br><span class="line">		b.eat(); </span><br><span class="line">		<span class="comment">//  b.fly(); b虽指向子类对象，但此时子类作为向上的代价丢失和父类不同的fly()方法</span></span><br><span class="line">		sleep(<span class="keyword">new</span> Male());</span><br><span class="line">		sleep(<span class="keyword">new</span> Female());<span class="comment">//传入的参数是子类-----！！</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(Human h)</span> <span class="comment">//方法的参数是父类------！！！</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line"> 		 h.sleep();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sheepmu;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"父类人类   sleep.."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Male</span> <span class="keyword">extends</span> <span class="title">Human</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"男人 sleep.."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Female</span> <span class="keyword">extends</span> <span class="title">Human</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"女人 sleep.."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//子类重写的父类的  eatting...</span></span><br><span class="line"><span class="comment">//男人 sleep..</span></span><br><span class="line"><span class="comment">//女人 sleep..</span></span><br></pre></td></tr></table></figure>
<p>解释：</p>
<ul>
<li><p>向上转型的实现         </p>
<pre><code>  Animal b=new Bird(); //向上转型
  b.eat(); // 调用的是子类的eat()方法
  b.fly(); // 报错!!!!!-b虽指向子类对象，但此时子类作为向上转型的代价丢失和父类不同的fly()法
</code></pre></li>
<li><p>为何不直接Bird b=new Bird();b.eat() 呢？</p>
<pre><code> 这样就没有体现出面向对象的抽象的编程思想呀，降低了代码的可扩展性.
</code></pre></li>
<li><p>向上转型的好处？</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  sleep(<span class="keyword">new</span> Male());<span class="comment">//调用方法时传入的参数是子类</span></span><br><span class="line">  sleep(<span class="keyword">new</span> Female());</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(Human h)</span> <span class="comment">//方法的参数是父类，若不用向上转型则需要传入各种子类</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     h.sleep();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上代码就是用的向上转型，若是不用向上转型，那么有多少个子类就得在这儿写多少种不同的睡觉方法</p>
<h3 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sheepmu;</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Fruit</span></span></span><br><span class="line"><span class="class">  </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"我是父类  水果..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span></span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myName</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123; </span><br><span class="line">		System.out.println(<span class="string">"我是子类  苹果..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myMore</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"我是你的小呀小苹果~~~~~~"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sys</span></span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">		Fruit a=<span class="keyword">new</span> Apple(); <span class="comment">//向上转型</span></span><br><span class="line">		a.myName();</span><br><span class="line">		</span><br><span class="line">		Apple aa=(Apple)a; <span class="comment">//向下转型,编译和运行皆不会出错(正确的)</span></span><br><span class="line">		aa.myName();<span class="comment">//向下转型时调用的是子类的</span></span><br><span class="line">		aa.myMore();;</span><br><span class="line">		  </span><br><span class="line">		Fruit f=<span class="keyword">new</span> Fruit();</span><br><span class="line">         Apple aaa=(Apple)f; <span class="comment">//-出错，不安全的---向下转型,编译无错但会运行会出错</span></span><br><span class="line">  		aaa.myName();</span><br><span class="line">  		aaa.myMore(); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输出：</span></span><br><span class="line"><span class="comment">我是子类  苹果...</span></span><br><span class="line"><span class="comment">我是子类  苹果... </span></span><br><span class="line"><span class="comment">我是你的小呀小苹果~~~~~~</span></span><br><span class="line"><span class="comment">Exception in thread "main" java.lang.ClassCastException: com.sheepmu.Fruit cannot be cast to com.sheepmu.Apple at com.sheepmu.Sys.main(Sys.java:30)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>解释：</p>
<ul>
<li>正确的向下转型    </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">     Fruit a=<span class="keyword">new</span> Apple(); <span class="comment">//向上转型</span></span><br><span class="line">     a.myName(); </span><br><span class="line">     Apple aa=(Apple)a; <span class="comment">//向下转型,编译和运行皆不会出错(正确的)</span></span><br><span class="line">     aa.myName();</span><br><span class="line">     aa.myMore();</span><br></pre></td></tr></table></figure>
<p><strong>a指向子类的对象，所以子类的实例aa也可以指向a啊。向下转型后因为都是指向子类对象，所以调用的当然全是子类的方法</strong></p>
<ul>
<li>不安全的向下转型（儿子不能指爸爸）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Fruit f=<span class="keyword">new</span> Fruit();</span><br><span class="line">Apple aaa=(Apple)f; <span class="comment">//-不安全的---向下转型,编译无错但会运行会出错</span></span><br><span class="line">aaa.myName();</span><br><span class="line">aaa.myMore();</span><br></pre></td></tr></table></figure>
<p>f是父类对象，子类的实例aaa肯定不能指向父类f啊</p>
<ul>
<li>Java为了解决不安全的向下转型问题，引入泛型的概念</li>
<li>为了安全的类型转换，最好先用 if(A instanceof  B) 判断一下下</li>
</ul>
<h1 id="static、final关键字和Object类"><a href="#static、final关键字和Object类" class="headerlink" title="static、final关键字和Object类"></a>static、final关键字和Object类</h1><h2 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h2><p>static 修饰符能够与变量、方法一起使用，<strong>表示是“静态”的</strong>。静态变量和静态方法能够通过类名来访问，<strong>不需要创建一个类的对象来访问该类的静态成员，所以static修饰的成员又称作类变量和类方法</strong>。静态变量与实例变量不同，<strong>实例变量总是通过对象来访问，因为它们的值在对象和对象之间有所不同。</strong>请看下面的例子： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    Demo() &#123;</span><br><span class="line">        <span class="keyword">this</span>.j = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"类变量 i="</span> + Demo.i); <span class="comment">//静态方法和变量通过类名访问</span></span><br><span class="line">        Demo obj = <span class="keyword">new</span> Demo();</span><br><span class="line">        System.out.println(<span class="string">"实例变量 j="</span> + obj.j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">类变量 i=<span class="number">10</span></span><br><span class="line">实例变量 j=<span class="number">20</span></span><br></pre></td></tr></table></figure>
<h3 id="static的内存分配"><a href="#static的内存分配" class="headerlink" title="static的内存分配"></a>static的内存分配</h3><p>静态变量属于类，不属于任何独立的对象，所以无需创建类的实例就可以访问静态变量。之所以会产生这样的结果，是<strong>因为编译器只为整个类创建了一个静态变量的副本，也就是只分配一个内存空间，虽然有多个实例，但这些实例共享该内存</strong>(也就是该静态变量会被多个实例共同修改)。<strong>实例变量则不同，每创建一个对象，都会分配一次内存空间，不同变量的内存相互独立，互不影响</strong>（各独立一份，不会被共同修改），改变 a 对象的实例变量不会影响 b 对象。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo obj1 = <span class="keyword">new</span> Demo();</span><br><span class="line">        obj1.i = <span class="number">10</span>;</span><br><span class="line">        obj1.j = <span class="number">20</span>;</span><br><span class="line">       </span><br><span class="line">        Demo obj2 = <span class="keyword">new</span> Demo();</span><br><span class="line">       </span><br><span class="line">        System.out.println(<span class="string">"obj1.i="</span> + obj1.i + <span class="string">", obj1.j="</span> + obj1.j);</span><br><span class="line">        System.out.println(<span class="string">"obj2.i="</span> + obj2.i + <span class="string">", obj2.j="</span> + obj2.j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">obj1.i=<span class="number">10</span>, obj1.j=<span class="number">20</span></span><br><span class="line">obj2.i=<span class="number">10</span>, obj2.j=<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>注意：静态变量虽然也可以通过对象来访问，但是不被提倡，编译器也会产生警告。</p>
<p>上面的代码中，i 是静态变量，通过 obj1 改变 i 的值，会影响到 obj2；j 是实例变量，通过 obj1 改变 j 的值，不会影响到 obj2。这是因为 obj1.i 和 obj2.i 指向同一个内存空间（为整个类只分配一个静态变量的空间），而 obj1.j 和 obj2.j 指向不同的内存空间，请看下图：</p>
<p><img src="/2019/01/20/java/java入门基础（一）/03.png" alt></p>
<p>注意：static 的变量是在类装载的时候就会被初始化。也就是说，只要类被装载，不管你是否使用了这个static 变量，它都会被初始化。</p>
<p>小结：类变量(class variables)用关键字 static 修饰，在类加载的时候，分配类变量的内存，以后再生成类的实例对象时，将共享这块内存（类变量），任何一个对象对类变量的修改，都会影响其它对象。外部有两种访问方式：通过对象来访问或通过类名来访问。</p>
<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>静态方法是一种不能向对象实施操作的方法。例如，Math 类的 pow() 方法就是一个静态方法，语法为 Math.pow(x, a)，用来计算 x 的 a 次幂，在使用时无需创建任何 Math 对象。</p>
<p>因为静态方法不能操作对象，所以不能在静态方法中访问实例变量，只能访问自身类的静态变量。</p>
<p>关于静态变量和静态方法的总结：</p>
<ul>
<li>一个类的静态方法只能访问静态变量；</li>
<li>一个类的静态方法不能够直接调用非静态方法；</li>
<li>如访问控制权限允许，静态变量和静态方法也可以通过对象来访问，但是不被推荐；</li>
<li>静态方法中不存在当前对象，因而不能使用 this，当然也不能使用 super；</li>
<li>静态方法不能被非静态方法覆盖；</li>
<li>构造方法不允许声明为 static 的；</li>
<li>局部变量不能使用static修饰。</li>
</ul>
<blockquote>
<p> 注意：实例变量只能通过对象来访问，不能通过类访问。 </p>
</blockquote>
<h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><p>在 Java 中，声明类、变量和方法时，可使用关键字 final 来修饰。final 所修饰的数据具有“终态”的特征，表示“最终的”意思。具体规定如下：</p>
<ul>
<li>final 修饰的类不能被继承。</li>
<li>final 修饰的方法不能被子类重写。</li>
<li>final 修饰的变量（成员变量或局部变量）即成为常量，只能赋值一次。</li>
<li>final 修饰的成员变量必须在声明的同时赋值，如果在声明的时候没有赋值，那么只有 一次赋值的机会，而且只能在构造方法中显式赋值，然后才能使用。</li>
<li>final 修饰的局部变量可以只声明不赋值，然后再进行一次性的赋值。</li>
</ul>
<p>final 一般用于修饰那些通用性的功能、实现方式或取值不能随意被改变的数据，以避免被误用，例如实现数学三角方法、幂运算等功能的方法，以及数学常量π=3.141593、e=2.71828 等。</p>
<p>需要注意的是，如果将引用类型（任何类的类型）的变量标记为 final，那么该变量不能指向任何其它对象。但可以改变对象的内容，因为只有引用本身是 final 的。</p>
<p>如果变量被标记为 final，其结果是使它成为常数。想改变 final 变量的值会导致一个编译错误。</p>
<p>常量因为有 final 修饰，所以不能被继承。 </p>
<p>final 也可以用来修饰类（放在 class 关键字前面），阻止该类再派生出子类 。</p>
<p>方法也可以被 final 修饰，被 final 修饰的方法不能被覆盖 </p>
<h2 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h2><p>Object 类位于 java.lang 包中，是所有 Java 类的祖先，Java 中的每个类都由它扩展而来。定义Java类时如果没有显示的指明父类，那么就默认继承了 Object 类。</p>
<p>Object 类定义了一些有用的方法，由于是根类，这些方法在其他类中都存在，一般是进行了重载或覆盖，实现了各自的具体功能。 </p>
<h3 id="equals-方法"><a href="#equals-方法" class="headerlink" title="equals() 方法"></a>equals() 方法</h3><p>Object 类中的 equals() 方法用来检测一个<strong>对象</strong>是否等价于另外一个<strong>对象</strong></p>
<h3 id="hashCode-方法"><a href="#hashCode-方法" class="headerlink" title="hashCode()方法"></a>hashCode()方法</h3><p>散列码(hashCode)是按照一定的算法由对象得到的一个数值，散列码没有规律。如果 x 和 y 是不同的对象，x.hashCode() 与 y.hashCode() 基本上不会相同。hashCode() 方法主要用来在集合中实现快速查找等操作，也可以用于对象的比较。</p>
<h3 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString()方法"></a>toString()方法</h3><p>toString() 方法是 Object 类中定义的另一个重要方法，是对象的字符串表现形式</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习（四）：循环神经网络</title>
    <url>/2018/12/18/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<p>在本章中，我们将看到循环神经网络背后的基本概念，他们所面临的主要问题（换句话说，在之前中讨论的消失／爆炸的梯度），以及广泛用于反抗这些问题的方法：LSTM 和 GRU cell（单元）。 循环神经网路主要解决带有时序性质的问题。</p>
<h2 id="基本循环神经"><a href="#基本循环神经" class="headerlink" title="基本循环神经"></a>基本循环神经</h2><p>看下图中一个简单的循环神经网络图，它由输入层、一个隐藏层和一个输出层组成。我们可以看到，循环神经网络的隐藏层的值s不仅仅取决于当前这次的输入x，<strong>还取决于上一次隐藏层的值s</strong>（结果向前和向后传播后的上一次这个位置的值）。</p>
<p><img src="/2018/12/18/深度学习/深度学习（四）：循环神经网络/01.jpg" alt></p>
<p>如果我们把上面的图展开，循环神经网络也可以画成下面这个样子：</p>
<p><img src="/2018/12/18/深度学习/深度学习（四）：循环神经网络/02.jpg" alt></p>
<p> 现在看起来就清楚不少了，这个网络在t时刻接收到输入$X<em>t$之后，隐藏层的值是$S_t$，输出值是$o_t$。关键一点是，$s_t$的值不仅仅取决于$X_t$，还取决于$S</em>{t−1}$。我们可以使用下面的公式来表示循环神经网络的计算方法： (U,V,W都为权重) </p>
<script type="math/tex; mode=display">
o_t=g(Vs_t)\\s_t=f(Ux_t+Ws_{t-1})</script><p>式1是输出层的计算公式，输出层是一个全连接层，也就是它的每个节点都和隐藏层的每个节点相连。V是输出层的权重矩阵，g是激活函数。式2是隐藏层的计算公式，它是循环层。U是输入x的权重矩阵，W是上一次的值st−1st−1作为这一次的输入的权重矩阵，f是激活函数。</p>
<p>从上面的公式可以看出，循环层和全连接层的区别就是多了一个权重矩阵W。</p>
<p>若反复把式2代入带式1，我们将得到：</p>
<script type="math/tex; mode=display">
o_t=g(Vs_t)=g(Vf(Ux_t+Ws_{t-1}))</script><script type="math/tex; mode=display">
=g(Vf(Ux_t+Wf(Ux_{t-1}+Ws_{t-2 })))</script><script type="math/tex; mode=display">
=g(Vf(Ux_t+Wf(Ux_{t-1}+Wf(Ux_{t-2}+Ws_{t-3 }))))</script><p> 从上面可以看出，循环神经网络的输出值$o<em>t$，是受前面历次输入值$x_t$、$x</em>{t−1}$、$x_{t−2}$…的影响的，这就是为什么循环神经网络可以往前看任意多个输入值的原因。 </p>
<p> 再来看一个清晰一点的循环神经元层，见下图， 在每个时间步t，每个神经元都接收输入向量$x^{(t)}$和前一个时间步的输出向量$y^{(t−1)}$，如图所示。 请注意，输入和输出都是向量（当只有一个神经元时，输出是一个标量）。 </p>
<p><img src="/2018/12/18/深度学习/深度学习（四）：循环神经网络/03.png" alt></p>
<p> 每个循环神经元有两组权重：一组用于输入 $x^{(t)}$，另一组用于前一时间步长 $y^{(t−1)}$的输出。我们称这些权重向量为$w_x$和$w_y$。如下面公式所示（<code>b</code>是偏差项，<code>φ(·)</code>是激活函数，例如 ReLU），可以计算单个循环神经元的输出。 </p>
<p><img src="/2018/12/18/深度学习/深度学习（四）：循环神经网络/04.png" alt></p>
<p> 就像前馈神经网络一样，我们可以使用上一个公式的向量化形式，对整个小批量计算整个层的输出。 </p>
<p><img src="/2018/12/18/深度学习/深度学习（四）：循环神经网络/05.png" alt></p>
<ul>
<li>$Y^{(t)}$是$m×n<em>{neurons}$矩阵，包含在最小批次中每个实例在时间步<code>t</code>处的层输出（<code>m</code>是小批次中的实例数， $n</em>{neurons}$是神经元数</li>
<li>$X^{(t)}$是$m×n<em>{inputs}$矩阵，包含所有实例的输入的（$n</em>{inputs}$是输入特征的数量 ）</li>
<li>$W<em>x$是$ n</em>{inputs}×n_{neurons} $矩阵，包含当前时间步的输入的连接权重的。</li>
<li>$W<em>y$是$n</em>{neurons}×n_{neurons}$矩阵，包含上一个时间步的输出的连接权重。</li>
<li>权重矩阵$W<em>x$和$W_y$通常连接成单个矩阵W，形状为$(n</em>{inputs}+n<em>{neurons})×n</em>{neurons}$（见上述公式第二行）</li>
<li><code>b</code>是大小为 $n_{neurons}$的向量，包含每个神经元的偏置项</li>
</ul>
<blockquote>
<p>注意， 在第一个时间步，<code>t = 0</code>，没有以前的输出，所以它们通常被假定为全零。</p>
</blockquote>
<h2 id="TensorFlow-中的解释基本-RNN"><a href="#TensorFlow-中的解释基本-RNN" class="headerlink" title="TensorFlow 中的解释基本 RNN"></a>TensorFlow 中的解释基本 RNN</h2><p>首先，我们来实现一个非常简单的 RNN 模型，而不使用任何 TensorFlow 的 RNN 操作，以更好地理解发生了什么。 我们将<strong>使用 tanh 激活函数创建由 5 个循环神经元的循环层组成的 RNN</strong>（如下图所示的 RNN）。</p>
<p><img src="/2018/12/18/深度学习/深度学习（四）：循环神经网络/03.png" alt></p>
<p> 我们将假设 RNN <strong>只运行两个时间步</strong>，每个时间步输入大小为 3 的向量。 下面的代码构建了这个 RNN，展开了两个时间步骤： </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n_inputs = <span class="number">3</span></span><br><span class="line">n_neurons = <span class="number">5</span></span><br><span class="line">X0 = tf.placeholder(tf.float32, [<span class="literal">None</span>, n_inputs])</span><br><span class="line"><span class="comment"># 充当经过向前向后传播后的下一时刻的输入值</span></span><br><span class="line">X1 = tf.placeholder(tf.float32, [<span class="literal">None</span>, n_inputs]) </span><br><span class="line">Wx = tf.Variable(tf.random_normal(shape=[n_inputs, n_neurons], dtype=tf.float32))</span><br><span class="line">Wy = tf.Variable(tf.random_normal(shape=[n_neurons, n_neurons], dtype=tf.float32))</span><br><span class="line">b = tf.Variable(tf.zeros([<span class="number">1</span>, n_neurons], dtype=tf.float32))</span><br><span class="line">Y0 = tf.tanh(tf.matmul(X0, Wx) + b)</span><br><span class="line">Y1 = tf.tanh(tf.matmul(Y0, Wy) + tf.matmul(X1, Wx) + b) <span class="comment"># 主要理解这句</span></span><br><span class="line">init = tf.global_variables_initializer()</span><br></pre></td></tr></table></figure>
<h2 id="双向循环神经网络"><a href="#双向循环神经网络" class="headerlink" title="双向循环神经网络"></a>双向循环神经网络</h2><p>对于语言模型来说，很多时候光看前面的词是不够的，比如下面这句话：</p>
<blockquote>
<p>我的手机坏了，我打算<em>__</em>一部新手机。</p>
</blockquote>
<p>可以想象，如果我们只看横线前面的词，手机坏了，那么我是打算修一修？换一部新的？还是大哭一场？这些都是无法确定的，但是如果我们也看到了后面的词是“一部新手机”，那么横线上的词填“买”的概率就大很多了。</p>
<p>而这个在单向循环神经网络是无法建模的，因此我们需要双向循环神经网络，如下图所示：</p>
<p><img src="/2018/12/18/深度学习/深度学习（四）：循环神经网络/06.jpg" alt></p>
<p> 我们先考虑$y_2$的计算，从上图可以看出，双向卷积神经网络的隐藏层要保存两个值，一个A参与正向计算，另一个A′参与反向计算。最终的输出值$y_2$取决于$A_2$和$A_2’$，其计算方法为： </p>
<script type="math/tex; mode=display">
y_2=g(VA_2+V'A_2')</script><p>$A_2$和$A_2’$ 则分别计算 </p>
<script type="math/tex; mode=display">
A_2=f(WA_1+Ux_2)</script><script type="math/tex; mode=display">
A_2'=f(W'A_3'+U'x_2 )</script><p> 现在，我们已经可以看出一般的规律：正向计算时，隐藏层的值$s<em>t$与$s</em>{t−1}$有关；反向计算时，隐藏层的值$s<em>t′$与$s′</em>{t+1}$有关；最终的输出取决于正向和反向计算的加和。现在，我们仿照式1和式2，写出双向循环神经网络的计算方法： </p>
<script type="math/tex; mode=display">
o_t=g(Vs_t+V's_t')</script><script type="math/tex; mode=display">
s_t=f(Ux_t+Ws_{t-1 })</script><script type="math/tex; mode=display">
s_t'=f(U'x_t+W's_{t+1}')</script><p>从上面三个公式我们可以看到，正向计算和反向计算不共享权重，也就是说U和U′、W和W′、V和V′都是不同的权重矩阵。</p>
<h2 id="深度循环神经网络"><a href="#深度循环神经网络" class="headerlink" title="深度循环神经网络"></a>深度循环神经网络</h2><p>前面我们介绍的循环神经网络只有一个隐藏层，我们当然也可以堆叠两个以上的隐藏层，这样就得到了深度循环神经网络。如下图所示</p>
<p><img src="/2018/12/18/深度学习/深度学习（四）：循环神经网络/07.jpg" alt></p>
<h2 id="训练-RNN"><a href="#训练-RNN" class="headerlink" title="训练 RNN"></a>训练 RNN</h2><p>为了训练一个 RNN，诀窍是在时间上展开（就像我们刚刚做的那样），然后简单地使用常规反向传播（见图 14-5）。 这个策略被称为时间上的标准反向传播（BPTT）。另外可以<strong>采用截断式沿时间反向传播算法</strong>（BPTT）可以降低循环网络中每项参数更新的复杂度。简而言之，此种算法可以让我们以同样的运算能力更快地定型神经网络 。假设用长度为12个时间步的时间序列定型一个循环网络。我们需要进行12步的正向传递，计算误差（基于预测与实际值对比），再进行12个时间步的反向传递：</p>
<p><img src="/2018/12/18/深度学习/深度学习（四）：循环神经网络/08.png" alt></p>
<p>就像在正常的反向传播中一样，展开的网络（用虚线箭头表示）有第一个正向传递。然后使用损失函数评估输出序列$C(Y<em>{t</em>{min}},Y<em>{t</em>{min+1}},…,Y<em>{t</em>{max}})$。其中$t<em>{min}$ 和$t</em>{max}$ 是第一个和最后一个输出时间步长，不计算忽略的输出），并且该损失函数的梯度通过展开的网络向后传播（实线箭头）；最后使用在 BPTT 期间计算的梯度来更新模型参数。 请注意，梯度在损失函数所使用的所有输出中反向流动，而不仅仅通过最终输出（截断式传播，例如，在图 14-5 中，损失函数使用网络的最后三个输出Y(2)，Y(3)，和Y(4)，所以梯度流经这三个输出，但不通过Y(0)和Y(1)。而且，由于在每个时间步骤使用相同的参数<code>W</code>和<code>b</code>，所以反向传播将做正确的事情并且总结所有时间步骤。</p>
<p>具体BPTT的解析过程可以看这篇<a href="http://www.cnblogs.com/zhbzz2007/p/6339346.html" target="_blank" rel="noopener">戳我</a></p>
<h3 id="训练序列分类器"><a href="#训练序列分类器" class="headerlink" title="训练序列分类器"></a>训练序列分类器</h3><p>我们训练一个 RNN 来分类 MNIST 图像。 卷积神经网络将更适合于图像分类，但这是一个你已经熟悉的简单例子。 我们将把每个图像视为 28 行 28 像素的序列（因为每个MNIST图像是<code>28×28</code>像素）。 我们将使用 150 个循环神经元的单元，再加上一个全连接层，其中包含连接到上一个时间步的输出的 10 个神经元（每个类一个），然后是一个 softmax 层（见图）。</p>
<p><img src="/2018/12/18/深度学习/深度学习（四）：循环神经网络/10.png" alt></p>
<p> 建模阶段非常简单， 它和我们在之前中建立的 MNIST 分类器几乎是一样的，只是展开的 RNN 替换了隐层。 注意，全连接层连接到状态张量，其仅包含 RNN 的最终状态（即，第 28 个输出）。 另请注意，<code>y</code>是目标类的占位符。 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n_steps = <span class="number">28</span></span><br><span class="line">n_inputs = <span class="number">28</span></span><br><span class="line">n_neurons = <span class="number">150</span></span><br><span class="line">n_outputs = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">learning_rate = <span class="number">0.001</span></span><br><span class="line"></span><br><span class="line">X = tf.placeholder(tf.float32, [<span class="literal">None</span>, n_steps, n_inputs])</span><br><span class="line">y = tf.placeholder(tf.int32, [<span class="literal">None</span>])</span><br><span class="line"></span><br><span class="line">basic_cell = tf.contrib.rnn.BasicRNNCell(num_units=n_neurons)</span><br><span class="line">outputs, states = tf.nn.dynamic_rnn(basic_cell, X, dtype=tf.float32)</span><br><span class="line"></span><br><span class="line">logits = tf.layers.dense(states, n_outputs)</span><br><span class="line">xentropy = tf.nn.sparse_softmax_cross_entropy_with_logits(labels=y,</span><br><span class="line">                                                          logits=logits)</span><br><span class="line">loss = tf.reduce_mean(xentropy)</span><br><span class="line">optimizer = tf.train.AdamOptimizer(learning_rate=learning_rate)</span><br><span class="line">training_op = optimizer.minimize(loss)</span><br><span class="line">correct = tf.nn.in_top_k(logits, y, <span class="number">1</span>)</span><br><span class="line">accuracy = tf.reduce_mean(tf.cast(correct, tf.float32))</span><br><span class="line"></span><br><span class="line">init = tf.global_variables_initializer()</span><br></pre></td></tr></table></figure>
<p>现在让我们加载 MNIST 数据，并按照网络的预期方式将测试数据重塑为<code>[batch_size, n_steps, n_inputs]</code>。 我们之后会关注训练数据的重塑。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.examples.tutorials.mnist <span class="keyword">import</span> input_data</span><br><span class="line">mnist = input_data.read_data_sets(<span class="string">"/tmp/data/"</span>)</span><br><span class="line">X_test = mnist.test.images.reshape((<span class="number">-1</span>, n_steps, n_inputs))</span><br><span class="line">y_test = mnist.test.labels</span><br></pre></td></tr></table></figure>
<p>现在我们准备训练 RNN 了。 执行阶段与第 10 章中 MNIST 分类器的执行阶段完全相同，不同之处在于我们在将每个训练的批量提供给网络之前要重新调整。</p>
<p>现在我们准备训练 RNN 了。 执行阶段与第 10 章中 MNIST 分类器的执行阶段完全相同，不同之处在于我们在将每个训练的批量提供给网络之前要重新调整。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">batch_size = <span class="number">150</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    init.run()</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> range(n_epochs):</span><br><span class="line">        <span class="keyword">for</span> iteration <span class="keyword">in</span> range(mnist.train.num_examples // batch_size):</span><br><span class="line">            X_batch, y_batch = mnist.train.next_batch(batch_size)</span><br><span class="line">            X_batch = X_batch.reshape((<span class="number">-1</span>, n_steps, n_inputs))</span><br><span class="line">            sess.run(training_op, feed_dict=&#123;X: X_batch, y: y_batch&#125;)</span><br><span class="line">        acc_train = accuracy.eval(feed_dict=&#123;X: X_batch, y: y_batch&#125;)</span><br><span class="line">        acc_test = accuracy.eval(feed_dict=&#123;X: X_test, y: y_test&#125;)</span><br><span class="line">        print(epoch, <span class="string">"Train accuracy:"</span>, acc_train, <span class="string">"Test accuracy:"</span>, acc_test)</span><br></pre></td></tr></table></figure>
<p>输出应该是这样的：</p>
<p><img src="/2018/12/18/深度学习/深度学习（四）：循环神经网络/11.png" alt></p>
<p>我们获得了超过 98% 的准确性 - 不错！ 另外，通过调整超参数，使用 He 初始化初始化 RNN 权重，更长时间训练或添加一些正则化（例如，droupout），你肯定会获得更好的结果。</p>
<p>你可以通过将其构造代码包装在一个变量作用域内（例如，使用<code>variable_scope(&quot;rnn&quot;, initializer = variance_scaling_initializer())</code>来使用 He 初始化）来为 RNN 指定初始化器。</p>
<h3 id="为预测时间序列而训练"><a href="#为预测时间序列而训练" class="headerlink" title="为预测时间序列而训练"></a>为预测时间序列而训练</h3><p>首先，我们来创建一个 RNN。 它将包含 100 个循环神经元，并且我们将在 20 个时间步骤上展开它，因为每个训练实例将是 20 个输入那么长。 每个输入将仅包含一个特征（在该时间的值）。 目标也是 20 个输入的序列，每个输入包含一个值。 代码与之前几乎相同：</p>
<p><img src="/2018/12/18/深度学习/深度学习（四）：循环神经网络/12.png" alt></p>
<p>一般来说，你将不只有一个输入功能。 例如，如果你试图预测股票价格，则你可能在每个时间步骤都会有许多其他输入功能，例如竞争股票的价格，分析师的评级或可能帮助系统进行预测的任何其他功能。</p>
<p>在每个时间步，我们现在有一个大小为 100 的输出向量。但是我们实际需要的是每个时间步的单个输出值。 最简单的解决方法是将单元包装在<code>OutputProjectionWrapper</code>中。 单元包装器就像一个普通的单元，代理每个方法调用一个底层单元，但是它也增加了一些功能。<code>Out putProjectionWrapper</code>在每个输出之上添加一个完全连接的线性神经元层（即没有任何激活函数）（但不影响单元状态）。 所有这些完全连接的层共享相同（可训练）的权重和偏差项。 结果 RNN 如图所示</p>
<p><img src="/2018/12/18/深度学习/深度学习（四）：循环神经网络/13.png" alt></p>
<p>装单元是相当容易的。 让我们通过将<code>BasicRNNCell</code>包装到<code>OutputProjectionWrapper</code>中来调整前面的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cell =tf.contrib.rnn.OutputProjectionWrapper(</span><br><span class="line">    tf.contrib.rnn.BasicRNNCell(num_units=n_neurons,activation=tf.nn.relu),</span><br><span class="line">    output_size=n_outputs)</span><br></pre></td></tr></table></figure>
<p>到现在为止还挺好。 现在我们需要定义损失函数。 我们将使用均方误差（MSE），就像我们在之前的回归任务中所做的那样。 接下来，我们将像往常一样创建一个 Adam 优化器，训练操作和变量初始化操作。（省略）</p>
<h3 id="生成-RNN"><a href="#生成-RNN" class="headerlink" title="生成 RNN"></a>生成 RNN</h3><p>到现在为止，我们已经训练了一个能够预测未来时刻样本值的模型，正如前文所述，可以用模型来生成新的序列。</p>
<p>为模型提供 长度为<code>n_steps</code>的种子序列, 比如全零序列，然后通过模型预测下一时刻的值；把该预测值添加到种子序列的末尾，用最后面 长度为<code>n_steps</code>的序列做为新的种子序列，做下一次预测，以此类推生成预测序列。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sequence = [<span class="number">0.</span>] * n_steps</span><br><span class="line"><span class="keyword">for</span> iteration <span class="keyword">in</span> range(<span class="number">300</span>):</span><br><span class="line">    X_batch = np.array(sequence[-n_steps:].reshape(<span class="number">1</span>, n_steps, <span class="number">1</span>)</span><br><span class="line">    y_pred = sess.run(outputs, feed_dict=&#123;X: X_batch&#125;</span><br><span class="line">    sequence.append(y_pred[<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h2 id="LSTM-单元"><a href="#LSTM-单元" class="headerlink" title="LSTM 单元"></a>LSTM 单元</h2><p><strong>在训练长序列的 RNN 模型时，那么就需要把 RNN 在时间维度上展开成很深的神经网络</strong>。正如任何深度神经网络一样，其面临着梯度消失/爆炸的问题，使训练无法终止或收敛。很多之前讨论过的缓解这种问题的技巧都可以应用在深度展开的 RNN 网络：好的参数初始化方式，非饱和的激活函数（如 ReLU），批量规范化（Batch Normalization）， 梯度截断（Gradient Clipping），更快的优化器。</p>
<p>即便如此， RNN 在处理适中的长序列（如 100 输入序列）也在训练时表现的很慢。最简单和常见的方法解决训练时长问题就是在训练阶段仅仅展开限定时间步长的 RNN 网络，一种称为截断时间反向传播的算法。</p>
<p><strong>在长的时间训练过程中，第二个要面临的问题时第一个输入的记忆会在长时间运行的 RNN 网络中逐渐淡去。 那么在一定时间后，第一个输入实际上会在 RNN 的状态中消失于无形</strong>。 为了解决其中的问题，各种能够携带长时记忆的神经单元的变体被提出。<strong>这些变体是有效的，往往基本形式的神经单元就不怎么被使用了。</strong></p>
<p>首先了解一下最流行的一种长时记忆神经单元：长短时记忆神经单元 LSTM。 可以看下面这篇文章</p>
<p><a href="https://www.yunaitong.cn/understanding-lstm-networks.html" target="_blank" rel="noopener">理解LSTM网络</a></p>
<blockquote>
<p>注：LSTM和GRU单元是近年来RNN成功背后的主要原因之一，特别实在自然语言的应用</p>
</blockquote>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>循环神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习（三）：卷积神经网络</title>
    <url>/2018/12/14/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h2 id="认识卷积神经网络"><a href="#认识卷积神经网络" class="headerlink" title="认识卷积神经网络"></a>认识卷积神经网络</h2><p>全连接神经网络之所以不太适合图像识别任务，主要有三个方面的问题：</p>
<ul>
<li>参数数量太多，一个输入1000×1000像素的图片有100万个神经元（一个像素点代表一个神经元）</li>
<li>没有利用像素之间的位置信息</li>
<li>网络层数限制，网络层数越多，其表达能力越强，但是通过梯度下降方法训练深度全连接神经网络很困难，因为全连接神经网络的梯度很难传递超过三层。</li>
</ul>
<h3 id="局部感受野（local-receptive-fields）"><a href="#局部感受野（local-receptive-fields）" class="headerlink" title="局部感受野（local receptive fields）"></a>局部感受野（local receptive fields）</h3><p>在之前的全连接神经网络中，一个样例的输入被转换为一个一维向量。但在一个卷积网络中，把输入看作是一个按照28×28排列的正方形，或者当有颜色通道的时候，比如28x28x3，就是宽高都是28，且有3个颜色通道。比如下图就代表了一个输入</p>
<p><img src="/2018/12/14/深度学习/深度学习（三）：卷积神经网络/01.jpg" alt></p>
<p> 然后，我们通常把输入像素连接到一个隐藏层的神经元，但和全连接神经网络那样每个输入都连接一个隐藏层神经元不同的是，这里我们只是把输入图像进行局部的连接。 </p>
<p><img src="/2018/12/14/深度学习/深度学习（三）：卷积神经网络/02.jpg" alt></p>
<p>如此不断地重复，构建起第一个隐藏层。注意如果我们有一个28×28的输入图像，5×5的局部感受野，那么隐藏层中就会有24×24个神经元。这是因为在抵达抵达最右边或最底部的输入图像之前，我们只能把局部感受野向右或向下移动23个神经元。</p>
<p><img src="/2018/12/14/深度学习/深度学习（三）：卷积神经网络/03.jpg" alt></p>
<p>如上图所示，把图中间的那个看作是可以“滑动的窗口”，他的作用是和输入相应的“感受域”下的像素做运算得到新的值。这个运算就是“卷积”运算了。图上面有详细的运算过程。实际上就是每个相应元素的值相乘，然后把得到的都加起来。这个窗口的本质是其中的数字和一个偏置构成的，通常就把<strong>这个窗口(Convolution kernel)叫做滤波器或者卷积核（相当于是全连接层里面要求的隐藏权重，它代表识别某个特征）</strong>。 这个“窗口”是可以滑动的，每次的滑动步长可以人为指定 。</p>
<h3 id="池化-Pooling"><a href="#池化-Pooling" class="headerlink" title="池化(Pooling)"></a>池化(Pooling)</h3><p>它的作用是逐渐<strong>降低数据体的空间尺寸，这样的话就能减少网络中参数的数量，使得计算资源耗费变少，也能有效控制过拟合</strong>。最常见的形式是汇聚层使用尺寸2x2的滤波器，以步长为2来对每个深度切片进行降采样，将其中75%的激活信息都丢掉。每个MAX操作是从4个数字中取最大值（也就是在深度切片中某个2x2的区域）。深度保持不变。</p>
<p>Pooling的方法很多，最常用的是Max Pooling。 此外，还有平均池化（average pooling）和L2-norm池化。</p>
<p><img src="/2018/12/14/深度学习/深度学习（三）：卷积神经网络/04.jpg" alt></p>
<h2 id="卷积神经网络的层"><a href="#卷积神经网络的层" class="headerlink" title="卷积神经网络的层"></a>卷积神经网络的层</h2><p>首先，让我们对卷积神经网络有一个感性的认识，下图就是一个卷积神经网络的示意图：</p>
<p><img src="/2018/12/14/深度学习/深度学习（三）：卷积神经网络/05.jpg" alt></p>
<p> 如上图所示，一个神经网络由若干卷积层（CONV）、Pooling层（POOL）、全连接层（FC）组成。你可以构建各种不同的卷积神经网络，它的常用架构模式为： </p>
<script type="math/tex; mode=display">
INPUT\rightarrow\left[\left[CONV\right]\times N\rightarrow POOL\right]\times M\rightarrow\left[FC\right]\times K</script><p>也就是N个卷积层叠加，然后叠加一个Pooling层（可选），重复这个结构M次，最后叠加K个全连接层。</p>
<p>对于上图来说，该卷积神经网络的架构为：</p>
<script type="math/tex; mode=display">
INPUT\rightarrow\left[\left[CONV\right]\times 1\rightarrow POOL\right]\times 2\rightarrow\left[FC\right]\times 2</script><p>也就是N=1,M=2,K=2</p>
<p>我们看到输入层的宽度和高度对应于输入图像的宽度和高度，而他的深度为1。接着第一个卷积层对这幅图像进行了卷积操作，得到了三个Feature Map。<strong>实际上这个卷积层包含三个Filter（卷积核，是隐藏不显示图上的），也就是三套参数，每个Filter都可以把原始输入图像卷积得到一个Feature Map，三个Filter就可以得到三个Feature Map</strong>。<strong>至于一个卷积层可以有多少个Filter，那是可以自由设定的。也就是说，卷积层的Filter个数也是一个超参数</strong>。<strong>我们可以把Feature Map可以看做是通过卷积变换提取到的图像特征，三个Filter就对原始图像提取出三组不同的特征</strong>，也就是得到了三个Feature Map，也称做三个通道(channel)。</p>
<p>在第一个卷积层之后，Pooling层对三个Feature Map做了下采样，得到了三个更小的Feature Map。接着，<strong>是第二个卷积层，它有5个Filter</strong>。<strong>每个Fitler都把前面下采样之后的3个Feature Map卷积在一起（每个Fitlter与输入有相同的深度，然后对应相乘后总相加）</strong>，得到一个新的Feature Map。这样，5个Filter就得到了5个Feature Map。接着，是第二个Pooling，继续对5个Feature Map进行下采样，得到了5个更小的Feature Map。</p>
<p><strong>最后两层是全连接层。第一个全连接层的每个神经元，和上一层5个Feature Map中的每个神经元相连</strong>，第二个全连接层(也就是输出层)的每个神经元，则和第一个全连接层的每个神经元相连，这样得到了整个网络的输出。</p>
<p>至此，我们对卷积神经网络有了最基本的感性认识。接下来，我们将介绍卷积神经网络中各种层的计算和训练。</p>
<h3 id="卷积层"><a href="#卷积层" class="headerlink" title="卷积层"></a>卷积层</h3><p>卷积层的参数是一些可学习的滤波器（卷积核，隐藏不显示，相当于全连接层的隐藏权重）构成，<strong>滤波器的宽度和高度一般不大，深度与其输入数据保持一致</strong>。见下图：</p>
<p><img src="/2018/12/14/深度学习/深度学习（三）：卷积神经网络/06.jpg" alt></p>
<p><img src="/2018/12/14/深度学习/深度学习（三）：卷积神经网络/07.jpg" alt></p>
<p><img src="/2018/12/14/深度学习/深度学习（三）：卷积神经网络/08.jpg" alt></p>
<p><img src="/2018/12/14/深度学习/深度学习（三）：卷积神经网络/09.jpg" alt></p>
<p><strong>要点</strong>：卷积层有一个或多个滤波器（卷积核）构成，每个卷积核宽度和高度（这里为5×5）一般不大，深度（这里为3）与其输入数据保持一致。这里有6个不同的卷积核，得到的6个不同的activation map分别表示诸如边缘特征、形状特征等特征图，将这些activation map映射在深度方向上层叠起来就生成了输出数据。所以在用了6个过滤器（卷积层）之后，我们可以得到28×28×6的激活图。</p>
<h3 id="卷积层输出值的计算"><a href="#卷积层输出值的计算" class="headerlink" title="卷积层输出值的计算"></a>卷积层输出值的计算</h3><p>我们使用一个简单的例子来讲述如何计算卷积，然后，抽象出卷积层的一些重要概念和计算方法。</p>
<p>假设有一个5×5的图像，使用一个3×3的滤波器进行卷积，想得到3×3的Feature Map，如下所示：</p>
<p><img src="/2018/12/14/深度学习/深度学习（三）：卷积神经网络/10.jpg" alt></p>
<p> 为了清楚地描述卷积的计算过程，我们首先对图像的每个像素进行编号，用$x<em>{i,j}$表示图像的第i行第j列元素，对filter的每个权重进行编号，用$w</em>{m,n}$表示第m行第n列权重，用$w<em>b$表示filter的偏置项；对Feature Map的每个元素进行编号，用$a</em>{i,j}$表示Feature Map的第i行第j列元素；用f表示激活函数（此处使用Relu函数作为激活函数）。然后使用下列公式计算卷积： </p>
<script type="math/tex; mode=display">
a_{i,j}=f\left(\sum_{m=0}^2{\sum_{n=0}^2{w_{m,n}x_{m+i,n+j}}}+w_b\right)</script><p> 例如，对于Feature Map的左上角元素$a_{0,0}$来说，其卷积计算方法为：</p>
<script type="math/tex; mode=display">
a_{0,0}=f\left(\sum_{m=0}^2{\sum_{n=0}^2{w_{m,n}x_{m+0,n+0}}}+w_b\right)=Relu\left(4\right)=4</script><p> 按照这个公式可以依次计算出Feature Map中所有的值，下面的动画显示了整个Feature Map的计算过程： </p>
<p><img src="/2018/12/14/深度学习/深度学习（三）：卷积神经网络/11.gif" alt></p>
<h3 id="填充和步幅"><a href="#填充和步幅" class="headerlink" title="填充和步幅"></a>填充和步幅</h3><p>假设输入形状的$n_h\times n_w$，卷积核窗口形状是$k_h\times k_w$，那么输出的形状将会是</p>
<script type="math/tex; mode=display">
(n_h-k_h+1)\times (n_w-k_w+1)</script><p>所以卷积层的输出形状由输⼊形状和卷积核窗口形状决定。这里我们将介绍卷积层的两个超参数，填充和步幅。它们可以对给定形状的输⼊和卷积核改变输出形状。</p>
<p><strong>填充</strong>（padding）是指在输入和宽的两侧填充元素（通常是0元素）。下图表示在原输入高的宽的两侧分别添加了值为0的元素，使得高和宽从3变成了5，并导致输出的高和宽由2增加到4.</p>
<p><img src="/2018/12/14/深度学习/深度学习（三）：卷积神经网络/12.png" alt></p>
<p>卷积窗口从输⼊数组的最左上⽅开始，按从左往右、从上往下的顺序，依次在输⼊数组上滑动。我们将每次滑动的⾏数和列数称为<strong>步幅</strong>（stride）</p>
<p>上面的计算过程中，步幅（stride）为1。当然步幅可以设为大于1的数。例如，当步幅为2时，Feature Map计算如下：</p>
<p><img src="/2018/12/14/深度学习/深度学习（三）：卷积神经网络/13.jpg" alt></p>
<h3 id="多输入通道"><a href="#多输入通道" class="headerlink" title="多输入通道"></a>多输入通道</h3><p>到此我们讲了深度为1的卷积层的计算方法，如果深度大于1怎么计算呢？其实也是类似的。 下图展⽰了含2个输⼊通道的⼆维互相关计算的例⼦。在每个通道上，⼆维输⼊数组与⼆维核数组做互相关运算，再按通道相加即得到输出。图中阴影部分为第⼀个输出元及其计算所使⽤的输⼊和核数组元素：</p>
<script type="math/tex; mode=display">
(1×1+2×2+4×3+5×4)+(0×0+1×1+3×2+4×3)=56</script><p><img src="/2018/12/14/深度学习/深度学习（三）：卷积神经网络/14.png" alt></p>
<p> 动画演示 </p>
<p><img src="/2018/12/14/深度学习/深度学习（三）：卷积神经网络/15.gif" alt></p>
<h2 id="内存需求"><a href="#内存需求" class="headerlink" title="内存需求"></a>内存需求</h2><p>CNN 的另一个问题是卷积层需要大量的 RAM，特别是在训练期间，因为反向传播需要在正向传递期间计算的所有中间值。</p>
<p><strong>如果由于内存不足错误导致训练崩溃，则可以尝试减少小批量大小。 或者，您可以尝试使用步幅降低维度，或者删除几个图层。 或者你可以尝试使用 16 位浮点数而不是 32 位浮点数。 或者你可以在多个设备上分发 CNN。</strong></p>
<h2 id="CNN-架构"><a href="#CNN-架构" class="headerlink" title="CNN 架构"></a>CNN 架构</h2><p>典型的 CNN 体系结构有一些卷积层（每一个通常跟着一个 ReLU 层），然后是一个池化层，然后是另外几个卷积层（+ ReLU），然后是另一个池化层，等等。 随着网络的进展，图像变得越来越小，但是由于卷积层的缘故，图像通常也会越来越深（即更多的特征映射）。 在堆栈的顶部，添加由几个全连接层（+ ReLU）组成的常规前馈神经网络，并且最终层输出预测（例如，输出估计类别概率的 softmax 层）。</p>
<p><strong>一个常见的错误是使用太大的卷积核。 通常可以通过将两个3×3内核堆叠在一起来获得与9×9内核相同的效果，计算量更少。</strong></p>
<p>多年来，这种基础架构的变体已经被开发出来，导致了该领域的惊人进步。<strong>这里就不展开讲了，大家感兴趣可以去找相关的论文和资料深入了解这些流行的CNN架构。</strong></p>
<h3 id="LeNet-5"><a href="#LeNet-5" class="headerlink" title="LeNet-5"></a>LeNet-5</h3><p>LeNet-5 架构也许是最广为人知的 CNN 架构。 如前所述，它是由 Yann LeCun 于 1998 年创建的，广泛用于手写数字识别（MNIST）。</p>
<p><img src="/2018/12/14/深度学习/深度学习（三）：卷积神经网络/16.png" alt></p>
<h3 id="AlexNet"><a href="#AlexNet" class="headerlink" title="AlexNet"></a>AlexNet</h3><p>AlexNet CNN 架构赢得了 2012 年的 ImageNet ILSVRC 挑战赛：它达到了 17% 的 top-5 的错误率，而第二名错误率只有 26%！ 它由 Alex Krizhevsky（因此而得名），Ilya Sutskever 和 Geoffrey Hinton 开发。 它与 LeNet-5 非常相似，只是更大更深，它是第一个将卷积层直接堆叠在一起，而不是在每个卷积层顶部堆叠一个池化层。</p>
<p><img src="/2018/12/14/深度学习/深度学习（三）：卷积神经网络/17.png" alt></p>
<h3 id="VGG"><a href="#VGG" class="headerlink" title="VGG"></a>VGG</h3><p>它名字来源于论⽂作者所在的实验室Visual Geometry Group。VGG提出了可以通过重复使⽤简单的基础块来构建深度模型的思路.</p>
<p>VGG块的组成规律是：连续使⽤数个相同的填充为1、窗口形状为3 × 3的卷积层后接上⼀个步幅为2、窗口形状为2 × 2的最⼤池化层。卷积层保持输⼊的⾼和宽不变，而池化层则对其减半。VGG⽹络同Alex Net和Le Net⼀样，VGG⽹络由卷积层模块后接全连接层模块构成。。全连接模块则跟Alex Net中的⼀样。</p>
<h3 id="GoogLeNet"><a href="#GoogLeNet" class="headerlink" title="GoogLeNet"></a>GoogLeNet</h3><p>GoogLeNet 架构是由 Christian Szegedy 等人开发的。 来自 Google Research，通过低于 7% 的 top-5 错误率，赢得了 ILSVRC 2014 的挑战赛。 这个伟大的表现很大程度上因为它比以前的 CNN 网络更深。 <strong>这是通过称为初始模块（inception modules）的子网络实现的</strong>，这使得 GoogLeNet 比以前的架构更有效地使用参数：实际上，GoogLeNet 的参数比 AlexNet 少了 10 倍（约 600 万而不是 6000 万）。</p>
<p><img src="/2018/12/14/深度学习/深度学习（三）：卷积神经网络/18.png" alt></p>
<h3 id="ResNet"><a href="#ResNet" class="headerlink" title="ResNet"></a>ResNet</h3><p>最后是，2015 年 ILSVRC 挑战赛的赢家 Kaiming He 等人开发的 Residual Network（或 ResNet），该网络的 top-5 误率低到惊人的 3.6%，它使用了一个非常深的 CNN，由 152 层组成。 能够训练如此深的网络的关键是使用跳过连接（skip connection，也称为快捷连接）：一个层的输入信号也被添加到位于下一层的输出。 让我们看看为什么这是有用的。</p>
<p>当训练一个神经网络时，目标是使其模拟一个目标函数<code>h(x)</code>。 如果将输入x添加到网络的输出中（即添加跳过连接），那么网络将被迫模拟<code>f(x)= h(x) - x</code>而不是<code>h(x)</code>。 这被称为残留学习</p>
<p><img src="/2018/12/14/深度学习/深度学习（三）：卷积神经网络/19.png" alt></p>
<p>当你初始化一个普通的神经网络时，它的权重接近于零，所以网络只输出接近零的值。 如果添加跳过连接，则生成的网络只输出其输入的副本; 换句话说，它最初对身份函数进行建模。 如果目标函数与身份函数非常接近（常常是这种情况），这将大大加快训练速度。 由于跳过连接，信号可以很容易地通过整个网络。 深度剩余网络可以看作是一堆剩余单位，其中每个剩余单位是一个有跳过连接的小型神经网络。</p>
<p>现在让我们看看 ResNet 的架构（见下图）。 这实际上是令人惊讶的简单。 它的开始和结束与GoogLeNet完全一样（除了没有 dropout 层），而在两者之间只是一堆很简单的残余单位。 每个残差单元由两个卷积层组成，使用<code>3×3</code>的内核和保存空间维度（步幅 1，<code>SAME</code>填充），批量归一化（BN）和 ReLU 激活。</p>
<p><img src="/2018/12/14/深度学习/深度学习（三）：卷积神经网络/20.jpg" alt></p>
<p>正如你所看到的，这个领域正在迅速发展，每年都会有各种各样的架构出现。 一个明显的趋势是 CNN 越来越深入。 他们也越来越轻量，需要越来越少的参数。 目<strong>前，ResNet 架构既是最强大的，也是最简单的，所以它现在应该是你应该使用的</strong> 。</p>
<p>Res Net中的跨层连接设计引申出了数个后续⼯作，稠密连接⽹络（Dense Net）是其中一个，Dense Net的主要构建模块是稠密块（dense block）和过渡层（transition layer）。前者定义了输⼊和输出是如何连结的，后者则⽤来控制通道数，使之不过⼤。</p>
<p>还有其他一些架构可供您参考，特别是 VGGNet（2014 年 ILSVRC 挑战赛的亚军）和 Inception-v4（将 GooLeNet 和 ResNet 的思想融合在一起，实现了接近 3% 的 top-5 误差 ImageNet 分类率）。</p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>卷积神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习（二）：训练深层神经网络</title>
    <url>/2018/12/11/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%AE%AD%E7%BB%83%E6%B7%B1%E5%B1%82%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<p>前面介绍了人工神经网络，并训练了我们的第一个深度神经网络。 但它是一个非常浅的 DNN，只有两个隐藏层。 如果你需要解决非常复杂的问题，例如检测高分辨率图像中的数百种类型的对象，该怎么办？ 你可能需要训练更深的 DNN，也许有 10 层，每层包含数百个神经元，通过数十万个连接来连接。 这会相当困难</p>
<ul>
<li>首先，你将面临棘手的梯度消失问题（或相关的梯度爆炸问题），这会影响深度神经网络，并使较低层难以训练。</li>
<li>其次，对于如此庞大的网络，训练将非常缓慢。</li>
<li>第三，具有数百万参数的模型将会有严重的过拟合训练集的风险。</li>
</ul>
<p>在本章中，我们将从解释<strong>梯度消失</strong>问题开始，并探讨解决这个问题的一些最流行的解决方案。 接下来我们将看看<strong>各种优化器，它们可以加速大型模型的训练</strong>。 最后，我们将浏览一些流行的<strong>大型神经网络正则化技术</strong>。 使用这些工具，你将能够训练非常深的网络：欢迎来到深度学习的世界！</p>
<h2 id="梯度消失-爆炸问题"><a href="#梯度消失-爆炸问题" class="headerlink" title="梯度消失/爆炸问题"></a>梯度消失/爆炸问题</h2><p>反向传播算法的工作原理是从输出层到输入层，传播误差的梯度。 一旦该算法已经计算了网络中每个参数的损失函数的梯度，它就使用这些梯度来用梯度下降步骤来更新每个参数。</p>
<p>不幸的是，梯度往往变得越来越小，随着算法进展到较低层。 结果，梯度下降更新使得低层连接权重实际上保持不变，并且训练永远不会收敛到良好的解决方案。 这被称为梯度消失问题。 在某些情况下，可能会发生相反的情况：梯度可能变得越来越大，许多层得到了非常大的权重更新，算法发散。这是梯度爆炸的问题，在循环神经网络中最为常见 。</p>
<h3 id="Xavier初始化和-He-初始化"><a href="#Xavier初始化和-He-初始化" class="headerlink" title="Xavier初始化和 He 初始化"></a>Xavier初始化和 He 初始化</h3><p>虽然这种不幸的行为已经经过了相当长的一段时间的实验观察 但直到 2010 年左右，人们才有了明显的进步。 Xavier Glorot 和 Yoshua Bengio 发表的题为《Understanding the Difficulty of Training Deep Feedforward Neural Networks》的论文分析了一些疑问，包括流行的 sigmoid 激活函数和当时最受欢迎的<strong>默认权重参数初始化技术的组合，即随机初始化时使用平均值为 0，标准差为 1 的正态分布 。</strong></p>
<p>简而言之，他们表明，用这个激活函数和这个初始化方案，每层输出的方差远大于其输入的方差。网络正向，每层的方差持续增加，直到激活函数在顶层饱和。这实际上是因为logistic函数的平均值为 0.5 而不是 0（双曲正切函数的平均值为 0，表现略好于深层网络中的logistic函数） 。看一下logistic 激活函数，可以看到当输入变大（负或正）时，函数饱和在 0 或 1，导数非常接近 0。因此，当反向传播开始时， 它几乎没有梯度通过网络传播回来，而且由于反向传播通过顶层向下传递，所以存在的小梯度不断地被稀释，因此较低层确实没有任何东西可用。</p>
<p>Glorot 和 Bengio 在他们的论文中提出了一种显著缓解这个问题的方法。 我们需要信号在两个方向上正确地流动：在进行预测时是正向的，在反向传播梯度时是反向的。 我们不希望信号消失，也不希望它爆炸并饱和。 <strong>为了使信号正确流动，作者认为，我们需要每层输出的方差等于其输入的方差</strong>。</p>
<p>实际上不可能保证两者都是一样的，除非这个层具有相同数量的输入和输出连接，但是他们提出了一个很好的折衷办法，在实践中证明这个折中办法非常好<strong>：随机初始化连接权重必须如下面公式所描述的那样</strong>。其中<code>n_inputs</code>和<code>n_outputs</code>是权重正在被初始化的层（也称为扇入和扇出）的输入和输出连接的数量。 <strong>这种初始化策略通常被称为Xavier初始化（在作者的名字之后）</strong> 。很多初始化策略也都是为了保持每层的分布不变 ，这样利于传递信息 。</p>
<p><img src="/2018/12/11/深度学习/深度学习（二）：训练深层神经网络/01.png" alt></p>
<p> 使用 Xavier 初始化策略可以大大加快训练速度，这是导致深度学习目前取得成功的技巧之一。 最近的一些论文针对不同的激活函数提供了类似的策略，如下表所示。 ReLU 激活函数（及其变体，包括简称 ELU 激活）的初始化策略有时称为 He 初始化（在其作者的姓氏之后）。 </p>
<p><img src="/2018/12/11/深度学习/深度学习（二）：训练深层神经网络/02.png" alt></p>
<h3 id="非饱和激活函数"><a href="#非饱和激活函数" class="headerlink" title="非饱和激活函数"></a>非饱和激活函数</h3><p>激活函数在深度神经网络中表现得更好，特别是 ReLU 激活函数，主要是因为它对正值不会饱和（也因为它的计算速度很快）。</p>
<p>不幸的是，<strong>ReLU</strong>激活功能并不完美。 它有一个被称为 “ReLU 死区” 的问题：在训练过程中，一些神经元有效地死亡，意味着它们停止输出 0 以外的任何东西。在某些情况下，你可能会发现你网络的一半神经元已经死亡，特别是如果你使用大学习率。 在训练期间，如果神经元的权重得到更新，使得神经元输入的加权和为负，则它将开始输出 0 。当这种情况发生时，由于当输入为负时，ReLU函数的梯度为0，神经元不可能恢复生机。</p>
<p>为了解决这个问题，你可能需要使用 ReLU 函数的一个变体，比如 <strong>leaky ReLU</strong>。这个函数定义为<code>LeakyReLUα(z)= max(αz，z)</code> 。超参数<code>α</code>定义了函数“leaks”的程度：它是<code>z &lt; 0</code>时函数的斜率，通常设置为 0.01。这个小斜坡确保 leaky ReLU 永不死亡；他们可能会长期昏迷，但他们有机会最终醒来。 事实上，设定<code>α= 0.2</code>（巨大 leak）似乎导致比<code>α= 0.01</code>（小 leak）更好的性能。</p>
<p><img src="/2018/12/11/深度学习/深度学习（二）：训练深层神经网络/03.png" alt></p>
<p> 最后，Djork-Arné Clevert 等人在 2015 年的一篇论文中提出了一种称为指数线性单元（exponential linear unit，ELU）的新的激活函数，在他们的实验中表现优于所有的 ReLU 变体：训练时间减少，神经网络在测试集上表现的更好，如下所示。 </p>
<p><img src="/2018/12/11/深度学习/深度学习（二）：训练深层神经网络/04.png" alt></p>
<p>它看起来很像 ReLU 函数，但有一些区别，主要区别在于：</p>
<ul>
<li>首先它在<code>z &lt; 0</code>时取负值，这使得该单元的平均输出接近于 0。这有助于减轻梯度消失问题，如前所述。 超参数<code>α</code>定义为当<code>z</code>是一个大的负数时，ELU 函数接近的值。它通常设置为 1，但是如果你愿意，你可以像调整其他超参数一样调整它。</li>
<li>其次，它对<code>z &lt; 0</code>有一个非零的梯度，避免了神经元死亡的问题。</li>
<li>第三，函数在任何地方都是平滑的，包括<code>z = 0</code>左右，这有助于加速梯度下降，因为它不会弹回<code>z = 0</code>的左侧和右侧。</li>
</ul>
<p>ELU 激活函数的主要缺点是计算速度慢于 ReLU 及其变体（由于使用指数函数），但是在训练过程中，这是通过更快的收敛速度来补偿的。 然而，在测试时间，ELU 网络将比 ReLU 网络慢。</p>
<p>那么你应该使用哪个激活函数来处理深层神经网络的隐藏层？ 虽然你的里程会有所不同，一般 ELU &gt; leaky ReLU（及其变体）&gt; ReLU &gt; tanh &gt; sigmoid。 如果您关心运行时性能，那么您可能喜欢 leaky ReLU超过ELU。</p>
<h3 id="批量标准化"><a href="#批量标准化" class="headerlink" title="批量标准化"></a>批量标准化</h3><p>尽管使用 He初始化和 ELU（或任何 ReLU 变体）可以显著减少训练开始阶段的梯度消失/爆炸问题，但不保证在训练期间问题不会回来。</p>
<p>在 2015 年的一篇论文中，Sergey Ioffe 和 Christian Szegedy 提出了一种称为批量标准化（Batch Normalization，BN）的技术来解决梯度消失/爆炸问题，每层输入的分布在训练期间改变的问题，更普遍的问题是当前一层的参数改变，每层输入的分布会在训练过程中发生变化（他们称之为内部协变量偏移问题）。</p>
<p>该技术包括在每层的激活函数之前在模型中添加操作，简单地对输入进行zero-centering和规范化，然后每层使用两个新参数（一个用于尺度变换，另一个用于偏移）对结果进行尺度变换和偏移。 换句话说，这个操作可以让模型学习到每层输入值的最佳尺度,均值。为了对输入进行归零和归一化，算法需要估计输入的均值和标准差。 它通过评估当前小批量输入的均值和标准差（因此命名为“批量标准化”）来实现。</p>
<p><img src="/2018/12/11/深度学习/深度学习（二）：训练深层神经网络/05.jpg" alt></p>
<p>在测试时，没有小批量计算经验均值和标准差，所以您只需使用整个训练集的均值和标准差。 这些通常在训练期间使用移动平均值进行有效计算。 因此，总的来说，每个批次标准化的层次都学习了四个参数：<code>γ</code>（标度），<code>β</code>（偏移），<code>μ</code>（平均值）和<code>σ</code>（标准差）</p>
<p>作者证明，这项技术大大改善了他们试验的所有深度神经网络。梯度消失问题大大减少了，他们可以使用饱和激活函数，如 tanh 甚至 sigmoid 激活函数。网络对权重初始化也不那么敏感。他们能够使用更大的学习率，显著加快了学习过程。 由于每层所需的额外计算，神经网络的预测速度较慢。 所以，如果你需要预测闪电般快速，你可能想要检查普通ELU + He初始化执行之前如何执行批量标准化。您可能会发现，训练起初相当缓慢，而渐变下降正在寻找每层的最佳尺度和偏移量，但一旦找到合理的好值，它就会加速。</p>
<p>当然，如果你训练的时间越长，准确性就越好，但是由于这样一个浅的网络，批量范数和 ELU 不太可能产生非常积极的影响：它们大部分都是为了更深的网络而发光。</p>
<p>批量标准化和初始化权重参数的意义差不多，更深的理解可以看这篇 <a href="https://plushunter.github.io/2017/05/14/深度学习系列（9）：Batch Normalization/" target="_blank" rel="noopener">批量标准化</a></p>
<h3 id="梯度裁剪"><a href="#梯度裁剪" class="headerlink" title="梯度裁剪"></a>梯度裁剪</h3><p>减少梯度爆炸问题的一种常用技术是在反向传播过程中<strong>简单地剪切梯度，使它们不超过某个阈值</strong>（这对于递归神经网络是非常有用的）。 这就是所谓的梯度裁剪。一般来说，人们更喜欢批量标准化，但了解梯度裁剪以及如何实现它仍然是有用的。</p>
<h2 id="复用预训练层"><a href="#复用预训练层" class="headerlink" title="复用预训练层"></a>复用预训练层</h2><p>从零开始训练一个非常大的 DNN 通常不是一个好主意，相反，您应该总是尝试找到一个现有的神经网络来完成与您正在尝试解决的任务类似的任务，然后复用这个网络的较低层：这就是所谓的迁移学习。这不仅会大大加快训练速度，还将需要更少的训练数据。 一般包括三个步骤</p>
<p>1、冻结较低层：在训练过程中变量不会发生变化（通常称为冻结层）。</p>
<p>2、缓存冻结层：由于冻结层不会改变，因此可以为每个训练实例缓存最上面的冻结层的输出。 由于训练贯穿整个数据集很多次，这将给你一个巨大的速度提升</p>
<p>3、调整，删除或替换较高层：对于新任务来说最有用的高层特征可能与对原始任务最有用的高层特征明显不同。 你需要找到正确的层数来复用。 一般拥有的训练数据越多，您可以解冻的层数就越多。</p>
<h3 id="Model-Zoos"><a href="#Model-Zoos" class="headerlink" title="Model Zoos"></a>Model Zoos</h3><p>你在哪里可以找到一个类似于你想要解决的任务训练的神经网络？ 首先看看显然是在你自己的模型目录。 这是保存所有模型并组织它们的一个很好的理由，以便您以后可以轻松地检索它们。 另一个选择是在模型动物园中搜索。 许多人为了各种不同的任务而训练机器学习模型，并且善意地向公众发布预训练模型。</p>
<p>TensorFlow 在 <a href="https://github.com/tensorflow/models" target="_blank" rel="noopener">https://github.com/tensorflow/models</a> 中有自己的模型动物园。 特别是，它包含了大多数最先进的图像分类网络，如 VGG，Inception 和 ResNet（参见第 13 章，检查<code>model/slim</code>目录），包括代码，预训练模型和 工具来下载流行的图像数据集。</p>
<p>另一个流行的模型动物园是 Caffe 模型动物园。 它还包含许多在各种数据集（例如，ImageNet，Places 数据库，CIFAR10 等）上训练的计算机视觉模型（例如，LeNet，AlexNet，ZFNet，GoogLeNet，VGGNet，开始）。 Saumitro Dasgupta 写了一个转换器，可以在 <a href="https://github.com/ethereon/caffetensorflow。" target="_blank" rel="noopener">https://github.com/ethereon/caffetensorflow。</a></p>
<h2 id="更快的优化器"><a href="#更快的优化器" class="headerlink" title="更快的优化器"></a>更快的优化器</h2><p>练一个非常大的深度神经网络可能会非常缓慢。 到目前为止，我们已经看到了四种加速训练的方法（并且达到更好的解决方案）：对连接权重应用良好的初始化策略，使用良好的激活函数，使用批量规范化以及重用预训练网络的部分。 另一个巨大的速度提升来自使用比普通渐变下降优化器更快的优化器。 在本节中，我们将介绍最流行的：动量优化，Nesterov 加速梯度，AdaGrad，RMSProp，最后是 Adam 优化。</p>
<p>剧透：<strong>本节的结论是，您几乎总是应该使用<code>Adam_optimization</code></strong>，所以如果您不关心它是如何工作的，只需使用<code>AdamOptimizer</code>替换您的<code>GradientDescentOptimizer</code>，然后跳到下一节！ 只需要这么小的改动，训练通常会快几倍。 <strong>但是，Adam 优化确实有三个可以调整的超参数（加上学习率）。 默认值通常工作的不错，但如果您需要调整它们，知道他们怎么实现的可能会有帮助</strong>。</p>
<p>理解这些优化器可以看这篇 <a href="https://plushunter.github.io/2017/05/11/深度学习系列（7）：神经网络的优化方法/" target="_blank" rel="noopener">神经网络的优化方法</a></p>
<h3 id="训练稀疏模型"><a href="#训练稀疏模型" class="headerlink" title="训练稀疏模型"></a>训练稀疏模型</h3><p>上面所有刚刚提出的优化算法都会产生密集的模型，这意味着大多数参数都是非零的。 如果你在运行时需要一个非常快速的模型，或者如果你需要它占用较少的内存，你可能更喜欢用一个稀疏模型优化器来代替。</p>
<p>这时可以使用FTRL 优化器，一种由尤里·涅斯捷罗夫（Yurii Nesterov）提出的技术。 当与 l1 正则化一起使用时，这种技术通常导致非常稀疏的模型。</p>
<h2 id="学习率调整"><a href="#学习率调整" class="headerlink" title="学习率调整"></a>学习率调整</h2><p>自适应下降的学习速率会更好。有三种流行的方法：</p>
<ul>
<li>性能调度：每 N 步测量验证误差（就像提前停止一样），当误差下降时，将学习率降低一个因子<code>λ</code>。</li>
<li>指数调度：将学习率设置为<strong>迭代次数<code>t</code></strong>的函数$\eta(t)=\eta_0\cdot10^{-t/r}$： 这很好，但它需要调整初始速率<code>η0</code>和<strong>总迭代次数</strong><code>r</code>。 学习率将由每<code>r</code>步下降 10 倍。</li>
<li>幂调度：设学习率为$\eta(t)=\eta_0(1+t/r)^{-c}$。 超参数<code>c</code>通常被设置为 1。这与指数调度类似，但是学习率下降要慢得多。</li>
</ul>
<p>根据Andrew Senior 等2013年的论文。 比较了使用动量优化训练深度神经网络进行语音识别时一些最流行的学习率调整的性能。 作者得出结论：在这种情况下，性能调度和指数调度都表现良好，但他们更喜欢指数调度，因为它实现起来比较简单，容易调整，收敛速度略快于最佳解决方案 。</p>
<h2 id="通过正则化避免过拟合"><a href="#通过正则化避免过拟合" class="headerlink" title="通过正则化避免过拟合"></a>通过正则化避免过拟合</h2><p>1、早起停止法</p>
<p>2、L1和L2正则化：注意不需要对bias正则，只对权重</p>
<p>3、Dropout</p>
<p>深度神经网络最流行的正则化技术可以说是 dropout。 它由 GE Hinton 于 2012 年提出，并在 Nitish Srivastava 等人的论文中进一步详细描述，并且已被证明是非常成功的：即使是最先进的神经网络，仅仅通过增加丢失就可以提高1-2％的准确度。</p>
<p>是一个相当简单的算法：在每个训练步骤中，每个神经元（包括输入神经元，但不包括输出神经元）都有一个暂时“丢弃”的概率<code>p</code>，这意味着在这个训练步骤中它将被完全忽略， 在下一步可能会激活（见下图 ）。 超参数<code>p</code>称为丢失率，通常设为 50%。 训练后，神经元不会再下降。</p>
<p><img src="/2018/12/11/深度学习/深度学习（二）：训练深层神经网络/05.png" alt></p>
<p>如果观察到模型过拟合，则可以增加 dropout 率（即，减少<code>keep_prob</code>超参数）。 相反，如果模型欠拟合训练集，则应尝试降低 dropout 率（即增加<code>keep_prob</code>）。 它也可以帮助增加大层的 dropout 率，并减少小层的 dropout 率。</p>
<p>dropout 似乎减缓了收敛速度，但通常会在调整得当时使模型更好。 所以，这通常值得花费额外的时间和精力。</p>
<p>Dropconnect是dropout的变体，其中单个连接随机丢弃而不是整个神经元。 一般而言，dropout表现会更好。</p>
<h2 id="最大范数正则化"><a href="#最大范数正则化" class="headerlink" title="最大范数正则化"></a>最大范数正则化</h2><p>另一种在神经网络中非常流行的正则化技术被称为最大范数正则化：对于每个神经元，它约束输入连接的权重<code>w</code>，使得$\Vert w\Vert_2 \leq r$，其中<code>r</code>是最大范数超参数，$\Vert \cdot \Vert$是 L2 范数。</p>
<p>我们通常通过在每个训练步骤之后计算 $\Vert w\Vert_2$来实现这个约束，并且如果需要的话可以剪切<code>W</code> ，即$w\leftarrow w\frac{r}{\Vert w\Vert_2}$。</p>
<p>减少<code>r</code>增加了正则化的数量(经常剪切<code>W</code>)，并有助于减少过拟合。 最大范数正则化还可以帮助减轻梯度消失/爆炸问题（如果您不使用批量标准化）。</p>
<h2 id="数据增强"><a href="#数据增强" class="headerlink" title="数据增强"></a>数据增强</h2><p>最后一个正则化技术，数据增强，包括从现有的训练实例中产生新的训练实例，人为地增加了训练集的大小。 这将减少过拟合，使之成为正则化技术。 诀窍是生成逼真的训练实例;</p>
<p>例如，如果您的模型是为了分类蘑菇图片，您可以稍微移动，旋转和调整训练集中的每个图片的大小，并将结果图片添加到训练集。 这迫使模型更能容忍图片中蘑菇的位置，方向和大小。 如果您希望模型对光照条件更加宽容，则可以类似地生成具有各种对比度的许多图像。 假设蘑菇是对称的，你也可以水平翻转图片。 通过结合这些转换，可以大大增加训练集的大小。</p>
<h2 id="实践指南"><a href="#实践指南" class="headerlink" title="实践指南"></a>实践指南</h2><p>当然，如果你能找到解决类似问题的方法，你应该尝试重用预训练的神经网络的一部分。</p>
<p>这个默认配置可能需要调整：</p>
<ul>
<li>如果你找不到一个好的学习率（收敛速度太慢，所以你增加了训练速度，现在收敛速度很快，但是网络的准确性不是最理想的），那么你可以尝试添加一个学习率调整，如指数衰减。</li>
<li>如果你的训练集太小，你可以实现数据增强。</li>
<li>如果你需要一个稀疏的模型，你可以添加 l1 正则化混合（并可以选择在训练后将微小的权重归零）。 如果您需要更稀疏的模型，您可以尝试使用 FTRL 而不是 Adam 优化以及 l1 正则化。</li>
<li>如果在运行时需要快速模型，则可能需要删除批量标准化，并可能用 leakyReLU 替换 ELU 激活函数。 有一个稀疏的模型也将有所帮助。</li>
</ul>
<hr>
<ol>
<li>使用 He 初始化随机选择权重，是否可以将所有权重初始化为相同的值？</li>
</ol>
<p>答：不，所有的权值都应该独立采样;它们的初值不应该相同。如果任意一层的所有神经元都有相同的权值。这就像每层只有一个神经元，而且速度要慢得多。</p>
<ol>
<li>可以将偏置初始化为 0 吗？</li>
</ol>
<p>答：可以</p>
<ol>
<li>说出 ELU 激活功能与 ReLU 相比的三个优点。</li>
</ol>
<p>答：</p>
<ul>
<li>它可以取负值，所以任意一层神经元的<strong>平均输出</strong>通常比使用relu激活函数(从不输出负值)时<strong>更接近于0</strong>。这有助于缓解渐变消失的问题。</li>
<li>它总是有一个非零的导数，这避免了神经元死亡的问题。</li>
<li>处处平滑，而Relu的斜率在z = 0时突然从0跳到1。这样的骤减使梯度下降效果降低，因为它会在z =0附近反弹.</li>
</ul>
<ol>
<li>在哪些情况下，您想要使用以下每个激活函数：ELU，leaky ReLU（及其变体），ReLU，tanh，logistic 以及 softmax？</li>
</ol>
<p>答：ELU是一个不错的默认选择。如果想要训练速度更快一些可以采用 leaky ReLU（及其变体）</p>
<ol>
<li>dropout 是否会减慢训练？ 它是否会减慢推断（即预测新的实例）？</li>
</ol>
<p>答：dropout确实会减慢训练速度，总的来说大概是两倍。然而，它没有对推断（预测新的实例）的影响，因为它只在训练期间打开。</p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>正则化</tag>
        <tag>深度学习</tag>
        <tag>梯度消失/爆炸</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习（一）：神经网络与反向传播</title>
    <url>/2018/12/09/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/</url>
    <content><![CDATA[<h2 id="神经元"><a href="#神经元" class="headerlink" title="神经元"></a>神经元</h2><p>首先我们从最简单的神经网络——神经元讲起，以下即为一个神经元（Neuron）的图示：</p>
<p><img src="/2018/12/09/深度学习/深度学习（一）：神经网络与反向传播/01.jpg" alt></p>
<p>我们知道感知机的激活函数是阶跃函数；而当我们说神经元的时，激活函数往往选择sigmoid函数或tanh函数 ,<strong>还有Relu函数（效果较好）</strong>。如下图所示 </p>
<p><img src="/2018/12/09/深度学习/深度学习（一）：神经网络与反向传播/02.jpg" alt></p>
<p>可以看出，这个单一神经元的输入输出的映射关系其实就是一个逻辑回归（logistic regression）。</p>
<h2 id="神经网络模型"><a href="#神经网络模型" class="headerlink" title="神经网络模型"></a>神经网络模型</h2><h3 id="神经网络模型-1"><a href="#神经网络模型-1" class="headerlink" title="神经网络模型"></a>神经网络模型</h3><p>所谓神经网络就是将许多神经元联结在一起，这样，一个神经元的输出就可以是另一神经元的输入。例如，下图就是一个简单的神经网络：</p>
<p><img src="/2018/12/09/深度学习/深度学习（一）：神经网络与反向传播/03.jpg" alt></p>
<p>这样的神经网络也称之为多层感知机（MLP），MLP 由一个（通过）输入层、一个或多个称为隐藏层的 LTU （单层感知器）组成，一个最终层 LTU 称为输出层。除了输出层之外的每一层包括偏置神经元，并且全连接到下一层。当人工神经网络有两个或多个隐含层时，称为深度神经网络（DNN）。</p>
<h2 id="BP反向传播"><a href="#BP反向传播" class="headerlink" title="BP反向传播"></a>BP反向传播</h2><p>反向传播指的是计算神经⽹络参数梯度的⽅法。总的来说，反向传播依据微积分中的链式法则，沿着从输出层到输⼊层的顺序，依次计算并存储⽬标函数有关神经⽹络各层的中间变量以及参数的梯度。</p>
<p><img src="/2018/12/09/深度学习/深度学习（一）：神经网络与反向传播/04.png" alt></p>
<p><img src="/2018/12/09/深度学习/深度学习（一）：神经网络与反向传播/05.png" alt></p>
<p><img src="/2018/12/09/深度学习/深度学习（一）：神经网络与反向传播/06.png" alt></p>
<p><img src="/2018/12/09/深度学习/深度学习（一）：神经网络与反向传播/07.png" alt></p>
<p>上图依次为利用dE/dx6求出第一个dE/dw; 利用分量的点对点继续求dE/dw; 利用求和来下一个dE/dy2 ;(这里的所以x,y总输入输出都是知道的)</p>
<ul>
<li>dE/dw是有上下夹层dE/dx与上面一层的y求出的</li>
<li>dE/dy是由上面一层全连接的wij 与其连接的dE/dx求出的</li>
</ul>
<p><img src="/2018/12/09/深度学习/深度学习（一）：神经网络与反向传播/08.png" alt></p>
<p>dE/dy2 = dE/dx4, w24 和 dE/dx5, dw25的求和得到其中，y2=w24*x4,故有dx_j/dy_i = wij</p>
<h2 id="用-TensorFlow-高级-API-训练-MLP"><a href="#用-TensorFlow-高级-API-训练-MLP" class="headerlink" title="用 TensorFlow 高级 API 训练 MLP"></a>用 TensorFlow 高级 API 训练 MLP</h2><p>与 TensorFlow 一起训练 MLP 最简单的方法是使用高级 API TF.Learn，这与 sklearn 的 API 非常相似。<code>DNNClassifier</code>可以很容易训练具有任意数量隐层的深度神经网络，而 softmax 输出层输出估计的类概率。例如，下面的代码训练两个隐藏层的 DNN（一个具有 300 个神经元，另一个具有 100 个神经元）和一个具有 10 个神经元的 SOFTMax 输出层进行分类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">feature_columns = tf.contrib.learn.infer_real_valued_columns_from_input(X) </span><br><span class="line">dnn_clf = tf.contrib.learn.DNNClassifier(hidden_units=[<span class="number">300</span>, <span class="number">100</span>], n_classes=<span class="number">10</span>,</span><br><span class="line">                                         feature_columns=feature_columns) </span><br><span class="line">dnn_clf.fit(x=X, y=y, batch_size=<span class="number">50</span>, steps=<span class="number">40000</span>)</span><br></pre></td></tr></table></figure>
<p>如果你在 MNIST 数据集上运行这个代码（在缩放它之后，例如，通过使用 skLearn 的<code>StandardScaler</code>），你实际上可以得到一个在测试集上达到 98.1% 以上精度的模型！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score &gt;&gt;&gt; y_pred = list(dnn_clf.predict(X_test)) &gt;&gt;&gt; accuracy_score(y_test, y_pred) <span class="number">0.98180000000000001</span></span><br></pre></td></tr></table></figure>
<p>TF.Learn 学习库也为评估模型提供了一些方便的功能：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dnn_clf.evaluate(X_test, y_test) &#123;<span class="string">'accuracy'</span>: <span class="number">0.98180002</span>, <span class="string">'global_step'</span>: <span class="number">40000</span>, <span class="string">'loss'</span>: <span class="number">0.073678359</span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用普通-TensorFlow-训练-DNN"><a href="#使用普通-TensorFlow-训练-DNN" class="headerlink" title="使用普通 TensorFlow 训练 DNN"></a>使用普通 TensorFlow 训练 DNN</h2><p>如果您想要更好地控制网络架构，您可能更喜欢使用 TensorFlow 的较低级别的 Python API。 在本节中，我们将使用与之前的 API 相同的模型，我们将实施 Minibatch 梯度下降来在 MNIST 数据集上进行训练。 第一步是建设阶段，构建 TensorFlow 图。 第二步是执行阶段，您实际运行计算图谱来训练模型。</p>
<h3 id="构造阶段"><a href="#构造阶段" class="headerlink" title="构造阶段"></a>构造阶段</h3><p>开始吧。 首先我们需要导入<code>tensorflow</code>库。 然后我们必须指定输入和输出的数量，并设置每个层中隐藏的神经元数量：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tfn_inputs = <span class="number">28</span>*<span class="number">28</span> <span class="comment"># MNISTn_hidden1 = 300n_hidden2 = 100n_outputs = 10</span></span><br></pre></td></tr></table></figure>
<p>接下来，可以使用占位符节点来表示训练数据和目标。<code>X</code>的形状仅有部分被定义。 我们知道它将是一个 2D 张量（即一个矩阵），沿着第一个维度的实例和第二个维度的特征，我们知道特征的数量将是<code>28×28</code>（每像素一个特征） <strong>但是我们不知道每个训练批次将包含多少个实例。 所以<code>X</code>的形状是<code>(None, n_inputs)</code></strong>。 <strong>同样，我们知道<code>y</code>将是一个 1D 张量，每个实例有一个入口，但是我们再次不知道在这一点上训练批次的大小，所以形状<code>(None)</code></strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = tf.placeholder(tf.float32, shape=(<span class="literal">None</span>, n_inputs), name=<span class="string">"X"</span>)y = tf.placeholder(tf.int64, shape=(<span class="literal">None</span>), name=<span class="string">"y"</span>)</span><br></pre></td></tr></table></figure>
<p>现在让我们创建一个实际的神经网络。 占位符<code>X</code>将作为输入层; 在执行阶段，它将一次更换一个训练批次（注意训练批中的所有实例将由神经网络同时处理）。 现在您需要创建两个隐藏层和输出层。 两个隐藏的层几乎相同：它们只是它们所连接的输入和它们包含的神经元的数量不同。 <strong>输出层也非常相似，但它使用 softmax 激活函数而不是 ReLU 激活函数</strong>。 <strong>所以让我们创建一个<code>neuron_layer()</code>函数，我们将一次创建一个图层。 它将需要参数来指定输入，神经元数量，激活函数和图层的名称：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">neuron_layer</span><span class="params">(X, n_neurons, name, activation=None)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> tf.name_scope(name):</span><br><span class="line">        n_inputs = int(X.get_shape()[<span class="number">1</span>])</span><br><span class="line">        stddev = <span class="number">2</span> / np.sqrt(n_inputs)</span><br><span class="line">        init = tf.truncated_normal((n_inputs, n_neurons), stddev=stddev)</span><br><span class="line">        W = tf.Variable(init, name=<span class="string">"weights"</span>) <span class="comment"># 使用满足分布概率来更好第初始化W权重</span></span><br><span class="line">        b = tf.Variable(tf.zeros([n_neurons]), name=<span class="string">"biases"</span>)</span><br><span class="line">        <span class="comment"># multiply这个函数实现的是元素级别的相乘，也就是两个相乘的数元素各自相乘，而不是矩阵乘法</span></span><br><span class="line">        <span class="comment"># tf.matmul才算矩阵乘法，注意区别</span></span><br><span class="line">        z = tf.matmul(X, W) + b </span><br><span class="line">        <span class="keyword">if</span> activation == <span class="string">"relu"</span>:</span><br><span class="line">            <span class="keyword">return</span> tf.nn.relu(z)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> z</span><br></pre></td></tr></table></figure>
<p>我们逐行浏览这个代码：</p>
<ol>
<li>首先，我们使用名称范围来创建每层的名称：它将包含该神经元层的所有计算节点。 <strong>这是可选的</strong>，但如果节点组织良好，则 TensorBoard 图形将会更加出色。</li>
<li>接下来，我们通过查找输入矩阵的形状并获得第二个维度的大小来获得输入数量（<strong>第一个维度用于实例数量</strong>）。</li>
<li>接下来的三行创建一个保存权重矩阵的<code>W</code>变量。 它将是包含每个输入和每个神经元之间的所有连接权重的2D张量；因此，<strong>它的形状将是<code>(n_inputs, n_neurons)</code></strong>。<strong>它将被随机初始化，使用具有标准差为<code>2/√n</code>的截断的正态（高斯）分布</strong>(使用截断的正态分布而不是常规正态分布确保不会有任何大的权重，这可能会减慢训练。).<strong>使用这个特定的标准差有助于算法的收敛速度更快</strong>（我们将在后面进一步讨论这一点），这是对神经网络的微小调整之一，对它们的效率产生了巨大的影响）。 重要的是为所有隐藏层随机初始化连接权重，以避免梯度下降算法无法中断的任何对称性。（例如，如果将所有权重设置为 0，则所有神经元将输出 0，并且给定隐藏层中的所有神经元的误差梯度将相同。 然后，梯度下降步骤将在每个层中以相同的方式更新所有权重，因此它们将保持相等。 换句话说，尽管每层有数百个神经元，你的模型就像每层只有一个神经元一样。）</li>
<li>下一行创建一个偏差的<code>b</code>变量，初始化为 0（在这种情况下无对称问题），每个神经元有一个偏置参数。</li>
<li>然后我们创建一个子图来计算<code>z = X·W + b</code>。 该向量化实现将有效地计算输入的加权和加上层中每个神经元的偏置，对于批次中的所有实例，仅需一次.</li>
<li>最后，如果激活参数设置为<code>relu</code>，则代码返回<code>relu(z)</code>（即<code>max(0,z)</code>），否则它只返回<code>z</code>。</li>
</ol>
<p>好了，现在你有一个很好的函数来创建一个神经元层。 让我们用它来创建深层神经网络！ 第一个隐藏层以<code>X</code>为输入。 第二个将第一个隐藏层的输出作为其输入。 最后，输出层将第二个隐藏层的输出作为其输入。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.name_scope(<span class="string">"dnn"</span>):</span><br><span class="line">        hidden1 = neuron_layer(X, n_hidden1, <span class="string">"hidden1"</span>, activation=<span class="string">"relu"</span>)</span><br><span class="line">    hidden2 = neuron_layer(hidden1, n_hidden2, <span class="string">"hidden2"</span>, activation=<span class="string">"relu"</span>)</span><br><span class="line">    logits = neuron_layer(hidden2, n_outputs, <span class="string">"outputs"</span>)</span><br></pre></td></tr></table></figure>
<p>要注意，<strong>logit 是在通过 softmax 激活函数之前神经网络的输出</strong>：为了优化，我们稍后将处理 softmax 计算。</p>
<p><strong>正如你所期望的，TensorFlow 有许多方便的功能来创建标准的神经网络层，所以通常不需要像我们刚才那样定义你自己的<code>neuron_layer()</code>函数</strong>。 例如，TensorFlow 的<code>tf.layers.dense()</code>函数创建一个完全连接的层，其中所有输入都连接到图层中的所有神经元。 <strong>它使用正确的初始化策略来负责创建权重和偏置变量，并且默认情况下不使用激活函数（我们可以使用<code>activate_fn</code>参数来更改它）</strong>。 它还支持正则化和归一化参数。 我们来调整上面的代码来使用<code>tf.layers.dense()</code>函数，而不是我们的<code>neuron_layer()</code>函数。 只需导入该功能，并使用以下代码替换之前所有 dnn 构建部分：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.name_scope(<span class="string">"dnn"</span>):</span><br><span class="line">    hidden1 = tf.layers.dense(X, n_hidden1, name=<span class="string">"hidden1"</span>,</span><br><span class="line">                              activation=tf.nn.relu)</span><br><span class="line">    hidden2 = tf.layers.dense(hidden1, n_hidden2, name=<span class="string">"hidden2"</span>,</span><br><span class="line">                              activation=tf.nn.relu)</span><br><span class="line">    logits = tf.layers.dense(hidden2, n_outputs, name=<span class="string">"outputs"</span>)</span><br></pre></td></tr></table></figure>
<h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p>现在我们已经有了神经网络模型，我们需要定义我们用来训练的损失函数。 正如我们在之前对 Softmax 回归所做的那样，我们将使用交叉熵。 我们将使用<code>sparse_softmax_cross_entropy_with_logits()</code>：它根据“logit”计算交叉熵（即，在通过 softmax 激活函数之前的网络输出），并且期望以 0 到 -1 数量的整数形式的标签（在我们的例子中，从 0 到 9）。 <strong>这将给我们一个包含每个实例的交叉熵的 1D 张量</strong>。 <strong>然后，我们可以使用 TensorFlow 的<code>reduce_mean()</code>函数来计算所有实例的平均交叉熵。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.name_scope(<span class="string">"loss"</span>):</span><br><span class="line">    xentropy = tf.nn.sparse_softmax_cross_entropy_with_logits(labels=y, logits=logits)</span><br><span class="line">    loss = tf.reduce_mean(xentropy, name=<span class="string">"loss"</span>)</span><br></pre></td></tr></table></figure>
<p>该<code>sparse_softmax_cross_entropy_with_logits()</code>函数等同于应用 SOFTMAX 激活函数，然后计算交叉熵，但它更高效，它妥善照顾的边界情况下，比如 logits 等于 0，这就是为什么我们没有较早的应用 SOFTMAX 激活函数。 还有称为<code>softmax_cross_entropy_with_logits()</code>的另一个函数，该函数在标签单热载体的形式（而不是整数 0 至类的数目减 1）。</p>
<h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><p>我们有神经网络模型，我们有损失函数，现在我们需要定义一个<code>GradientDescentOptimizer</code>来调整模型参数以最小化损失函数。没什么新鲜的; 就像我们之前中所做的那样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">learning_rate = <span class="number">0.01</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.name_scope(<span class="string">"train"</span>):</span><br><span class="line">    optimizer = tf.train.GradientDescentOptimizer(learning_rate)</span><br><span class="line">    training_op = optimizer.minimize(loss)</span><br></pre></td></tr></table></figure>
<h3 id="评估模型性能"><a href="#评估模型性能" class="headerlink" title="评估模型性能"></a>评估模型性能</h3><p>建模阶段的最后一个重要步骤是指定如何评估模型。 我们将简单地将精度用作我们的绩效指标。 首先，对于每个实例，通过检查最高 logit 是否对应于目标类别来确定神经网络的预测是否正确。 为此，您可以使用<code>in_top_k()</code>函数。 这返回一个充满布尔值的 1D 张量，因此我们需要将这些布尔值转换为浮点数，然后计算平均值。 这将给我们网络的整体准确性.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.name_scope(<span class="string">"eval"</span>):</span><br><span class="line">    correct = tf.nn.in_top_k(logits, y, <span class="number">1</span>)</span><br><span class="line">    accuracy = tf.reduce_mean(tf.cast(correct, tf.float32))</span><br></pre></td></tr></table></figure>
<p>而且，像往常一样，我们需要创建一个初始化所有变量的节点，我们还将创建一个<code>Saver</code>来将我们训练有素的模型参数保存到磁盘中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">init = tf.global_variables_initializer()</span><br><span class="line">saver = tf.train.Saver()</span><br></pre></td></tr></table></figure>
<p>建模阶段结束。 这是不到 40 行代码，但相当激烈：我们为输入和目标创建占位符，我们创建了一个构建神经元层的函数，我们用它来创建 DNN，我们定义了损失函数，我们 创建了一个优化器，最后定义了性能指标。 现在到执行阶段。</p>
<h3 id="执行阶段"><a href="#执行阶段" class="headerlink" title="执行阶段"></a>执行阶段</h3><p>首先，我们加载 MNIST。 我们可以像之前的章节那样使用 ScikitLearn，但是 TensorFlow 提供了自己的助手来获取数据，将其缩放（0 到 1 之间），将它洗牌，并提供一个简单的功能来一次加载一个小批量：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.examples.tutorials.mnist <span class="keyword">import</span> input_data</span><br><span class="line">mnist = input_data.read_data_sets(<span class="string">"/tmp/data/"</span>)</span><br><span class="line">n_epochs = <span class="number">10001</span>  <span class="comment"># 迭代次数</span></span><br><span class="line">batch_size = <span class="number">50</span>   <span class="comment"># 小批量大小</span></span><br></pre></td></tr></table></figure>
<p>现在我们去训练模型:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    init.run()</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> range(n_epochs):</span><br><span class="line">        <span class="keyword">for</span> iteration <span class="keyword">in</span> range(mnist.train.num_examples // batch_size): <span class="comment"># 每批量一次</span></span><br><span class="line">            X_batch, y_batch = mnist.train.next_batch(batch_size)</span><br><span class="line">            sess.run(training_op, feed_dict=&#123;X: X_batch, y: y_batch&#125;) <span class="comment"># 运行计算程序</span></span><br><span class="line">        acc_train = accuracy.eval(feed_dict=&#123;X: X_batch, y: y_batch&#125;)</span><br><span class="line">        acc_test = accuracy.eval(feed_dict=&#123;X: mnist.test.images, y: mnist.test.labels&#125;)</span><br><span class="line">        print(epoch, <span class="string">"Train accuracy:"</span>, acc_train, <span class="string">"Test accuracy:"</span>, acc_test)</span><br><span class="line"></span><br><span class="line">    save_path = saver.save(sess, <span class="string">"./my_model_final.ckpt"</span>)</span><br></pre></td></tr></table></figure>
<p>该代码打开一个 TensorFlow 会话，并运行初始化所有变量的<code>init</code>节点。 然后它运行的主要训练循环：在每个时期，通过一些小批次的对应于训练集的大小的代码进行迭代。 <strong>每个小批量通过<code>next_batch()</code>方法获取，然后代码简单地运行训练操作</strong>，为当前的小批量输入数据和目标提供。 接下来，在每个时期结束时，代码评估最后一个小批量和完整训练集上的模型，并打印出结果。 最后，模型参数保存到磁盘。</p>
<h3 id="使用神经网络进行预测"><a href="#使用神经网络进行预测" class="headerlink" title="使用神经网络进行预测"></a>使用神经网络进行预测</h3><p>现在神经网络被训练了，你可以用它进行预测。 为此，您可以重复使用相同的建模阶段，但是更改执行阶段，如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    saver.restore(sess, <span class="string">"./my_model_final.ckpt"</span>) <span class="comment"># or better, use save_path</span></span><br><span class="line">    X_new_scaled = mnist.test.images[:<span class="number">20</span>]</span><br><span class="line">    Z = logits.eval(feed_dict=&#123;X: X_new_scaled&#125;)</span><br><span class="line">    y_pred = np.argmax(Z, axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>首先，代码从磁盘加载模型参数。 然后加载一些您想要分类的新图像。 记住应用与训练数据相同的特征缩放（在这种情况下，将其从 0 缩放到 1）。 然后代码评估对数点节点。 如果您想知道所有估计的类概率，则需要将<code>softmax()</code>函数应用于对数，但如果您只想预测一个类，则可以简单地选择具有最高 logit 值的类（使用<code>argmax()</code>函数做的伎俩）。</p>
<h2 id="微调神经网络超参数"><a href="#微调神经网络超参数" class="headerlink" title="微调神经网络超参数"></a>微调神经网络超参数</h2><p>神经网络的灵活性也是其主要缺点之一：有很多超参数要进行调整。 不仅可以使用任何可想象的网络拓扑（如何神经元互连），而且即使在简单的 MLP 中，您可以更改层数，每层神经元数，每层使用的激活函数类型，权重初始化逻辑等等。 你怎么知道什么组合的超参数是最适合你的任务？</p>
<p>可以使用具有交叉验证的网格搜索来查找正确的超参数 ，但是由于要调整许多超参数，并且由于在大型数据集上训练神经网络需要很多时间 。像之前讨论过的，使用随机搜索要好得多 ，另一个选择是使用诸如 Oscar 之类的工具，它可以实现更复杂的算法，以帮助您快速找到一组好的超参数.</p>
<h3 id="隐藏层数量"><a href="#隐藏层数量" class="headerlink" title="隐藏层数量"></a>隐藏层数量</h3><p>实际上已经表明，只有一个隐藏层的 MLP 可以建模甚至最复杂的功能，只要它具有足够的神经元。 但是他们忽略了这样一个事实：深层网络具有比浅层网络更高的参数效率：他们可以使用比浅网格更少的神经元来建模复杂的函数，使得训练更快。</p>
<p>总而言之，对于许多问题，您可以从一个或两个隐藏层开始。(MNIST 数据集上容易达到 97% 以上的准确度使用两个具有相同总神经元数量的隐藏层 )；对于更复杂的问题，您可以逐渐增加隐藏层的数量，直到您开始覆盖训练集。 <strong>但是，我们很少从头开始训练这样的网络：重用预先训练的最先进的网络执行类似任务的部分更为常见</strong>。训练将会更快，需要更少的数据 。</p>
<h3 id="每层隐藏层的神经元数量"><a href="#每层隐藏层的神经元数量" class="headerlink" title="每层隐藏层的神经元数量"></a>每层隐藏层的神经元数量</h3><p>不幸的是，正如你所看到的，找到完美的神经元数量仍然是黑色的艺术.</p>
<p><strong>一个更简单的方法是选择一个具有比实际需要的更多层次和神经元的模型</strong>，然后使用早期停止来防止它过度拟合（以及其他正则化技术，特别是 drop out，我们将在后面）。 这被称为“拉伸裤”的方法：而不是浪费时间寻找完美匹配您的大小的裤子，只需使用大型伸缩裤，缩小到合适的尺寸。</p>
<h3 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h3><p>在大多数情况下，您可以在隐藏层中使用 ReLU 激活函数（或其中一个变体 ）</p>
<p>对于输出层，softmax 激活函数通常是分类任务的良好选择（当这些类是互斥的时）。 对于回归任务，您完全可以不使用激活函数。</p>
<hr>
<ol>
<li>为什么通常使用逻辑斯蒂回归分类器而不是经典感知器（即使用感知器训练算法训练单层的线性阈值单元）？你如何调整感知器使之等同于逻辑回归分类器？</li>
</ol>
<p>答：经典感知器只有在数据集是线性可分的情况下才会收敛。相比之下，逻辑回归分类器将收敛于一个很好的解决方案，即使数据集不是线性可分的，它会输出类的概率。如果你将感知器的激活函数改为逻辑激活函数(或如果有多个神经元，则为softmax激活函数)，，则等价于逻辑回归分类器。</p>
<ol>
<li>为什么激活函数是训练第一个 MLP 的关键因素？</li>
</ol>
<p>答：logistic激活函数是训练第一批MLP的关键因素，因为它是一个复杂的过程导数总是不为零的，所以梯度下降总是可以沿着斜率向下滚动。当激活函数是阶跃函数，梯度下降无法移动，因为根本没有斜率。</p>
<ol>
<li>假设有一个 MLP 有一个 10 个神经元组成的输入层，接着是一个 50 个神经元的隐藏层，最后一个 3 个神经元输出层。所有人工神经元使用 Relu 激活函数。</li>
</ol>
<ul>
<li>输入矩阵<code>X</code>的形状是什么？ ——   -m × 10，其中m为batch size.</li>
<li>隐藏层的权重向量的形状以及它的偏置向量的形状如何？ ——W_h=50 × 10，b_h = 50（一维长度）</li>
<li>输出层的权重向量和它的偏置向量的形状是什么？ ——W_o=50 × 3，b_o=3</li>
<li>网络的输出矩阵<code>Y</code>是什么形状？ ——Y=m × 3</li>
<li>写出计算网络输出矩阵的方程 —$-Y=(X\cdot W_h+b_h)\cdot W_o+b_o$</li>
</ul>
<ol>
<li>如果你想把电子邮件分类成垃圾邮件或正常邮件，你需要在输出层中有多少个神经元？在输出层中应该使用什么样的激活函数？如果你想解决 MNIST 问题，你需要多少神经元在输出层，使用什么激活函数？</li>
</ol>
<p>答：只需要神经系统在输出层中的一个神经元，通常在估计概率时，使用输出层的logistic激活函数。如果你想处理mnist，你需要输出层的10个神经元，你必须替换<br>logistic函数与softmax激活函数，它可以处理多个分裂，每个类输出一个概率。如果现在想让你的神经网络预测房屋价格，则需要一个输出神经元，不使用任何激活函数<br>输出层。</p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>反向传播</tag>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>数据挖掘概念与技术笔记（8）：聚类（2）</title>
    <url>/2018/11/14/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%888%EF%BC%89%EF%BC%9A%E8%81%9A%E7%B1%BB%EF%BC%882%EF%BC%89/</url>
    <content><![CDATA[<h2 id="基于密度的聚类"><a href="#基于密度的聚类" class="headerlink" title="基于密度的聚类"></a>基于密度的聚类</h2><p>密度聚类方法的指导思想是，只要样本点的密度大于某阈值，则将该样本添加到最近的簇中。这类算法能克服基于距离的算法只能发现“类圆”（凸）的聚类的缺点，可发现任意形状的聚类，且对噪声数据不敏感。但计算密度单元的计算复杂度大，需要建立空间索引来降低计算量。</p>
<h3 id="DBSCAN：一种基于高密度连通区域的密度聚类"><a href="#DBSCAN：一种基于高密度连通区域的密度聚类" class="headerlink" title="DBSCAN：一种基于高密度连通区域的密度聚类"></a>DBSCAN：一种基于高密度连通区域的密度聚类</h3><p>DBCSAN（Density-Based Spatial Clustering of Applications with Noise）是一个比较有代表性的基于密度的聚类算法。与划分和层次聚类方法不同，它将簇定义为密度相连的点的最大集合，能够把具有足够高密度的区域划分为簇，并可在有“噪声”的数据中发现任意形状的聚类。</p>
<p>基础概念</p>
<ul>
<li>对象的ϵ−领域：给定对象在半径ϵϵ内的区域</li>
<li>核心对象：对于给定的数目m，如果一个对象的ϵ−领域至少包含m个对象，则称该对象为核心对象。</li>
<li>直接密度可达：给定一个对象集合D，如果p是在q的ϵ−领域内，而q是一个核心对象，我们说对象p从对象q出发时直接密度可达的。</li>
</ul>
<p>如图ϵ=1 ，m=5， q是一个核心对象，从对象q出发到对象p是直接密度可达的。</p>
<p><img src="/2018/11/14/数据挖掘概念与技术/数据挖掘概念与技术笔记（8）：聚类（2）/01.jpg" alt></p>
<ul>
<li>密度可达：如果存在一个对象链$p<em>1,p_2,⋅⋅⋅,p_n$，使得$p_1=q$，$p_n=p$，并且对$p_i (1≤i≤n)∈D$，有$p</em>{i+1}$是从$p_i$关于ϵ和m直接密度可达的，则p是从q密度可达的(也就是中间连接了多个直接密度可达)。注意密度可达不是等价关系，因为它不是对称的。如果$o_1$和$o_2$都是核心对象，则都是密度可达；如果$o_2$是核心对象$o_1$不是，则$o_1$可能是从$o_2$密度可达，反过来就不可以。（需要从核心出发到不核心）</li>
</ul>
<p><img src="/2018/11/14/数据挖掘概念与技术/数据挖掘概念与技术笔记（8）：聚类（2）/02.jpg" alt></p>
<p> 密度相连：如果对象集合D中存在一个对象o，使得对p和q是从o关于ϵ和m密度可达的，那么对象p和q是关于ϵ和m密度相连的。 (存在中间点o，分别到q和p两条路线都是密度可达，则q和p密度相连)。不像密度可达，密度相连是等价的。 </p>
<p><img src="/2018/11/14/数据挖掘概念与技术/数据挖掘概念与技术笔记（8）：聚类（2）/03.jpg" alt></p>
<p>算法步骤：</p>
<p>下面这张图来自WIKI，图上有若干个点，其中标出了A、B、C、N这四个点，据此来说明这个算法的步骤：</p>
<p><img src="/2018/11/14/数据挖掘概念与技术/数据挖掘概念与技术笔记（8）：聚类（2）/04.jpg" alt></p>
<ul>
<li>1、首先随机选择A点为算法实施的切入点，我们将ϵϵ设置为图中圆的半径，对象密度个数$m（minPts）$设定为4。这里我们看到，A点的ϵϵ领域包含4个对象（自己也包含在内），大于等于$m(minPts)$，则创建A作为核心对象的新簇，簇内其他点都（暂时）标记为边缘点。</li>
<li>2、然后在标记的边缘点中选取一个重复上一步，寻找并合并核心对象直接密度可达的对象。对暂时标记为边缘点反复递归上述算法，直至没有新的点可以更新簇时，算法结束。这样就形成了一个以A为起始的一个聚类，为图中红色的中心点和黄色的边缘点（黄红点都形成簇）</li>
<li>3、如果还有Points未处理，再次新产生一个类别来重新启动这个算法过程。遍历所有数据，如果有点既不是边缘点也不是中心点，将其标记为噪音。</li>
</ul>
<p><img src="/2018/11/14/数据挖掘概念与技术/数据挖掘概念与技术笔记（8）：聚类（2）/05.webp" alt></p>
<p>初始，给定数据集D中的所有对象都标记为”unvisited”。DBSCAN随机地选择一个未访问的对象p，标记p为”visited”，并检查p是否为核心对象。如果不是，标记p为噪点，否则为p创建一个新的簇C，并且将领域内所有对象都放到候选集合N中（这个集合会慢慢加大）。<strong>DBSCAN迭代地把N中不属于其他簇的对象添加C中</strong>。在此过程中，对于N中标记为”unvisited”的对象p’ ，标记为”visited”，如果它是核心对象，则将它的领域节点都添加到N中。DBSCAN继续从候选集N中添加到C，直到N的集合为空。此时，簇C完全生成，于是被输出。</p>
<p>从上述算法可知：</p>
<ul>
<li>每个簇至少包含一个核心对象；</li>
<li>非核心对象可以是簇的一部分，构成了簇的边缘（edge）；</li>
<li>包含过少对象的簇被认为是噪声；</li>
</ul>
<p>DBSCAN的主要优点有：</p>
<p>　　1） 可以对任意形状的稠密数据集进行聚类，相对的，K-Means之类的聚类算法一般只适用于凸数据集。</p>
<p>　　2） 可以在聚类的同时发现异常点，对数据集中的异常点不敏感。</p>
<p>　　3） 聚类结果没有偏倚，相对的，K-Means之类的聚类算法初始值对聚类结果有很大影响。</p>
<p>DBSCAN的主要缺点有：</p>
<p>　　1）如果样本集的密度不均匀、聚类间距差相差很大时，聚类质量较差，这时用DBSCAN聚类一般不适合。</p>
<p>　　2） 如果样本集较大时，聚类收敛时间较长，此时可以对搜索最近邻时建立的KD树或者球树进行规模限制来改进。</p>
<p>　　3） 调参相对于传统的K-Means之类的聚类算法稍复杂，主要需要对距离阈值ϵ，邻域样本数阈值$m(MinPts)$联合调参，不同的参数组合对最后的聚类效果有较大影响。</p>
<h3 id="OPTICS-通过点排序识别聚类结构"><a href="#OPTICS-通过点排序识别聚类结构" class="headerlink" title="OPTICS:通过点排序识别聚类结构"></a>OPTICS:通过点排序识别聚类结构</h3><p>在前面介绍的DBSCAN算法中，有两个初始参数Eps（邻域半径）和minPts(Eps邻域最小点数)需要手动设置，并且聚类的结果对这两个参数的取值非常敏感，不同的取值将产生不同的聚类结果。为了克服DBSCAN算法这一缺点，提出了OPTICS算法（Ordering Points to identify the clustering structure），翻译过来就是，对点排序以此来确定簇结构。</p>
<p>OPTICS是对DBSCAN的一个扩展算法。该算法可以让算法对半径Eps不再敏感。只要确定minPts的值，半径Eps的轻微变化，并不会影响聚类结果 。OPTICS并不显示的产生结果类簇，而是为聚类分析生成一个增广的簇排序，从这个排序中可以得到基于任何参数Eps和minPts的DBSCAN算法的聚类结果。</p>
<h4 id="核心距离与可达距离"><a href="#核心距离与可达距离" class="headerlink" title="核心距离与可达距离"></a>核心距离与可达距离</h4><p>要搞清楚OPTICS算法，需要搞清楚2个新的定义：<strong>核心距离和可达距离</strong>。</p>
<ul>
<li>核心距离：一个对象p的核心距离是<strong>使得其成为核心对象的最小半径</strong>，如果p不是核心点，其可达距离没有定义 。</li>
<li>可达距离：从q到p的可达距离是$\max {core-distance(q), dist(p,q)}$。如果q不是核心点，其从q到p的可达距离没有定义。另外对象p关于不同的核心对象，p可能有多个可达距离。p的最小可达距离代表离一个稠密簇的距离越短，越处于核心密集地段。</li>
</ul>
<p>举例，下图中假设minPts=3，半径是ϵϵ。那么P点的核心距离是d(1,P)，点2的可达距离是d(1,P)，点3的可达距离也是d(1,P)，点4的可达距离则是d(4,P)的距离。</p>
<p><img src="/2018/11/14/数据挖掘概念与技术/数据挖掘概念与技术笔记（8）：聚类（2）/06.png" alt></p>
<h4 id="OPTICS算法描述"><a href="#OPTICS算法描述" class="headerlink" title="OPTICS算法描述"></a>OPTICS算法描述</h4><p>输入：样本集D, 邻域半径ϵϵ, 给定点在ϵϵ领域内成为核心对象的最小领域点数MinPts</p>
<p>输出：具有可达距离信息的样本点输出排序</p>
<p>首先创建两个队列，有序队列和结果队列。（有序队列用来存储核心对象及其该核心对象的直接可达对象，并按可达距离升序排列；结果队列用来存储样本点的输出次序。你可以把有序队列里面放的理解为待处理的数据，而结果队列里放的是已经处理完的数据）。</p>
<p>步骤：</p>
<ul>
<li>D: 待聚类的集合</li>
<li>Q: 有序队列，元素按照可达距离排序，可达距离最小的在队首</li>
<li>O: 结果队列，最后输出结果的点集的有序队列</li>
</ul>
<p>首先从D中取出一个核心对象p，首先p要先标记加入结果队列，它的领域则加入有序队列。从有序队列取队首q，先把队首q标记且加入结果队列，若q不为核心对象则继续从Q队列中取队首处理；否则若为核心队列则将q的领域加入到有序队列并重新排列顺序。加入新元素后再取有序队列队首依次循环处理。算法结束，输出结果队列中的有序样本点。</p>
<p><img src="/2018/11/14/数据挖掘概念与技术/数据挖掘概念与技术笔记（8）：聚类（2）/07.png" alt></p>
<p>得到结果队列后，使用如下算法得到最终的聚类结果：</p>
<ul>
<li>从结果队列中按顺序取出点，如果该点的<strong>可达距离</strong>不大于给定半径ϵϵ，则该点属于当前类别，否则至步骤2</li>
<li>如果该点的<strong>核心距离</strong>大于给定半径ϵ，则该点为噪声，可以忽略，否则该点属于新的聚类，跳至步骤1</li>
<li>结果队列遍历结束，则算法结束</li>
</ul>
<p><img src="/2018/11/14/数据挖掘概念与技术/数据挖掘概念与技术笔记（8）：聚类（2）/08.png" alt></p>
<p> 上面的算法处理完后，我们得到了输出结果序列，每个节点的可达距离和核心距离。我们以可达距离为纵轴，样本点输出次序为横轴进行可视化： </p>
<p><img src="/2018/11/14/数据挖掘概念与技术/数据挖掘概念与技术笔记（8）：聚类（2）/09.png" alt></p>
<p>其中：</p>
<ul>
<li>X轴代表OPTICS算法处理点的顺序，Y轴代表可达距离。</li>
<li>簇在坐标轴中表述为山谷，并且山谷越深，簇越紧密</li>
<li>黄色代表的是噪声，它们不形成任何凹陷。</li>
</ul>
<p>当你需要提取聚集的时候，参考Y轴和图像，自己设定一个阀值就可以提取聚集了。再来一张凹陷明显的：</p>
<p><img src="/2018/11/14/数据挖掘概念与技术/数据挖掘概念与技术笔记（8）：聚类（2）/10.png" alt></p>
<p>OPTICS的核心思想：</p>
<ul>
<li>较稠密簇中的对象在簇排序中相互靠近</li>
<li>一个对象的最小可达距离给出了一个对象连接到一个稠密簇的最短路径</li>
</ul>
<h3 id="DPCA算法"><a href="#DPCA算法" class="headerlink" title="DPCA算法"></a>DPCA算法</h3><p>2014年6月，Alex Rodriguez和Alessandro Laio在ScienceScience上发表了一篇名为《Clustering by fast search and find of density peaks》的文章，提供了一种简洁而优美的聚类算法，是一种基于密度的聚类方法，可以识别各种形状的类簇，并且参数很容易确定。它克服了DBSCAN中不同类的密度差别大、邻域范围难以设定的问题，鲁棒性强。 在文章中提出的聚类方法DPCA算法（Desity Peaks Clustering Algorithm）基于这样一种假设：对于一个数据集，聚类中心被一些低局部密度的数据点包围，而且这些低局部密度点距离其他有高局部密度的点的距离都比较大。</p>
<h4 id="一些概念："><a href="#一些概念：" class="headerlink" title="一些概念："></a>一些概念：</h4><ul>
<li>局部密度$p_i$ ：即到对象i的距离小于$d_c$的对象个数。</li>
<li>高局部密度点距离（顾名思义，密度是特别局部的），其定义为：</li>
</ul>
<script type="math/tex; mode=display">
\delta_i=\min\limits_{j:p_j>p_i}d_{ij}</script><p> 即在局部密度高于对象i的所有对象中，到对象i最近的距离。 而极端地，对于局部密度最大的那个对象(它没有比它更大的了)，我们设置$\delta=max(d_{ij})$，即它与离它最远的点的距离； 只有那些密度是局部或者全局最大的点（即稀疏的点）才会有远大于正常值的高局部密度点距离。 </p>
<h4 id="聚类过程"><a href="#聚类过程" class="headerlink" title="聚类过程"></a>聚类过程</h4><p>这个聚类实例摘自作者的PPT讲演，在一个二维空间中对数据进行聚类，具体步骤如下：</p>
<p>1、首先计算每一个点的局部密度ρiρi，如图中，$ρ<em>1=7,ρ_8=5,ρ</em>{10}=4$</p>
<p><img src="/2018/11/14/数据挖掘概念与技术/数据挖掘概念与技术笔记（8）：聚类（2）/11.jpg" alt></p>
<p> 2、然后对于每一个点i计算在局部密度高于对象i的所有对象中，到对象i最近的距离，即$ \delta_i $</p>
<p><img src="/2018/11/14/数据挖掘概念与技术/数据挖掘概念与技术笔记（8）：聚类（2）/12.jpg" alt></p>
<p> 3、对每一个点，绘制出局部密度与高局部密度点距离的关系散点图 </p>
<p><img src="/2018/11/14/数据挖掘概念与技术/数据挖掘概念与技术笔记（8）：聚类（2）/13.jpg" alt></p>
<p> 4、<strong>图上的异常点即为簇中心</strong>。如图所示，1和10两点的局部密度和高局部密度距离都很大，将其作为簇中心。 </p>
<p><img src="/2018/11/14/数据挖掘概念与技术/数据挖掘概念与技术笔记（8）：聚类（2）/14.jpg" alt></p>
<p>5、将其他的点分配给距离其最近的有着更高的局部密度的簇。</p>
<p><img src="/2018/11/14/数据挖掘概念与技术/数据挖掘概念与技术笔记（8）：聚类（2）/15.jpg" alt></p>
<p> 左图是所有点在二维空间的分布，右图是以ρρ为横坐标，以δδ为纵坐标绘制的决策图。容<strong>易发现，1和10两个点的$ρ_i$和$ \delta_i $都比较大，作为簇的中心点</strong>。<strong>26、27、28三个点的δδ也比较大，但是ρ比较小，所以是异常点</strong>。 </p>
<h4 id="簇中心的识别"><a href="#簇中心的识别" class="headerlink" title="簇中心的识别"></a>簇中心的识别</h4><p>那些有着比较大的局部密度ρiρi和很大的高局部密度δiδi的点被认为是簇的中心； 而高局部密度距离δiδi较大但局部密度ρiρi较小的点是异常点； 确定簇中心之后，其他点按照距离已知簇的中心最近进行分类，也可以按照密度可达的方法进行分类。</p>
<p>但是，这里我们在确定聚类中心时，没有定量地分析，而是通过肉眼观察，包含很多的主观因素。因此，作者在文中给出了一种确定聚类中心个数的提醒：计算一个将ρ值和$ \delta$值综合考虑的量</p>
<script type="math/tex; mode=display">
\gamma_i=\rho_i\delta_i</script><p>显然γ值越大，越有可能是聚类中心。因此，只需对其降序排列，然后从前往后截取若干个数据点作为聚类中心就可以了。</p>
<p>领域阈值$d_c$的选择：一种推荐做法是选择$d_c$，使得平均每个点的邻居数为所有点的1%~2%。</p>
<h2 id="基于网格的聚类"><a href="#基于网格的聚类" class="headerlink" title="基于网格的聚类"></a>基于网格的聚类</h2><p>基于格子的参考这篇文章吧，感觉很少用啊，主要是STING统计信息网格算法和CLIQUE子空间聚类算法。</p>
<p><a href="https://cloud.tencent.com/developer/article/1005263" target="_blank" rel="noopener">戳我</a></p>
<h2 id="谱聚类"><a href="#谱聚类" class="headerlink" title="谱聚类"></a>谱聚类</h2><p>谱聚类似乎也应用较广，这篇博客写的很清晰了</p>
<p><a href="https://blog.csdn.net/google19890102/article/details/45697695" target="_blank" rel="noopener">戳我</a></p>
]]></content>
      <categories>
        <category>数据挖掘</category>
      </categories>
      <tags>
        <tag>聚类</tag>
        <tag>DBSCAN聚类</tag>
        <tag>STING聚类</tag>
        <tag>DPCA聚类</tag>
        <tag>谱聚类</tag>
        <tag>OPTICS聚类</tag>
      </tags>
  </entry>
  <entry>
    <title>数据挖掘概念与技术笔记（7）：聚类（1）</title>
    <url>/2018/11/12/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%887%EF%BC%89%EF%BC%9A%E8%81%9A%E7%B1%BB%EF%BC%881%EF%BC%89/</url>
    <content><![CDATA[<p> 下图简单地总结了一些聚类方法的简单划分 </p>
<p><img src="/2018/11/12/数据挖掘概念与技术/数据挖掘概念与技术笔记（7）：聚类（1）/01.png" alt></p>
<h2 id="基于划分的聚类"><a href="#基于划分的聚类" class="headerlink" title="基于划分的聚类"></a>基于划分的聚类</h2><p>聚类分析最简单、最基本的版本是基于划分的聚类，它把对象组织成多个互斥的组或簇。为了使得问题说明简洁，我们假定簇个数作为背景知识给定，这个参数是划分方法的起点。</p>
<h3 id="k-均值（k-mean）-：一种基于形心的技术"><a href="#k-均值（k-mean）-：一种基于形心的技术" class="headerlink" title="k-均值（k-mean） ：一种基于形心的技术"></a>k-均值（k-mean） ：一种基于形心的技术</h3><p><strong>k均值算法非常简单，它用簇$C_i$的形心代表该簇。每次确定K个类别中心，然后将各个结点归属到与之距离最近的中心点所在的Cluster，然后将类别中心更新为属于各Cluster的所有样本的均值</strong>，反复迭代，直至类别中心不再发生变化或变化小于某阈值。 下面给出该算法的伪代码</p>
<p><img src="/2018/11/12/数据挖掘概念与技术/数据挖掘概念与技术笔记（7）：聚类（1）/02.png" alt></p>
<ul>
<li>优点：<ul>
<li>是解决聚类问题的一种经典算法，简单、快速</li>
<li>对处理大数据集，该算法保持可伸缩性和高效率</li>
</ul>
</li>
<li>缺点：<ul>
<li>必须事先给出K，而且对初值敏感，对于不同的初始值，结果可能不同</li>
<li>只能发现球状Cluster，不适合于发现非凸形状的簇或者大小差别很大的簇</li>
<li>对噪声和孤立点数据敏感，如簇中含有异常点，将导致均值偏离严重</li>
</ul>
</li>
</ul>
<p>如何确定k类</p>
<p><a href="https://www.cnblogs.com/yan2015/p/5239970.html" target="_blank" rel="noopener">https://www.cnblogs.com/yan2015/p/5239970.html</a></p>
<h3 id="k-中心点（k-mediods）：一种基于代表对象的技术"><a href="#k-中心点（k-mediods）：一种基于代表对象的技术" class="headerlink" title="k-中心点（k-mediods）：一种基于代表对象的技术"></a>k-中心点（k-mediods）：一种基于代表对象的技术</h3><p>k-均值算法对离群点敏感，因为这种对象远离大多数数据，因此分配到一个簇时，它们可能严重地扭曲簇的均值。因此，提出了k-中心点算法，<strong>它挑选实际对象代表簇，每个簇使用一个代表对象。这个代表对象选择的规则是：选择簇内一个点到其他点的距离之和的最小代价值，作为新的中心点</strong>。</p>
<p>K-中心聚类算法计算的是某点到其它所有点的距离之和最小的点，通过距离之和最短的计算方式可以减少某些孤立数据对聚类过程的影响 。下面给出算法的伪代码</p>
<p><img src="/2018/11/12/数据挖掘概念与技术/数据挖掘概念与技术笔记（7）：聚类（1）/03.png" alt></p>
<h2 id="基于层次的聚类"><a href="#基于层次的聚类" class="headerlink" title="基于层次的聚类"></a>基于层次的聚类</h2><p>尽管基于划分的聚类算法能够实现把数据集划分成指定数量的簇，但是在某些情况下，需要把数据集划分成不同层上的簇。<strong>层次聚类方法将数据组成层次结构或簇的”树”</strong></p>
<p><strong>基于层次的聚类算法（Hierarchical Clustering）可以</strong>是凝聚的（Agglomerative）或者分裂的（Divisive），取决于层次的划分是“自底向上”还是“自顶向下”。</p>
<ul>
<li>自顶向下： 它把所有对象至于一个簇中开始，该簇是层次结构的根。然后，它把根上的簇划分为多个较小的子簇，并且递归地把这次簇划分成更小的簇，直到满足终止条件。常见的自顶向下的算法有K-means层次聚类算法。</li>
<li>自底向上：把数据集中的每个对象最为一个簇开始，迭代地把簇合并成为更大的簇，直到最终形成一个大簇，或者满足某个终止条件。基于自底向上算法有凝聚算法、BIRCH算法、CURE算法、变色龙算法等。</li>
</ul>
<h3 id="自顶向下算法"><a href="#自顶向下算法" class="headerlink" title="自顶向下算法"></a>自顶向下算法</h3><h4 id="Hierarchical-K-means算法"><a href="#Hierarchical-K-means算法" class="headerlink" title="Hierarchical K-means算法"></a>Hierarchical K-means算法</h4><p>Hierarchical K-means算法是“自顶向下”的层次聚类算法，用到了基于划分的聚类算法那K-means，算法思路如下：</p>
<ol>
<li>首先，把原始数据集放到一个簇C，这个簇形成了层次结构的最顶层；</li>
<li>使用K-means算法把簇C划分成指定的K个子簇$C_i，i=1,2,…,k$，形成一个新的层；</li>
<li>对于步骤2所生成的K个簇，递归使用K-means算法划分成更小的子簇，直到每个簇不能再划分（只包含一个数据对象）或者满足设定的终止条件。</li>
</ol>
<p>如下图，展示了一组数据进行了二次K-means算法的过程</p>
<p><img src="/2018/11/12/数据挖掘概念与技术/数据挖掘概念与技术笔记（7）：聚类（1）/04.png" alt></p>
<p> Hierarchical K-means算法一个很大的问题是，一旦两个点在最开始被划分到了不同的簇，即使这两个点距离很近，在后面的过程中也不会被聚类到一起。 </p>
<p><img src="/2018/11/12/数据挖掘概念与技术/数据挖掘概念与技术笔记（7）：聚类（1）/05.png" alt></p>
<p>对于以上的例子，红色椭圆框中的对象聚类成一个簇可能是更优的聚类结果，但是由于橙色对象和绿色对象在第一次K-means就被划分到不同的簇，之后也不再可能被聚类到同一个簇。</p>
<h3 id="自底向上算法"><a href="#自底向上算法" class="headerlink" title="自底向上算法"></a>自底向上算法</h3><h4 id="Agglomerative-Clustering算法"><a href="#Agglomerative-Clustering算法" class="headerlink" title="Agglomerative Clustering算法"></a>Agglomerative Clustering算法</h4><p>相比于Hierarchical K-means算法存在的问题，Agglomerative Clustering算法能够保证距离近的对象能够被聚类到一个簇中，该算法采用的“自底向上”聚类的思路。</p>
<p> 算法思路，对于数据集$D，D=x_1,x_2,…,x_n$：</p>
<ol>
<li>将数据集中的每个对象生成一个簇，得到簇列表$C，C=c_1,c_2,…,c_n$<ul>
<li>a) 每个簇只包含一个数据对象：$c_i=x_i$；</li>
</ul>
</li>
<li>重复如下步骤，直到C中只有一个簇：<ul>
<li>a) 从C中的簇中找到两个“距离”最近的两个簇：$\min D(ci,cj)$；</li>
<li>b) 合并簇$c<em>i$和$c_j$，形成新的簇$c</em>{ij}；</li>
<li>c) 从C中删除簇$c<em>i%和$c_j$，添加簇$c</em>{ij}</li>
</ul>
</li>
</ol>
<h5 id="簇间距离计算"><a href="#簇间距离计算" class="headerlink" title="簇间距离计算"></a>簇间距离计算</h5><p>在上面描述的算法中涉及到计算两个簇之间的距离，对于簇$C_1$和$C_2$，计算$minD(C1,C2)$，有以下几种计算方式：</p>
<p> <strong>最小距离：</strong> </p>
<script type="math/tex; mode=display">
\min\ dist_{min}(C_i,C_j)=\min \mathop{\min} \limits_{p\in C_i,q\in C_j}\{|p-q|\}</script><p><img src="/2018/11/12/数据挖掘概念与技术/数据挖掘概念与技术笔记（7）：聚类（1）/06.png" alt></p>
<p>两个簇之间最近的两个点的距离作为簇之间的距离，该方式的缺陷是受噪点影响大，容易产生长条状的簇。</p>
<p><strong>最大距离：</strong></p>
<script type="math/tex; mode=display">
\min\ dist_{max}(C_i,C_j)=\min \mathop{\max} \limits_{p\in C_i,q\in C_j}\{|p-q|\}</script><p><img src="/2018/11/12/数据挖掘概念与技术/数据挖掘概念与技术笔记（7）：聚类（1）/07.png" alt></p>
<p>两个簇之间最远的两个点的距离作为簇之间的距离，采用该距离计算方式得到的聚类比较紧凑。</p>
<p><strong>均值距离：</strong> $m_i$和$m_j$为簇内所有点的均值坐标</p>
<script type="math/tex; mode=display">
\min\ dist_{mean}(C_i,C_j)=\min |m_i-m_j|</script><p> <strong>平均距离：</strong> </p>
<script type="math/tex; mode=display">
\min\ dist_{avg}(C_i,C_j)=\min\ \frac{1}{n_in_j}\mathop{\sum}\limits_{p\in C_i,q\in C_j}\{|p-q|\}</script><h5 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h5><p><img src="/2018/11/12/数据挖掘概念与技术/数据挖掘概念与技术笔记（7）：聚类（1）/09.png" alt></p>
<p>Agglomerative聚类算法的优点是能够根据需要在不同的尺度上展示对应的聚类结果，缺点同Hierarchical K-means算法一样，一旦两个距离相近的点被划分到不同的簇，之后也不再可能被聚类到同一个簇，即无法撤销先前步骤的工作。另外，Agglomerative性能较低，并且因为聚类层次信息需要存储在内存中，内存消耗大，不适用于大量级的数据聚类，下面介绍一种针对大数据量级的聚类算法BIRCH。</p>
<h4 id="BIRCH算法：使用聚类特征树"><a href="#BIRCH算法：使用聚类特征树" class="headerlink" title="BIRCH算法：使用聚类特征树"></a>BIRCH算法：使用聚类特征树</h4><p><strong>BIRCH算法利用了一个树结构来帮助实现快速的聚类，这个数结构类似于平衡B+树，一般将它称之为聚类特征树(Clustering Feature Tree，简称CF Tree)。</strong>这颗树的<strong>每一个节点是由若干个聚类特征(Clustering Feature，简称CF)组成</strong>。从下图可以看看聚类特征树是什么样子的：<strong>每个节点包括叶子节点都有若干个CF，而内部节点的CF有指向孩子节点的指针，所有的叶子节点用一个双向链表链接起来</strong>。</p>
<p><img src="/2018/11/12/数据挖掘概念与技术/数据挖掘概念与技术笔记（7）：聚类（1）/10.png" alt></p>
<p> <strong>在聚类特征树中，一个聚类特征CF是这样定义的：</strong>每一个CF是一个三元组，可以用（N，LS，SS）表示，其中<strong>N代表了这个CF中拥有的样本点的数量；LS代表了这个CF中拥有的样本点各特征维度的和向量，SS代表了这个CF中拥有的样本点各特征维度的平方和</strong>。 聚类特征本质上是定簇的统计汇总。使用聚类特征，我们可以很容易地推导出簇的许多有用的统计量，例如簇的形心$x_0$、半径R和直径D分别是 </p>
<script type="math/tex; mode=display">
x_0=\frac{\sum_{i=1}^nx_i}{n}=\frac{LS}{n}</script><script type="math/tex; mode=display">
R=\sqrt{\frac{\sum_{i=1}^n(x_i-x_0)^2}{n}}</script><script type="math/tex; mode=display">
D=\sqrt{\frac{\sum_{i=1}^n\sum_{j=1}^n(x_i-x_j)^2}{n(n-1)}}=\sqrt{\frac{2nSS-2LS^2}{n(n-1)}}</script><p>其中，R是成员对象到形心的平均距离，D是簇中逐对对象的平均距离。<strong>R和D都反映了形心周围簇的紧凑程度</strong>。</p>
<p>此外，<strong>聚类特征是可加的</strong>，也就是说，对于两个不相交的簇$C_1$和$C_2$，其聚类特征分别是$CF_1[n_1,LS_1,SS_1]$和$CF_2 [n_2,LS_2,SS_2]，合并后的簇的聚类特征是 </p>
<script type="math/tex; mode=display">
CF_1+CF_2=[n_1+n_2,LS_1+LS_2,SS_1+SS_2]</script><p>对于CF Tree，一般有几个重要参数，<strong>第一个参数是每个内部节点的最大CF数B</strong>，<strong>第二个参数是每个叶子节点的最大CF数L</strong>，<strong>第三个参数是针对叶子节点中某个CF中的样本点来说的，它是叶节点每个CF的最大样本半径阈值T</strong>，也就是说，在<strong>这个CF中的所有样本点一定要在半径小于T的一个超球体内</strong>。对于图中的CF Tree，<strong>限定了B=7， L=5， 也就是说内部节点最多有7个CF，而叶子节点最多有5个CF</strong>。</p>
<p><strong>将所有的训练集样本建立了CF Tree，一个基本的BIRCH算法就完成了，对应的输出就是若干个CF节点，每个节点里的样本点就是一个聚类的簇。也就是说BIRCH算法的主要过程，就是建立CF Tree的过程。</strong></p>
<h5 id="聚类特征树CF-Tree的生成"><a href="#聚类特征树CF-Tree的生成" class="headerlink" title="聚类特征树CF Tree的生成"></a>聚类特征树CF Tree的生成</h5><p>下面看看怎么生成CF Tree。<strong>先定义好CF Tree的参数： 即内部节点的最大CF数B， 叶子节点的最大CF数L， 叶节点每个CF的最大样本半径阈值T。</strong></p>
<p><strong>开始时CF Tree是空的，</strong>没有任何样本，我们<strong>从训练集读入第一个样本点，将它放入一个新的CF三元组A</strong>，这个三元组的N=1，将这个新的CF放入根节点，<strong>此时的CF Tree如下图：</strong></p>
<p><img src="/2018/11/12/数据挖掘概念与技术/数据挖掘概念与技术笔记（7）：聚类（1）/11.png" alt></p>
<p> <strong>现在继续读入第二个样本点，发现这个样本点和第一个样本点A在半径为T的超球体范围内，即他们属于一个CF，将第二个点也加入CF A,此时需要更新A的三元组的值。</strong>此时A的三元组中N=2。此时的CF Tree如下图： </p>
<p><img src="/2018/11/12/数据挖掘概念与技术/数据挖掘概念与技术笔记（7）：聚类（1）/12.png" alt></p>
<p> <strong>此时读取第三个节点，结果发现这个节点不能融入刚才前面的节点形成的超球体内，</strong>也就是说，<strong>需要一个新的CF三元组B来容纳这个新的值。此时根节点有两个CF三元组A和B</strong>，此时的CF Tree如下图： </p>
<p><img src="/2018/11/12/数据挖掘概念与技术/数据挖掘概念与技术笔记（7）：聚类（1）/13.png" alt></p>
<p> <strong>当来到第四个样本点时，发现和B在半径小于T的超球体，这样更新后的CF Tree如下图：</strong> </p>
<p><img src="/2018/11/12/数据挖掘概念与技术/数据挖掘概念与技术笔记（7）：聚类（1）/14.png" alt></p>
<p>那个什么时候CF Tree的节点需要分裂呢？假设现在的CF Tree 如下图， 叶子节点LN1有三个CF， LN2和LN3各有两个CF。<strong>叶子节点的最大CF数L=3</strong>。此时一个新的样本点来了，发现它离LN1节点最近，因此开始判断它是否在sc1,sc2,sc3这3个CF对应的超球体之内，但是很不幸，它不在，因此它需要建立一个新的CF，即sc8来容纳它。<strong>问题是我们的L=3，也就是说LN1的CF个数已经达到最大值了，不能再创建新的CF了，怎么办？此时就要将LN1叶子节点一分为二了</strong>。</p>
<p><strong>将LN1里所有CF元组中，找到两个最远的CF做这两个新叶子节点的种子CF，然后将LN1节点里所有CF sc1, sc2, sc3，以及新样本点的新元组sc8划分到两个新的叶子节点上。</strong>将LN1节点划分后的CF Tree如下图：</p>
<p><img src="/2018/11/12/数据挖掘概念与技术/数据挖掘概念与技术笔记（7）：聚类（1）/15.png" alt></p>
<p> <strong>如果内部节点的最大CF数B=3，则此时叶子节点一分为二会导致根节点的最大CF数超了，也就是说，根节点现在也要分裂</strong>，分裂的方法和叶子节点分裂一样，分裂后的CF Tree如下图： </p>
<p><img src="/2018/11/12/数据挖掘概念与技术/数据挖掘概念与技术笔记（7）：聚类（1）/16.png" alt></p>
<p><strong>有了上面这一系列的图，相信大家对于CF Tree的插入就没有什么问题了，总结下CF Tree的插入：</strong></p>
<ul>
<li>1、<strong>从根节点向下寻找</strong>和新样本距离最近的叶子节点和叶子节点里最近的CF节点（判断新节点与NLN1和NLN2谁近一些，然后继续往下）</li>
<li>2、如果新样本加入后，这个CF节点对应的超球体半径仍然满足小于阈值T，则更新路径上所有的CF三元组，插入结束。否则转入3.</li>
<li>3、如果当前叶子节点的CF节点个数小于阈值L，则创建一个新的CF节点，放入新样本，将新的CF节点放入这个叶子节点，更新路径上所有的CF三元组，插入结束。否则转入4。</li>
<li>4、将当前叶子节点划分为两个新叶子节点，选择旧叶子节点中所有CF元组里超球体距离最远的两个CF元组，分布作为两个新叶子节点的第一个CF节点。将其他元组和新样本元组按照距离远近原则放入对应的叶子节点。依次向上检查父节点是否也要分裂，如果需要按和叶子节点分裂方式相同。</li>
</ul>
<p>当然，真实的BIRCH算法除了建立CF Tree来聚类，其实还有一些可选的算法步骤的，<strong>现在我们就来看看 BIRCH算法的流程。</strong></p>
<ul>
<li>1） 将所有的样本依次读入，在内存中建立一颗CF Tree, 建立的方法参考上一节。</li>
<li>2）（可选）将第一步建立的CF Tree进行筛选，去除一些异常CF节点，这些节点一般里面的样本点很少。对于一些超球体距离非常近的元组进行合并</li>
<li>3）（可选）利用其它的一些聚类算法比如K-Means对所有的CF元组进行聚类，得到一颗比较好的CF Tree.这一步的主要目的是消除由于样本读入顺序导致的不合理的树结构，以及一些由于节点CF个数限制导致的树结构分裂。</li>
<li>4）（可选）利用第三步生成的CF Tree的所有CF节点的质心，作为初始质心点，对所有的样本点按距离远近进行聚类。这样进一步减少了由于CF Tree的一些限制导致的聚类不合理的情况。</li>
</ul>
<p><strong>从上面可以看出，BIRCH算法的关键就是步骤1，也就是CF Tree的生成，其他步骤都是为了优化最后的聚类结果。</strong></p>
<p><strong>优点</strong></p>
<ul>
<li>1) 节约内存，所有的样本都在磁盘上，CF Tree仅仅存了CF节点和对应的指针。</li>
<li>2) 聚类速度快，只需要一遍扫描训练集就可以建立CF Tree，CF Tree的增删改都很快。</li>
<li>3) 可以识别噪音点，还可以对数据集进行初步分类的预处理</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>1) 由于CF Tree对每个节点的CF个数有限制，导致聚类的结果可能和真实的类别分布不同.</li>
<li>2) 对高维特征的数据聚类效果不好。此时可以选择Mini Batch K-Means</li>
<li>3) 如果数据集的分布簇不是类似于超球体，或者说不是凸的，则聚类效果不好。</li>
</ul>
<h4 id="CURE算法"><a href="#CURE算法" class="headerlink" title="CURE算法"></a>CURE算法</h4><p>CURE（Clustering Using Representatives）是一种针对大型数据库的高效的聚类算法。基于划分的传统的聚类算法得到的是球状的，相等大小的聚类，对异常数据比较脆弱。CURE采用了用多个点代表一个簇的方法，可以较好的处理以上问题。并且在处理大数据量的时候采用了随机取样，分区的方法，来提高其效率，使得其可以高效的处理大量数据。</p>
<p>我们先看一下基于划分聚类算法的缺陷：</p>
<p><img src="/2018/11/12/数据挖掘概念与技术/数据挖掘概念与技术笔记（7）：聚类（1）/17.png" alt></p>
<p>如上图所示，基于划分的聚类算法比如Hierarchical K-means聚类算法，不能够很好地区分尺寸差距大的簇，原因是K-means算法基于“质心”加一定“半径”对数据进行划分，导致最后聚类的簇近似“圆形”。</p>
<p><strong>CURE算法核心的思想是使用一定数量的“分散的”点（scattered points）来代表一个簇（cluster）</strong>，而不像是其他层次聚类算法中，只使用一个点，使得CURE算法有如下优势：</p>
<ul>
<li>准确地识别任意形状的簇；</li>
<li>准确地识别尺寸差距大的簇；</li>
<li>很好地处理“噪点”</li>
</ul>
<p>所以，CURE算法很好地解决了上面提到的聚类结果的缺陷，CURE算法主流程如下：</p>
<p><strong>Pass 1</strong></p>
<ul>
<li>1、从总数据中随机选取一个样本；</li>
<li>2、利用层次聚类算法把这个样本聚类，形成最初的簇$C_i,(i=1,2,…,k)$；</li>
<li>3、选取“代表点”（representative pionts）;</li>
</ul>
<p>①对于每个簇，选取代表点（比如4个），这些点尽量分散;</p>
<p>②按照固定的比例α（比如20%），把每个样本点向簇的“质心”收缩，生成代表点</p>
<script type="math/tex; mode=display">
\{p'_{i1},p'_{i2},p'_{i3},p'_{i4}\}</script><p><strong>Pass 2</strong></p>
<ul>
<li>重新扫描所有的数据， 对于点p，找到距离p最近的簇，把它放到 “最近的簇”。简单来讲，<strong>是点p到簇$C_i$的距离为点p到簇$C_i$的四个“代表点 中最近的点之间的距离</strong>。</li>
</ul>
<p>收缩系数α的取值不同，聚类结果也相应不同。当α趋于0时，所有的“代表点”都汇聚到质心，算法退化为基于“质心”的聚类；当α趋于1时，“代表点”完全没有收缩，算法退化为基于“全连接”的聚类，因此α值需要要根据数据特征灵活选取，才能得到更好的聚类结果</p>
<h4 id="Chameleon变色龙算法：使用动态建模"><a href="#Chameleon变色龙算法：使用动态建模" class="headerlink" title="Chameleon变色龙算法：使用动态建模"></a>Chameleon变色龙算法：使用动态建模</h4><p>Chameleon（变色龙）是一种层次聚类算法，它采用动态建模来确定一对簇之间的相似度。在Chameleon中，簇的相似性依据以下两点评估：1）簇中对象的连接情况 ；2）簇的邻近性。也就是说，如果两个簇的互连性都很高并且它们之间又靠得很近就将其合并。</p>
<p><img src="/2018/11/12/数据挖掘概念与技术/数据挖掘概念与技术笔记（7）：聚类（1）/18.png" alt></p>
<p>整体算法流程：</p>
<p>1、创建KNN图，每个节点将其最相似的k个节点用一条边连接起来；</p>
<p>2、使用最大流算法或者最小割算法，将kNN图分隔成小图； 也就是说簇C被划分为子簇CiCi和$C_j$，使得把C二分成$C_i$和$C_j$而被切断的边的权重之和最小。</p>
<p>3、将小簇进行和并，找对最大的度量值$RC*RI^\alpha$的两个簇，合并条件是$RC*RI^\alpha$大于某个阈值，否则结束合并。RC和RI的一个基本思想是，点之间的链接越多，这些点越可能连接成一个簇，C表示一个簇，是点的集合，|C|是集合的大小，即点的个数, $EC(A,B)$表示两个簇之间的边的数量。</p>
<p><strong>相似互连度</strong>$RI(C_i,C_j)$</p>
<script type="math/tex; mode=display">
RI(C_i,C_j)=\frac{|EC_{\{C_i,C_j\}}|}{\frac{1}{2}(|EC_{C_i}|+|EC_{C_j}|)}</script><p> 相对接近度$RC(C_i,C_j)$</p>
<script type="math/tex; mode=display">
RC(C_i,C_j)=\frac{\overline S_{EC_{\{C_i,C_j\}}}}{\frac{|C_i|}{|C_i|+|C_j|} \overline S_{EC_{C_i}}+ \frac{|C_i|}{|C_i|+|C_j|} \overline S_{EC_{C_j}}  }</script><p> 其中，分子是连接$C_i$顶点和$C_j$顶点的边的平均权重，分母SECC是最小二分簇$C_i$（或$C_j$）的边的平均权重。 </p>
]]></content>
      <categories>
        <category>数据挖掘</category>
      </categories>
      <tags>
        <tag>聚类</tag>
        <tag>k均值</tag>
        <tag>k中心点</tag>
        <tag>层次聚类</tag>
        <tag>BIRCH聚类</tag>
        <tag>Chameleon变色龙聚类</tag>
      </tags>
  </entry>
  <entry>
    <title>数据挖掘概念与技术笔记（6）：高级分类方法</title>
    <url>/2018/11/09/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%886%EF%BC%89%EF%BC%9A%E9%AB%98%E7%BA%A7%E5%88%86%E7%B1%BB%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="贝叶斯信念网络"><a href="#贝叶斯信念网络" class="headerlink" title="贝叶斯信念网络"></a>贝叶斯信念网络</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>朴素贝叶斯分类有一个限制条件，就是特征属性<strong>必须有条件独立或基本独立</strong>（实际上在现实应用中几乎不可能做到完全独立）。当这个条件成立时，朴素贝叶斯分类法的准确率是最高的，但不幸的是，现实中各个特征属性间往往并不条件独立，而是具有<strong>较强的相关性</strong>，这样就限制了朴素贝叶斯分类的能力。 解决这个问题的一种算法叫<strong>贝叶斯网络（又称贝叶斯信念网络或信念网络）</strong>。</p>
<p>贝叶斯网络由两个成分定义：1）有向无环图（DAG）; 2)条件概率表的集合(Conditional Probability Table，CPT)</p>
<p><img src="/2018/11/09/数据挖掘概念与技术/数据挖掘概念与技术笔记（6）：高级分类方法/01.png" alt></p>
<p>上图给出了一个布尔变量的简单贝叶斯信念网络，图中的弧可看做因果知识。<strong>换言之，一旦我们知道变量LungCanner的结果，那么变量FamilyHistory和Smoker就不再提供关于PostiveXRay的任何附近信息</strong>。</p>
<p>DAG中每一个节点表示一个随机变量，可以是可直接观测变量或隐藏变量，而有向边表示随机变量间的条件依赖；<strong>条件概率表中的每一个元素对应DAG中唯一的节点，存储此节点对于其所有直接前驱节点的联合条件概率</strong>。贝叶斯网络有一条极为重要的性质，就是我们<strong>断言每一个节点在其直接前驱节点的值制定后，这个节点条件独立于其所有非直接前驱前辈节点</strong>。这条特性的<strong>重要意义</strong>在于明确了贝叶斯网络可以方便计算联合概率分布。 一般情况先，多变量非独立联合条件概率分布有如下求取公式：</p>
<script type="math/tex; mode=display">
P(x_1,x_2,..,x_n)=P(x_1)P(x_2|x_1)P(x_3|x_1,x_2)...P(x_n|x_1,x_2,...,x_{n-1})</script><p> 而在贝叶斯网络中，由于存在前述性质，任意随机变量组合的联合条件概率分布被化简成 </p>
<script type="math/tex; mode=display">
P(x_1,x_2,...,x_n)=\prod_{i=1}^nP(x_i|Parents(x_i))</script><p> 其中，$P(x_1,…,x_n)$是X的值的特定组合的概率，Parents表示xi的直接前驱节点的<strong>联合</strong> ，而$P(x_i|Parents(x_i))$的值对应于CPT概率表的值。 </p>
<p><img src="/2018/11/09/数据挖掘概念与技术/数据挖掘概念与技术笔记（6）：高级分类方法/02.png" alt></p>
<p>上图是一个有向无环图（DAG） ，不过仅有这个图的话，只能<strong>定性</strong>给出随机变量间的关系，如果要定量，还需要一些数据，这些数据就是每个节点对其直接前驱节点的条件概率（也就是CPT表的概率），而没有前驱节点的节点则使用先验概率表示。</p>
<p>没有前驱的节点用先验概率表示；以及CPT条件概率，例如P(H=0|R=0)=0.9（真实账号为假，头像也为假的概率）</p>
<p><img src="/2018/11/09/数据挖掘概念与技术/数据挖掘概念与技术笔记（6）：高级分类方法/03.png" alt></p>
<p> <strong>有了这些数据，不但能顺向推断，还能通过贝叶斯定理进行逆向推断</strong>。例如，现随机抽取一个账户，已知其头像为假，求其账号也为假的概率： </p>
<p><img src="/2018/11/09/数据挖掘概念与技术/数据挖掘概念与技术笔记（6）：高级分类方法/04.png" alt></p>
<p><strong>如果给出所有节点的条件概率表，则可以在观察值不完备的情况下对任意随机变量进行统计推断</strong>。上述方法就是使用了贝叶斯网络。</p>
<h3 id="训练贝叶斯网络"><a href="#训练贝叶斯网络" class="headerlink" title="训练贝叶斯网络"></a>训练贝叶斯网络</h3><p>构造与训练贝叶斯网络分为以下两步：</p>
<ul>
<li>1、确定随机变量间的拓扑关系，形成DAG。<strong>这一步通常需要领域专家完成</strong>，而想要建立一个好的拓扑结构，通常需要不断迭代和改进才可以。</li>
<li>2、训练贝叶斯网络。如果不训练的，我们只能知道定性的网络，而不能定量。<strong>实际上这一步也就是要完成条件概率表(CPT表)的构造</strong>，如果每个随机变量的值都是可以直接观察的，像我们上面的例子，那么这一步的训练是直观的，方法类似于朴素贝叶斯分类。<strong>但是通常贝叶斯网络的中存在隐藏变量节点，那么训练方法就是比较复杂，例如使用梯度下降法</strong>。</li>
</ul>
<h3 id="性能如何"><a href="#性能如何" class="headerlink" title="性能如何"></a>性能如何</h3><p>贝叶斯网络已经广泛于临床，生物，征信等领域。其强大之处在于两点</p>
<ul>
<li>1.贝叶斯网络最强大之处在于从每个阶段结果所获得的概率都是数学与科学的反映，换句话说，假设我们了解了足够多的信息，根据这些信息获继而得统计知识，网络就会告诉我们合理的推断。</li>
<li>2.贝叶斯网络最很容易扩展(或减少,简化),以<strong>适应不断变化的需求和变化的知识</strong>。</li>
</ul>
<h2 id="使用频繁模式分类"><a href="#使用频繁模式分类" class="headerlink" title="使用频繁模式分类"></a>使用频繁模式分类</h2><h3 id="关联分类"><a href="#关联分类" class="headerlink" title="关联分类"></a>关联分类</h3><p>回顾一下之前的关联规则，显示了规则的置信度和支持度</p>
<script type="math/tex; mode=display">
age=youth \land credit=ok \Rightarrow buys\_computer=yes \\ [support =20\%，confidence=93\%]</script><p>从分类角度，置信度类似于规则的准准确度。例如，93%的置信度意味着D中身为年轻人并且信誉度为OK的顾客中，93%属于类buysconputer=yes。支持度20%意味着D中20%的顾客是青年，信誉为OK，并且属于类buyscomputer=yes</p>
<p>一般而言，关联规则的分类包括以下步骤：</p>
<ul>
<li>1、挖掘数据，找出频繁项集，即找出数据经常出现的属性-值对</li>
<li>2、分析频繁项集，产生每个类的关联规则，它们满足置信度和支持度标准</li>
<li>3、组织规则，形成基于规则的分类器</li>
</ul>
<p>这里，我们考察以下三种分类方法1）CBA ; 2) CMAR ; 3)CPAR</p>
<h4 id="CBA"><a href="#CBA" class="headerlink" title="CBA"></a>CBA</h4><p>最早、最简单的关联分类算法是CBA。CBA使用迭代的方法挖掘频繁项集，类似于Apriori算法。CBA使用了一种启发式方法构造分类器，其中<strong>规则按照它们的置信度和支持度递减优先级排序</strong>，如果当中一组规则具有相同的前件，则选取具有最高置信度的规则代表该集合。<strong>在对新元组分类是，使用满足该元组第一个规则对它进行分类</strong>。分类器还包含一个默认规则，具有最低优先级。</p>
<h4 id="CMAR"><a href="#CMAR" class="headerlink" title="CMAR"></a>CMAR</h4><p>CMAR和CBA在频繁项集挖掘和构建分类器都不同，<strong>CMAR采用FP-growth算法的变形来发现满足最小支持的最小置信度的规则完全集</strong>。构造分类器时，如果新元组X只匹配一个规则，则简单地把规则的类标号给这个元组。如果多个规则满足X，把这些规则形成一个集合S。CBA将集合S中最大置信度的规则的类标号指派给X，而CMAR考虑多个规则。<strong>它根据S的类标号将规则分类，不同组中的规则具有不同的类标号</strong>，然后CMAR使用X2X2卡方度量，根据组中规则的统计相关联找出相关性“最强的”规则组，再把该类标号指派个X元组。这样，<strong>它就考虑了多个规则，不是像CBA一样只考虑一个规则</strong>。CMAR在准确率和复杂的都比CBA更有效一点。</p>
<h4 id="CPAR"><a href="#CPAR" class="headerlink" title="CPAR"></a>CPAR</h4><p>CPAR和CMAR相差不多，<strong>它通过FOIL算法而不是FP-growth来挖掘规</strong>则。同样也将集合S的规则按类分组。然而，CPAR根据期望准确率，使用每组中最好的k个规则预测X元组的类标号，<strong>通过考虑组中最好的k个规则而不是所有规则</strong>。在大数据集上，CPAR和CMAR准确率差不多，但产生的规则要比CMAR少的多。</p>
<h3 id="基于有区别力的频繁模式分类"><a href="#基于有区别力的频繁模式分类" class="headerlink" title="基于有区别力的频繁模式分类"></a>基于有区别力的频繁模式分类</h3><p>如果我们把所有频繁模式都添加到特征空间，可能许多模式是冗余，还可能因特征太多而过分拟合，导致准确率降低。因此，一种好的做法是使用特征选择，删除区别能力较弱的特征，其一般框架步骤(两步法)如下：</p>
<ul>
<li>特征产生：频繁模式的集合F形成候选特征</li>
<li>特征选择： 通过信息增等度量对F进行特征选择，得到选择后的频繁模式FsFs，数据集DD变换成D′D′</li>
<li>学习分类模型：在数据集D′D′建立分类器</li>
</ul>
<p><img src="/2018/11/09/数据挖掘概念与技术/数据挖掘概念与技术笔记（6）：高级分类方法/05.png" alt></p>
<p>为了提高两步法的效率，考虑将步骤1和步骤2合并为一步。即有可能只挖掘具有高度区别能力的频繁模式的集合，而不是完全集。DDPMine算法采用这种方法，它首先把训练数据变换到一个称频繁模式树或FP树的紧凑树结构，然后再该树种搜索有区别能力的模式。</p>
<p>在准确率和效率两个方面，DDPMine都优于最先进的关联分类方法。</p>
<h2 id="k-近邻分类"><a href="#k-近邻分类" class="headerlink" title="k-近邻分类"></a>k-近邻分类</h2><p><strong>对于，k-近邻分类算法，位置元组每次都被指派到它的k个最近邻（距离度量）的多数类</strong>。</p>
]]></content>
      <categories>
        <category>数据挖掘</category>
      </categories>
      <tags>
        <tag>贝叶斯信念网络</tag>
        <tag>关联分类</tag>
        <tag>k近邻</tag>
      </tags>
  </entry>
  <entry>
    <title>数据挖掘概念与技术笔记（5）：分类</title>
    <url>/2018/11/06/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89%EF%BC%9A%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<p>这一章很多概念都是之前就接触了，就不一一记录了，这里记录一些感兴趣的吧。</p>
<h2 id="决策树剪枝"><a href="#决策树剪枝" class="headerlink" title="决策树剪枝"></a>决策树剪枝</h2><p>为了避免决策树过拟合数据，一般要对决策树进行剪枝：<strong>先剪枝和后剪枝</strong></p>
<p>在先剪枝方法中，通过提前停止树的构造（例如，通过决定在给定的结点上不再分裂或划分训练样本的子集）而对树“剪枝”。在构造树时，统计意义下的度量，如信息增益、基尼指数等，可以用于评估分裂的优劣。如果在一个结点划分样本将导致低于预定义阈值的分裂，则给定子集的进一步划分将停止。然而，选取一个适当的阈值是困难的。较高的阈值可能导致过分简化的树，而较低的阈值可能使得树的化简太少。</p>
<p>第二种更常用的方法是后剪枝，它由“完全生长”的树之后再剪去分枝，通过用叶子节点替换要删除的分枝。CART使用的代价复杂度剪枝算法是后剪枝方法的一个实例。该方法把树的复杂度看做树叶节点的个数和树的错误率的函数，如果减去节点N的子树导致较小的代价复杂度，则剪掉该子树；否则，保留该子树。</p>
<h2 id="可伸缩性与决策树"><a href="#可伸缩性与决策树" class="headerlink" title="可伸缩性与决策树"></a>可伸缩性与决策树</h2><p>已有的决策树算法，如ID3、C4.5和CART都是为相对较小的数据集规模。另外，大部分情况下，大规模的训练数据不能放在内存！因此，由于训练元组在主存和高速缓存换进换出，决策树的构造可能变得效率低下。最近，已经提出了一些可以解决伸缩问题的决策树算法，例如，<strong>RainForest（雨林）能适应可用的内存量，采用了一种新的数据结构形式</strong>。</p>
<p><img src="/2018/11/06/数据挖掘概念与技术/数据挖掘概念与技术笔记（5）：分类/01.png" alt></p>
<p> 转为AVC集的聚集信息的数据结构来存放 </p>
<p><img src="/2018/11/06/数据挖掘概念与技术/数据挖掘概念与技术笔记（5）：分类/02.png" alt></p>
<p><strong>另外一种方法是采用树构造的自助乐观算法（BOAT）</strong>，它采用了统计学计数，创建给定训练数据的一些较小的样本（或子集），其中每个子集都能放在内存中。使用每个子集构造一颗树，导致多棵树，并使用它们构造一个新树。</p>
<h2 id="使用IF-THEN规则分类"><a href="#使用IF-THEN规则分类" class="headerlink" title="使用IF-THEN规则分类"></a>使用IF-THEN规则分类</h2><p>基于规则的分类器使用一组IF-THEN规则进行分类。一个IF-THEN的规则R1一般表示形式有如下两种</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">R1:IF age=youth AND student=yes THEN buys_conmputer = yes </span><br><span class="line"></span><br><span class="line">R1:IF age=youth ^ student=yes THEN buys_computer = yes</span><br></pre></td></tr></table></figure>
<p> 规<strong>则R可以用覆盖率和准确率来评估</strong>。给定类标记的数据集D中的一个元组X，设$n<em>{covers}$为规则R覆盖的元组数，$n</em>{covers}$为R正确分类的元组数，|D|是D中的总元组数，可将R的<strong>覆盖率</strong>和<strong>准确率</strong>定义为： </p>
<script type="math/tex; mode=display">
coverage(R)=\frac{n_{cover}}{|D|} \\ accuracy(R)=\frac{n_{correct}}{n_{covers}}</script><h3 id="如何建立基于规则的分类器呢"><a href="#如何建立基于规则的分类器呢" class="headerlink" title="如何建立基于规则的分类器呢"></a>如何建立基于规则的分类器呢</h3><ul>
<li>1、根据决策树提取规则</li>
</ul>
<p><strong>对从根到树叶节点的每条路经创建一个规则</strong>。沿着给定路经上的每个属性-值的逻辑AND形成规则前件（“IF”部分）。叶结点包含类预测，形成规则后件（“THEN”部分）。<strong>由于这些规则都是直接从书中提取的，所以它们是互斥的和穷举的</strong>（互斥意味不可能存在规则冲突），<strong>因此规则的序不重要——它们是无序的</strong>。</p>
<p>由于每个树叶对应一个规则，所以提取的规则集的量也很多。所以有两种解决方法，第一种是先对决策树剪枝，然后提取规则。另外一种是直接提取规则，然后修剪规则，对于不能提高规则的估计准确率的任何条件都可以删减，从而泛化该规则。</p>
<ul>
<li>2、使用顺序覆盖算法</li>
</ul>
<p>顺序覆盖算法是最广泛使用的挖掘分类规则取集的方法，有许多流行的顺序覆盖算法，包括AQ、CN2和最近提出的RIPPER。算法的一般策略如下：一次学习一个规则，每学习一个规则，就删除该规则覆盖的元组，并在剩下的元组上重负该过程。</p>
<p><img src="/2018/11/06/数据挖掘概念与技术/数据挖掘概念与技术笔记（5）：分类/03.png" alt></p>
<p>从最一般的规则开始，即从规则前件条件为空的规则开始。该规则是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IF  THEN loan_decision = accept</span><br></pre></td></tr></table></figure>
<p>然后，我们考虑每个可以添加到该规则中可能属性测试。Learn_One_Rule采用一种贪心策略，每次选择最能提高规则质量的属性。目前，我们使用规则的准确率作为质量度量。假设Learn_One_Rule发现属性测试income=high最大限度地提高了当前（空）规则的准确率。把它添加到条件中，当前规则变成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IF income=high THEN loan_decision = accept</span><br></pre></td></tr></table></figure>
<p>下一次迭代时，再次考虑可能的属性测试，结果选中credit_rating=excellent，当前规则增长，变成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IF income=high AND credit_rating=excellent THEN loan_decision = accept</span><br></pre></td></tr></table></figure>
<p>重复该过程，直到结果规则达到可接受的质量水平。另外，贪心策略如果不自觉选到一个很差的属性怎么办，为了减少这种发生的几率，可以选出最好的k个而不是最好的一个属性添加到当前规则。</p>
<h3 id="规则质量的度量"><a href="#规则质量的度量" class="headerlink" title="规则质量的度量"></a>规则质量的度量</h3><p>Learn_One_Rule需要度量规则的质量，之前我们用的是准确率。但准确率本身并非规则质量的可靠估计。这里介绍几个相对有用的几种度量：1）、熵 ；2）、信息增益；3）考虑覆盖率的统计检验</p>
<p>我们想知道给定属性测试到condition中是否导致更好的规则，我们称新的条件为condition’，换言之，我们想知道R’是否比R好。</p>
<p><strong>熵</strong>：D是condition’覆盖元组集合，而$p_i$是D中$C_i$类的概率。熵越小，condition’越好。熵更偏向于覆盖单个类大量元组和少量其他类元组的条件。</p>
<p><strong>信息增益</strong>：FOIL算法是一种学习一阶逻辑规则的顺序覆盖算法，FOIL用下式估计扩展condition’s而获得信息</p>
<script type="math/tex; mode=display">
FOIL\_Gain=pos'\times (log_2\frac{pos'}{pos'+neg'}-log_2\frac{pos}{pos+neg})</script><p>它偏向于具有高准确率并且覆盖许多正元组的规则</p>
<p><strong>似然率统计量</strong></p>
<script type="math/tex; mode=display">
Likelihood\_Ratio=2\sum_{i=1}^mf_ilog(\frac{f_i}{e_i})</script><p>其中，m是类数，$f_i$是这些元组类i的观测概率，$e_i$是规则随机预测时类i的期望频率。似然率有助于识别具有显著覆盖率的规则。</p>
<p>CN2使用熵和似然率检验，而FOIL的信息增益被RIPPER使用。</p>
<h3 id="规则剪枝"><a href="#规则剪枝" class="headerlink" title="规则剪枝"></a>规则剪枝</h3><p>之前说了可以在决策树生成之后对规则剪枝，有很多剪枝策略。这里介绍FOIL使用的一种简单但很有效的方法，给定规则R，有：</p>
<script type="math/tex; mode=display">
FOIL\_Prune(R)=\frac{pos-neg}{pos+neg}</script><p>其中，pos和neg分别为规则R覆盖的正元组数和负元组数。这个值将随着R在剪枝集上的准确率增加而增加。因此，如果R剪枝后版本的FOIL_Prune值较高，则对R剪枝。</p>
<h3 id="如何使用规则分类器来预测元组类标号呢？"><a href="#如何使用规则分类器来预测元组类标号呢？" class="headerlink" title="如何使用规则分类器来预测元组类标号呢？"></a>如何使用规则分类器来预测元组类标号呢？</h3><p>如果正常的话，R1是唯一满足的规则，则该规则激活，返回X的类预测。但如果有多个规则被触发，它们指定了不同的类，这时则需要一种解决冲突的策略来决定激活哪一个规则。我们考察两种，即规模序和规则序：</p>
<p>规模序：方案吧最高优先权赋予给”最苛刻”要求的规则，其中苛刻性用<strong>规则前件的规模度量</strong>（类似于树的深度）</p>
<p>规则序：这<strong>种序可以是基于类的或基于规则的</strong>。<strong>使用基于类的序</strong>，类按”重要性”递减排序，如按普遍性的降序排序；<strong>基于规则的序</strong>，或者根据领域专家的建议，把规则组织成一个优先权列表。</p>
<h2 id="使用统计显著性检验选择模型"><a href="#使用统计显著性检验选择模型" class="headerlink" title="使用统计显著性检验选择模型"></a>使用统计显著性检验选择模型</h2><p>在前面我们已经使用了 一些策略来测算分类器的准确率（例如K折交叉验证）。在这里，我们假设经处理，最后生成了两个分类器，他们的评估度量都不相同，那么我们应该选择哪个分类器呢？</p>
<p>直观的看法当然是选择指标好的那个分类器呀，但是 实际上这种差别很有可能是偶然的。我们为了判定这种差别是否是偶然的，还需要进行<strong>统计显著性检验</strong>。 此外，希望得到平均错误率的置信界，使得我们可以做出这样的陈述：”对于未来样本的95%，观测到的均值将不会偏离正、负两个标准差”或者”一个模型比另外一个模型好，误差幅度为±4±4”</p>
<p>这里用的是显著性检验是t-检验。知乎上给出了相关的解释 ： <a href="https://www.zhihu.com/question/60321751/answer/399954823" target="_blank" rel="noopener">知乎t检验解释</a> <a href="https://www.zhihu.com/question/60321751/answer/399954823" target="_blank" rel="noopener">https://www.zhihu.com/question/60321751/answer/399954823</a></p>
<p> 对于10-折交叉验证（k=10）的第ii轮，设$err(M_1)_i$(或$err(M_2)_i$)是模型$M_1$(或$M_2$)在第i轮的错误率。对$M_1$的错误率取平均值得到$M_1$的平均错误率，记为$\overline {err}(M_1)$，类似的，可以得到$\overline {err}(M_2)$。两个模型差的方差记为$var(M_1-M_2)$。在我们的例子中，k=10，这里的k个样本是从每个模型的10-折交叉验证得到的错误率。逐对比较t-统计量按下式计算： </p>
<script type="math/tex; mode=display">
t=\frac{\overline{err}(M_1)-\overline{err}(M_2)}{\sqrt{var(M_1-M_2)/k}}</script><p> 其中 </p>
<script type="math/tex; mode=display">
var(M_1-M_2)=\frac{1}{k}\sum_{i=1}^k[err(M_1)_i-err(M_2)_i-(\overline{err}(M_1)-\overline{err}(M_2))]^2</script><p>为了计算$M_1$和$M_2$是否显著不同，计算t并选择显著水平sig。实践中，通常使用5%或1%的显著水平。然后，查找t-分布表。通常该表以自由度为行（k个样本具有k-1个自由度，对于我们的例子，自由度为9），显著水平为列。假定要确定$M_1$和$M_2$之间的差对总体的95%（即sig=5%或0.05）是否显著不同。然而，由于t分布是对称的，通常只显示分布上部的百分点，因此，找z=sig/2=0.025的表值，其中z也称为置信界。如果t&gt;z或t&lt;-z，则t落在拒斥域，在分布的尾部。这意味着可以拒绝$M_1$和$M_2$的均值相同的原假设，并断言两个模型之间存在统计的显著的差别。否则，如果不能拒绝原假设，于是断言$M_1$和$M_2$之间的差可能是随机的。</p>
<p>如果有两个检验集而不是单个检验集，则使用t-检验的非逐对版本，其中两个模型的均值之间的方差估计为：</p>
<script type="math/tex; mode=display">
var(M_1-M_2)=\sqrt{\frac{var(M_1)}{k_1}+\frac{var(M_2)}{k_2}}</script><p> 其中，k1和k2分别用于M1和M2的交叉验证样本数（在我们的情况下，10-折交叉验证的轮）。这也称为两个样本的t检验。在查t分布表时，自由度取两个模型的最小自由度。 </p>
]]></content>
      <categories>
        <category>数据挖掘</category>
      </categories>
      <tags>
        <tag>决策树剪枝</tag>
        <tag>IF-THEN规则分类</tag>
        <tag>t检验</tag>
      </tags>
  </entry>
  <entry>
    <title>数据挖掘概念与技术笔记（4）：高级模式挖掘</title>
    <url>/2018/11/05/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89%EF%BC%9A%E9%AB%98%E7%BA%A7%E6%A8%A1%E5%BC%8F%E6%8C%96%E6%8E%98/</url>
    <content><![CDATA[<p>于大量的研究、问题的多方面扩展和广泛的应用研究。频繁模式挖掘已经远远超过了事务数据。<strong>这里，我们介绍其他多种挖掘模式类型的方法，包括多层模式、多维模式、稀有模式、负模式、受约束的频繁模式和巨型模式挖掘</strong>。书上的内容都是比较浅显，更多的是介绍性的东西，可能需要到实际工作上才能理解更深一些。</p>
<h2 id="挖掘多层关联规则"><a href="#挖掘多层关联规则" class="headerlink" title="挖掘多层关联规则"></a>挖掘多层关联规则</h2><p>对于许多应用，在较高的抽象层（抽象的大类，例如电脑，而不是具体某种品牌和型号的电脑）发现的强关联规则，可能有很高的支持度，但可能是常识性知识。我们希望往下钻，在更细节的层次发现新颖的模式。另外一方面，在较低或原始抽象层，可能有太多的零散模式，其中一些只不过是较高层模式的平方特化。</p>
<p>在这种较低层或原始层数据中很难发现有趣的规则模式，例如，“Dell Studio XPS 16 Notebook”和“Logitech VX Nano Cordless Laser Mouse”每个都在很少一部分事务中出现，则可能很难找到涉及它们的强关联规则。少数人同时购买它们，使得该商品集不太可能满足最小支持度。然而，我们预料，在这些商品的泛化抽象之间，如在”Dell Notebook” 和”Cordless Mouse”之间，可望更容易发现强规则。这种在多个抽象层的数据上挖掘产生的规则称为多层关联规则，一般采用如下自顶向下的方法：</p>
<ul>
<li><strong>对于所有层使用一致的支持度（称作一致支持度）</strong>：在每一层挖掘时，使用相同的最小支持度阈值</li>
</ul>
<p>然<strong>而，一致支持度方法有一些困难。较低层次抽象的项不大可能象较高层次抽象的项出现得那么频繁。如果最小支持度阈值设置太高，可能丢掉出现在较低抽象层中有意义的关联规则。如果阈值设置太低，可能会产生出现在较高抽象层的无兴趣的关联规则。这导致了下面的方法</strong>：</p>
<ul>
<li>在较低层使用递减的支持度（称作递减支持度）：每个抽象层有它自己的最小支持度阈值。抽象层越低，对应的阈值越小。</li>
<li>使用基于项或基于分组的最小支持度：例如，用户可以根据产品价格或者根据感兴趣的商品设置最小支持度，对如”价格超过1000美元的照相机”或”平板电脑” 设置特别低的支持度，以便特别关注这类商品的关联模式</li>
</ul>
<p>为了从具有不同支持度阈值的组中挖掘混合项模式，通常在挖掘中取所有组的最低支持度阈值。这将避免过滤掉有价值的模式，该模式包含来自具有最低支持度阈值组的项。同时，每组的最小支持阈值应该保持，以免从每个组产生无趣的项集。</p>
<h3 id="检查多层关联规则冗余性"><a href="#检查多层关联规则冗余性" class="headerlink" title="检查多层关联规则冗余性"></a>检查多层关联规则冗余性</h3><p>挖掘多层关联规则一个严重的副作用是，由于项之间的“祖先”关系，可能产生一些多个抽象层上的冗余的规则，例如：”desktop computer”是”IBM desktop computer”的祖先，有以下规则：</p>
<p><img src="/2018/11/05/数据挖掘概念与技术/数据挖掘概念与技术笔记（4）：高级模式挖掘/01.png" alt></p>
<p>如果后一个具有较小一般性的规则不提供新的信息，应当删除它。让我们看看如何来确定。规则 R1 是规则 R2 的祖先，如果R1能够通过将R2中的项，用它在概念分层（分配比率）中的祖先替换得到，则可以将R2删除。</p>
<p>以上诉规则例子：假定规则(6.9)具有 70%置信度，8%支持度，<strong>并且大约四分之一的”desktop computer”销售是”IBM desktop computer”</strong>。可以期望规则(6.10)具有大约 70%的置信度（由于所有的”IBM desktop computer”样本也是” desktop computer”样本）和 2%（即，8%×1/4）的支持度。也就是说，根据实际销量的分层可以通过R1推到出R2的规则与规则(6.10)相差无几，则R2规则是冗余的。</p>
<h2 id="挖掘多维关联规则"><a href="#挖掘多维关联规则" class="headerlink" title="挖掘多维关联规则"></a>挖掘多维关联规则</h2><p>本节，你将学习挖掘多维关联规则的方法。<strong>多维关联规则是涉及多个属性或谓词的规则</strong>（例如，关于顾客的 buys 和顾客的 age 的规则）。<strong>我们把规则中每个不同的谓词称作维</strong>。例如：</p>
<script type="math/tex; mode=display">
age(X, "20...29") \land buys(X, "laptop")⇒buys(X, "HP\ printer")</script><p>其中，数据库属性可能是分类属性和量化属性（数值），对于量化属性，挖掘多维相关规则的计数可以分为两种基本方法：</p>
<ul>
<li>第一种方法：使用预定义的概念分层对量化属性离散化，例如，income 的概念分层可以用于以区间值，如“0…20K”代替</li>
<li>第二种方法：根据数据的分布，将量化属性离散化或聚类到“箱”</li>
</ul>
<p>正如前面讨论的，我们可以把量化属性离散化为多个区间，而后在关联挖掘时把它们看做是分类属性。然而，这种简单的离散化可能导致产生大量的规则，其中许多规则可能没什么用。这里我们介绍三种方法，帮助克服这一困难，以便发现新颖的关联关系：</p>
<ul>
<li>1、数据立方体方法</li>
<li>2、基于聚类的方法</li>
<li>3、揭示异常行为的统计学方法</li>
</ul>
<h2 id="挖掘稀有模式和负模式"><a href="#挖掘稀有模式和负模式" class="headerlink" title="挖掘稀有模式和负模式"></a>挖掘稀有模式和负模式</h2><p>迄今为止，介绍的都是挖掘频繁模式，然而，有时令人感兴趣的不是频繁模式，而是发现<strong>稀有的模式</strong>（例如钻石表的销售是稀有的），或发现反映项之间的<strong>负相关的模式</strong>（例如发现顾客频繁地购买经典可口可乐或无糖可乐，但不可能一起都买）。</p>
<ul>
<li><strong>稀有模式</strong>：是指其支持度低于（或远低于）用户指定的最小支持度阈值的模式。然而，由于大多数项集的出现频度通常都低于甚至远低于最小支持度阈值，因此实践中允许用户指定稀有模式的其他条件是可取的。</li>
<li><strong>负相关模式</strong>：如果项集X和Y 都是频繁的，但很少一起出现$(sup(X \cup Y) &lt; sup(X) \times sup(Y))$ ，则项集X和Y是负相关的，并且$X\cup Y$ 是负相关模式.如果$(sup(X \cup Y) \ll sup(X) \times sup(Y))$， 则项集X和Y是强负相关的，并且$X\cup Y$是强负相关模式。 </li>
</ul>
<p><strong>然而，上面这个公式度量不是零不变的，只能有效地解决非零事务的数据</strong>。如果数据库存在大量的零事务，则应该使用零不变度量Kulczynski，下面给出具体定义：</p>
<p><strong>零不变负相关模式</strong>：假设项集X和Y都是频繁的，即$sup(X)\geq min_sup$ ，$sup(Y)\geq min_sup$ ， 其中$min_sup$是最小支持度阈值。如果有$(P(X|Y)+P(Y|X))/2&lt;\epsilon$，其中$\epsilon$是负模式阈值，则$X\cup Y$是负相关模式。 </p>
<h2 id="基于约束的频繁模式挖掘"><a href="#基于约束的频繁模式挖掘" class="headerlink" title="基于约束的频繁模式挖掘"></a>基于约束的频繁模式挖掘</h2><p><strong>作为限制搜索空间的约束条件</strong>，这种策略称为基于约束的挖掘。</p>
<p><strong>元规则</strong>就是挖掘用户感兴趣的规则的<strong>语法形式</strong>，例如：</p>
<script type="math/tex; mode=display">
P_1(X,Y)\land P_2(X,W) \Rightarrow buys(X, "officesoftware")</script><p>其中，P1和P2是谓词变量，在挖掘过程中被例示为给定数据库的属性；X是变量，代表顾客；Y和W是分别赋给P1和P2的属性值。</p>
<p>对于规则约束，如何使用规则约束对搜索空间进行剪枝？主要有两种方法：1、对模式空间剪枝；2、数据空间剪枝</p>
<h3 id="对模式空间剪枝"><a href="#对模式空间剪枝" class="headerlink" title="对模式空间剪枝"></a>对模式空间剪枝</h3><p>根据约束如何与模式挖掘过程配合，模式剪枝约束可以分为五类：1）反单调的；2）单调的；3）简洁的；4）可转变的；5）不可转变的（这个不重要）</p>
<ul>
<li>反单调的：规则约束$”sum(I.price)\leq 100”$，如果一个候选项集中的商品价格和大于 100 美元，则该项集可以由搜索空间剪去，因为向该项集中进一步添加项将会使它更贵，因此不可能满足限制。换一句话说，如果一个项集不满足该规则限制，它的任何超集也不可能满足该规则限制。如果一个规则具有这一性质，则称它是反单调的。 </li>
<li>单调的：规则约束$”sum(I.price)\geq 100”$，集合中的单价和大于 100，进一步添加更多的项到此项集将增加价格，并且总是满足该限制。因此，在项集 I 上进一步检查该限制是多余的。换言之，如果一个项集满足这个规则限制，它的所有超集也满足。如果一个规则具有这一性质，则称它是单调的。 </li>
<li>简洁：对于这类约束，我们可以枚举并且仅仅列出所有确保满足该限制的集合。因为有一个精确“公式”，产生满足简洁限制的所有集合，在挖掘过程中不必迭代地检验规则限制 </li>
<li>可转变的约束：有些限制不属于以上三类。然而，如果项集中的项以特定的次序排列，则对于频繁项集挖掘过程，限制可能成为单调的或反单调的。例如，限制“avg(I.price)”既不是反单调的，也不是单调的。然而，如果事务中的项以单价的递增序添加到项集中，则该限制就成了反单调的。类似的，如果是递减顺序添加则是单调的。 </li>
</ul>
<h3 id="对数据空间剪枝"><a href="#对数据空间剪枝" class="headerlink" title="对数据空间剪枝"></a>对数据空间剪枝</h3><p>第二种对基于约束的频繁模式挖掘的搜索空间进行剪枝的方法是对数据空间剪枝。这种策略是剪掉对其后挖掘过程中可满足模式的产生没有贡献的数据片段。例如，对于约束是数据简洁的，如果一个挖掘查询要求被挖掘模式必须包含数码相机，则可以在挖掘过程开始减剪掉所有不包含数码相机的事务。对于约束的反单调的，基于当前模式，如果一个数据项不满足数据反单调约束，则可以剪掉它，因为在剩下的挖掘过程中，它不能对当前模式的超模式的产生有任何贡献。</p>
<h2 id="巨型模式"><a href="#巨型模式" class="headerlink" title="巨型模式"></a>巨型模式</h2><p>对于数据库有数百或者数千维的数据，用已介绍方法来挖掘高维数据是非常低效的，一种是使用垂直格式数据，之前已经介绍过了。另外一种新的方向是用模型融合，用于巨型模式，即非常长的模式(例如蛋白质的DNA长序列)。这种方法在模式搜索空间中跳跃，得到巨型频繁模式完全集的一个很好的近似解。</p>
<p>对于Apriori和FP-growth算法，会不可避免产生大量中型模式，使得它不可能达到巨型模式。因此提出了模式融合，它融合了少量较短的频繁模式，形成巨型模式候选。</p>
<p>书上提到了<strong>核模式</strong>的概念，这里没怎么看懂，觉得是<strong>核模式代表了一定的鲁棒性</strong>。但是书上也直接给出了推论，巨型模式比较短模式有更多的核模式，更鲁棒。也就是说，如果从该模式中去掉少量项，则结果模式会有类似的支集。巨型模式较低层的核模式叫做<strong>核后代</strong>。<strong>所以基于这个特性，模式融合可以融合少量较短的频繁模式</strong>。这也是它为什么被称为模式融合的原因 ，因此巨型模式可以通过合并其核模式的真子集产生，<strong>例如， abcef可以通过它的两个核模式ab和cef产生。而不需要用单个项增量地扩展，而是与池中多个模式进行凝聚，这样能够迅速地到达巨型模式</strong>。</p>
<p>模型融合包括以下两个阶段：</p>
<ul>
<li><p>1、池初始化</p>
<p>模式融合假定有一个短频繁模式的初始池。这是一个短长度的频繁模式挖掘集。这个初始值可以用任意已有的有效挖掘算法挖掘。</p>
</li>
<li><p>2、迭代的模式融合</p>
<p>用户首先指定一个参数K的值（K代表挖掘模式的最大个数），然后从当前池中随机地选取K个种子，对于每个种子，我们找出直径为ττ的球内的所有模式。然后，每个”球“中的所有模式融合在一起，形成一个超模式集，这些超模式形成新的池，然后再从这个新的池子中随机地找到K个种子，然后重复上面的工作，一直迭代，直到不能融合为止</p>
</li>
</ul>
<p>因此，该方法可以绕过中型模式，通往巨型模式。</p>
<p>7.5/7.6的内容暂时不是特别重要，用到再补。</p>
]]></content>
      <categories>
        <category>数据挖掘</category>
      </categories>
      <tags>
        <tag>多层挖掘模式</tag>
        <tag>多维模式挖掘</tag>
        <tag>稀有模式和负模式挖掘</tag>
        <tag>基于约束模式挖掘</tag>
        <tag>巨型模式挖掘</tag>
      </tags>
  </entry>
  <entry>
    <title>数据挖掘概念与技术笔记（3）：挖掘频繁模式、关联和相关性</title>
    <url>/2018/11/02/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89%EF%BC%9A%E6%8C%96%E6%8E%98%E9%A2%91%E7%B9%81%E6%A8%A1%E5%BC%8F%E3%80%81%E5%85%B3%E8%81%94%E5%92%8C%E7%9B%B8%E5%85%B3%E6%80%A7/</url>
    <content><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="关联规则"><a href="#关联规则" class="headerlink" title="关联规则"></a>关联规则</h3><p>关联规则可以用以下表示：</p>
<script type="math/tex; mode=display">
computer\Rightarrow antivirus\_software[support=2\%;confidence=60\%]</script><p>规则的支持度和置信度是两个规则兴趣度度量，它们分别反映发现规则的有用性和确定性。上诉关联规则<br>的<strong>支持度（表示同时包含A和B的事务占所有事物的比例）为2%，意味所分析的事务的2%显示 计算机和杀毒软件被同时购买。置信度（表示包含A的事务同时也包含B的比例） 60%意味购买计算机的顾客 60%的几率也购买财务管理软件</strong>。一般如果关联规则<strong>满足最小支持度阈值和最小置信度阈值</strong>，则认为关联规则是有趣的，是值得关注的现象。</p>
<h3 id="频繁项集、闭项集、极大项集"><a href="#频繁项集、闭项集、极大项集" class="headerlink" title="频繁项集、闭项集、极大项集"></a>频繁项集、闭项集、极大项集</h3><p>设任务相关的数据 D 是数据库事务的集合，每一个事务有一个标识符，称作 TID。设A、B是两个项集，有：</p>
<script type="math/tex; mode=display">
support(A\Rightarrow B)=P(A\cup B) \\ confidence(A\Rightarrow B)=P(B\vert A)</script><p>同时满足最小支持度阈值(min_sup)和最小置信度阈值(min_conf)的规则称作强规则</p>
<p>项的集合称为项集。包含 k 个项的项集称为 k-项集。项集的出现频率是包含项集的事务数，简称为项集的频率、支持计数或计数。如果项集满足最小支持度，则称它为频繁项集。频繁 k -项集的集合通常记作 LkLk。一般而言，关联规则的挖掘是一个两步的过程：</p>
<p>1、<strong>找出所有频繁项集</strong>：根据定义，这些项集出现的频繁性至少和预定义的最小支持计数一样。</p>
<p>2、<strong>由频繁项集产生强关联规则</strong>：根据定义，这些规则必须满足最小支持度和最小置信度。</p>
<p>从大型数据集中挖掘项集的主要挑战是，这种挖掘常常产生大量满足最小支持度（min_sup）阈值的项集，当min_sup设置的很低的时候尤其如此，这是因为如果一个项集的频繁的（项集每个项计数都满足最小支持度），则它的每个子集都是频繁的。因此，得到的频繁项集的总个数太大了，为了更好的计算和存储，引入了闭频繁项集和极大频繁项集的概念。</p>
<ul>
<li><strong>闭频繁项集</strong>：指这个项集X既是频繁项集又是闭项集，闭项集是指不存在真超项集Y和此项集X具有相同的支持度计数</li>
<li><strong>极大频繁项集</strong>：指这个项集X既是频繁项集又是极大项集，极大项集是指不存在频繁的真超项集Y，它已经是最大规模频繁项集了。</li>
</ul>
<p>一个举例：(AB项集为非闭是因为和ABC项集具有相同的支持度计数，ABC为非极大是存在频繁项集ABCD)</p>
<p><img src="/2018/11/02/数据挖掘概念与技术/数据挖掘概念与技术笔记（3）：挖掘频繁模式、关联和相关性/01.png" alt></p>
<h2 id="挖掘频繁项集的方法"><a href="#挖掘频繁项集的方法" class="headerlink" title="挖掘频繁项集的方法"></a>挖掘频繁项集的方法</h2><h3 id="Apriori-算法"><a href="#Apriori-算法" class="headerlink" title="Apriori 算法"></a>Apriori 算法</h3><p>算法是一种最有影响的挖掘布尔关联规则频繁项集的算法。Apriori 使用一种称作逐层搜索的迭代方法，<strong>k项集用于探索(k+1)项集</strong>。首先，找出频繁 1-项集的集合。该集合记作 L1。L1用于找频繁 2-项集的集合 L2，而L2用于找L3，如此下去，直到不能找到频繁 k-项集.</p>
<p>所以关键在于须看看如何用频繁项集$L<em>k$找到频繁项集$L</em>{k+1}$.具体是由以下两步组成：</p>
<p>1、连接步：为找 $L<em>k$，通过$L</em>{k - 1}$与自己连接产生候选 k-项集的集合。假定事务或项集中的项按字典次序排序，如果$L_{k - 1}$它们前(k-2)个项相同的，则可以执行连接操作。</p>
<p>2、剪枝步：连接操作得到$C<em>k$，$C_k$是 $L_k$的超集，可以通过扫描数据库计算支持度从而在$C_k$里确定$L_k$。然而，$C_k$可能很大，这样所涉及的计算量就很大。为压缩 $C_k$，可以用以下办法使用 Apriori 先验性质：任何非频繁的(k-1)项集都不是可能是频繁 k项集的子集(频繁项集的子集一定是频繁的)。因此，如果一个候选 k项集的(k-1)子集不在 $L\</em>{k - 1}$中 ($L_{k - 1}$包含所有频繁的k-1项集，若某个k-1项集不在里面则是不频繁的)，则该候选也不可能是频繁的，从而可以由$C_k$中删除。</p>
<p> 一个例子: </p>
<p><img src="/2018/11/02/数据挖掘概念与技术/数据挖掘概念与技术笔记（3）：挖掘频繁模式、关联和相关性/02.png" alt></p>
<p> aproori算法过程：假设最小支持度计数为2，即min_sup=2 </p>
<p><img src="/2018/11/02/数据挖掘概念与技术/数据挖掘概念与技术笔记（3）：挖掘频繁模式、关联和相关性/03.png" alt></p>
<p> 其中，$L_2$连接步寻找$L_3$，要将$L_2$的前（3-2）个相同的项连接起来，得到{I1,I2,I3}, {I1,I2,I5}, {I1,I3,I5}, {I2,I3,I4}, {I2,I3,I5}, {I2,I4,I5}，然后执行剪枝步，扫描整个数据库，可以得到剩下的{1,I2,I3}, {I1,I2,I5}。或者使用Apriori 先验性质：举{I2,I4,I5}项集为例，{I2,I4,I5}的2项子集为{I2,I4}, {I2,I5} 和 {I4,I5}。但{I4, I5}不是$L_2$的元素，因此不是频繁的。同理L3L3连接步得到{I1, I2, I3, I5}的其中一个3项集{I2,I3,I5}不是$L_3$的元素，因此{I1, I2, I3, I5}也不是频繁的。 </p>
<h3 id="由频繁项集产生关联规则"><a href="#由频繁项集产生关联规则" class="headerlink" title="由频繁项集产生关联规则"></a>由频繁项集产生关联规则</h3><p>一旦由数据库 D 中的事务找出频繁项集，由它们产生强关联规则是直接了当的（强关联规则满足最小支持度和最小置信度）。对于置信度，可以用下式，其中条件概率用项集支持度计数表示</p>
<script type="math/tex; mode=display">
confidence(A\Rightarrow B)=P(A\vert B)=\frac{support\_count(A\cup B)}{support\_count(A)}</script><p><img src="/2018/11/02/数据挖掘概念与技术/数据挖掘概念与技术笔记（3）：挖掘频繁模式、关联和相关性/04.png" alt></p>
<h3 id="FP-growth算法"><a href="#FP-growth算法" class="headerlink" title="FP-growth算法"></a>FP-growth算法</h3><p>正如我们已经看到的，在许多情况下，Apriori 的候选产生-检查方法大幅度压缩了候选项集的大小，并导致很好的性能。然而，它可能受两种超高开销的影响：</p>
<ul>
<li>它可能需要产生大量候选项集。例如，如果有 10^4个频繁 1-项集，则 Apriori 算法需要产生多达 10^7个候选 2-项集</li>
<li>它可能需要重复地扫描数据库</li>
</ul>
<p>“ 可以设计一种方法，挖掘全部频繁项集，而不产生候选吗？”一种有趣的方法称作<strong>频繁模式增长</strong>，或简单地，FP-增长，它采取如下分治策略：<strong>将提供频繁项集的数据库压缩到一棵频繁模式树（或 FP-树）</strong>，但仍保留项集关联信息；然后，将这种压缩后的数据库分成一组条件数据库（一种特殊类型的投影数据库），每个关联一个频繁项，并分别挖掘每个数据库。</p>
<p>FP-growth算法的优点是采用了高级的数据结构。那么这种高级的数据结构是什么呢？实际上就是FP树。 FP树是一种输入数据的压缩表示。他通过把事务映射到FP树上来构造一条路径。这样如果不同事务之间的重叠路径越多，那么就有理由认为他们是频繁项集。由于不同的事务可能会有若干个相同的项，因此它们的路径相互重叠越多，则使用FP树结构获得的压缩效果越好。</p>
<p><strong>FP-growth算法的基本过程1）构建FP数。 2）从FP树中挖掘频繁项集</strong></p>
<p>依然是用之前那个例子：</p>
<p><img src="/2018/11/02/数据挖掘概念与技术/数据挖掘概念与技术笔记（3）：挖掘频繁模式、关联和相关性/02.png" alt></p>
<p>数据库的第一次扫描与 Apriori 相同，它<strong>导出频繁项（1-项集）的集合，并得到它们的支持度计数（频繁性）</strong>。设最小支持度计数为 2。频繁项的集合<strong>按支持度计数的递减序排序。结果集或表记作 L</strong>。这样，<strong>我们有 L = [I2:7, I1:6, I3:6, I4:2, I5:2]。</strong></p>
<p>然后，FP-树构造如下：首先，创建树的根结点，用“null”标记。二次扫描数据库 D。<strong>每个事务中的项按 L 中的次序处理（即，根据递减支持度计数排序）</strong>并<strong>对每个事务创建一个分枝</strong>。例如，第一个事务“T100: I1, I2, I5”按 L 的次序包含三个项{ I2, I1, I5}，导致构造树的第一个分枝[(I2:1), (I1:1), (I5:1)]。该分枝具有三个结点，其中，I2 作为根的子女链接，I1 链接到 I2，I5 链接到 I1。第二个事务 T200 按 L 的次序包含项 I2 和 I4，它导致一个分枝，其中，I2 链接到根，I4 链接到 I2。然而，该分枝应当与 T100 已存在的路径共享前缀 I2。这样，我们将结点 I2 的计数增加 1，并创建一个新结点(I4:1)，它作为(I2:2)的子女链接。一般地，当为一个事务考虑增加分枝时，沿共同前缀上的每个结点的计数增加 1，为随在前缀之后的项创建结点并链接。</p>
<p>按TID顺序T100到T900，不断创建节点和连接，并更新节点的支持度计数，知道完成FP树的构建</p>
<p><img src="/2018/11/02/数据挖掘概念与技术/数据挖掘概念与技术笔记（3）：挖掘频繁模式、关联和相关性/05.png" alt></p>
<p>构建好FP树后，开始利用FP树挖掘频繁项集。FP-树挖掘处理如下。<strong>由长度为 1 的频繁模式（初始后缀模式）开始，构造它的条件模式基</strong>（一个“子数据库”， 由 FP-树中与后缀模式一起出现的前缀路径集组成）<strong>。然后，构造它的（条件）FP-树，并递归地在该树上进行挖掘。</strong>模式增长通过后缀模式与由条件 FP-树产生的频繁模式连接实现。</p>
<p>FP-树的挖掘总结在表 6.1 中，细节如下。<strong>让我们首先考虑 I5，它是 L 中的最后一个项，而不是第一个</strong>。其原因随着我们解释 FP-树挖掘过程就会清楚。I5 出现在上图 的 FP-树的两个分枝。（I5 的出现容易通过沿它的结点链到。）<strong>它的两个对应前缀路径是[(I2, I1:1)&gt;和&lt;(I2, I1, I3:1)]</strong>，它们形成I5 的<strong>条件模式基</strong>。<strong>然后以及条件模式基和最小支持度计数构建条件FP树</strong>，它的条件 FP-树只包含单个路径[(I2:2, I1:2)] (括号里面为路径形式，给出构建的FP树种每个节点的支持度计数)；不包含 I3，因为它的支持度计数为 1，小于最小支持度计数。<strong>最后，I5与该路径产生频繁模式的所有组合（I5与路径的所有组合一定是要包含I5的）</strong>。组合的支持度计数是根据与结合的节点的支持数决定的。</p>
<p><img src="/2018/11/02/数据挖掘概念与技术/数据挖掘概念与技术笔记（3）：挖掘频繁模式、关联和相关性/06.png" alt></p>
<p> 类似的，对于 I4，它的两个前缀形成条件模式基{(I2 I1:1), (I2:1)}，产生一个单结点的条件 FP-树&lt; I2:2&gt;，并导出一个频繁模式 I2 I4:2。与以上分析类似，I3 的条件模式基是{(I2 I1:2), (I2:2), (I1:2)}。它的条件 FP-树有两个分枝&lt; I2:4, I1:2&gt;和&lt; I1:2&gt;，如图 6.9 所示，它产生模式集：{I2 I3:4, I1 I3:2, I2 I1 I3:2}. </p>
<p><img src="/2018/11/02/数据挖掘概念与技术/数据挖掘概念与技术笔记（3）：挖掘频繁模式、关联和相关性/07.png" alt></p>
<p>FP-增长方法将发现长频繁模式的问题转换成递归地发现一些短模式，然后与后缀连接。它使用最不<br>频繁的项作后缀，提供了好的选择性。该方法大大降低了搜索开销。</p>
<h3 id="使用垂直数据格式挖掘频繁项集"><a href="#使用垂直数据格式挖掘频繁项集" class="headerlink" title="使用垂直数据格式挖掘频繁项集"></a>使用垂直数据格式挖掘频繁项集</h3><p>Apriori算法和FP-growth算法都是从TID-项集格式（即{TID : itemset }）的事务集中挖掘频繁模式，其中TID是事务标识符， 而itemset是事务TID中购买的商品。这种数据格式称为<strong>水平数据格式</strong>。或者，数据也可以用项-TID集格式（即{item ： TID_set}）表示，这种格式称为<strong>垂直数据格式</strong>。</p>
<p><img src="/2018/11/02/数据挖掘概念与技术/数据挖掘概念与技术笔记（3）：挖掘频繁模式、关联和相关性/08.png" alt></p>
<p> 通过取每对频繁项的TID集的交，可以在该数据集上进行挖掘。项集的支持度计数为TID-集的元素个数。 </p>
<p><img src="/2018/11/02/数据挖掘概念与技术/数据挖掘概念与技术笔记（3）：挖掘频繁模式、关联和相关性/09.png" alt></p>
<h2 id="强规则不一定是有趣的"><a href="#强规则不一定是有趣的" class="headerlink" title="强规则不一定是有趣的"></a>强规则不一定是有趣的</h2><p>大部分关联规则挖掘算法使用支持度-置信度框架。尽管使用最小支持度和置信度阈值排除了一些无兴趣的规则的探<br>查，仍然会产生一些对用户来说不感兴趣的规则。<strong>当A与B是负相关时，规则 A ⇒ B 的置信度有一定的欺骗性</strong>。因此，支持度和置信度度量不足以过滤掉无趣的关联规则，为<strong>了处理这个问题，可以使用相关性度量来扩充关联规则的支持度-置信度框架</strong>。这导致如下形式的相关规则</p>
<script type="math/tex; mode=display">
A\Rightarrow B[support , confidence, correlation]</script><h3 id="提升度（lift）"><a href="#提升度（lift）" class="headerlink" title="提升度（lift）"></a>提升度（lift）</h3><p>提升度（lift）是一种简单的相关性度量，A和B出现之间的<strong>提升度</strong>可以通过计算下式得到</p>
<script type="math/tex; mode=display">
lift(A,B)=\frac{P(A\cup B)}{P(A)P(B)}</script><p>如果lift(A,B)值小于1，则A的出现和B的出现是负相关的，意味一个出现可能导致另一个不出现。如果值大于1，则A和B是正相关的，意味着每一个的出现都蕴含另一个的出现。如果结果值等于1，则A和B是独立的，它们之间没有相关性。</p>
<h3 id="使用提升度的相关分析"><a href="#使用提升度的相关分析" class="headerlink" title="使用提升度的相关分析"></a>使用提升度的相关分析</h3><p>如果我们要分析如下的关联规则：</p>
<script type="math/tex; mode=display">
buys(X, "computer games")\Rightarrow buys(X, "videos") \\ [support = 40\%, confidence=66\%]</script><p> 且有下面的事务相依表： </p>
<p><img src="/2018/11/02/数据挖掘概念与技术/数据挖掘概念与技术笔记（3）：挖掘频繁模式、关联和相关性/10.png" alt></p>
<p><img src="/2018/11/02/数据挖掘概念与技术/数据挖掘概念与技术笔记（3）：挖掘频繁模式、关联和相关性/11.png" alt></p>
<h3 id="使用卡方检测的相关分析"><a href="#使用卡方检测的相关分析" class="headerlink" title="使用卡方检测的相关分析"></a>使用卡方检测的相关分析</h3><p><img src="/2018/11/02/数据挖掘概念与技术/数据挖掘概念与技术笔记（3）：挖掘频繁模式、关联和相关性/12.png" alt></p>
<p><img src="/2018/11/02/数据挖掘概念与技术/数据挖掘概念与技术笔记（3）：挖掘频繁模式、关联和相关性/13.png" alt></p>
<h3 id="模式评估度量比较"><a href="#模式评估度量比较" class="headerlink" title="模式评估度量比较"></a>模式评估度量比较</h3><p>最近，另外一些模式评估度量引起了关注，本书介绍了四种这样的度量：全置信度、最大置信度、Kulczynsji和余弦。然后，比较它们的有效性，并且与提升度和卡方检测$X^2$进行比较。</p>
<p>全置信度：</p>
<script type="math/tex; mode=display">
all\_conf(A,B)=\frac{sup(A\cup B)}{max\{sup(A), sup(B)\}}=min\{P(A|B),P(B|A)\}</script><p> 最大置信度： </p>
<script type="math/tex; mode=display">
max\_conf(A,B)=max\{P(A|B),P(B|A)\}</script><p> Kulczynski: </p>
<script type="math/tex; mode=display">
Kulc(A,B)=\frac{1}{2}(P(A|B)+P(B|A))</script><p> 余弦： </p>
<script type="math/tex; mode=display">
cosine(A,B)=\frac{sup(A\cup B)}{\sqrt{sup(A)\times sup(B)}}=\sqrt{P(A|B)\times P(B|A)}</script><p> 对于评估所发现的模式联系，哪一个度量最好呢？<strong>对于零事务提升度和卡方检测效果都不好</strong>，<strong>零事务是指不包含任何考察项集的事务。典型地，零事务的个数可能远远大于个体的购买的个数，因为许多人都即不买牛奶也不买咖啡。另一方面，上面的新的四种度量都能解决零事务，因为他们的定义都消除了零事务的影响。</strong>一般的，推荐Kluc优先。 </p>
]]></content>
      <categories>
        <category>数据挖掘</category>
      </categories>
      <tags>
        <tag>频繁模式</tag>
        <tag>Apriori算法</tag>
        <tag>FP-Growth算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据挖掘概念与技术笔记（2）：数据预处理</title>
    <url>/2018/11/02/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h2 id="冗余和相关分析"><a href="#冗余和相关分析" class="headerlink" title="冗余和相关分析"></a>冗余和相关分析</h2><h3 id="分类属性的-X-2-卡方检测"><a href="#分类属性的-X-2-卡方检测" class="headerlink" title="分类属性的$X^2$卡方检测"></a>分类属性的$X^2$卡方检测</h3><p>对于分类属性，两个属性A和B的相关联系可以通过X2X2(卡方)检测。</p>
<p>以下为一个典型的<strong>四格卡方检验</strong>，我们想知道喝牛奶对感冒发病率有没有影响：</p>
<p><img src="/2018/11/02/数据挖掘概念与技术/数据挖掘概念与技术笔记（2）：数据预处理/01.png" alt></p>
<p>通过简单的统计我们得出喝牛奶组和不喝牛奶组的感冒率为30.94%和25.00%，两者的差别可能是抽样误差导致，也有可能是牛奶对感冒率真的有影响。</p>
<p>得到的感冒率可能是抽样误差导致，也有可能是牛奶对感冒率真的有影响。</p>
<p>为了确定真实原因,我们<strong>先假设喝牛奶对感冒发病率是没有影响的</strong>,即喝牛奶喝感冒时独立无关的,所以我们可以得出感冒的<strong>实际发病率</strong>是(43 + 28)/(43 + 28 + 96 + 84)= 28.29%</p>
<p>所以,<strong>理论的四格表</strong>应该如下表所示:</p>
<p><img src="/2018/11/02/数据挖掘概念与技术/数据挖掘概念与技术笔记（2）：数据预处理/02.png" alt></p>
<p> 即下表: </p>
<p><img src="/2018/11/02/数据挖掘概念与技术/数据挖掘概念与技术笔记（2）：数据预处理/03.png" alt></p>
<p><strong>如果喝牛奶喝感冒真的是独立无关的,那么四格表里的理论值和实际值差别应该会很小。</strong></p>
<p>$X^2$卡方检测值可以用下式计算：</p>
<script type="math/tex; mode=display">
x^2=\sum\frac{(A-T)^2}{T}</script><p>其中，A为实际值，T为理论值。$x^2$值用于衡量实际值与理论值的差异程度和相对大小，值越小属性越独立无关，值越大，属性是统计相关的。</p>
<p>根据上面的卡方检验公式，有</p>
<script type="math/tex; mode=display">
x^2=\frac{(43-39.3231)^2}{39.3231}+\frac{(28-31.6848)^2}{31.6848}+\frac{(96-99.6769)^2}{99.6769}+\frac{(84-80.3152)^2}{80.3152}=1.077</script><p><strong>卡方分布的临界值</strong>:</p>
<p>上一步我们得到了卡方的值,但是如何通过卡方的值来判断喝牛奶和感冒是否真的是独立无关的?也就是说,怎么知道无关性假设是否可靠?</p>
<p><img src="/2018/11/02/数据挖掘概念与技术/数据挖掘概念与技术笔记（2）：数据预处理/04.png" alt></p>
<p><strong>答案是,通过查询卡方分布的临界值表</strong>。这里需要用到一个<strong>自由度的概念</strong>,自由度等于V =(行数- 1)*(列数- 1),对四格表,自由V = 1度。对V = 1,喝牛奶和感概冒95%率不相关的卡方分布的临界概率是:3.84。即如果卡方大于3.84,则认为喝牛奶和感冒有95%的概率相关，有统计联系。</p>
<p><strong>显然1.077 &lt; 3.84,没有达到卡方分布的临界值,所以喝牛奶和感冒独立不相关的假设成立,说明两者之间没说明联系</strong>。</p>
<h3 id="数值类型的皮尔逊相关系数"><a href="#数值类型的皮尔逊相关系数" class="headerlink" title="数值类型的皮尔逊相关系数"></a>数值类型的皮尔逊相关系数</h3><script type="math/tex; mode=display">
r_{A,B}=\frac{\sum_{i=1}^n(a_i-\bar A)(b_i-\bar B)}{n\sigma_A \sigma_B}</script><p> 其中，$\bar A$和$\bar B$为均值，和$\sigma_A$ 和$\sigma_B$为标准差。 </p>
<h3 id="数值类型的协方差"><a href="#数值类型的协方差" class="headerlink" title="数值类型的协方差"></a>数值类型的协方差</h3><p>在概率学和统计学中，协方差和方差是两个类型的度量，<strong>评估两个属性如何一起变化。</strong></p>
<script type="math/tex; mode=display">
Cov(A,B)=\frac{\sum_{i=1}^n(a_i-\bar A)(b_i-\bar B)}{n}=E(A\cdot B)-\bar A\bar B</script><p> 其中，$E(A\cdot B)$表示期望 ，用均值表示。</p>
<p> <strong>协方差值为0表示具有独立性，协方差越大代表两个属性会一起变化。</strong></p>
<h3 id="小波变换"><a href="#小波变换" class="headerlink" title="小波变换"></a>小波变换</h3><p>知乎这里讲的很清楚了，主要用于选出有效的特征属性。</p>
<p><a href="https://zhuanlan.zhihu.com/p/22450818" target="_blank" rel="noopener">戳我</a></p>
]]></content>
      <categories>
        <category>数据挖掘</category>
      </categories>
      <tags>
        <tag>卡方检测</tag>
        <tag>皮尔逊相关系数</tag>
        <tag>小波变换</tag>
      </tags>
  </entry>
  <entry>
    <title>数据挖掘概念与技术笔记（1）：数据认识</title>
    <url>/2018/11/01/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E8%AE%A4%E8%AF%86/</url>
    <content><![CDATA[<h2 id="数据的基本统计描述"><a href="#数据的基本统计描述" class="headerlink" title="数据的基本统计描述"></a>数据的基本统计描述</h2><h3 id="中心趋势度量：均值、中位数和众数"><a href="#中心趋势度量：均值、中位数和众数" class="headerlink" title="中心趋势度量：均值、中位数和众数"></a>中心趋势度量：均值、中位数和众数</h3><p>尽管均值是描述数据集的最有用的单个量，但是它并非总是度量数据中心的最佳方法。主要问题是，均值对极端值（例如、离群点）很敏感。为了解决这个问题，我们可以采用结尾均值。结尾均值是丢弃高低极端值后的均值。</p>
<p>对于倾斜（非对称）数据，数据中心的更好的度量是中位数。</p>
<h3 id="度量数据散布：极差、四分位数、方差、标准差和四分位数极差"><a href="#度量数据散布：极差、四分位数、方差、标准差和四分位数极差" class="headerlink" title="度量数据散布：极差、四分位数、方差、标准差和四分位数极差"></a>度量数据散布：极差、四分位数、方差、标准差和四分位数极差</h3><p>极差：集合的最大值减去最小值</p>
<p>四分位数第1个四分位数记作$Q_1$，是第25个百分位数，第2个为50%，第3个四分位数记作$Q_3$，第75个百分位数。其中，第1个和第3个百分位数之间的距离是散布的一种简单度量，它给出被数据的中间一半所覆盖的范围。该距离称为四分位数极差（IQR），定义为</p>
<script type="math/tex; mode=display">
IQR=Q_3-Q_1</script><p>识别离群点的通常规则是，挑选落在第3个四分位数之上或第1个四分位数之下至少1.5×IQR处的值。</p>
<p>盒图是一种流行的分布的直观表示，盒图表示了五数概括：</p>
<ul>
<li>盒的端点一般在Q1和Q3四分位数上，使得盒的长度是四分位数极差</li>
<li>中位数用盒内的线标记</li>
<li>盒外的两条线（称为胡须）延伸到集合的最大和最小值</li>
</ul>
<p>方差和标准差：标准差是方差的平方根，低的标准差表示数据观测趋向于非常靠近均值。</p>
<h3 id="分位数图"><a href="#分位数图" class="headerlink" title="分位数图"></a>分位数图</h3><p><strong>分位数图</strong>是一种观察数据分布的简单有效的方法。首先，它显示所有的数据（允许用户评估总的情况和不寻常的出现），并将数据由小到大排序，每个观测值$x_(i)$  与一个百分数 $f_i$ 配对。下图表示了单价数据的分位数图。</p>
<p><img src="/2018/11/01/数据挖掘概念与技术/数据挖掘概念与技术笔记（1）：数据认识/01.png" alt></p>
<p><strong>分位数-分位数图</strong>，或 <strong>q-q 图</strong>对着另一个的对应分位数，绘制一个单变量分布的分位数。它是一<br>种强有力的直观表示工具，使得用户可以观察从一个分布到另一个是否有移位。</p>
<p>假定对于变量单价，我们有两个观测集，取自两个不同的分店。每组数据都已按递增序排序。下图给出两个部门的QQ图（分位数-分位数图） </p>
<p><img src="/2018/11/01/数据挖掘概念与技术/数据挖掘概念与技术笔记（1）：数据认识/02.png" alt></p>
<h2 id="度量数据的相似性和相异性"><a href="#度量数据的相似性和相异性" class="headerlink" title="度量数据的相似性和相异性"></a>度量数据的相似性和相异性</h2><p>一般的，<strong>如果两个对象i和j不相似</strong>，则他们的相似性度量将<strong>返回0</strong>。<strong>反之两个对象相似则返回1</strong>。</p>
<h3 id="数据矩阵和相异性矩阵"><a href="#数据矩阵和相异性矩阵" class="headerlink" title="数据矩阵和相异性矩阵"></a>数据矩阵和相异性矩阵</h3><p>数据矩阵称对象-属性结构，形式为n×p（n个对象p个属性）矩阵存放n个数据对象，每行对应于一个对象；相异性矩阵存放n个对象两两之间的相似度量，是个n×n对称矩阵(类似皮尔逊相关系数)</p>
<h3 id="分类属性的邻近性度量"><a href="#分类属性的邻近性度量" class="headerlink" title="分类属性的邻近性度量"></a>分类属性的邻近性度量</h3><p>如何计算分类属性所刻画对象之间的相异性？两个对象i和j之间的相异性可以根据不匹配率来计算：</p>
<script type="math/tex; mode=display">
d(i,j)=\frac{p-m}{p}</script><p> 其中，m是匹配的数目（即i和j取值相同状态的属性数），而p是刻画对象的属性总数。<strong>假设我们有表2.2中的4个对象的数据样本</strong>，每个对象3个属性，<strong>其中只有一个分类属性test-1</strong>，在上面的式子中，当对象i和j属性匹配时， $d(i,j)=0$ 当对象不匹配时，  $d(i,j)=1$.</p>
<p><img src="/2018/11/01/数据挖掘概念与技术/数据挖掘概念与技术笔记（1）：数据认识/03.png" alt></p>
<p><img src="/2018/11/01/数据挖掘概念与技术/数据挖掘概念与技术笔记（1）：数据认识/04.png" alt></p>
<h3 id="布尔属性的邻近性度量"><a href="#布尔属性的邻近性度量" class="headerlink" title="布尔属性的邻近性度量"></a>布尔属性的邻近性度量</h3><h3 id><a href="#" class="headerlink" title></a><img src="/2018/11/01/数据挖掘概念与技术/数据挖掘概念与技术笔记（1）：数据认识/05.png" alt></h3><p><strong>上面表示两个对象的取0或1的属性数目(q,s,r,t)</strong></p>
<p>对于<strong>对称的二元属性（布尔属性），是指每个属性都同样重要。基于对称二元属性的相异性称作对称的二元相异性</strong>。如果对象i和j都用对称的二元属性刻画，则i和j的<strong>相异性</strong>为：</p>
<script type="math/tex; mode=display">
d(i,j)=\frac{r+s}{q+r+s+t}</script><p> 互补的,相似性可用下式计算： </p>
<script type="math/tex; mode=display">
sim(i，j)=1-d(i,j)</script><p> 一个例子：下面gender为对称属性，其余为非对称属性（共6个），<strong>这里我们只考虑患者(对象)非对称属性</strong>，值Y(yes)和P(positive)都设置为1，N(no,negative)为0. <strong>采用上面非对称的二元相异性计算公式</strong>。 </p>
<p><img src="/2018/11/01/数据挖掘概念与技术/数据挖掘概念与技术笔记（1）：数据认识/06.png" alt></p>
<p><img src="/2018/11/01/数据挖掘概念与技术/数据挖掘概念与技术笔记（1）：数据认识/07.png" alt></p>
<h3 id="数值属性的相异性：闵可夫斯基距离"><a href="#数值属性的相异性：闵可夫斯基距离" class="headerlink" title="数值属性的相异性：闵可夫斯基距离"></a>数值属性的相异性：闵可夫斯基距离</h3><script type="math/tex; mode=display">
d(i,j)=\sqrt[p]{|x_{i1}-x_{j1}|^p+|x_{i2}-x_{j2}|^p+...+|x_{i1}-x_{j1}|^p}</script><h3 id="偏序属性的邻近性度量"><a href="#偏序属性的邻近性度量" class="headerlink" title="偏序属性的邻近性度量"></a>偏序属性的邻近性度量</h3><p>偏序属性的值之间具有意义的序或排位，例如size属性的序列值[small, medium, large]. 计算这种偏序属性首先计算状态在序数属性上的排名，并映射到[0, 1]数值上。然后把转换后的数值用闵可夫斯基距离来计算相似性。排名转换公式如下：</p>
<script type="math/tex; mode=display">
z_{if}=\frac{r_{if}-1}{M_f-1}</script><p>其中，属性$f$有$M<em>f$个有序的状态，表示排位$1,2…M_f$。排位$r</em>{if}$表示当前属性状态排名。</p>
<p>一个例子：</p>
<p><img src="/2018/11/01/数据挖掘概念与技术/数据挖掘概念与技术笔记（1）：数据认识/03.png" alt></p>
<p> test-2偏序属性，有三个状态，即$M_f$=3，四个对象转换为排位分别为3、1、2、3。然后分别映射为1.0、0.0、0.5、1.0数值，最后可以使用欧几里得距离来计算如下的相异性矩阵。</p>
<p><img src="/2018/11/01/数据挖掘概念与技术/数据挖掘概念与技术笔记（1）：数据认识/08.png" alt></p>
<h3 id="混合类型属性的相异性"><a href="#混合类型属性的相异性" class="headerlink" title="混合类型属性的相异性"></a>混合类型属性的相异性</h3><p>解决这种情况的方法是讲所有类型一起处理，<strong>把所有有意义的属性转换到共同区间[0.0 , 1.0]上</strong></p>
<p> <img src="/2018/11/01/数据挖掘概念与技术/数据挖掘概念与技术笔记（1）：数据认识/09.png" alt></p>
<p>1、如果是数值，用归一化。2、如果是类别属性，匹配为1不匹配为0。3、偏序将排位先转为数值，再按数值的归一化处理。</p>
<p>一个例子：（混合了分类、偏序、和数值）</p>
<p><img src="/2018/11/01/数据挖掘概念与技术/数据挖掘概念与技术笔记（1）：数据认识/03.png" alt></p>
<p>之前，处理test-1(分类属性)和test-2(偏序属性)的过程已经给出，可以使用它们之前的相异性矩阵。所以这里首先计算test-3(数值属性)的相异性矩阵。有max=64，min=22，比较对象用归一化处理后，得到test-3的相异性矩阵：</p>
<p><img src="/2018/11/01/数据挖掘概念与技术/数据挖掘概念与技术笔记（1）：数据认识/10.png" alt></p>
<p>其中，d(3,1)是对象1和对象3每个不同属性的相似性矩阵计算得到的值，总的处理方式还是归一化。</p>
<h3 id="余弦相似性"><a href="#余弦相似性" class="headerlink" title="余弦相似性"></a>余弦相似性</h3><p>给出了四个文档的词频向量，用于比较这些文档之间的相似性。</p>
<p><img src="/2018/11/01/数据挖掘概念与技术/数据挖掘概念与技术笔记（1）：数据认识/11.png" alt></p>
<p><img src="/2018/11/01/数据挖掘概念与技术/数据挖掘概念与技术笔记（1）：数据认识/12.png" alt></p>
]]></content>
      <categories>
        <category>数据挖掘</category>
      </categories>
      <tags>
        <tag>相似性</tag>
        <tag>分位数图</tag>
        <tag>QQ图</tag>
        <tag>相异性</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划</title>
    <url>/2018/09/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h2 id="五问动态规划"><a href="#五问动态规划" class="headerlink" title="五问动态规划"></a>五问动态规划</h2><p>问：动态规划是什么？</p>
<p><strong>答：</strong>动态规划是一种通过“大而化小”的思路解决问题的算法。区别于一些固定形式的算法，如二分法，宽度优先搜索法，动态规划没有实际的步骤来规定第一步做什么第二步做什么。所以更加确切的说，动态规划是一种解决问题的思想。这种思想的本质是，一个规模比较大的问题（假如用2-3个参数可以表示），是通过规模比较小的若干问题的结果来得到的（通过取最大，取最小，或者加起来之类的运算）所以我们经常看到的动态规划的核心——状态转移方程都长成这样：</p>
<script type="math/tex; mode=display">
f[i][j] = f[i - 1][j] + f[i][j - 1]</script><script type="math/tex; mode=display">
f[i] = max\{f[j]    if   j < i and …\} + 1</script><script type="math/tex; mode=display">
f[i][j] = f[0][j - 1] \&\& judge(1,i)   ||   f[1][j - 1] \&\& judge(2,i) ||</script><p>问：动态规划什么时候可以用？</p>
<p>答：动态规划解决的一定是最优化问题。一个问题必须有重叠的子问题和最优子结构，才能使用动态规划取解决问题。</p>
<p>问：动态规划的常见类型有哪些？</p>
<ul>
<li>矩阵型</li>
<li>序列型</li>
<li>双序列型</li>
<li>划分型</li>
<li>区间型</li>
<li>背包型</li>
</ul>
<p>问：什么样的问题适合使用动态规划？</p>
<p><strong>答：</strong>可以使用动态规划的问题一般都有一些特点可以遵循。如题目的问法一般是三种方式：</p>
<ol>
<li>求最大值/最小值</li>
<li>求可不可行</li>
<li>求方案总数</li>
</ol>
<p>如果你碰到一个问题，是问你这三个问题之一的，那么有90%的概率是使用动态规划来求解。要重点说明的是，如果一个问题让你求出“所有的”方案和结果，则肯定不是使用动态规划。</p>
<p>解决一个动态规划问题的步骤是什么？</p>
<p><strong>答：</strong>首先判断是否是动态规划的问题，如果是，则尝试将其进行分类常见类型，找到对应的类别和相似的问题。接着从下面的4个要素去逐步剖析解决这道题：</p>
<ol>
<li>状态是什么</li>
<li>状态转移方程是什么</li>
<li>状态的初始值是什么</li>
<li>问题要求的最后答案是什么</li>
</ol>
<p>每个步骤分析完成之后，就基本上解决了整道动态规划的问题。</p>
<h2 id="动态规划相关题"><a href="#动态规划相关题" class="headerlink" title="动态规划相关题"></a>动态规划相关题</h2><h3 id="交叉字符串"><a href="#交叉字符串" class="headerlink" title="交叉字符串"></a>交叉字符串</h3><p><strong>题目</strong>：给出三个字符串:s1、s2、s3，判断s3是否由s1和s2交叉构成。</p>
<p><strong>样例</strong></p>
<p>比如 s1 = <strong>“aabcc”</strong> s2 = <strong>“dbbca”</strong></p>
<ul>
<li>当 s3 = <strong>“aadbbcbcac”</strong>，返回 true.</li>
</ul>
<ul>
<li>当 s3 = <strong>“aadbbbaccc”</strong>， 返回 false.</li>
</ul>
<p><strong>思路：</strong></p>
<p> 1.这题我们利用动态规划加记忆化搜索。如果能够进行交叉组成，利用动态规划，建立 $boolean    dp[i][j]$， 意思是s1的第i为 和s2的第j为是否能够够成s3的i + j 长度的交叉字符串。不一定要每个字符交替插入，s1 = aa, s2 = d 也可以组成s3 = aad。记忆矩阵这里要清楚定义，一个维度是s1的长度，一个维度是s2的长度。 </p>
<p> 2.因此状态转移方程就可以写成: </p>
<script type="math/tex; mode=display">
dp[i][j] = 1) dp[i][j-1] if s3[i+j -1] == s2[j-1] 2) dp[i-1][j] if s3[i+j-1] == s1[i-1]</script><p> 3.初始条件要注意，我们这里是把记忆矩阵建立为$test$，因此第一行就是没有s1的情况下看看s2能不能与s3配对，第一列就是在没有s2的情况下能不能与s3配对。<br>4.最后就是看最右下角的dp。时间复杂度是o(n*m)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @params s1, s2, s3: Three strings as description.</span></span><br><span class="line"><span class="string">    @return: return True if s3 is formed by the interleaving of</span></span><br><span class="line"><span class="string">             s1 and s2 or False if not.</span></span><br><span class="line"><span class="string">    @hint: you can use [[True] * m for i in range (n)] to allocate a n*m matrix.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isInterleave</span><span class="params">(self, s1, s2, s3)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">if</span> s1 <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> s2 <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> s3 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> len(s1) + len(s2) != len(s3):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 初始边界s1行s2列的false</span></span><br><span class="line">        interleave = [[<span class="literal">False</span>] * (len(s2) + <span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s1) + <span class="number">1</span>)]</span><br><span class="line">        interleave[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s1)):</span><br><span class="line">            interleave[i + <span class="number">1</span>][<span class="number">0</span>] = s1[:i + <span class="number">1</span>] == s3[:i + <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s2)):</span><br><span class="line">            interleave[<span class="number">0</span>][i + <span class="number">1</span>] = s2[:i + <span class="number">1</span>] == s3[:i + <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s1)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(s2)):</span><br><span class="line">                interleave[i + <span class="number">1</span>][j + <span class="number">1</span>] = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">if</span> s1[i] == s3[i + j + <span class="number">1</span>]:</span><br><span class="line">                    interleave[i + <span class="number">1</span>][j + <span class="number">1</span>] = interleave[i][j + <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> s2[j] == s3[i + j + <span class="number">1</span>]:</span><br><span class="line">                    interleave[i + <span class="number">1</span>][j + <span class="number">1</span>] |= interleave[i + <span class="number">1</span>][j]</span><br><span class="line">        <span class="keyword">return</span> interleave[len(s1)][len(s2)]</span><br></pre></td></tr></table></figure>
<h3 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h3><p><strong>描述</strong>：给定一个整数序列，找到最长上升子序列（LIS，<strong>不要求一定连续</strong>），返回LIS的长度。例如现在有序列A={1,2,3,-1,-2,7,9}，它的最长上升子序列为{1,2,3,7,9}，长度为5.</p>
<p>思路：dp[i] 表示走到第i个元素时的当前最大连续子序列的长度 ，这样对A[i]有两种可能：</p>
<p>1、如果A[i]之前的元素A[j]，其中$jdp[i]$，那么可以把A[i]拼接到A[j]的后面</p>
<p>2、如果之前的元素都比A[i]大，则A[i]自己成为最大的上升自序，长度为1</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param nums: The integer array</span></span><br><span class="line"><span class="string">    @return: The length of LIS (longest increasing subsequence)</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestIncreasingSubsequence</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">if</span> nums <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [<span class="number">1</span>] * len(nums) <span class="comment"># 边界初始条件</span></span><br><span class="line">        <span class="keyword">for</span> curr, val <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">for</span> prev <span class="keyword">in</span> xrange(curr):</span><br><span class="line">                <span class="keyword">if</span> nums[prev] &lt; val:  <span class="comment"># 如果之前的元素大于等于curr，则dp[curr]为初始的1</span></span><br><span class="line">                    dp[curr] = max(dp[curr], dp[prev] + <span class="number">1</span>) <span class="comment">#状态转移方程</span></span><br><span class="line">        <span class="keyword">return</span> max(dp)</span><br></pre></td></tr></table></figure>
<h3 id="单词拆分"><a href="#单词拆分" class="headerlink" title="单词拆分 ++"></a>单词拆分 ++</h3><p><strong>描述</strong>：给定字符串 s 和单词字典 dict，确定 s 是否可以分成一个或多个以空格分隔的子串，并且这些子串都在字典中存在。</p>
<p><strong>样例</strong>：给出s = <strong>“lintcode”</strong>，dict = <strong>[“lint”,”code”]</strong>返回 true 因为<strong>“lintcode”</strong>可以被空格切分成<strong>“lint code”</strong></p>
<p>思路：如果最大字典长度为k，f[i]的状态由前面i-k到i-1之间决定，这中间任何一段属于dict则f[I]为True</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param s: A string s</span></span><br><span class="line">    <span class="comment"># @param dict: A dictionary of words dict</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wordBreak</span><span class="params">(self, s, dict)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(dict) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> len(s) == <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">        n = len(s)</span><br><span class="line">        f = [<span class="literal">False</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        f[<span class="number">0</span>] = <span class="literal">True</span>  <span class="comment"># 初始边界</span></span><br><span class="line">        </span><br><span class="line">        maxLength = max([len(w) <span class="keyword">for</span> w <span class="keyword">in</span> dict]) <span class="comment">#先计算字典中最大长度，减少复杂度</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, min(i, maxLength) + <span class="number">1</span>): <span class="comment">#不必遍历i之前的所有j</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> f[i - j]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> s[i - j:i] <span class="keyword">in</span> dict:</span><br><span class="line">                    f[i] = <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">break</span> <span class="comment"># 有一个满足即可判断下一个f[i+1]</span></span><br><span class="line">        <span class="keyword">return</span> f[n]</span><br></pre></td></tr></table></figure>
<h3 id="数字三角形"><a href="#数字三角形" class="headerlink" title="数字三角形"></a>数字三角形</h3><p><strong>描述</strong>：给定一个数字三角形，找到从顶部到底部的最小路径和。每一步可以移动到下面一行的相邻数字上</p>
<p><strong>样例</strong>：比如，给出下列数字三角形：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">     [<span class="number">2</span>],</span><br><span class="line">    [<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">   [<span class="number">6</span>,<span class="number">5</span>,<span class="number">7</span>],</span><br><span class="line">  [<span class="number">4</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">3</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>从顶到底部的最小路径和为11 ( 2 + 3 + 5 + 1 = 11)。</p>
<p><strong>思路</strong>：自底向上的动态规划, 当前位置由左下或者右下最小值决定，时间复杂度O(n), python3 实现 ， triangle数组代表第i行第j个数字</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param triangle: a list of lists of integers</span></span><br><span class="line"><span class="string">    @return: An integer, minimum path sum</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumTotal</span><span class="params">(self, triangle)</span>:</span></span><br><span class="line">        rows = len(triangle)</span><br><span class="line">        dp = [[<span class="number">0</span>] * len(triangle[row]) <span class="keyword">for</span> row <span class="keyword">in</span> range(rows)] </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(triangle[rows - <span class="number">1</span>])):</span><br><span class="line">            dp[rows - <span class="number">1</span>][i] = triangle[rows - <span class="number">1</span>][i] <span class="comment">#初始边界</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(rows - <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>):</span><br><span class="line">                dp[i][j] = min(dp[i + <span class="number">1</span>][j], dp[i + <span class="number">1</span>][j + <span class="number">1</span>]) + triangle[i][j] <span class="comment">#状态转移方程</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h3 id="最小路径和"><a href="#最小路径和" class="headerlink" title="最小路径和"></a>最小路径和</h3><p>描述：给定一个只含非负整数的m×n网格，找到一条<strong>从左上角到右下角</strong>的可以使数字和最小的路径。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param grid: a list of lists of integers.</span></span><br><span class="line"><span class="string">    @return: An integer, minimizes the sum of all numbers along its path</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minPathSum</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(grid)): </span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(grid[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">and</span> j &gt; <span class="number">0</span>:</span><br><span class="line">                    grid[i][j] += grid[i][j<span class="number">-1</span>] <span class="comment"># 第一行，只在左边</span></span><br><span class="line">                <span class="keyword">elif</span> j == <span class="number">0</span> <span class="keyword">and</span> i &gt; <span class="number">0</span>:</span><br><span class="line">                    grid[i][j] += grid[i<span class="number">-1</span>][j] <span class="comment"># 第一列，只在右边</span></span><br><span class="line">                <span class="keyword">elif</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> j &gt; <span class="number">0</span>:</span><br><span class="line">                    grid[i][j] += min(grid[i<span class="number">-1</span>][j], grid[i][j<span class="number">-1</span>])  <span class="comment"># 由上面和左面的最小路径决定</span></span><br><span class="line">        <span class="keyword">return</span> grid[len(grid) - <span class="number">1</span>][len(grid[<span class="number">0</span>]) - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯 ++"></a>爬楼梯 ++</h3><p>描述：假设你正在爬楼梯，需要n步你才能到达顶部。但每次你只能爬一步或者两步，你能有多少种不同的方法？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param n: An integer</span></span><br><span class="line"><span class="string">    @return: An integer</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        result=[<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-2</span>):</span><br><span class="line">            result.append(result[<span class="number">-2</span>]+result[<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> result[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="不同的路径"><a href="#不同的路径" class="headerlink" title="不同的路径"></a>不同的路径</h3><p><strong>描述</strong>：有一个机器人的位于一个 m × n 个网格左上角。机器人每一时刻只能向下或者向右移动一步。机器人试图达到网格的右下角。问有多少条不同的路径？</p>
<p><strong>思路</strong>：有左边一格的路径数和上面一格的路径数决定</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span><span class="params">(self, m, n)</span>:</span></span><br><span class="line">        paths = [[<span class="number">0</span>] * n <span class="keyword">for</span> i <span class="keyword">in</span> range(m)] <span class="comment">#初始边界</span></span><br><span class="line">        <span class="comment"># initial rows</span></span><br><span class="line">        paths[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">            paths[x][<span class="number">0</span>] = paths[x - <span class="number">1</span>][<span class="number">0</span>] <span class="comment">#边界</span></span><br><span class="line">        <span class="comment"># initail columns</span></span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            paths[<span class="number">0</span>][y] = paths[<span class="number">0</span>][y - <span class="number">1</span>] <span class="comment">#边界</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">                paths[x][y] = paths[x <span class="number">-1</span>][y] + paths[x][y - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> paths[m - <span class="number">1</span>][n - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离 +"></a>编辑距离 +</h3><p><strong>题目</strong>：给出两个单词word1和word2，计算出将word1 转换为word2的最少操作次数。你总共三种操作方法：</p>
<ul>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ul>
<p><strong>样例</strong>：给出 work1=”mart” 和 work2=”karma”，返回 3。（先进行2个替换，后面进行1个插入）</p>
<p>思路：f[i][j代表第一个字符串以i结尾匹配上（编辑成）第二个字符串以j结尾的字符串，最少需要多少次编辑。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param word1: A string</span></span><br><span class="line"><span class="string">    @param word2: A string</span></span><br><span class="line"><span class="string">    @return: The minimum number of steps.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDistance</span><span class="params">(self, word1, word2)</span>:</span></span><br><span class="line">        n, m = len(word1), len(word2)</span><br><span class="line">        f = [[<span class="number">0</span>] * (m + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n + <span class="number">1</span>)]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n + <span class="number">1</span>):</span><br><span class="line">            f[i][<span class="number">0</span>] = i <span class="comment"># 边界</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(m + <span class="number">1</span>):</span><br><span class="line">            f[<span class="number">0</span>][j] = j <span class="comment"># 边界</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]:</span><br><span class="line">                    f[i][j] = min(f[i - <span class="number">1</span>][j - <span class="number">1</span>], f[i - <span class="number">1</span>][j] + <span class="number">1</span>, f[i][j - <span class="number">1</span>] + <span class="number">1</span>)</span><br><span class="line">                    <span class="comment"># equivalent to f[i][j] = f[i - 1][j - 1]</span></span><br><span class="line">                <span class="keyword">else</span>: <span class="comment">#分别代表替换，插入，删除</span></span><br><span class="line">                    f[i][j] = min(f[i - <span class="number">1</span>][j - <span class="number">1</span>], f[i - <span class="number">1</span>][j], f[i][j - <span class="number">1</span>]) + <span class="number">1</span></span><br><span class="line">                        </span><br><span class="line">        <span class="keyword">return</span> f[n][m]</span><br></pre></td></tr></table></figure>
<h3 id="正则表达式匹配"><a href="#正则表达式匹配" class="headerlink" title="正则表达式匹配 ++"></a>正则表达式匹配 ++</h3><p><strong>描述</strong>：实现支持<strong>‘.’</strong>和<strong>‘*‘</strong>的正则表达式匹配。’.’匹配任意一个字母。’*’匹配零个或者多个前面的元素。匹配应该覆盖整个输入字符串，而不仅仅是一部分。返回true 和 false</p>
<p><strong>样例</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">isMatch(<span class="string">"aa"</span>,<span class="string">"a"</span>) → false</span><br><span class="line"></span><br><span class="line">isMatch(<span class="string">"aa"</span>,<span class="string">"aa"</span>) → true</span><br><span class="line"></span><br><span class="line">isMatch(<span class="string">"aaa"</span>,<span class="string">"aa"</span>) → false</span><br><span class="line"></span><br><span class="line">isMatch(<span class="string">"aa"</span>, <span class="string">"a*"</span>) → true</span><br><span class="line"></span><br><span class="line">isMatch(<span class="string">"aa"</span>, <span class="string">".*"</span>) → true</span><br><span class="line"></span><br><span class="line">isMatch(<span class="string">"ab"</span>, <span class="string">".*"</span>) → true</span><br><span class="line"></span><br><span class="line">isMatch(<span class="string">"aab"</span>, <span class="string">"c*a*b"</span>) → true</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># DP</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s, p)</span>:</span></span><br><span class="line">        dp = [[<span class="literal">False</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(p) + <span class="number">1</span>)] <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, len(s) + <span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(p) + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> (p[i - <span class="number">1</span>] == <span class="string">'*'</span>):</span><br><span class="line">                dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i - <span class="number">2</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(s) + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(p) + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> p[j - <span class="number">1</span>] == <span class="string">'*'</span>:</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">2</span>]</span><br><span class="line">                    <span class="keyword">if</span> s[i - <span class="number">1</span>] == p[j - <span class="number">2</span>] <span class="keyword">or</span> p[j - <span class="number">2</span>] == <span class="string">'.'</span>:</span><br><span class="line">                        dp[i][j] |= dp[i<span class="number">-1</span>][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> s[i - <span class="number">1</span>] == p[j - <span class="number">1</span>] <span class="keyword">or</span> p[j - <span class="number">1</span>] == <span class="string">'.'</span>:</span><br><span class="line">                        dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> dp[len(s)][len(p)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 懒癌版</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s, p)</span>:</span></span><br><span class="line">        <span class="comment"># '$'字符规则代表匹配字符串的末尾，匹配返回一个Match 对象，否则返回None</span></span><br><span class="line">        <span class="keyword">return</span> re.match(p + <span class="string">'$'</span>, s) != <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<h3 id="不同的二叉查找树-II"><a href="#不同的二叉查找树-II" class="headerlink" title="不同的二叉查找树 II"></a>不同的二叉查找树 II</h3><p><strong>描述：</strong>给出n，生成所有由1…n为节点组成的不同的二叉查找树</p>
<p><strong>样例</strong>：给出n = 3，生成所有5种不同形态的二叉查找树：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>         <span class="number">3</span>     <span class="number">3</span>       <span class="number">2</span>    <span class="number">1</span></span><br><span class="line"> \       /     /       / \    \</span><br><span class="line">  <span class="number">3</span>     <span class="number">2</span>     <span class="number">1</span>       <span class="number">1</span>   <span class="number">3</span>    <span class="number">2</span></span><br><span class="line"> /     /       \                \</span><br><span class="line"><span class="number">2</span>     <span class="number">1</span>         <span class="number">2</span>                <span class="number">3</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Definition of TreeNode:</span></span><br><span class="line"><span class="string">class TreeNode:</span></span><br><span class="line"><span class="string">    def __init__(self, val):</span></span><br><span class="line"><span class="string">        this.val = val</span></span><br><span class="line"><span class="string">        this.left, this.right = None, None</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @paramn n: An integer</span></span><br><span class="line">    <span class="comment"># @return: A list of root</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateTrees</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">return</span> self.dfs(<span class="number">1</span>, n)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, start, end)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> start &gt; end: <span class="keyword">return</span> [<span class="literal">None</span>]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> rootval <span class="keyword">in</span> range(start, end+<span class="number">1</span>):</span><br><span class="line">            LeftTree = self.dfs(start, rootval<span class="number">-1</span>)</span><br><span class="line">            RightTree = self.dfs(rootval+<span class="number">1</span>, end)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> LeftTree:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> RightTree:</span><br><span class="line">                    root = TreeNode(rootval)</span><br><span class="line">                    root.left = i</span><br><span class="line">                    root.right = j</span><br><span class="line">                    res.append(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="乘积最大子序列"><a href="#乘积最大子序列" class="headerlink" title="乘积最大子序列 +"></a>乘积最大子序列 +</h3><p><strong>描述</strong>：找出一个序列中乘积最大的连续子序列（至少包含一个数）</p>
<p><strong>样例</strong>：比如, 序列 <code>[2,3,-2,4]</code> 中乘积最大的子序列为 <code>[2,3]</code> ，其乘积为<code>6</code>。</p>
<p>思路：这道题和maximal subarray思路一样，不同的是对于加法加上负数会变小，加上正数会变大；而对于乘法，乘以正数有可能变大也有可能变小（原数是负数的情况下），乘以负数也有可能变大或者变小</p>
<p>所以需要两个变量：<br>min_p表示行进到当前subarray能得到的最小的积<br>max_p表示行进到当前subarray能得到的最大的积</p>
<p>对于某一个subarray来说，它最大的积，有可能来自之前的最大积乘以一个正数，或者之前的最小积乘以一个负数，或者nums[i]就是最大的<br>因此 $max_p = max(nums[i], max_p × nums[i], min_p × nums[i])$<br>最小积同理</p>
<p>最后用res变量跟踪一下全局最大</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param nums: An array of integers</span></span><br><span class="line"><span class="string">    @return: An integer</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProduct</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            </span><br><span class="line">        global_max = prev_max = prev_min = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums[<span class="number">1</span>:]:</span><br><span class="line">            <span class="keyword">if</span> num &gt; <span class="number">0</span>:</span><br><span class="line">                curt_max = max(num, prev_max * num)</span><br><span class="line">                curt_min = min(num, prev_min * num)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                curt_max = max(num, prev_min * num)</span><br><span class="line">                curt_min = min(num, prev_max * num)</span><br><span class="line">            </span><br><span class="line">            global_max = max(global_max, curt_max)</span><br><span class="line">            prev_max, prev_min = curt_max, curt_min</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> global_max</span><br></pre></td></tr></table></figure>
<h3 id="通配符匹配"><a href="#通配符匹配" class="headerlink" title="通配符匹配"></a>通配符匹配</h3><p><strong>描述</strong>：判断两个可能包含通配符“？”和“*”的字符串是否匹配。匹配规则如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'?'</span> 可以匹配任何单个字符。</span><br><span class="line"><span class="string">'*'</span> 可以匹配任意字符串（包括空字符串）。</span><br><span class="line">两个串完全匹配才算匹配成功。</span><br></pre></td></tr></table></figure>
<p>样例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">isMatch(<span class="string">"aa"</span>,<span class="string">"a"</span>) → false</span><br><span class="line">isMatch(<span class="string">"aa"</span>,<span class="string">"aa"</span>) → true</span><br><span class="line">isMatch(<span class="string">"aaa"</span>,<span class="string">"aa"</span>) → false</span><br><span class="line">isMatch(<span class="string">"aa"</span>, <span class="string">"*"</span>) → true</span><br><span class="line">isMatch(<span class="string">"aa"</span>, <span class="string">"a*"</span>) → true</span><br><span class="line">isMatch(<span class="string">"ab"</span>, <span class="string">"?*"</span>) → true</span><br><span class="line">isMatch(<span class="string">"aab"</span>, <span class="string">"c*a*b"</span>) → false</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param s: A string</span></span><br><span class="line"><span class="string">    @param p: A string includes "?" and "*"</span></span><br><span class="line"><span class="string">    @return: A boolean</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s, p)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        m = len(p)</span><br><span class="line">        f = [[<span class="literal">False</span>] * (m + <span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(n + <span class="number">1</span>)]</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">and</span> p.count(<span class="string">'*'</span>) == m:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, m + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> j &gt; <span class="number">0</span>:</span><br><span class="line">                    f[i][j] |= f[i<span class="number">-1</span>][j<span class="number">-1</span>] <span class="keyword">and</span> (s[i<span class="number">-1</span>] == p[j<span class="number">-1</span>] <span class="keyword">or</span> p[j - <span class="number">1</span>] <span class="keyword">in</span> [<span class="string">'?'</span>, <span class="string">'*'</span>])</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> j &gt; <span class="number">0</span>:</span><br><span class="line">                    f[i][j] |= f[i - <span class="number">1</span>][j] <span class="keyword">and</span> p[j - <span class="number">1</span>] == <span class="string">'*'</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> j &gt; <span class="number">0</span>:</span><br><span class="line">                    f[i][j] |= f[i][j - <span class="number">1</span>] <span class="keyword">and</span> p[j - <span class="number">1</span>] == <span class="string">'*'</span></span><br><span class="line">        <span class="keyword">return</span> f[n][m]</span><br></pre></td></tr></table></figure>
<h3 id="打劫房屋"><a href="#打劫房屋" class="headerlink" title="打劫房屋 ++"></a>打劫房屋 ++</h3><p><strong>描述</strong>：假设你是一个专业的窃贼，准备沿着一条街打劫房屋。每个房子都存放着特定金额的钱。你面临的唯一约束条件是：相邻的房子装着相互联系的防盗系统，且 <strong>当相邻的两个房子同一天被打劫时，该系统会自动报警</strong>。给定一个非负整数列表，表示每个房子中存放的钱， 算一算，如果今晚去打劫，你最多可以得到多少钱 <strong>在不触动报警装置的情况下</strong>。</p>
<p> <strong>样例</strong>：给定 <code>[3, 8, 4]</code>, 返回 <code>8</code>. </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param A: An array of non-negative integers</span></span><br><span class="line"><span class="string">    @return: The maximum amount of money you can rob tonight</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">houseRobber</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> A:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(A) &lt;= <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> max(A)</span><br><span class="line">            </span><br><span class="line">        f = [<span class="number">0</span>] * len(A)</span><br><span class="line">        f[<span class="number">0</span>], f[<span class="number">1</span>] = A[<span class="number">0</span>], max(A[<span class="number">0</span>], A[<span class="number">1</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(A)):</span><br><span class="line">            f[i] = max(f[i - <span class="number">1</span>], f[i - <span class="number">2</span>] + A[i])</span><br><span class="line">        <span class="keyword">return</span> f[len(A) - <span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 使用滚动数组版本</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param A: An array of non-negative integers</span></span><br><span class="line"><span class="string">    @return: The maximum amount of money you can rob tonight</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">houseRobber</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> A:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(A) &lt;= <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> max(A)</span><br><span class="line">            </span><br><span class="line">        f = [<span class="number">0</span>] * <span class="number">3</span></span><br><span class="line">        f[<span class="number">0</span>], f[<span class="number">1</span>] = A[<span class="number">0</span>], max(A[<span class="number">0</span>], A[<span class="number">1</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(A)):</span><br><span class="line">            f[i % <span class="number">3</span>] = max(f[(i - <span class="number">1</span>) % <span class="number">3</span>], f[(i - <span class="number">2</span>) % <span class="number">3</span>] + A[i])</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> f[(len(A) - <span class="number">1</span>) % <span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<h3 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a>买卖股票的最佳时机</h3><p><strong>描述</strong>：假设你有一个数组，它的第i个元素是一支给定的股票在第i天的价格。设计一个算法来找到最大的利润。你最多可以完成 <code>k</code> 笔交易。你不可以同时参与多笔交易(你必须在再次购买前出售掉之前的股票)</p>
<p>样例：给定价格 = <code>[4,4,6,1,1,4,2,5]</code>, 且 k = <code>2</code>, 返回 <code>6</code>.（1买4卖，2买5卖）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param k: an integer</span></span><br><span class="line"><span class="string">    @param prices: an integer array</span></span><br><span class="line"><span class="string">    @return: an integer which is maximum profit</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, k, prices)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        size = len(prices)</span><br><span class="line">        <span class="keyword">if</span> k &gt;= size / <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> self.quickSolve(size, prices)</span><br><span class="line">        dp = [<span class="literal">None</span>] * (<span class="number">2</span> * k + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(size):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(min(<span class="number">2</span> * k, i + <span class="number">1</span>) , <span class="number">0</span> , <span class="number">-1</span>):</span><br><span class="line">                dp[j] = max(dp[j], dp[j - <span class="number">1</span>] + prices[i] * [<span class="number">1</span>, <span class="number">-1</span>][j % <span class="number">2</span>])</span><br><span class="line">        <span class="keyword">return</span> max(dp)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quickSolve</span><span class="params">(self, size, prices)</span>:</span></span><br><span class="line">        sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(size - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> prices[x + <span class="number">1</span>] &gt; prices[x]:</span><br><span class="line">                sum += prices[x + <span class="number">1</span>] - prices[x]</span><br><span class="line">        <span class="keyword">return</span> sum</span><br></pre></td></tr></table></figure>
<h3 id="解码方法"><a href="#解码方法" class="headerlink" title="解码方法+"></a>解码方法+</h3><p><strong>描述</strong>：有一个消息包含<code>A-Z</code>通过以下规则编码，现在给你一个加密过后的消息，问有几种解码的方式</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">'A' -&gt; 1</span><br><span class="line">'B' -&gt; 2</span><br><span class="line">...</span><br><span class="line">'Z' -&gt; 26</span><br></pre></td></tr></table></figure>
<p><strong>样例</strong>：给你的消息为<code>12</code>，有两种方式解码 AB(12) 或者 L(12). 所以返回 <code>2</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param &#123;string&#125; s a string,  encoded message</span></span><br><span class="line">    <span class="comment"># @return &#123;int&#125; an integer, the number of ways decoding</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numDecodings</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># Write your code here</span></span><br><span class="line">        <span class="keyword">if</span> s == <span class="string">""</span> <span class="keyword">or</span> s[<span class="number">0</span>] == <span class="string">'0'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        dp=[<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,len(s) + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="number">10</span> &lt;= int(s[i - <span class="number">2</span> : i]) &lt;=<span class="number">26</span> <span class="keyword">and</span> s[i - <span class="number">1</span>] != <span class="string">'0'</span>:</span><br><span class="line">                dp.append(dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>])</span><br><span class="line">            <span class="keyword">elif</span> int(s[i<span class="number">-2</span> : i]) == <span class="number">10</span> <span class="keyword">or</span> int(s[i - <span class="number">2</span> : i]) == <span class="number">20</span>:</span><br><span class="line">                dp.append(dp[i - <span class="number">2</span>])</span><br><span class="line">            <span class="keyword">elif</span> s[i<span class="number">-1</span>] != <span class="string">'0'</span>:</span><br><span class="line">                dp.append(dp[i<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[len(s)]</span><br></pre></td></tr></table></figure>
<h3 id="完美平方"><a href="#完美平方" class="headerlink" title="完美平方"></a>完美平方</h3><p><strong>描述</strong>：给一个正整数 n, 找到若干个完全平方数(比如1, 4, 9, … )使得他们的和等于 n。你需要让平方数的个数最少。</p>
<p><strong>样例</strong>：</p>
<p>给出 n = <code>12</code>, 返回 <code>3</code> 因为 <code>12 = 4 + 4 + 4</code>。<br>给出 n = <code>13</code>, 返回 <code>2</code> 因为 <code>13 = 4 + 9</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numSquares</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        dp = []</span><br><span class="line">        <span class="keyword">import</span> sys</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n+<span class="number">1</span>):</span><br><span class="line">            dp.append(sys.maxint)</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i * i &lt;= n:</span><br><span class="line">            dp[i*i] = <span class="number">1</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n+<span class="number">1</span>):</span><br><span class="line">            j = <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j * j &lt;= i:</span><br><span class="line">                dp[i] = min(dp[i], dp[i-j*j] + <span class="number">1</span>)</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>重点掌握</title>
    <url>/2018/09/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%87%8D%E7%82%B9%E6%8E%8C%E6%8F%A1/</url>
    <content><![CDATA[<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#节点类</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,data = <span class="number">-1</span>)</span>:</span></span><br><span class="line">        self.data = data</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#树类</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.root = Node()</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self,data)</span>:</span></span><br><span class="line">        <span class="comment"># 为树加入节点</span></span><br><span class="line">        node  = Node(data)</span><br><span class="line">        <span class="keyword">if</span> self.root.data == <span class="number">-1</span>:        <span class="comment">#如果树为空，就对根节点赋值</span></span><br><span class="line">            self.root = node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            myQueue = []</span><br><span class="line">            treeNode = self.root</span><br><span class="line">            myQueue.append(treeNode)</span><br><span class="line">            <span class="keyword">while</span> myQueue:              <span class="comment">#对已有的节点进行层次遍历</span></span><br><span class="line">                treeNode = myQueue.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> treeNode.left:</span><br><span class="line">                    treeNode.left = node</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">elif</span> <span class="keyword">not</span> treeNode.right:</span><br><span class="line">                    treeNode.right = node</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    myQueue.append(treeNode.left)</span><br><span class="line">                    myQueue.append(treeNode.right)</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pre_order_recursion</span><span class="params">(self,root)</span>:</span>     <span class="comment">#递归实现前序遍历</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">print</span> root.data,</span><br><span class="line">        self.pre_order_recursion(root.left)</span><br><span class="line">        self.pre_order_recursion(root.right)</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pre_order_stack</span><span class="params">(self,root)</span>:</span>         <span class="comment">#堆栈实现前序遍历（非递归）</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        myStack = []</span><br><span class="line">        node = root</span><br><span class="line">        <span class="keyword">while</span> myStack <span class="keyword">or</span> node:</span><br><span class="line">            <span class="keyword">while</span> node:       <span class="comment">#从根节点开始，一直寻找他的左子树</span></span><br><span class="line">                <span class="keyword">print</span> node.data,     <span class="comment"># 先序，进栈前就要读取了</span></span><br><span class="line">                myStack.append(node) <span class="comment"># 先存进栈，以后还需要它的右节点</span></span><br><span class="line">                node = node.left</span><br><span class="line">            node = myStack.pop()    <span class="comment">#while结束表示当前节点node为空，即前一个节点没有左子树了</span></span><br><span class="line">            node = node.right       <span class="comment">#开始查看它的右子树</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">in_order_recursion</span><span class="params">(self,root)</span>:</span>      <span class="comment">#递归实现中序遍历</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.in_order_recursion(root.left)</span><br><span class="line">        <span class="keyword">print</span> root.data,</span><br><span class="line">        self.in_order_recursion(root.right)</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">in_order_stack</span><span class="params">(self,root)</span>:</span>        <span class="comment">#堆栈实现中序遍历（非递归）</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        myStack = []</span><br><span class="line">        node = root</span><br><span class="line">        <span class="keyword">while</span> myStack <span class="keyword">or</span> node:     <span class="comment">#从根节点开始，一直寻找它的左子树</span></span><br><span class="line">            <span class="keyword">while</span> node:</span><br><span class="line">                myStack.append(node) </span><br><span class="line">                node = node.left</span><br><span class="line">            node = myStack.pop() <span class="comment"># 中序，弹出来后才读取</span></span><br><span class="line">            <span class="keyword">print</span> node.data,</span><br><span class="line">            node = node.right</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post_order_recursion</span><span class="params">(self,root)</span>:</span>     <span class="comment">#递归实现后序遍历</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.post_order_recursion(root.left)</span><br><span class="line">        self.post_order_recursion(root.right)</span><br><span class="line">        <span class="keyword">print</span> root.data,</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post_order_stack</span><span class="params">(self, root)</span>:</span>  <span class="comment"># 堆栈实现后序遍历（非递归）</span></span><br><span class="line">        <span class="comment"># 先遍历根节点，再遍历右子树，最后是左子树，这样就可以转化为和先序遍历一个类型了，最后只把遍历结果逆序输出就OK了。</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        myStack1 = []</span><br><span class="line">        myStack2 = []</span><br><span class="line">        node = root</span><br><span class="line">        <span class="keyword">while</span> myStack1 <span class="keyword">or</span> node:</span><br><span class="line">            <span class="keyword">while</span> node:</span><br><span class="line">                myStack2.append(node)</span><br><span class="line">                myStack1.append(node)</span><br><span class="line">                node = node.right</span><br><span class="line">            node = myStack1.pop()</span><br><span class="line">            node = node.left</span><br><span class="line">        <span class="keyword">while</span> myStack2:</span><br><span class="line">            <span class="keyword">print</span> myStack2.pop().data,</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">level_order_queue</span><span class="params">(self,root)</span>:</span>       <span class="comment">#队列实现层次遍历（非递归）</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root :</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        myQueue = []</span><br><span class="line">        node = root</span><br><span class="line">        myQueue.append(node)</span><br><span class="line">        <span class="keyword">while</span> myQueue:</span><br><span class="line">            node = myQueue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">print</span> node.data,</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                myQueue.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                myQueue.append(node.right)</span><br><span class="line">                </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment">#主函数</span></span><br><span class="line">    datas = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line">    tree = Tree()          <span class="comment">#新建一个树对象</span></span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> datas:</span><br><span class="line">        tree.add(data)      <span class="comment">#逐个加入树的节点</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">print</span> <span class="string">'递归实现前序遍历：'</span></span><br><span class="line">    tree.pre_order_recursion(tree.root)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">print</span> <span class="string">'\n堆栈实现前序遍历'</span></span><br><span class="line">    tree.pre_order_stack(tree.root)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">print</span> <span class="string">"\n\n递归实现中序遍历："</span></span><br><span class="line">    tree.in_order_recursion(tree.root)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">print</span> <span class="string">"\n堆栈实现中序遍历："</span></span><br><span class="line">    tree.in_order_stack(tree.root)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">print</span> <span class="string">'\n\n递归实现后序遍历：'</span></span><br><span class="line">    tree.post_order_recursion(tree.root)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">print</span> <span class="string">'\n堆栈实现后序遍历：'</span></span><br><span class="line">    tree.post_order_stack(tree.root)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">print</span> <span class="string">'\n\n队列实现层次遍历：'</span></span><br><span class="line">    tree.level_order_queue(tree.root)！</span><br></pre></td></tr></table></figure>
<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  二分查找</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">BinarySearch</span><span class="params">(array,t)</span>:</span></span><br><span class="line">    low = <span class="number">0</span></span><br><span class="line">    height = len(array)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> low &lt; height:</span><br><span class="line">        mid = (low+height)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> array[mid] &lt; t:</span><br><span class="line">            low = mid + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> array[mid] &gt; t:</span><br><span class="line">            height = mid - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> array[mid]</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">print</span> BinarySearch([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">34</span>,<span class="number">56</span>,<span class="number">57</span>,<span class="number">78</span>,<span class="number">87</span>],<span class="number">57</span>)</span><br></pre></td></tr></table></figure>
<h3 id="广度优先与深度优先"><a href="#广度优先与深度优先" class="headerlink" title="广度优先与深度优先"></a>广度优先与深度优先</h3><p><strong>下面的代码强调一下: dfs和bfs区别（重点）</strong></p>
<ol>
<li>pop()和pop(0)</li>
<li>order加入w的时机</li>
<li>判断w的条件</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">深度优先遍历： 是一种用于遍历树或者图的算法。沿着树的深度遍历树的节点，尽可能深地搜索树的分支。当节点v的所在边都被搜索过了。搜索将回溯到节点v的那条边的起始节点。直到已发现从源节点可达的所有节点为止。如果还存在未发现的节点，则选择其中一个作为源节点并重复上述过程，整个进程反复进行直到所有节点都被访问为止.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">广度优先遍历：从根节点开始，沿着树的宽度遍历树的节点，如果所有节点都被访问，则算法终止</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, nodes, sides)</span>:</span></span><br><span class="line">        <span class="comment"># nodes表示用户输入的点，int型，sides表示用户输入的边，是一个二元组(u, v)</span></span><br><span class="line">        <span class="comment"># self.sequence是字典，key是点，value是与key相连的边</span></span><br><span class="line">        self.sequence = &#123;&#125;</span><br><span class="line">        <span class="comment"># self.side是临时变量，主要用于保存与 指定点v 相连接的点</span></span><br><span class="line">        self.side = []</span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> nodes:</span><br><span class="line">            <span class="keyword">for</span> side <span class="keyword">in</span> sides:</span><br><span class="line">                u, v = side</span><br><span class="line">                <span class="keyword">if</span> node == u:</span><br><span class="line">                    self.side.append(v)</span><br><span class="line">                <span class="keyword">elif</span> node == v:</span><br><span class="line">                    self.side.append(u)</span><br><span class="line">            <span class="comment"># 第二层主要是遍历属于这个点的所有边，然后将点和边组成字典</span></span><br><span class="line">            self.sequence[node] = self.side</span><br><span class="line">            self.side = []</span><br><span class="line">        <span class="comment"># print self.sequence</span></span><br><span class="line">        <span class="comment"># &#123;1: [2, 3], 2: [1, 4, 5], 3: [1, 6, 7], 4: [2, 8], 5: [2, 8], 6: [3, 7], 7: [3, 6], 8: [4, 5]&#125;</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, node0)</span>:</span></span><br><span class="line">        <span class="comment"># order里面存放的是具体的访问路径，已经遍历的了</span></span><br><span class="line">        queue, order = [], []</span><br><span class="line">        queue.append(node0)</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            v = queue.pop()  <span class="comment"># 取出最后一个，为上一个刚加入节点的连接节点</span></span><br><span class="line">            order.append(v) <span class="comment"># 深度优先先加入，注意这个order的加入顺序</span></span><br><span class="line">            <span class="keyword">for</span> w <span class="keyword">in</span> self.sequence[v]: <span class="comment"># 两边</span></span><br><span class="line">                <span class="comment"># 不在order表示没被遍历，</span></span><br><span class="line">                <span class="keyword">if</span> w <span class="keyword">not</span> <span class="keyword">in</span> order <span class="keyword">and</span> w <span class="keyword">not</span> <span class="keyword">in</span> queue:</span><br><span class="line">                    queue.append(w)</span><br><span class="line">        <span class="keyword">return</span> order</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># bfs同理</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(self, node0)</span>:</span></span><br><span class="line">        queue, order = [], []</span><br><span class="line">        queue.append(node0)</span><br><span class="line">        order.append(node0)</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            v = queue.pop(<span class="number">0</span>)  <span class="comment"># 层次遍历按迅速取出</span></span><br><span class="line">            <span class="keyword">for</span> w <span class="keyword">in</span> self.sequence[v]:</span><br><span class="line">                <span class="comment"># if w not in order and w not in queue:</span></span><br><span class="line">                <span class="keyword">if</span> w <span class="keyword">not</span> <span class="keyword">in</span> order</span><br><span class="line">                    order.append(w) <span class="comment"># 没被遍历就直接将两边加入order</span></span><br><span class="line">                    queue.append(w)</span><br><span class="line">        <span class="keyword">return</span> order</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">        nodes = [i+<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">8</span>)]</span><br><span class="line">        sides = [(<span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line">                 (<span class="number">1</span>, <span class="number">3</span>),</span><br><span class="line">                 (<span class="number">2</span>, <span class="number">4</span>),</span><br><span class="line">                 (<span class="number">2</span>, <span class="number">5</span>),</span><br><span class="line">                 (<span class="number">4</span>, <span class="number">8</span>),</span><br><span class="line">                 (<span class="number">5</span>, <span class="number">8</span>),</span><br><span class="line">                 (<span class="number">3</span>, <span class="number">6</span>),</span><br><span class="line">                 (<span class="number">3</span>, <span class="number">7</span>),</span><br><span class="line">                 (<span class="number">6</span>, <span class="number">7</span>)]</span><br><span class="line"> </span><br><span class="line">        G = Graph(nodes, sides)</span><br><span class="line">        <span class="keyword">print</span> G.dfs(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">print</span> G.bfs(<span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串解题</title>
    <url>/2018/09/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E9%A2%98/</url>
    <content><![CDATA[<p>字符串相关题_python版</p>
<h3 id="最长无重复字符子串长度"><a href="#最长无重复字符子串长度" class="headerlink" title="最长无重复字符子串长度"></a>最长无重复字符子串长度</h3><p><strong>题目</strong>：给定一个字符串，请找出其中无重复字符的最长子字符串。例如，在”abcabcbb”中，其无重复字符的最长子字符串是”abc”，其长度为 3。</p>
<p><strong>思路</strong>：遍历字符串中的每一个元素。借助一个辅助键值对来存储某个元素最后一次出现的下标。用一个整形变量存储当前无重复字符的子串开始的下标。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 分析 a b c d e f g d 此时从最近重复的前一个字符d的后一位开始记，即e标记为start。此时继续取下一个数， 例如a，它的前一个字符下标为d[s[i]]=0，若d[s[i]]&lt;start，则不需要更新start,否则更新start。新的无重复子串变为e f g d a</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param: s: a string</span></span><br><span class="line"><span class="string">    @return: an integer</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> s <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> len(s) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        d = &#123;&#125; <span class="comment"># 存储某个元素最后一次出现的下标</span></span><br><span class="line">        tmp = <span class="number">0</span> <span class="comment"># 存储每次循环中最长的子串长度</span></span><br><span class="line">        start = <span class="number">0</span>  <span class="comment"># 记录最近重复字符所在的位置+1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)): <span class="comment"># 下标</span></span><br><span class="line">            <span class="comment"># 判断当前字符是否在字典中和当前字符的下标是否大于等于最近重复字符的所在位置</span></span><br><span class="line">            <span class="keyword">if</span> s[i] <span class="keyword">in</span> d <span class="keyword">and</span> d[s[i]] &gt;= start: <span class="comment"># 这里的d[s[i]]为前一个重复的下标</span></span><br><span class="line">                start = d[s[i]] + <span class="number">1</span></span><br><span class="line">            tmp = i - start + <span class="number">1</span></span><br><span class="line">            d[s[i]] = i</span><br><span class="line">            res = max(res, tmp)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="最长回文字符串"><a href="#最长回文字符串" class="headerlink" title="最长回文字符串"></a>最长回文字符串</h3><p>思路一：中心扩展法。根据回文的特性，显然所有的回文串都是对称的。<strong>长度为奇数回文串以最中间字符的位置为对称轴左右对称，而长度为偶数的回文串的对称轴在中间两个字符之间的空隙</strong>。可否利用这种对称性来提高算法效率呢？答案是肯定的。我们知道整个字符串中的所有字符，以及字符间的空隙，都可能是某个回文子串的对称轴位置。<strong>可以遍历这些位置，在每个位置上同时向左和向右扩展，直到左右两边的字符不同，或者达到边界</strong>。对于一个长度为n的字符串，这样的位置一共有n+n-1=2n-1个 ，时间复杂度O(n^2)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        str_length = len(s)</span><br><span class="line">        max_length = <span class="number">0</span>   <span class="comment"># 记录最大字符串长度,不是对称长度</span></span><br><span class="line">        start = <span class="number">0</span>  <span class="comment"># 记录位置</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(str_length): <span class="comment"># 当前下标位置</span></span><br><span class="line">            <span class="comment"># 对称位置在对称轴间隙，偶数</span></span><br><span class="line">            <span class="keyword">if</span> i - max_length &gt;= <span class="number">1</span> <span class="keyword">and</span> s[i-max_length<span class="number">-1</span>: i+<span class="number">1</span>] == s[i-max_length<span class="number">-1</span>: i+<span class="number">1</span>][::<span class="number">-1</span>]:</span><br><span class="line">                <span class="comment"># 记录当前开始位置</span></span><br><span class="line">                start = i - max_length - <span class="number">1</span></span><br><span class="line">                max_length += <span class="number">2</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 对称位置在对称字符，奇数</span></span><br><span class="line">            <span class="keyword">if</span> i - max_length &gt;= <span class="number">0</span> <span class="keyword">and</span> s[i-max_length: i+<span class="number">1</span>] == s[i-max_length: i+<span class="number">1</span>][::<span class="number">-1</span>]:</span><br><span class="line">                start = i - max_length</span><br><span class="line">                max_length += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 返回最长回文子串</span></span><br><span class="line">        <span class="keyword">return</span> s[start: start + max_length]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = <span class="string">"babad"</span></span><br><span class="line">    <span class="comment"># s = "cbbd"</span></span><br><span class="line">    sl = Solution()</span><br><span class="line">    print(sl.longestPalindrome(s))</span><br></pre></td></tr></table></figure>
<p>思路二：马拉车算法</p>
<p><a href="https://segmentfault.com/a/1190000003914228#articleHeader0" target="_blank" rel="noopener">看这篇</a></p>
<h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><p><a href="http://www.ruanyifeng.com/blog/2013/05/Knuth–Morris–Pratt_algorithm.html" target="_blank" rel="noopener">过程描述看这篇</a></p>
<p>其实就是,<strong>对模式串p进行预处理,得到前后缀的部分匹配表,使得我们可以借助已知信息,算出可以右移多少位.即 kmp = 朴素匹配 + 移动多位</strong>.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#KMP</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kmp_match</span><span class="params">(self, s, p)</span>:</span>  </span><br><span class="line">        m = len(s)</span><br><span class="line">        n = len(p)  </span><br><span class="line">        cur = <span class="number">0</span>  <span class="comment"># 起始指针cur，累积移动数  </span></span><br><span class="line">        table = self.partial_table(p)  </span><br><span class="line">        <span class="keyword">while</span> cur &lt;= m-n: <span class="comment"># 长度不够就终止  </span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n):  <span class="comment"># 一次p从头开始匹配的长度 </span></span><br><span class="line">                <span class="keyword">if</span> s[i+cur] != p[i]:  </span><br><span class="line">                    <span class="comment"># 移动位数 = 已匹配的字符数 - 对应的部分匹配值</span></span><br><span class="line">                    <span class="comment"># 有了部分匹配表,我们不只是单纯的1位1位往右移,可以一次移动多位  </span></span><br><span class="line">                    cur += max(i - table[i<span class="number">-1</span>], <span class="number">1</span>) </span><br><span class="line">                    <span class="keyword">break</span>  </span><br><span class="line">            <span class="keyword">else</span>: <span class="comment"># 执行了break就不会执行这句，相当于for循环里所有都满足 s[i+cur] == p[i]</span></span><br><span class="line">                <span class="keyword">return</span> cur <span class="comment"># 返回匹配开始的位置</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>  <span class="comment"># 匹配失败</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#部分匹配表  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partial_table</span><span class="params">(self, p)</span>:</span>  </span><br><span class="line">        <span class="string">'''''partial_table("ABCDABD") -&gt; [0, 0, 0, 0, 1, 2, 0]'''</span>  </span><br><span class="line">        prefix = set()  </span><br><span class="line">        table = [<span class="number">0</span>]  </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(p)):  <span class="comment"># 从1开始进行前后缀比较  </span></span><br><span class="line">            prefix.add(p[:i])  <span class="comment"># 前缀每次累加就行</span></span><br><span class="line">            postfix = set()</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, i+<span class="number">1</span>):  <span class="comment"># i+1 因为i需要包括</span></span><br><span class="line">                postfix.add(p[j:i+<span class="number">1</span>]) </span><br><span class="line">            <span class="comment"># print(prefix, postfix)</span></span><br><span class="line">            <span class="comment"># print(prefix&amp;postfix, len(prefix&amp;postfix))</span></span><br><span class="line">            <span class="comment"># table.append(len((sorted((prefix&amp;postfix),key = len)or &#123;''&#125;).pop()))</span></span><br><span class="line">            <span class="keyword">if</span> prefix&amp;postfix:</span><br><span class="line">                table.append(max(map(len,prefix&amp;postfix)))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                table.append(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> table</span><br></pre></td></tr></table></figure>
<h3 id="字符串去重"><a href="#字符串去重" class="headerlink" title="字符串去重"></a>字符串去重</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">string = <span class="string">'abc123456ab2s'</span>r = <span class="string">''</span>.join(x <span class="keyword">for</span> i, x <span class="keyword">in</span> enumerate(string) <span class="keyword">if</span> string.index(x) == i)</span><br></pre></td></tr></table></figure>
<h3 id="统计一个字符串中英文字母、空格、数字的个数"><a href="#统计一个字符串中英文字母、空格、数字的个数" class="headerlink" title="统计一个字符串中英文字母、空格、数字的个数"></a>统计一个字符串中英文字母、空格、数字的个数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line">s = raw_input(<span class="string">'请输入一个字符串:\n'</span>)</span><br><span class="line">letters = <span class="number">0</span></span><br><span class="line">space = <span class="number">0</span></span><br><span class="line">digit = <span class="number">0</span></span><br><span class="line">others = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">    <span class="keyword">if</span> c.isalpha():</span><br><span class="line">        letters += <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> c.isspace():</span><br><span class="line">        space += <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> c.isdigit():</span><br><span class="line">        digit += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        others += <span class="number">1</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'char = %d,space = %d,digit = %d,others = %d'</span> % (letters,space,digit,others)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数组解题</title>
    <url>/2018/09/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84%E8%A7%A3%E9%A2%98/</url>
    <content><![CDATA[<p> 数组相关题_python版 </p>
<h3 id="寻找某个值的区间（leetcode-34-Search-for-a-Range）"><a href="#寻找某个值的区间（leetcode-34-Search-for-a-Range）" class="headerlink" title="寻找某个值的区间（leetcode 34 Search for a Range）"></a>寻找某个值的区间（leetcode 34 Search for a Range）</h3><p>题目：这题要求在一个排好序可能有重复元素的数组里面找到包含某个值的区间范围。<strong>要求使用O(log n)的时间</strong>，所以我们采用两次二分查找。</p>
<blockquote>
<p>For Example：<br>Given [5, 7, 7, 8, 8, 10] and target value 8,<br>return [3, 4].</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param A, a list of integers</span></span><br><span class="line">    <span class="comment"># @param target, an integer to be searched</span></span><br><span class="line">    <span class="comment"># @return a list of length 2, [index1, index2]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchRange</span><span class="params">(self, A, target)</span>:</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = len(A) - <span class="number">1</span>      </span><br><span class="line">        result = [<span class="number">-1</span>, <span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = (left + right) / <span class="number">2</span>           </span><br><span class="line">            <span class="keyword">if</span> A[mid] &gt; target:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> A[mid] &lt; target:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: <span class="comment"># 找到时</span></span><br><span class="line">                result[<span class="number">0</span>] = mid</span><br><span class="line">                result[<span class="number">1</span>] = mid</span><br><span class="line">                </span><br><span class="line">                i = mid - <span class="number">1</span> <span class="comment"># 向前找</span></span><br><span class="line">                <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> A[i] == target:</span><br><span class="line">                    result[<span class="number">0</span>] = i</span><br><span class="line">                    i -= <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">                i = mid + <span class="number">1</span> <span class="comment"># 向后找</span></span><br><span class="line">                <span class="keyword">while</span> i &lt; len(A) <span class="keyword">and</span> A[i] == target:</span><br><span class="line">                    result[<span class="number">1</span>] = i</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h3 id="第K个数的问题"><a href="#第K个数的问题" class="headerlink" title="第K个数的问题"></a>第K个数的问题</h3><p>题目：这题是一道很好的面试题目，首先题目短小，很快就能说清题意而且有很多种解法。从简单到复杂的解法都有，梯度均匀。解决它不需要预先知道特殊领域知识。</p>
<p>这题有很多思路：</p>
<ol>
<li>按从大到小全排序，然后取第k个元素，时间复杂度O(nlogn)，空间复杂度O(1)</li>
<li>利用堆进行部分排序。维护一个大根堆，将数组元素全部压入堆，然后弹出k次，第k个就是答案。时间复杂度O(klogn)O(klogn)，空间复杂度O(n)O(n)</li>
<li>选择排序，第k次选择后即可得到第k大的数，时间复杂度O(nk)，空间复杂度O(1)</li>
</ol>
<p>以上三种方法时间复杂度太高。下面介绍两种<strong>更好的方法</strong>：</p>
<blockquote>
<p>维持K大小的堆排序（优先队列）</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">用容量为K的最大堆来存储最小的K个数。最大堆的堆顶元素就是最小K个数中的最大的一个。每次扫描一个数据X，如果X比堆顶元素Y大，则不需要改变原来的堆。如果X比堆顶元素小，那么用X替换堆顶元素Y，在替换之后，X可能破坏了最大堆的结构，需要调整堆来维持堆的性质。用优先队列思想也一样，只不过k大小的队列每次移动的元素量较大，堆会好一些。</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># 使用了heapq的内置数据结构，用了一个trick 因为默认是创建小顶堆，所以在添加元素的时候加个 负号就变成大顶堆了。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetLeastNumbers_Solution</span><span class="params">(self, tinput, k)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> k &gt; len(tinput) <span class="keyword">or</span> k == <span class="number">0</span>: <span class="keyword">return</span> []</span><br><span class="line">        heap = []</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> tinput:</span><br><span class="line">            <span class="keyword">if</span> len(heap) &lt; k:</span><br><span class="line">                heapq.heappush(heap, -num)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> -num &gt; heap[<span class="number">0</span>]:</span><br><span class="line">                    heapq.heapreplace(heap, -num)</span><br><span class="line">        <span class="keyword">return</span> sorted(list(map(<span class="keyword">lambda</span> x: x*<span class="number">-1</span>, heap)))</span><br></pre></td></tr></table></figure>
<blockquote>
<p> 快速排序，时间复杂度近似O（n） </p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">利用快速排序的思想，从数组S中随机找出一个元素X，把数组分为两部分Sa和Sb。Sa中的元素大于等于X，Sb中元素小于X。这时有两种情况：</span></span><br><span class="line"><span class="string">1. Sa中元素的个数小于k，则Sb中的第k-|Sa|个元素即为第k大数；</span></span><br><span class="line"><span class="string">2. Sa中元素的个数大于等于k，则返回Sa中的第k大数。时间复杂度近似为O(n)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">qselect</span><span class="params">(A,k)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(A)&lt;k:<span class="keyword">return</span> A</span><br><span class="line">    pivot = A[<span class="number">-1</span>]</span><br><span class="line">    right = [pivot] + [x <span class="keyword">for</span> x <span class="keyword">in</span> A[:<span class="number">-1</span>] <span class="keyword">if</span> x&gt;=pivot]</span><br><span class="line">    rlen = len(right)</span><br><span class="line">    <span class="keyword">if</span> rlen==k:</span><br><span class="line">        <span class="keyword">return</span> right</span><br><span class="line">    <span class="keyword">if</span> rlen&gt;k:</span><br><span class="line">        <span class="keyword">return</span> qselect(right, k)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        left = [x <span class="keyword">for</span> x <span class="keyword">in</span> A[:<span class="number">-1</span>] <span class="keyword">if</span> x&lt;pivot]</span><br><span class="line">        <span class="keyword">return</span> qselect(left, k-rlen) + right</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">    <span class="keyword">print</span> qselect([<span class="number">11</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">9</span>], i)</span><br></pre></td></tr></table></figure>
<h3 id="求根算法（-LeetCode-69）"><a href="#求根算法（-LeetCode-69）" class="headerlink" title="求根算法（ LeetCode 69）"></a>求根算法（ LeetCode 69）</h3><p>题目：计算并返回 x 的平方根，其中 x 是非负整数。 由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p>
<p>思路一：直接从1到x/2之间遍历，判断是否是平方根的条件是，i*i小于等于x并且小于等于x并且(i+1)*(i+1)大于x，则返回i。超时 。</p>
<p>思路二：二分查找法。初始化i=0，j=x，mid=0。进入循环，找到中间值mid = (i + j) / 2，如果mid&gt;x / mid，表示mid不是平方根，且数值过大，则j=mid。如果mid小于等于x / mid，则判断(mid + 1) &gt; x / (mid + 1)，表示mid*mid小于x，并且mid再加1后的平方就会比x大，这表示mid就是那个平方根，返回mid。否则表示mid过小，i=mid。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type x: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> x==<span class="number">0</span> <span class="keyword">or</span> x==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">        i=<span class="number">0</span></span><br><span class="line">        j=x</span><br><span class="line">        mid=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            mid=(i+j)/<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> mid&gt;x/mid:</span><br><span class="line">                j=mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> (mid+<span class="number">1</span>)&gt;x/(mid+<span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">return</span> mid</span><br><span class="line">                i=mid</span><br></pre></td></tr></table></figure>
<h3 id="数组中后面的数减前面的数的差的最大值"><a href="#数组中后面的数减前面的数的差的最大值" class="headerlink" title="数组中后面的数减前面的数的差的最大值"></a>数组中后面的数减前面的数的差的最大值</h3><p>题目：如何求数组中数对差最大。数对差是指一个数组中某两个元素a和b（并且a排在b的前面），a减去b所得到的差值。</p>
<p>思路一：遍历存储最大值</p>
<p>思路二：首先求出数组中任意一对相邻的数据之间的差值，得到一个新的数组。如果某两个数据之间的数对差最大，也就是说这两个数据之间的差值最大。假设这两个数据的位置是i和j，那么这两个位置之间的数据是a[i]，a[i+1]，a[i+2]……，a[j-1]，a[j]。那么a[i]-a[j]=(a[i]-a[i+1])+(a[i+1]-a[i+2])+……(a[j-1]-a[j])，括号中的数据是相邻数据的差值，都已经在前面求出来了。<strong>然后这个问题就转化为了求数组中连续的子数组和最大的问题</strong>，这个问题可以通过动态规划问题求出来。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Max</span><span class="params">(firstNum,secondNum)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> firstNum&gt;=secondNum:</span><br><span class="line">		<span class="keyword">return</span> firstNum</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		<span class="keyword">return</span> secondNum</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Count</span><span class="params">(array)</span>:</span></span><br><span class="line">	gapArray=[]</span><br><span class="line">	length=len(array)</span><br><span class="line">	<span class="comment">#遍历一遍记录相邻两个之间的gap</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> xrange(length<span class="number">-1</span>):</span><br><span class="line">		gap=array[i]-array[i+<span class="number">1</span>]</span><br><span class="line">		gapArray.append(gap)</span><br><span class="line">	<span class="comment">#转化为子集合最大和问题</span></span><br><span class="line">	max=-((<span class="number">1</span>&lt;&lt;<span class="number">32</span>)<span class="number">-1</span>)</span><br><span class="line">	sum=<span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(gapArray)):</span><br><span class="line">		sum+=gapArray[i]</span><br><span class="line">		max=Max(max,sum)</span><br><span class="line">		<span class="keyword">if</span> sum&lt;<span class="number">0</span>:</span><br><span class="line">			sum=<span class="number">0</span></span><br><span class="line">	<span class="keyword">return</span> max</span><br><span class="line"> </span><br><span class="line">array=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">20</span>):</span><br><span class="line">	array.append(random.randint(<span class="number">0</span>,<span class="number">50</span>))</span><br><span class="line"><span class="keyword">print</span> array</span><br><span class="line"><span class="keyword">print</span> <span class="string">"max gap:"</span>+str(Count(array))</span><br></pre></td></tr></table></figure>
<h3 id="合并多个有序数组"><a href="#合并多个有序数组" class="headerlink" title="合并多个有序数组"></a>合并多个有序数组</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#采用归并排序算法</span></span><br><span class="line"><span class="comment">#拆解到最后，实际变成两个数组进行排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MergeSort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="comment">#请牢记传入的参数是多维数组</span></span><br><span class="line">    <span class="comment">#此处是递归出口</span></span><br><span class="line">    <span class="keyword">if</span> len(nums) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    mid = len(nums) // <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#记住此处得到的也是多维数组</span></span><br><span class="line">    Left = MergeSort(nums[:mid])</span><br><span class="line">    Right = MergeSort(nums[mid:])</span><br><span class="line"></span><br><span class="line">    <span class="comment">#print(Left[0], Right[0])</span></span><br><span class="line">    <span class="comment">#要传入的参数是数组中第一个索引处的值</span></span><br><span class="line">    <span class="keyword">return</span> Sort_list(Left[<span class="number">0</span>], Right[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Sort_list</span><span class="params">(Left, Right)</span>:</span></span><br><span class="line">    <span class="comment">#存储排序后的值</span></span><br><span class="line">    res = []</span><br><span class="line">    a = <span class="number">0</span></span><br><span class="line">    b = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> a &lt; len(Left) <span class="keyword">and</span> b &lt; len(Right):</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> Left[a] &lt; Right[b]:</span><br><span class="line">            res.append(Left[a])</span><br><span class="line">            a += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res.append(Right[b])</span><br><span class="line">            b += <span class="number">1</span></span><br><span class="line">    res = res + Left[a:] + Right[b:]</span><br><span class="line">    <span class="comment"># 转为二维数组</span></span><br><span class="line">    res = [res]</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="两个有序数组求差集"><a href="#两个有序数组求差集" class="headerlink" title="两个有序数组求差集"></a>两个有序数组求差集</h3><p>思路一：依次取出较小数组的元素，然后再另外一个数组上进行二分查找</p>
<p>思路二：用齐头并进的两个下标</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intersect</span><span class="params">(self, nums1, nums2)</span>:</span></span><br><span class="line">        nums3 = []</span><br><span class="line">        nums1.sort()</span><br><span class="line">        nums2.sort()</span><br><span class="line">        m = len(nums1)</span><br><span class="line">        n = len(nums2)</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;m <span class="keyword">and</span> j&lt;n:</span><br><span class="line">            <span class="keyword">if</span> nums1[i] == nums2[j]:</span><br><span class="line">                nums3.append(nums1[i])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums1[i] &gt; nums2[j]:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> nums3</span><br></pre></td></tr></table></figure>
<h3 id="两个集合如何求并集，交集；"><a href="#两个集合如何求并集，交集；" class="headerlink" title="两个集合如何求并集，交集；"></a>两个集合如何求并集，交集；</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python集合支持一系列标准操作，包括并集、交集、差集和对称差集，例如：  </span><br><span class="line"></span><br><span class="line">a = t | s          <span class="comment"># t 和 s的并集  </span></span><br><span class="line">  </span><br><span class="line">b = t &amp; s          <span class="comment"># t 和 s的交集  </span></span><br><span class="line">  </span><br><span class="line">c = t – s          <span class="comment"># 求差集（项在t中，但不在s中）</span></span><br></pre></td></tr></table></figure>
<h3 id="给定一个数组求中位数"><a href="#给定一个数组求中位数" class="headerlink" title="给定一个数组求中位数"></a>给定一个数组求中位数</h3><p>(中位数，就是数组排序后处于数组最中间的那个元素)</p>
<p>思路：和TOP k问题一样，这里就不写了。（先排序再取中位数不优）</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>链表解题</title>
    <url>/2018/09/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8%E8%A7%A3%E9%A2%98/</url>
    <content><![CDATA[<p>链表相关题_python版</p>
<h3 id="在O-1-时间删除链表结点"><a href="#在O-1-时间删除链表结点" class="headerlink" title="在O(1)时间删除链表结点"></a>在O(1)时间删除链表结点</h3><p><strong>题目</strong>：给定单向链表的头指针和一个结点指针，定义一个函数在O(1)时间删除该结点。</p>
<p><strong>思路</strong>：我们要删除结点i，先把i的下一个结点i.next的内容复制到i，然后在把i的指针指向i.next结点的下一个结点即i.next.next，它的效果刚好是把结点i给删除了。<strong>需要考虑如果这个节点是链表的尾节点那么就需要从头遍历这个链表了。</strong>（通常，在单向链表中，删除一个链表的结点，都会先从表头开始遍历整个链表，找到需要删除的结点的前一个结点，然后将这个结点的(指向下一个结点的)指针元素指向需要删除结点的下一个结点，最后把需要删除的结点删除．但此过程的平均时间复杂度为 O(n)． ）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self.value = value</span><br><span class="line">        self.next_ = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span><span class="params">(self,pHead,Node)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> Node == <span class="literal">None</span> <span class="keyword">or</span> pHead == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> Node.next != <span class="literal">None</span>: <span class="comment"># else情况1：只有一个Node节点；情况2：Node节点在尾巴</span></span><br><span class="line">            Node.val = Node.next.val</span><br><span class="line">            Node.next = Node.next.next</span><br><span class="line">        <span class="keyword">elif</span> Node == pHead:<span class="comment"># 如果链表只有一个节点，那么就把头节点删掉就好了</span></span><br><span class="line">            pHead.val = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pNode = pHead  <span class="comment"># 把Node节点删除，然后接上一个None</span></span><br><span class="line">            <span class="keyword">while</span> pNode.next != Node:</span><br><span class="line">                pNode = pNode.next</span><br><span class="line">            pNode.next = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> pHead</span><br></pre></td></tr></table></figure>
<h3 id="合并两个排序的链表-要求不新建链表"><a href="#合并两个排序的链表-要求不新建链表" class="headerlink" title="合并两个排序的链表(要求不新建链表)"></a>合并两个排序的链表(要求不新建链表)</h3><p><strong>题目</strong>：输入两个递增排序的链表，合并这两个链表并使新链表中的结点仍然是按照递增排序的。</p>
<p><strong>思路</strong>：非递归情况：<strong>找到两个链表中头节点值相对更小的链表，将其作为主链表，第二个链表中的元素则不断加入到主链表中</strong>。具体策略是：主链表定义两个指针，指向两个相邻的元素。<strong>当第二个链表中的元素值小于主链表中第二个指针时，将第二个链表的当前元素插入到主链表两个指针指向的元素中间</strong>，并调整指针指向。 不要让链表断开，考虑链表为空的几种情况。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  ============非递归版本===============</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Merge</span><span class="params">(self, pHead1, pHead2)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> pHead1:</span><br><span class="line">        <span class="keyword">return</span> pHead2</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> pHead2:</span><br><span class="line">        <span class="keyword">return</span>  pHead1</span><br><span class="line">    mainHead = pHead1 <span class="keyword">if</span> pHead1.val &lt;= pHead2.val <span class="keyword">else</span> pHead2 <span class="comment"># 主链</span></span><br><span class="line">    secHead = pHead2 <span class="keyword">if</span> mainHead == pHead1 <span class="keyword">else</span> pHead1 <span class="comment"># 副链</span></span><br><span class="line">    mergeHead = mainHead</span><br><span class="line">    mainNext = mainHead.next <span class="comment"># 主链第二个指针</span></span><br><span class="line">    <span class="keyword">while</span> mainNext <span class="keyword">and</span> secHead: </span><br><span class="line">        <span class="keyword">if</span> secHead.val &lt;= mainNext.val: <span class="comment"># 副链节点插入到两个指针之间</span></span><br><span class="line">            mainHead.next = secHead <span class="comment"># 第一个指针连接到副链头指针</span></span><br><span class="line">            secHead = secHead.next <span class="comment"># 副链头指针后移</span></span><br><span class="line">            mainHead.next.next = mainNext <span class="comment"># 副链头指针连接到第二个指针</span></span><br><span class="line">            mainHead = mainHead.next <span class="comment"># 第一个指针后移（变成原副链的头指针），插入操作第二个指针不需要后移</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            mainHead = mainNext</span><br><span class="line">            mainNext = mainNext.next</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> mainNext: <span class="comment"># 副链元素都比第二个指针要大，不能插入，要拼接</span></span><br><span class="line">        mainHead.next = secHead</span><br><span class="line">    <span class="keyword">return</span> mergeHead</span><br><span class="line"><span class="comment"># ==================递归版本=================</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回合并后列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Merge</span><span class="params">(self, pHead1, pHead2)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> pHead1 <span class="keyword">is</span> <span class="literal">None</span>: <span class="comment"># 处理末尾状态，pHead1为空，要拼接的就是pHead2了</span></span><br><span class="line">            <span class="keyword">return</span> pHead2</span><br><span class="line">        <span class="keyword">if</span> pHead2 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> pHead1</span><br><span class="line">        <span class="keyword">if</span> pHead1.val &lt; pHead2.val:</span><br><span class="line">            pHead1.next = self.Merge(pHead1.next,pHead2)</span><br><span class="line">            <span class="keyword">return</span> pHead1 <span class="comment"># 返回整段拼接后的链表</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pHead2.next = self.Merge(pHead1,pHead2.next)</span><br><span class="line">            <span class="keyword">return</span> pHead2</span><br></pre></td></tr></table></figure>
<h3 id="二叉搜索树与双向链表"><a href="#二叉搜索树与双向链表" class="headerlink" title="二叉搜索树与双向链表"></a>二叉搜索树与双向链表</h3><p><strong>题目</strong>：输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向 ，例如</p>
<p><img src="/2018/09/11/数据结构与算法/链表解题/01.jpg" alt></p>
<p><strong>思路</strong>：</p>
<ol>
<li>核心算法依旧是中序遍历</li>
<li>不是从根节点开始，而是从中序遍历得到的第一个节点开始</li>
<li>定义两个辅助节点listHead(链表头节点)、listTail(链表尾节点)。事实上，二叉树只是换了种形式的链表；<strong>listHead用于记录链表的头节点，用于最后算法的返回；listTail用于定位当前需要更改指向的节点</strong>。了解了listHead和listTail的作用，代码理解起来至少顺畅80%。</li>
</ol>
<p>过程图示例</p>
<p><img src="/2018/09/11/数据结构与算法/链表解题/03.png" alt></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">稍微多说一句，其实这段代码也就5行，2行是中序遍历的代码；3行是更改节点指向的代码，为if、else行。if语句段只有在中序遍历到第一个节点时调用，自此之后listHead不变，listTail跟随算法的进度。对比中序遍历可以看出来，实际上只是中序遍历中的第八行代码被上述的if-else语句替代了，仅此而已。</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line">        self.val = x</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.listHead = <span class="literal">None</span></span><br><span class="line">        self.listTail = <span class="literal">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Convert</span><span class="params">(self, pRootOfTree)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> pRootOfTree==<span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.Convert(pRootOfTree.left)</span><br><span class="line">        <span class="keyword">if</span> self.listHead==<span class="literal">None</span>:  <span class="comment"># if/else替换中序遍历存储值</span></span><br><span class="line">            self.listHead = pRootOfTree <span class="comment"># if这一段只有中序遍历的第一个节点出现，即最左子树</span></span><br><span class="line">            self.listTail = pRootOfTree <span class="comment"># 此时，链表头尾指针都指向中序第一个节点</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.listTail.right = pRootOfTree <span class="comment"># 尾指针与中序下一个节点互连，有right属性是因为上一步self.listTail和self.listHead已经指向pRootOfTree了</span></span><br><span class="line">            pRootOfTree.left = self.listTail</span><br><span class="line">            self.listTail = pRootOfTree <span class="comment"># 尾指针指向中序下一个节点</span></span><br><span class="line">        self.Convert(pRootOfTree.right)</span><br><span class="line">        <span class="keyword">return</span> self.listHead</span><br></pre></td></tr></table></figure>
<h3 id="翻转部分链表"><a href="#翻转部分链表" class="headerlink" title="翻转部分链表"></a>翻转部分链表</h3><p>题目：给定一个单链表的头指针 head， 以及两个整数 a 和 b下标，在单链表中反转 linked_list[a-b] 的结点，然后返回整个链表的头指针 。</p>
<p>思路：采用翻转单链表的思路，回顾一下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">翻转单链表</span></span><br><span class="line"><span class="string">思路很简单：1-&gt;2-&gt;3-&gt;4-&gt;5，遍历链表，把1的next置为None，2的next置为1，以此类推，5的next置为4。得到反转链表。</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回ListNode</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ReverseList</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> pHead==<span class="literal">None</span> <span class="keyword">or</span> pHead.next==<span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> pHead</span><br><span class="line">        pre = <span class="literal">None</span> <span class="comment"># 前指针</span></span><br><span class="line">        cur = pHead <span class="comment"># 当前指针</span></span><br><span class="line">        <span class="keyword">while</span> cur!=<span class="literal">None</span>:</span><br><span class="line">            tmp = cur.next <span class="comment"># 记录下一个指针，为下一步当前指针后移准备</span></span><br><span class="line">            cur.next = pre</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = tmp</span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 翻转部分链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBetween</span><span class="params">(self, head, m, n)</span>:</span></span><br><span class="line">        <span class="comment"># 计算需要逆至的节点数</span></span><br><span class="line">        reverse_length = n - m + <span class="number">1</span></span><br><span class="line">        pre_head = <span class="literal">None</span> <span class="comment"># 初始化要记录的前驱节点</span></span><br><span class="line">        result = head   <span class="comment"># 最终转换后要返回的链表头结点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将head向后移动m-1个位置</span></span><br><span class="line">        <span class="keyword">while</span> head <span class="keyword">and</span> m &gt; <span class="number">1</span>:</span><br><span class="line">            pre_head = head</span><br><span class="line">            head = head.next</span><br><span class="line">            m -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 记录翻转后的链表尾部，翻转后的尾巴即为当前head</span></span><br><span class="line">        modify_list_tail = head</span><br><span class="line">        pre = <span class="literal">None</span> <span class="comment"># 前指针</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 逆置n - m + 1个节点</span></span><br><span class="line">        <span class="keyword">while</span> head <span class="keyword">and</span> reverse_length: <span class="comment">#和翻转单链表一样，翻转后和第一、第三段是断开的</span></span><br><span class="line">            tmp = head.next </span><br><span class="line">            head.next = pre</span><br><span class="line">            pre = head</span><br><span class="line">            head = tmp</span><br><span class="line">            reverse_length -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 此时，尾巴为空， modify_list_tail指向最后一个非空元素</span></span><br><span class="line">        <span class="comment"># 连接逆置后的链表尾与第三段的头结点结合，此时head已经指向第三段正序的头结点</span></span><br><span class="line">        modify_list_tail.next = head</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果pre_head不为空，说明不是从第一个节点开始逆至，即m&gt;1</span></span><br><span class="line">        <span class="keyword">if</span> pre_head <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># pre_head指向第一段最后一个元素，连接逆序后的头结点</span></span><br><span class="line">            pre_head.next = pre <span class="comment">#pre指向逆序后头结点，head为第三段的头结点</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 此时m=1，则逆置后的头结点就是链表的头结点，即翻转整个单链表</span></span><br><span class="line">            result = pre</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h3 id="链表插入排序-leetcode-147-Insertion-Sort-List"><a href="#链表插入排序-leetcode-147-Insertion-Sort-List" class="headerlink" title="链表插入排序(leetcode 147 Insertion Sort List)"></a>链表插入排序(leetcode 147 Insertion Sort List)</h3><p>题目：利用插入排序对链表进行排序</p>
<p>思路：1-&gt;3-&gt;2-&gt;4-&gt;null，将头结点和后面的部分断开，变成1-&gt;null和3-&gt;2-&gt;4-&gt;null，1-&gt;null看做是排好序的部分，添加的时候依次取后面的那部分的节点，比如在这里，先取3，然后对前面排好序的链表从前往后遍历，找到应该插入的位置即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Definition of ListNode</span></span><br><span class="line"><span class="string">class ListNode(object):</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    def __init__(self, val, next=None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.next = next</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param: head: The first node of linked list.</span></span><br><span class="line"><span class="string">    @return: The head of linked list.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertionSortList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> head.next <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        l=ListNode(<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            node=l <span class="comment"># 每次从头开始</span></span><br><span class="line">            fol=head.next <span class="comment"># 保持下一个，防止断开</span></span><br><span class="line">            <span class="keyword">while</span> node.next <span class="keyword">and</span> node.next.val &lt; head.val: <span class="comment"># 插入到node和node.next之间</span></span><br><span class="line">                node = node.next</span><br><span class="line">            head.next = node.next  <span class="comment"># 先连接后面head-&lt;node.next</span></span><br><span class="line">            node.next = head     <span class="comment"># 再连接前面</span></span><br><span class="line">            head = fol</span><br><span class="line">        <span class="keyword">return</span> l.next</span><br></pre></td></tr></table></figure>
<h3 id="链表归并排序-leetcode-148-Sort-List"><a href="#链表归并排序-leetcode-148-Sort-List" class="headerlink" title="链表归并排序(leetcode 148 Sort List)"></a>链表归并排序(leetcode 148 Sort List)</h3><p>题目：要求我们用O(nlogn)算法对链表进行排序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, val, next=None)</span>:</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.next = next</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 归并法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> head.next <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        pre = head</span><br><span class="line">        slow = head               <span class="comment"># 使用快慢指针来确定中点</span></span><br><span class="line">        fast = head</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">            pre = slow</span><br><span class="line">            slow = slow.next</span><br><span class="line">            fast = fast.next.next</span><br><span class="line">        </span><br><span class="line">        left = head  </span><br><span class="line">        right = pre.next  <span class="comment"># 第二段头结点</span></span><br><span class="line">        pre.next = <span class="literal">None</span>           <span class="comment"># 从中间打断链表</span></span><br><span class="line">        left = self.sortList(left)  </span><br><span class="line">        right = self.sortList(right)  </span><br><span class="line">        <span class="keyword">return</span> self.merge(left,right)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, left, right)</span>:</span> <span class="comment">#合并两个有序链表</span></span><br><span class="line">        pre = ListNode(<span class="number">-1</span>) <span class="comment"># 新链表</span></span><br><span class="line">        first = pre <span class="comment"># 新链表头结点</span></span><br><span class="line">        <span class="keyword">while</span> left <span class="keyword">and</span> right:</span><br><span class="line">            <span class="keyword">if</span> left.val &lt; right.val:</span><br><span class="line">                pre.next = left</span><br><span class="line">                pre = left</span><br><span class="line">                left = left.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre.next = right</span><br><span class="line">                pre = right</span><br><span class="line">                right = right.next</span><br><span class="line">        <span class="keyword">if</span> left:</span><br><span class="line">            pre.next = left</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pre.next = right             </span><br><span class="line">        <span class="keyword">return</span> first.next</span><br></pre></td></tr></table></figure>
<h3 id="两两交换链表中相邻的两个元素"><a href="#两两交换链表中相邻的两个元素" class="headerlink" title="两两交换链表中相邻的两个元素"></a>两两交换链表中相邻的两个元素</h3><p><strong>题目</strong>：交换链表中相邻的两个元素。 注意第一个节点与第二个节点要交换位置，而第二个节点不用与第三个节点交换位置。 如要交换链表中A-&gt;B-&gt;C-&gt;D中的B和C需要做如下操作（<strong>交换B和C</strong>）：</p>
<ul>
<li>将A指向C</li>
<li>将B指向D</li>
<li>将C指向B</li>
</ul>
<p>思路：在头节点之前加一个假节点就可以使所有的交换都符合上面的情况。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        dummy = ListNode(<span class="number">-1</span>)</span><br><span class="line">        dummy.next = head <span class="comment"># 假结点连接原链表</span></span><br><span class="line">        temp = dummy <span class="comment"># 头结点</span></span><br><span class="line">        <span class="keyword">while</span> temp.next <span class="keyword">and</span> temp.next.next:</span><br><span class="line">            node1 = temp.next  <span class="comment"># node1是B</span></span><br><span class="line">            node2 = temp.next.next  <span class="comment"># node2是C</span></span><br><span class="line">            temp.next = node2  <span class="comment"># A指向C</span></span><br><span class="line">            node1.next = node2.next  <span class="comment"># B指向D</span></span><br><span class="line">            node2.next = node1  <span class="comment"># C指向B</span></span><br><span class="line">            temp = temp.next.next  <span class="comment"># 跳过两个</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure>
<h3 id="判断两个链表相交和相交的第一个节点"><a href="#判断两个链表相交和相交的第一个节点" class="headerlink" title="判断两个链表相交和相交的第一个节点"></a>判断两个链表相交和相交的第一个节点</h3><p>思路1：链表两个链表的长度差diff，然后快指针先走diff步，然后快慢指针一起走。直到两个指针相同，否则无相交节点。（需要先遍历得到两个链表长度）</p>
<p>思路2：两个指针一起走，当一个指针p1走到终点时，说明p1所在的链表比较短，让p1指向另一个链表的头结点开始走，直到p2走到终点，让p2指向短的链表的头结点，那么，接下来两个指针要走的长度就一样了 ，然后就可以一起走，直到两个指针相同。(若无交点，可以一开始在链表尾巴的设置一个标志点)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 思路二</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindFirstCommonNode</span><span class="params">(self, pHead1, pHead2)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead1 <span class="keyword">or</span> <span class="keyword">not</span> pHead2:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        p1, p2 = pHead1, pHead2</span><br><span class="line">        <span class="keyword">while</span> p1 != p2:</span><br><span class="line">            p1 = pHead2 <span class="keyword">if</span> <span class="keyword">not</span> p1 <span class="keyword">else</span> p1.next</span><br><span class="line">            p2 = pHead1 <span class="keyword">if</span> <span class="keyword">not</span> p2 <span class="keyword">else</span> p2.next</span><br><span class="line">        <span class="keyword">return</span> p1</span><br></pre></td></tr></table></figure>
<h3 id="分隔链表"><a href="#分隔链表" class="headerlink" title="分隔链表"></a>分隔链表</h3><p><strong>题目：</strong>给定一个链表以及一个目标值，把小于该目标值的所有节点都移至链表的前端，大于或等于目标值的节点移至链表的尾端，同时要保持这两部分在原先链表中的相对位置。</p>
<p><strong>思路</strong>：两个链表指针，一个负责收集比目标小的，一个收集大于等于目标的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, head, x)</span>:</span></span><br><span class="line">        dummy = ListNode(<span class="number">-1</span>)</span><br><span class="line">        dummy.next = head</span><br><span class="line">        small_dummy = ListNode(<span class="number">-1</span>)</span><br><span class="line">        large_dummy = ListNode(<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># small_prev和large_prev往后遍历增加，small_dummy和large_dummy则负责最后作为返回头结点</span></span><br><span class="line">        small_prev = small_dummy</span><br><span class="line">        large_prev = large_dummy</span><br><span class="line">        <span class="keyword">while</span> dummy.next:  <span class="comment"># head第一个节点</span></span><br><span class="line">            curr = dummy.next</span><br><span class="line">            <span class="keyword">if</span> curr.val &lt; x:</span><br><span class="line">                small_prev.next = curr</span><br><span class="line">                small_prev = small_prev.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                large_prev.next = curr</span><br><span class="line">                large_prev = large_prev.next</span><br><span class="line">            dummy = dummy.next</span><br><span class="line"></span><br><span class="line">        large_prev.next = <span class="literal">None</span>  <span class="comment"># 最后指针置为none</span></span><br><span class="line">        small_prev.next = large_dummy.next  <span class="comment"># large_dummy对应的是大链表的第一个数</span></span><br><span class="line">        <span class="keyword">return</span> small_dummy.next  <span class="comment"># 返回的是small_dummy</span></span><br></pre></td></tr></table></figure>
<h3 id="重排链表"><a href="#重排链表" class="headerlink" title="重排链表"></a>重排链表</h3><p>将单向链表L0→L1→…→Ln-1→Ln转化为L0→Ln→L1→Ln-1→L2→Ln-2→…的形式，也就是从头部取一个节点，从尾部取一个节点，直到将原链表转化成新的链表。</p>
<p>思路：</p>
<ol>
<li>去中间节点，将链表分为两段.</li>
<li>翻转后一段</li>
<li>拼接</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reorderList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># split &#123;1,2,3,4,5&#125; to &#123;1,2,3&#125;&#123;4,5&#125;</span></span><br><span class="line">        fast = slow = head </span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">            slow = slow.next</span><br><span class="line">            fast = fast.next.next</span><br><span class="line">        head1 = head</span><br><span class="line">        head2 = slow.next</span><br><span class="line">        slow.next = <span class="literal">None</span></span><br><span class="line">        <span class="comment"># reverse the second &#123;4,5&#125; to &#123;5,4&#125;</span></span><br><span class="line">        cur, pre = head2, <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            tmp = cur.next <span class="comment"># 标记下一个</span></span><br><span class="line">            cur.next = pre</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = tmp</span><br><span class="line">        <span class="comment"># merge</span></span><br><span class="line">        cur1, cur2 = head1, pre</span><br><span class="line">        <span class="keyword">while</span> cur2:</span><br><span class="line">            nex1, nex2 = cur1.next, cur2.next</span><br><span class="line">            cur1.next = cur2</span><br><span class="line">            cur2.next = nex1</span><br><span class="line">            cur1, cur2 = nex1, nex2</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>经典排序总结</title>
    <url>/2018/09/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>先看一个排序算法可视化大概了解一下经典的排序算法。</p>
<p><a href="http://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html" target="_blank" rel="noopener">排序算法可视化</a></p>
<h2 id="冒泡排序-BubbleSort"><a href="#冒泡排序-BubbleSort" class="headerlink" title="冒泡排序 BubbleSort"></a>冒泡排序 BubbleSort</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>冒泡排序(bubble sort)：每个回合都从第一个元素开始和它后面的元素比较，如果比它后面的元素更大的话就交换，一直重复，直到这个元素到了它能到达的位置。每次遍历都将剩下的元素中最大的那个放到了序列的“最后”(除去了前面已经排好的那些元素)。注意检测是否已经完成了排序，如果已完成就可以退出了。</p>
<p><img src="/2018/09/11/数据结构与算法/经典排序总结/01.jpg" alt></p>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对第0个到第n-1个数据做同样的工作。这时，最大的数就“浮”到了数组最后的位置上。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ol>
<h3 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h3><p><strong>Python源代码（错误版本）：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(arry)</span>:</span></span><br><span class="line">    n = len(arry)                   <span class="comment">#获得数组的长度</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span>  arry[i] &gt; arry[j] :       <span class="comment">#如果前者比后者大</span></span><br><span class="line">                arry[i],arry[j] = arry[j],arry[i]      <span class="comment">#则交换两者</span></span><br><span class="line">    <span class="keyword">return</span> arry</span><br></pre></td></tr></table></figure>
<blockquote>
<p> 注：上述代码是没有问题的，但是实现却不是冒泡排序，而是选择排序（原理见选择排序），注意冒泡排序的本质是“相邻元素”的顺序交换，而非每次完成一个最小数字的选定。 </p>
</blockquote>
<p> <strong>Python源代码（正确版本）：</strong> </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(arry)</span>:</span></span><br><span class="line">    n = len(arry)                   <span class="comment">#获得数组的长度</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">    <span class="comment"># 这里n-i有可能是最后的下标，如果用j和j+1会超过数组限制，所以应该用j-1和j，把 range改为（1，n-i）</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n-i):     <span class="comment"># 每轮找到最大数值，n-i因为前面已经确定i个最大值，只需比较剩下n-i个</span></span><br><span class="line">            <span class="keyword">if</span>  arry[j<span class="number">-1</span>] &gt; arry[j] :       <span class="comment">#如果前者比后者大</span></span><br><span class="line">                arry[j<span class="number">-1</span>],arry[j] = arry[j],arry[j<span class="number">-1</span>]      <span class="comment">#则交换两者</span></span><br><span class="line">    <span class="keyword">return</span> arry</span><br></pre></td></tr></table></figure>
<p><strong>优化1：</strong></p>
<p>某一趟遍历如果没有数据交换，则说明已经排好序了，因此不用再进行迭代了。用一个标记记录这个状态即可。</p>
<p><strong>Python源代码：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort2</span><span class="params">(ary)</span>:</span></span><br><span class="line">    n = len(ary)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        flag = <span class="literal">False</span>    <span class="comment"># 标记</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n - i):</span><br><span class="line">            <span class="keyword">if</span> ary[j] &lt; ary[j<span class="number">-1</span>]:</span><br><span class="line">                ary[j], ary[j<span class="number">-1</span>] = ary[j<span class="number">-1</span>], ary[j]</span><br><span class="line">                flag = <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 某一趟遍历如果没有数据交换，则说明已经排好序了，因此不用再进行迭代了</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> flag:    </span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> ary</span><br></pre></td></tr></table></figure>
<h2 id="选择排序-SelectionSort"><a href="#选择排序-SelectionSort" class="headerlink" title="选择排序 SelectionSort"></a>选择排序 SelectionSort</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>每个回合都选择出剩下的元素中最大的那个，选择的方法是首先默认第一元素是最大的，如果后面的元素比它大的话，那就更新剩下的最大的元素值，找到剩下元素中最大的之后将它放入到合适的位置就行了。和冒泡排序类似，只是找剩下的元素中最大的方式不同而已。</p>
<p><img src="/2018/09/11/数据结构与算法/经典排序总结/02.jpg" alt></p>
<h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</li>
<li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li>
<li>以此类推，直到所有元素均排序完毕。</li>
</ol>
<h3 id="源代码-1"><a href="#源代码-1" class="headerlink" title="源代码"></a>源代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_sort</span><span class="params">(ary)</span>:</span></span><br><span class="line">    n = len(ary)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,n):</span><br><span class="line">        min = i                             <span class="comment"># 最小元素下标标记，这句是最重要的</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">if</span> ary[j] &lt; ary[min] :</span><br><span class="line">                min = j                     <span class="comment"># 找到最小值的下标</span></span><br><span class="line">        ary[min],ary[i] = ary[i],ary[min]   <span class="comment"># 交换两者</span></span><br><span class="line">    <span class="keyword">return</span> ary</span><br></pre></td></tr></table></figure>
<h2 id="插入排序-Insertion-Sort"><a href="#插入排序-Insertion-Sort" class="headerlink" title="插入排序 Insertion Sort"></a>插入排序 Insertion Sort</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p>插入排序的工作原理是，<strong>对于每个未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入</strong>。 对具有nn个数据元素的序列进行排序时，插入排序需要进行n−1n−1趟插入。进行第j(1≥j≥n−1)j(1≥j≥n−1)趟插入时，前面已经有jj个元素排好序了，第jj趟将aj+1aj+1插入到已经排好序的序列中，这样既可使前面的j+1j+1个数据排好序。</p>
<p><img src="/2018/09/11/数据结构与算法/经典排序总结/03.gif" alt></p>
<h3 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>从第一个元素开始，该元素可以认为已经被排序</li>
<li>取出下一个元素，<strong>在已经排序的元素序列中从后向前扫描</strong></li>
<li><strong>如果被扫描的元素（已排序）大于新元素，将该元素后移一位</strong></li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li>
<li>将新元素插入到该位置后</li>
<li>重复步骤2~5</li>
</ol>
<h3 id="源代码-2"><a href="#源代码-2" class="headerlink" title="源代码"></a>源代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span><span class="params">(ary)</span>:</span></span><br><span class="line">    n = len(ary)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">        pre_key = i - <span class="number">1</span> <span class="comment"># 往前的下标</span></span><br><span class="line">        mark = ary[i] <span class="comment"># 记录当前元素 这两句很重要</span></span><br><span class="line">        <span class="keyword">while</span> pre_key &gt;= <span class="number">0</span> <span class="keyword">and</span> ary[pre_key] &gt; mark:  <span class="comment"># 找到第一个比mark的小的元素或到头时结束</span></span><br><span class="line">            ary[pre_key+<span class="number">1</span>] = ary[pre_key]  <span class="comment"># 往后移一位</span></span><br><span class="line">            pre_key -= <span class="number">1</span></span><br><span class="line">        ary[pre_key+<span class="number">1</span>] = mark   <span class="comment"># 找到并插入（想象一个简单的例子）</span></span><br><span class="line">    <span class="keyword">return</span> ary</span><br></pre></td></tr></table></figure>
<h2 id="希尔排序-ShellSort"><a href="#希尔排序-ShellSort" class="headerlink" title="希尔排序 ShellSort"></a>希尔排序 ShellSort</h2><h3 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h3><p>希尔排序，也称递减增量排序算法，实质是<strong>分组插入排序</strong>。由 Donald Shell 于1959年提出。希尔排序是非稳定排序算法。</p>
<p>希尔排序的基本思想是：先将整个待排元素序列分割成若干个子序列（由相隔某个“增量”的元素组成的）<strong>分别进行直接插入排序</strong>，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。因为直接插入排序在元素基本有序的情况下（接近最好情况），效率是很高的，因此希尔排序在时间效率上比前两种方法有较大提高。</p>
<p>n=10的一个数组49, 38, 65, 97, 26, 13, 27, 49, 55, 4为例</p>
<p><strong>第一次 gap = 10/2 = 5</strong></p>
<p>49 38 65 97 26 13 27 49 55 4</p>
<p>1A 1B 2A 2B 3A 3B 4A 4B 5A 5B</p>
<blockquote>
<p> 1A, 1B, 2A, 2B等为分组标记，数字相同的表示在同一组，同组进行直接插入排序 </p>
</blockquote>
<p><strong>第二次 gap = 5 / 2 = 2</strong>，排序后</p>
<p>13 27 49 55 4 49 38 65 97 26</p>
<p>1A 1B 1C 1D 1E 2A 2B 2C 2D 2E</p>
<p><strong>第三次 gap = 2 / 2 = 1</strong></p>
<p>4 26 13 27 38 49 49 55 97 65</p>
<p>1A 1B 1C 1D 1E 1F 1G 1H 1I 1J</p>
<p><strong>第四次 gap = 1 / 2 = 0</strong> 排序完成得到数组：</p>
<p>4 13 26 27 38 49 49 55 65 97</p>
<h3 id="源代码-3"><a href="#源代码-3" class="headerlink" title="源代码"></a>源代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shell_sort</span><span class="params">(ary)</span>:</span></span><br><span class="line">        count = len(ary)</span><br><span class="line">        gap = round(count/<span class="number">2</span>)   <span class="comment"># round精度不够可以考虑用math.floor()  </span></span><br><span class="line">        <span class="comment"># 双杠用于整除（向下取整），在python直接用 “/” 得到的永远是浮点数，用round()得到四舍五入值</span></span><br><span class="line">        <span class="keyword">while</span> gap &gt;= <span class="number">1</span>: <span class="comment"># 不要忘了这句</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(gap, count): <span class="comment"># 前面的gap间隔数组视为已排好序，每次插入到排好序数组中</span></span><br><span class="line">                cur = ary[i] </span><br><span class="line">                preindex = i -gap <span class="comment"># 往前的下标</span></span><br><span class="line">                <span class="keyword">while</span> preindex &gt;= <span class="number">0</span> <span class="keyword">and</span> ary[preindex] &gt; cur:  <span class="comment"># 到这里与插入排序一样了</span></span><br><span class="line">                    ary[preindex+gap] = ary[preindex]  <span class="comment"># 往后移</span></span><br><span class="line">                    preindex -= gap</span><br><span class="line">                ary[preindex+gap] = cur  <span class="comment"># 插入</span></span><br><span class="line">            gap = round(gap/<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> ary</span><br></pre></td></tr></table></figure>
<h2 id="归并排序-Merge-Sort"><a href="#归并排序-Merge-Sort" class="headerlink" title="归并排序 Merge Sort"></a>归并排序 Merge Sort</h2><h3 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h3><p>归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。</p>
<p>首先考虑下如何将将二个有序数列合并。这个非常简单，只要从比较二个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可。</p>
<p><img src="/2018/09/11/数据结构与算法/经典排序总结/04.gif" alt></p>
<h3 id="源代码-4"><a href="#源代码-4" class="headerlink" title="源代码"></a>源代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 归并排序</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(self, ary)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> len(ary) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> ary</span><br><span class="line"></span><br><span class="line">        median = int(len(ary)/<span class="number">2</span>)    <span class="comment"># 二分分解</span></span><br><span class="line">        left = self.merge_sort(ary[:median]) <span class="comment"># 先自调用，最里一层只有一个单元素</span></span><br><span class="line">        right = self.merge_sort(ary[median:])</span><br><span class="line">        <span class="keyword">return</span> self.merge(left, right)    <span class="comment"># 合并成有序数组</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, left, right)</span>:</span></span><br><span class="line">     <span class="string">'''合并操作，将两个有序数组left[]和right[]合并成一个大的有序数组'''</span></span><br><span class="line">        res = []</span><br><span class="line">        i = j = k = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; len(left) <span class="keyword">and</span> j &lt; len(right)):</span><br><span class="line">            <span class="keyword">if</span> left[i] &lt; right[j]:</span><br><span class="line">                res.append(left[i])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(right[j])</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        res = res + left[i:] + right[j:]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h2 id="快速排序-QuickSort"><a href="#快速排序-QuickSort" class="headerlink" title="快速排序 QuickSort"></a>快速排序 QuickSort</h2><h3 id="介绍-5"><a href="#介绍-5" class="headerlink" title="介绍"></a>介绍</h3><p>快速排序是图灵奖得主C.R.A Hoare于1960年提出的一种划分交换排序。它采用了一种分治的策略，通常称其为分治法。分治法的基本思想是：将原问题分解为若干个规模更小但结构与原问题相似的子问题。递归地解这些子问题，然后将这些子问题组合为原问题的解。</p>
<p><img src="/2018/09/11/数据结构与算法/经典排序总结/05.gif" alt></p>
<p><img src="/2018/09/11/数据结构与算法/经典排序总结/06.gif" alt></p>
<p>以一个数组作为示例，取区间第一个数为基准数。</p>
<blockquote>
<p>0 1 2 3 4 5 6 7 8 9</p>
<p>72 6 57 88 60 42 83 73 48 85</p>
</blockquote>
<p>初始时，i = 0; j = 9; X = a[i] = 72</p>
<p>由于已经将a[0]中的数保存到X中，可以理解成在数组a[0]上挖了个坑，可以将其它数据填充到这来。</p>
<p>从j开始向前找一个比X小或等于X的数。当j=8，符合条件，将a[8]挖出再填到上一个坑a[0]中。a[0]=a[8]; i++; 这样一个坑a[0]就被搞定了，但又形成了一个新坑a[8]，这怎么办了？简单，再找数字来填a[8]这个坑。这次从i开始向后找一个大于X的数，当i=3，符合条件，将a[3]挖出再填到上一个坑中a[8]=a[3]; j–;</p>
<p>数组变为：</p>
<blockquote>
<p>0 1 2 3 4 5 6 7 8 9</p>
<p>48 6 57 88 60 42 83 73 88 85</p>
</blockquote>
<p>i = 3; j = 7; X=72</p>
<p>再重复上面的步骤，<strong>先从后向前找，再从前向后找。</strong></p>
<h3 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤"></a>步骤</h3><p>利用分治法可将快速排序分为三步：</p>
<ol>
<li>从数列中挑出一个元素作为“基准”（pivot）。</li>
<li>分区过程，将比基准数大的放到右边，小于或等于它的数都放到左边。这个操作称为“分区操作”，分区操作结束后，基准元素所处的位置就是最终排序后它的位置</li>
<li>再对“基准”左右两边的子集不断重复第一步和第二步，直到所有子集只剩下一个元素为止。</li>
</ol>
<h3 id="源代码-5"><a href="#源代码-5" class="headerlink" title="源代码"></a>源代码</h3><h4 id="版本一"><a href="#版本一" class="headerlink" title="版本一"></a>版本一</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(self, ary)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> qsort(ary, <span class="number">0</span>, len(ary)<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">qsort</span><span class="params">(self, ary, start, end)</span>:</span>  <span class="comment"># ary为原数组，其他为下标</span></span><br><span class="line">    <span class="keyword">if</span> start &lt; end: <span class="comment"># 这句不能忘！！！</span></span><br><span class="line">        left = start</span><br><span class="line">        right = end</span><br><span class="line">        key = ary[start]</span><br><span class="line">        <span class="keyword">while</span> left &lt; right: <span class="comment"># 这里都没有等号，left=right是最后key赋值</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> ary[right] &gt;= key: <span class="comment"># 核心</span></span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> left &lt; right:    <span class="comment">#说明打破while循环的原因是ary[right] &lt;= key</span></span><br><span class="line">                ary[left] = ary[right] <span class="comment"># 填坑</span></span><br><span class="line">                left += <span class="number">1</span> <span class="comment"># 换位继续</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> ary[left] &lt; key:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> left &lt; right:    <span class="comment">#说明打破while循环的原因是ary[left] &gt;= key</span></span><br><span class="line">                ary[right] = ary[left]</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">        ary[left] = key    <span class="comment">#此时，left=right，用key来填坑</span></span><br><span class="line">        self.qsort(ary, start, left<span class="number">-1</span>)  <span class="comment"># 注意这里的下标顺序</span></span><br><span class="line">        self.qsort(ary, left+<span class="number">1</span>, end)</span><br><span class="line">    <span class="keyword">return</span> ary</span><br></pre></td></tr></table></figure>
<h4 id="版本二"><a href="#版本二" class="headerlink" title="版本二"></a>版本二</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quickSort</span><span class="params">(array)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(array)&lt;<span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> array</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        base = array[<span class="number">0</span>] <span class="comment"># 元素，return时要变为列表</span></span><br><span class="line">        <span class="comment">#小于等于基准值的元素组成的数组</span></span><br><span class="line">        less = [i <span class="keyword">for</span> i <span class="keyword">in</span> array[<span class="number">1</span>:] <span class="keyword">if</span> i&lt;=base]</span><br><span class="line">        <span class="comment">#大于基准值的元素组成的数组</span></span><br><span class="line">        greater = [i <span class="keyword">for</span> i <span class="keyword">in</span> array[<span class="number">1</span>:] <span class="keyword">if</span> i&gt; base]</span><br><span class="line">        <span class="comment">#将数组串起来</span></span><br><span class="line">        <span class="keyword">return</span> quickSort(less)+[base]+quickSort(greater)</span><br><span class="line"></span><br><span class="line">print(quickSort([<span class="number">45</span>, <span class="number">26</span>, <span class="number">34</span>, <span class="number">2</span>, <span class="number">888</span>, <span class="number">54</span>, <span class="number">23</span>, <span class="number">45</span>, <span class="number">76</span>, <span class="number">2</span>]))</span><br></pre></td></tr></table></figure>
<h2 id="堆排序-HeapSort"><a href="#堆排序-HeapSort" class="headerlink" title="堆排序 HeapSort"></a>堆排序 HeapSort</h2><h3 id="介绍-6"><a href="#介绍-6" class="headerlink" title="介绍"></a>介绍</h3><p>堆排序在 top K 问题中使用比较频繁。堆排序是采用二叉堆的数据结构来实现的，虽然实质上还是一维数组。堆（二叉堆）可以视为一棵完全的二叉树，完全二叉树的一个“优秀”的性质是，除了最底层之外，每一层都是满的，这使得堆可以利用数组来表示（普通的一般的二叉树通常用链表作为基本容器表示），每一个结点对应数组中的一个元素。</p>
<p>如下图，是一个堆和数组的相互关系，<strong>可看做堆的初始化</strong></p>
<p><img src="/2018/09/11/数据结构与算法/经典排序总结/07.jpg" alt></p>
<p>对于给定的某个结点的下标 i，可以很容易的计算出这个结点的父结点、孩子结点的下标：</p>
<ul>
<li>Parent(i) = floor(i/2)，i 的父节点下标</li>
<li>Left(i) = 2i，i 的左子节点下标</li>
<li>Right(i) = 2i + 1，i 的右子节点下标</li>
</ul>
<p><img src="/2018/09/11/数据结构与算法/经典排序总结/08.jpg" alt></p>
<p>二叉堆具有以下性质：</p>
<ol>
<li>父节点的键值总是大于或等于（小于或等于）任何一个子节点的键值。</li>
<li>每个节点的左右子树都是一个二叉堆（都是最大堆或最小堆）。</li>
</ol>
<p><img src="/2018/09/11/数据结构与算法/经典排序总结/09.gif" alt></p>
<p><img src="/2018/09/11/数据结构与算法/经典排序总结/10.gif" alt></p>
<h3 id="步骤-4"><a href="#步骤-4" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>构造最大堆（Build_Max_Heap）<strong>自底向上</strong>：若数组下标范围为0~n，<strong>考虑到单独一个元素是大根堆，则从下标n/2开始的元素均为大根堆</strong>。<strong>于是只要从n/2-1开始(最后一个非叶子节点开始)</strong>，<strong>分别与左孩子和右孩子比较大小，如果最大，则不用调整，否则和孩子中的值最大的一个交换位置，若交换之后还比此节点的孩子要小，继续向下交换（这里是自顶向下）</strong> 。并向前依次构造大根堆，这样就能保证，构造到某个节点时，它的左右子树都已经是大根堆。</li>
<li>堆排序（HeapSort）：由于堆是用数组模拟的。<strong>得到一个最大根堆后</strong>，数组内部并不是有序的。因此需要将堆化数组有序化。<strong>思想是总是移除根节点（用最后一个元素来填补空缺）</strong>，并做最大堆调整的递归运算。<strong>第一次将heap[0]与heap[n-1]交换，再对heap[0…n-2]做最大堆调整</strong>。第二次将heap[0]与heap[n-2]交换，再对heap[0…n-3]做最大堆调整。重复该操作直至heap[0]和heap[1]交换。由于每次都是将最大的数并入到后面的有序区间，故操作完后整个数组就是有序的了。</li>
<li>最大堆调整（Max_Heapify）：该方法是提供给上述两个过程调用的。目的是将堆的末端子节点作调整，使得子节点永远小于父节点 。</li>
</ol>
<p><strong>构造最大堆：</strong>先自底向上，再自顶向下</p>
<p><img src="/2018/09/11/数据结构与算法/经典排序总结/11.png" alt></p>
<p> <strong>调整最大堆</strong>：交换之后，被交换的节点从顶向下调整，调完继续交换，依次递归。 </p>
<p><img src="/2018/09/11/数据结构与算法/经典排序总结/12.png" alt></p>
<h3 id="源代码-6"><a href="#源代码-6" class="headerlink" title="源代码"></a>源代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_sort</span><span class="params">(ary)</span>:</span></span><br><span class="line">    n = len(ary)</span><br><span class="line">    first = int(n/<span class="number">2</span><span class="number">-1</span>)    <span class="comment">#最后一个非叶子节点</span></span><br><span class="line">    <span class="keyword">for</span> start <span class="keyword">in</span> range(first,<span class="number">-1</span>,<span class="number">-1</span>):    <span class="comment">#构建最大堆</span></span><br><span class="line">        max_heapify(ary,start,n<span class="number">-1</span>)</span><br><span class="line">    <span class="comment"># range(n-1,0,-1)因为0时不用和顶点自己交换</span></span><br><span class="line">    <span class="keyword">for</span> end <span class="keyword">in</span> range(n<span class="number">-1</span>,<span class="number">0</span>,<span class="number">-1</span>): <span class="comment">#堆排，将最大跟堆转换成有序数组，</span></span><br><span class="line">        ary[end],ary[<span class="number">0</span>] = ary[<span class="number">0</span>], ary[end]    <span class="comment">#将根节点元素与最后叶子节点进行互换，取出最大根节点元素，对剩余节点重新构建最大堆</span></span><br><span class="line">        max_heapify(ary,<span class="number">0</span>,end<span class="number">-1</span>)    <span class="comment">#因为end上面取的是n-1，故而这里直接放end-1，相当于忽略了最后最大根节点元素ary[n-1]</span></span><br><span class="line">    <span class="keyword">return</span> ary</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#最大堆调整：将堆的末端子节点作调整，使得子节点永远小于父节点</span></span><br><span class="line"><span class="comment">#start为当前需要调整最大堆的位置，end为调整边界</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max_heapify</span><span class="params">(ary,start,end)</span>:</span></span><br><span class="line">    root = start</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:  <span class="comment"># 记住这一句</span></span><br><span class="line">        child = root * <span class="number">2</span> + <span class="number">1</span>    <span class="comment">#调整节点的子节点,这里要注意数值下标从0开始，左节点为root * 2 + 1，这里都是下标表示</span></span><br><span class="line">        <span class="keyword">if</span> child &gt; end: <span class="comment"># 左子树超过边界，右子树肯定也超了</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> child + <span class="number">1</span> &lt;= end <span class="keyword">and</span> ary[child] &lt; ary[child+<span class="number">1</span>]: <span class="comment">#两个都没超，选数值大的下标</span></span><br><span class="line">            child = child + <span class="number">1</span>   <span class="comment">#取较大的子节点</span></span><br><span class="line">        <span class="comment"># 满足父节点比子节点小才叫交换</span></span><br><span class="line">        <span class="keyword">if</span> ary[root] &lt; ary[child]:    <span class="comment"># 子节点成为父节点；child为左子树或上一步较大的子节点</span></span><br><span class="line">            ary[root], ary[child] = ary[child], ary[root]    <span class="comment">#交换</span></span><br><span class="line">            root = child <span class="comment"># 调整时候要自顶向下继续调整，不要忘了这一句</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<h2 id="时空复杂度总结"><a href="#时空复杂度总结" class="headerlink" title="时空复杂度总结"></a>时空复杂度总结</h2><p><img src="/2018/09/11/数据结构与算法/经典排序总结/13.png" alt></p>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><blockquote>
<p>＂快些以O(nlog2n)O(nlog2n)的速度归队＂</p>
</blockquote>
<p>即快，希，归，堆都是O(nlog2n)O(nlog2n)，其他都是O(n2)O(n2)，基数排序例外，是O(d(n+rd))O(d(n+rd))</p>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><ul>
<li>快排O(log2n)O(log2n)</li>
<li>归并O(n)O(n)</li>
<li>基数O(rd)O(rd)</li>
<li>其他O(1)O(1)</li>
</ul>
<h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><blockquote>
<p>＂心情不稳定，快些找一堆朋友聊天吧＂</p>
</blockquote>
<p>即不稳定的有：快，希，堆</p>
<h3 id="其他性质"><a href="#其他性质" class="headerlink" title="其他性质"></a>其他性质</h3><ul>
<li>直接插入排序，初始基本有序情况下，是O(n)O(n)</li>
<li>冒泡排序，初始基本有序情况下，是O(n)O(n)</li>
<li>快排在初始状态越差的情况下算法效果越好．</li>
<li>堆排序适合记录数量比较大的时候，从n个记录中选择k个记录．</li>
<li>经过一趟排序，元素可以在它最终的位置的有：交换类的（冒泡，快排），选择类的（简单选择，堆）</li>
<li>比较次数与初始序列无关的是：简单选择与折半插入</li>
<li>排序趟数与原始序列有关的是：交换类的（冒泡和快排）</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>经典排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer解题_Python版</title>
    <url>/2018/09/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer%E8%A7%A3%E9%A2%98_Python%E7%89%88/</url>
    <content><![CDATA[<h3 id="1-二维数组中的查找"><a href="#1-二维数组中的查找" class="headerlink" title="1.二维数组中的查找"></a>1.二维数组中的查找</h3><p><strong>题目：</strong> 在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p><strong>思路：</strong>遍历每一行，查找该元素是否在该行之中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># array 二维列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Find</span><span class="params">(self, target, array)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> array:</span><br><span class="line">            <span class="keyword">if</span> target <span class="keyword">in</span> i:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h3 id="2-替换空格"><a href="#2-替换空格" class="headerlink" title="2.替换空格"></a>2.替换空格</h3><p><strong>题目：</strong> 请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
<p><strong>思路：</strong>利用字符串中的replace直接替换即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># s 源字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replaceSpace</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> s.replace(<span class="string">' '</span>,<span class="string">'%20'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="3-从尾到头打印链表"><a href="#3-从尾到头打印链表" class="headerlink" title="3.从尾到头打印链表"></a>3.从尾到头打印链表</h3><p><strong>题目：</strong>输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。</p>
<p><strong>思路：</strong>将链表中的值记录到list之中，然后进行翻转list。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回从尾部到头部的列表值序列，例如[1,2,3]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printListFromTailToHead</span><span class="params">(self, listNode)</span>:</span></span><br><span class="line">        l = list()</span><br><span class="line">        <span class="keyword">while</span> listNode:</span><br><span class="line">            l.append(listNode.val)</span><br><span class="line">            listNode=listNode.next</span><br><span class="line">        <span class="keyword">return</span> l[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="4-重建二叉树-flag"><a href="#4-重建二叉树-flag" class="headerlink" title="4.重建二叉树(flag)"></a>4.重建二叉树(flag)</h3><p><strong>题目：</strong>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>
<p><strong>题解：</strong>首先前序遍历的第一个元素为二叉树的根结点，<strong>那么便能够在中序遍历之中找到根节点，那么在根结点左侧则是左子树；在根结点右侧，便是右子树</strong>。然后在递归遍历左子树和右子树。这里要注意一点，<strong>pre的左右子树分割长度与中序的左右子树分割长度一致</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回构造的TreeNode根节点</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reConstructBinaryTree</span><span class="params">(self, pre, tin)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(pre)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> len(pre)==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> TreeNode(pre[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            flag = TreeNode(pre[<span class="number">0</span>])</span><br><span class="line">            <span class="comment">#pre的左右子树分割长度与中序的左右子树分割长度一致。</span></span><br><span class="line">            flag.left = self.reConstructBinaryTree(pre[<span class="number">1</span>:tin.index(pre[<span class="number">0</span>])+<span class="number">1</span>],tin[:tin.index(pre[<span class="number">0</span>])])  </span><br><span class="line">            flag.right = self.reConstructBinaryTree(pre[tin.index(pre[<span class="number">0</span>])+<span class="number">1</span>:],tin[tin.index(pre[<span class="number">0</span>])+<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">return</span> flag</span><br></pre></td></tr></table></figure>
<h3 id="5-用两个栈实现队列-flag"><a href="#5-用两个栈实现队列-flag" class="headerlink" title="5.用两个栈实现队列(flag)"></a>5.用两个栈实现队列(flag)</h3><p><strong>题目：</strong>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p>
<p><strong>题解：</strong>申请两个栈Stack1和Stack2，Stack1当作输入，Stack2当作pop。<strong>当Stack2空的时候</strong>，将Stack1进行反转，并且输入到Stack2。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.Stack1=[]</span><br><span class="line">        self.Stack2=[]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        self.Stack1.append(node)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># return xx</span></span><br><span class="line">        <span class="keyword">if</span> self.Stack2==[]:</span><br><span class="line">            <span class="keyword">while</span> self.Stack1:</span><br><span class="line">                self.Stack2.append(self.Stack1.pop())</span><br><span class="line">            <span class="keyword">return</span> self.Stack2.pop()</span><br><span class="line">        <span class="keyword">return</span> self.Stack2.pop()</span><br></pre></td></tr></table></figure>
<h3 id="6-旋转数组的最小数字"><a href="#6-旋转数组的最小数字" class="headerlink" title="6.旋转数组的最小数字"></a>6.旋转数组的最小数字</h3><p><strong>题目：</strong>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumberInRotateArray</span><span class="params">(self, rotateArray)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> rotateArray:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            <span class="keyword">return</span> min(rotateArray)</span><br></pre></td></tr></table></figure>
<h3 id="7-斐波那契数列-flag"><a href="#7-斐波那契数列-flag" class="headerlink" title="7.斐波那契数列(flag)"></a>7.斐波那契数列(flag)</h3><p><strong>题目：</strong>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。n&lt;=39。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Fibonacci</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">1</span> <span class="keyword">or</span> n==<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        a,b=<span class="number">1</span>,<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-2</span>):</span><br><span class="line">            a,b=b,a+b</span><br><span class="line">        <span class="keyword">return</span> b</span><br></pre></td></tr></table></figure>
<h3 id="8-跳台阶"><a href="#8-跳台阶" class="headerlink" title="8.跳台阶"></a>8.跳台阶</h3><p><strong>题目：</strong>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p>
<p><strong>题解：</strong>ans[n]=ans[n-1]+ans[n-2]</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jumpFloor</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> number:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> number==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> number==<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        a,b=<span class="number">1</span>,<span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(number<span class="number">-2</span>):</span><br><span class="line">            a,b=b,a+b</span><br><span class="line">        <span class="keyword">return</span> b</span><br></pre></td></tr></table></figure>
<h3 id="9-变态跳台阶"><a href="#9-变态跳台阶" class="headerlink" title="9.变态跳台阶"></a>9.变态跳台阶</h3><p><strong>题目：</strong>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
<p><strong>题解：</strong>ans[n]=ans[n-1]+ans[n-2]+ans[n-3]+…+ans[n-n]，ans[n-1]=ans[n-2]+ans[n-3]+…+ans[n-n]，ans[n]=2*ans[n-1]。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jumpFloorII</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> number:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> number==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> number==<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>**(number<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>
<h3 id="10-矩形覆盖"><a href="#10-矩形覆盖" class="headerlink" title="10.矩形覆盖"></a>10.矩形覆盖</h3><p><strong>题目：</strong>我们可以用2<em>1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2</em>1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p>
<p><strong>题解：</strong>新增加的小矩阵竖着放，则方法与n-1时相同，新增加的小矩阵横着放，则方法与n-2时相同，于是f(n)=f(n-1)+f(n-2)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rectCover</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> number:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> number==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> number==<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        a,b=<span class="number">1</span>,<span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(number<span class="number">-2</span>):</span><br><span class="line">            a,b=b,a+b</span><br><span class="line">        <span class="keyword">return</span> b</span><br></pre></td></tr></table></figure>
<h3 id="11-二进制中1的个数-flag"><a href="#11-二进制中1的个数-flag" class="headerlink" title="11.二进制中1的个数(flag)"></a>11.二进制中1的个数(flag)</h3><p><strong>题目：</strong>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p>
<p><strong>题解：</strong>每次进行右移一位，然后与1进行相与，如果是1则进行加1。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 向右移1位可以看成除以2，向左移一位可以看成乘以2。移动n位可以看成乘以或者除以2的n次方。</span></span><br><span class="line"><span class="comment"># 负数原码（int整型用32位表示）所有位取反码然后+1得到补码；正数的补码为其自身</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>  <span class="comment">#转为字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">NumberOf1</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n&gt;<span class="number">0</span>:</span><br><span class="line">            a=bin(n).count(<span class="string">'1'</span>)</span><br><span class="line">            <span class="keyword">return</span> a</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            a=bin(<span class="number">2</span>**<span class="number">32</span>+n).count(<span class="string">'1'</span>)</span><br><span class="line">            <span class="keyword">return</span> a</span><br><span class="line">            </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span> <span class="comment">#每次移一位，看此为是否为1，负数的表示内部已经是补码了</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">NumberOf1</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">            count += (n &gt;&gt; i) &amp; <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>
<h3 id="12-数值的整次方"><a href="#12-数值的整次方" class="headerlink" title="12.数值的整次方"></a>12.数值的整次方</h3><p><strong>题目：</strong>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Power</span><span class="params">(self, base, exponent)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        ans=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,abs(exponent)):</span><br><span class="line">            ans=ans*base</span><br><span class="line">        <span class="keyword">if</span> exponent&gt;<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>/ans</span><br></pre></td></tr></table></figure>
<h3 id="13-调整数组顺序使奇数位于偶数前面"><a href="#13-调整数组顺序使奇数位于偶数前面" class="headerlink" title="13.调整数组顺序使奇数位于偶数前面"></a>13.调整数组顺序使奇数位于偶数前面</h3><p><strong>题目：</strong>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>
<p><strong>题解：</strong>申请奇数数组和偶数数组，分别存放奇数值和偶数值，数组相加便为结果。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reOrderArray</span><span class="params">(self, array)</span>:</span></span><br><span class="line">        array=list(array)</span><br><span class="line">        a=[]</span><br><span class="line">        b=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> array:</span><br><span class="line">            <span class="keyword">if</span> i%<span class="number">2</span>==<span class="number">1</span>:</span><br><span class="line">                a.append(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                b.append(i)</span><br><span class="line">        <span class="keyword">return</span> a+b</span><br></pre></td></tr></table></figure>
<h3 id="14-链表中倒数第K个节点"><a href="#14-链表中倒数第K个节点" class="headerlink" title="14.链表中倒数第K个节点"></a>14.链表中倒数第K个节点</h3><p><strong>题目：</strong>输入一个链表，输出该链表中倒数第k个结点。</p>
<p><strong>题解：</strong>快慢指针。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindKthToTail</span><span class="params">(self, head, k)</span>:</span></span><br><span class="line">        l=[]</span><br><span class="line">        count=<span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        a1=head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> a1:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                a1=a1.next</span><br><span class="line">        a2=head</span><br><span class="line">        <span class="keyword">while</span> a1:</span><br><span class="line">            a1=a1.next</span><br><span class="line">            a2=a2.next</span><br><span class="line">        <span class="keyword">return</span> a2</span><br></pre></td></tr></table></figure>
<h3 id="15-反转链表-flag"><a href="#15-反转链表-flag" class="headerlink" title="15.反转链表(flag)"></a>15.反转链表(flag)</h3><p><strong>题目：</strong>输入一个链表，反转链表后，输出新链表的表头。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回ListNode</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ReverseList</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead.next:</span><br><span class="line">            <span class="keyword">return</span> pHead</span><br><span class="line">        Pre=<span class="literal">None</span></span><br><span class="line">        Next=<span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> pHead:</span><br><span class="line">            Next=pHead.next <span class="comment"># 暂存当前节点的下一个节点信息</span></span><br><span class="line">            pHead.next=Pre  <span class="comment"># 断开链表, 反转节点, 这两句都是为了保护链表断开不丢失next的指向</span></span><br><span class="line">            Pre=pHead</span><br><span class="line">            pHead=Next</span><br><span class="line">        <span class="keyword">return</span> Pre</span><br></pre></td></tr></table></figure>
<h3 id="16-合并两个排序的列表"><a href="#16-合并两个排序的列表" class="headerlink" title="16.合并两个排序的列表"></a>16.合并两个排序的列表</h3><p><strong>题目：</strong>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回合并后列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Merge</span><span class="params">(self, pHead1, pHead2)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead1 <span class="keyword">and</span> <span class="keyword">not</span> pHead2:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead1 <span class="keyword">or</span> <span class="keyword">not</span> pHead2:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> pHead1:</span><br><span class="line">                <span class="keyword">return</span> pHead2</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> pHead1</span><br><span class="line">        merge=ListNode(<span class="number">0</span>)<span class="comment"># 新一个头结点数值为x的链表</span></span><br><span class="line">        p=merge    <span class="comment">#返回时的指向头结点的指针</span></span><br><span class="line">        <span class="keyword">while</span> pHead1 <span class="keyword">and</span> pHead2:</span><br><span class="line">            <span class="keyword">if</span> pHead1.val&lt;=pHead2.val:</span><br><span class="line">                merge.next=pHead1</span><br><span class="line">                pHead1=pHead1.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                merge.next=pHead2</span><br><span class="line">                pHead2=pHead2.next</span><br><span class="line">            merge=merge.next</span><br><span class="line">        <span class="keyword">while</span> pHead1:</span><br><span class="line">            merge.next=pHead1</span><br><span class="line">            pHead1=pHead1.next</span><br><span class="line">            merge=merge.next</span><br><span class="line">        <span class="keyword">while</span> pHead2:</span><br><span class="line">            merge.next=pHead2</span><br><span class="line">            pHead2=pHead2.next</span><br><span class="line">            merge=merge.next</span><br><span class="line">        <span class="keyword">return</span> p.next</span><br></pre></td></tr></table></figure>
<h3 id="17-树的子结构-flag"><a href="#17-树的子结构-flag" class="headerlink" title="17.树的子结构(flag)"></a>17.树的子结构(flag)</h3><p><strong>题目：</strong>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）。</p>
<p><strong>题解：</strong>递归；或者将树转变为中序序列，然后转变为str类型，最后判断是否包含。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">HasSubtree</span><span class="params">(self, pRoot1, pRoot2)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot1 <span class="keyword">or</span> <span class="keyword">not</span> pRoot2:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        root1 = pRoot1</span><br><span class="line">        root2 = pRoot2</span><br><span class="line">        result = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> root1.val==root2.val:  <span class="comment"># HasSubtree条件出口，满足根节点相同才继续判断子树结构</span></span><br><span class="line">            result = self.hastree(root1,root2)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> result:</span><br><span class="line">            result = self.HasSubtree(root1.left,root2)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> result:</span><br><span class="line">            result = self.HasSubtree(root1.right,root2)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hastree</span><span class="params">(self,root1,root2)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root2==<span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> root1==<span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> root1.val==root2.val:</span><br><span class="line">            <span class="keyword">return</span> self.hastree(root1.left,root2.left) <span class="keyword">and</span> self.hastree(root1.right,root2.right)</span><br><span class="line">        <span class="keyword">if</span> root1.val!=root2.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h3 id="18-二叉树的镜像"><a href="#18-二叉树的镜像" class="headerlink" title="18.二叉树的镜像"></a>18.二叉树的镜像</h3><p><strong>题目：</strong> 操作给定的二叉树，将其变换为源二叉树的镜像。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回镜像树的根节点</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Mirror</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            root.left,root.right=root.right,root.left</span><br><span class="line">            self.Mirror(root.left)</span><br><span class="line">            self.Mirror(root.right)</span><br></pre></td></tr></table></figure>
<h3 id="19-顺时针打印矩阵-flag"><a href="#19-顺时针打印矩阵-flag" class="headerlink" title="19.顺时针打印矩阵(flag)"></a>19.顺时针打印矩阵(flag)</h3><p><strong>题目:</strong> 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># matrix类型为二维列表，需要返回列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printMatrix</span><span class="params">(self, matrix)</span>:</span></span><br><span class="line">        rows=len(matrix)</span><br><span class="line">        cols=len(matrix[<span class="number">0</span>])</span><br><span class="line">        l=[]</span><br><span class="line">        <span class="keyword">if</span> rows==<span class="number">1</span> <span class="keyword">and</span> cols==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> [matrix[<span class="number">0</span>][<span class="number">0</span>]]</span><br><span class="line">        left,right, up, down = <span class="number">0</span>,cols<span class="number">-1</span>,<span class="number">0</span>,rows<span class="number">-1</span>  <span class="comment">#这个是数组下标</span></span><br><span class="line">        <span class="keyword">while</span> left&lt;=right <span class="keyword">and</span> up&lt;=down:    </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(left,right+<span class="number">1</span>):     <span class="comment">#range函数接收参数从小到大，大的数值不计入</span></span><br><span class="line">                l.append(matrix[up][i])</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(up+<span class="number">1</span>,down+<span class="number">1</span>):</span><br><span class="line">                l.append(matrix[j][right])</span><br><span class="line">            <span class="keyword">if</span> down-up&gt;=<span class="number">1</span>:   <span class="comment">#相等时为剩余单行</span></span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(left,right)[::<span class="number">-1</span>]:   <span class="comment">#这里注意逆序的数组下标</span></span><br><span class="line">                    l.append(matrix[down][k])</span><br><span class="line">            <span class="keyword">if</span> right-left&gt;=<span class="number">1</span>:   <span class="comment">#相等时为剩余单列</span></span><br><span class="line">                <span class="keyword">for</span> p <span class="keyword">in</span> range(up+<span class="number">1</span>,down)[::<span class="number">-1</span>]:</span><br><span class="line">                    l.append(matrix[p][left])</span><br><span class="line">            up=up+<span class="number">1</span></span><br><span class="line">            down=down<span class="number">-1</span></span><br><span class="line">            left=left+<span class="number">1</span></span><br><span class="line">            right=right<span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> l</span><br></pre></td></tr></table></figure>
<h3 id="20-包含Min函数的栈-flag"><a href="#20-包含Min函数的栈-flag" class="headerlink" title="20.包含Min函数的栈(flag)"></a>20.包含Min函数的栈(flag)</h3><p><strong>题目：</strong>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.stack=[]</span><br><span class="line">        self.minstack=[]      <span class="comment">#pop()删除列表的最后一个元素,[-1]获取最后一个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, node)</span>:</span>     <span class="comment">#最小栈存储 整个原栈的最小元素，若最小元素在原栈删除，则也要删除最小栈</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.minstack <span class="keyword">or</span> node&lt;self.minstack[<span class="number">-1</span>]:   </span><br><span class="line">            self.minstack.append(node)</span><br><span class="line">        self.stack.append(node)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.stack:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">elif</span> self.stack[<span class="number">-1</span>]==self.minstack[<span class="number">-1</span>]:</span><br><span class="line">            self.minstack.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.stack.pop()</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.stack[<span class="number">-1</span>]</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">min</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.minstack[<span class="number">-1</span>]</span><br><span class="line">        <span class="comment"># write code here</span></span><br></pre></td></tr></table></figure>
<h3 id="21-栈的压入弹出序列-flag"><a href="#21-栈的压入弹出序列-flag" class="headerlink" title="21.栈的压入弹出序列(flag)"></a>21.栈的压入弹出序列(flag)</h3><p><strong>题目：</strong>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）。</p>
<p><strong>题解：</strong>构建压入和活动栈，只有处于压入栈栈顶或者活动栈内才可弹出；或者新构建一个中间栈，来模拟栈的输入和栈的输出，比对输入结果和输出结果是否相等。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">IsPopOrder</span><span class="params">(self, pushV, popV)</span>:</span>  </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pushV:   </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        fixed=[]   <span class="comment">#压下去的辅助栈，处于栈顶可以出栈</span></span><br><span class="line">        left=pushV[:]   <span class="comment">#剩余的可活动栈，p元素位置之前的都要压入辅助栈</span></span><br><span class="line">        flag=<span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> popV:</span><br><span class="line">            <span class="keyword">if</span> p <span class="keyword">not</span> <span class="keyword">in</span> pushV:   <span class="comment">#还要判断pushV和popV元素不同的情况</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> p <span class="keyword">in</span> left:</span><br><span class="line">                k=left.index(p)</span><br><span class="line">                fixed=fixed+left[:k+<span class="number">1</span>]</span><br><span class="line">                left=left[k+<span class="number">1</span>:]</span><br><span class="line">                fixed.pop()</span><br><span class="line">            <span class="keyword">elif</span> fixed:  <span class="comment">#避免fixed[-1]越界</span></span><br><span class="line">                <span class="keyword">if</span> p!=fixed[<span class="number">-1</span>]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">else</span>:fixed.pop()</span><br><span class="line">        <span class="keyword">return</span> flag</span><br></pre></td></tr></table></figure>
<h3 id="22-从上往下打印二叉树"><a href="#22-从上往下打印二叉树" class="headerlink" title="22.从上往下打印二叉树"></a>22.从上往下打印二叉树</h3><p><strong>题目：</strong>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p>
<p><strong>思路：</strong>层次遍历，用队列。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回从上到下每个节点值列表，例：[1,2,3]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">PrintFromTopToBottom</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        res=[]</span><br><span class="line">        value=[]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []  <span class="comment">#返回空列表，而不是None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res.append(root)</span><br><span class="line">            value.append(root.val)</span><br><span class="line">        <span class="keyword">while</span> res:</span><br><span class="line">            p=res.pop(<span class="number">0</span>)   <span class="comment"># pop(0)才是第一个元素</span></span><br><span class="line">            <span class="keyword">if</span> p.left:</span><br><span class="line">                res.append(p.left)</span><br><span class="line">                value.append(p.left.val)</span><br><span class="line">            <span class="keyword">if</span> p.right:</span><br><span class="line">                res.append(p.right)</span><br><span class="line">                value.append(p.right.val)</span><br><span class="line">        <span class="keyword">return</span> value</span><br></pre></td></tr></table></figure>
<h3 id="23-二叉树的后续遍历序列-flag"><a href="#23-二叉树的后续遍历序列-flag" class="headerlink" title="23.二叉树的后续遍历序列(flag)"></a>23.二叉树的后续遍历序列(flag)</h3><p><strong>题目：</strong>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p>
<p><strong>思路：</strong>二叉搜索树的特性是所有左子树值都小于中节点，所有右子树的值都大于中节点，递归遍历左子树和右子树的值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># 后续遍历要满足 去除序列最后一个元素（根）后，将小于和大于这个元素直接分成两段，递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">VerifySquenceOfBST</span><span class="params">(self, sequence)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> sequence:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> len(sequence)==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        front=[]</span><br><span class="line">        back=[]</span><br><span class="line">        flag=<span class="number">0</span>  <span class="comment"># 辅助与分段的标记，第一个大于p元素之后的都放在back断</span></span><br><span class="line">        p=sequence.pop()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> sequence:</span><br><span class="line">            <span class="keyword">if</span> i&lt;=p <span class="keyword">and</span> flag==<span class="number">0</span>:</span><br><span class="line">                front.append(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                flag=<span class="number">1</span></span><br><span class="line">                back.append(i)</span><br><span class="line">        <span class="keyword">if</span> front <span class="keyword">and</span> max(front)&gt;p:  <span class="comment">#front要满足所有元素都小于p</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> back <span class="keyword">and</span> min(back)&lt;p: <span class="comment">#back要满足所有元素都大于p</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        LEFT=<span class="literal">True</span>  <span class="comment">#递归出口</span></span><br><span class="line">        RIGHT=<span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> front:</span><br><span class="line">            LEFT=self.VerifySquenceOfBST(front)</span><br><span class="line">        <span class="keyword">if</span> back:</span><br><span class="line">            RIGHT=self.VerifySquenceOfBST(back)</span><br><span class="line">        <span class="keyword">return</span> LEFT <span class="keyword">and</span> RIGHT</span><br></pre></td></tr></table></figure>
<h3 id="24-二叉树中和为某一值的路径-flag"><a href="#24-二叉树中和为某一值的路径-flag" class="headerlink" title="24.二叉树中和为某一值的路径(flag)"></a>24.二叉树中和为某一值的路径(flag)</h3><p><strong>题目：</strong>输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回二维列表，内部每个列表表示找到的路径</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindPath</span><span class="params">(self, root, expectNumber)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment"># 这题不太会，记一下</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="comment">#即是一开始条件语句，也是递归出口，若叶子节点不满足条件，left或者right返回空</span></span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">and</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right <span class="keyword">and</span> root.val == expectNumber:</span><br><span class="line">            <span class="keyword">return</span> [[root.val]]  <span class="comment">#递归出口，即叶子节点满足条件，不会执行以下任何语句；</span></span><br><span class="line">                                 </span><br><span class="line">        res = [] <span class="comment">#每次清空</span></span><br><span class="line">        <span class="comment"># 先会一直先递归left，相当于深度优先搜索</span></span><br><span class="line">        left = self.FindPath(root.left, expectNumber-root.val) <span class="comment">#left_left1_left11_right11_...right1</span></span><br><span class="line">        right = self.FindPath(root.right, expectNumber-root.val)</span><br><span class="line">        <span class="comment"># 遍历后的操作</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> left+right:  <span class="comment">#是指里面的元素，[[root.val]]得到的元素是[root.val]</span></span><br><span class="line">            res.append([root.val]+i)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">   <span class="comment">#      6        左图所示，left返回[[3]],right返回的res为[].append([2]+[1])=[[2,1]]</span></span><br><span class="line">    <span class="comment">#   3   2      最后一层返回[[6,3],[6,2,1]]</span></span><br><span class="line">     <span class="comment">#     1</span></span><br></pre></td></tr></table></figure>
<h3 id="25-复杂链表的复制-flag"><a href="#25-复杂链表的复制-flag" class="headerlink" title="25.复杂链表的复制(flag)"></a>25.复杂链表的复制(flag)</h3><p><strong>题目：</strong>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）。</p>
<p><strong>思路：</strong></p>
<p>1、遍历链表，复制每个结点，如复制结点A得到A1，将结点A1插到结点A后面（暂不处理随机节点）；</p>
<p>2、重新遍历链表，复制老结点的随机指针给新结点，如A1.random = A.random.next;</p>
<p>3、拆分链表，将链表拆分为原链表和复制后的链表</p>
<p><img src="/2018/09/07/数据结构与算法/剑指offer解题_Python版/01.png" alt></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.label = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line">        self.random = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回 RandomListNode</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Clone</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        pCur = pHead</span><br><span class="line">        <span class="keyword">while</span> pCur:</span><br><span class="line">            node = RandomListNode(pCur.label)</span><br><span class="line">            node.next = pCur.next</span><br><span class="line">            pCur.next = node</span><br><span class="line">            pCur = node.next</span><br><span class="line">        pCur = pHead</span><br><span class="line">        <span class="keyword">while</span> pCur:</span><br><span class="line">            <span class="keyword">if</span> pCur.random:</span><br><span class="line">                pCur.next.random = pCur.random</span><br><span class="line">            pCur = pCur.next.next</span><br><span class="line">        pCur = pHead</span><br><span class="line">        cur = pHead.next</span><br><span class="line">        h = cur</span><br><span class="line">        <span class="keyword">while</span> cur:  <span class="comment">#拆分</span></span><br><span class="line">            pCur.next = cur.next</span><br><span class="line">            <span class="keyword">if</span> pCur.next:</span><br><span class="line">                cur.next = pCur.next.next</span><br><span class="line">            pCur = pCur.next</span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="keyword">return</span> h</span><br></pre></td></tr></table></figure>
<h3 id="26-二叉搜索树与双向列表"><a href="#26-二叉搜索树与双向列表" class="headerlink" title="26.二叉搜索树与双向列表"></a>26.二叉搜索树与双向列表</h3><p><strong>题目：</strong>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p>
<p><strong>思路：</strong>中序遍历，然后添加一个pre指针</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.a=[]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Convert</span><span class="params">(self, pRootOfTree)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">         </span><br><span class="line">        <span class="keyword">if</span> pRootOfTree==<span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        self.Convert(pRootOfTree.left)</span><br><span class="line">        self.a.append(pRootOfTree)</span><br><span class="line">        self.Convert(pRootOfTree.right)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(self.a)<span class="number">-1</span>):</span><br><span class="line">            self.a[i].right=self.a[i+<span class="number">1</span>]</span><br><span class="line">            self.a[i+<span class="number">1</span>].left=self.a[i]</span><br><span class="line">        <span class="keyword">return</span> self.a[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h3 id="27-字符串的排列-flag"><a href="#27-字符串的排列-flag" class="headerlink" title="27.字符串的排列(flag)"></a>27.字符串的排列(flag)</h3><p><strong>题目：</strong>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p>
<p><strong>输入：</strong>输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。</p>
<p><strong>思路：</strong>用itertools.permutations;或者通过将固定每一位的字符，然后进行和后面的每个字符进行交换，得到所有结果集。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Permutation</span><span class="params">(self, ss)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> ss:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">return</span> sorted(list(set(map(<span class="string">''</span>.join, itertools.permutations(ss)))))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#  abc</span></span><br><span class="line">    <span class="comment">#  itertools.permutations(ss)输出('a','b','c') ('a','c','b')...等</span></span><br><span class="line">    <span class="comment">#  map函数后为abc acb..</span></span><br></pre></td></tr></table></figure>
<h3 id="28-数组中出现次数超过一般的数字"><a href="#28-数组中出现次数超过一般的数字" class="headerlink" title="28.数组中出现次数超过一般的数字"></a>28.数组中出现次数超过一般的数字</h3><p><strong>题目：</strong>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0</p>
<p><strong>题解：</strong>判断是否有超过一半的元素，如果有则在数组中间的元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(self, numbers)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> numbers:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(numbers)==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> numbers[<span class="number">0</span>]</span><br><span class="line">        l=len(numbers)//<span class="number">2</span></span><br><span class="line">        k=sorted(list(numbers))  <span class="comment">#排序，满足条件处于中间位置的为最多元素</span></span><br><span class="line">        count=<span class="number">0</span>                  <span class="comment">#不满足条件则遍历判断 此元素maxcount是否超过一半</span></span><br><span class="line">        maxcount=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(k)<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> k[i]==k[i+<span class="number">1</span>]:</span><br><span class="line">                count=count+<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> count&gt;maxcount:</span><br><span class="line">                    maxcount=count</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count=<span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> maxcount&gt;=l:</span><br><span class="line">            <span class="keyword">return</span> k[l]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h3 id="29-最小的K个数"><a href="#29-最小的K个数" class="headerlink" title="29.最小的K个数"></a>29.最小的K个数</h3><p><strong>题目：</strong>输入n个整数，找出其中最小的K个数，例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetLeastNumbers_Solution</span><span class="params">(self, tinput, k)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> len(tinput)&lt;k:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res=sorted(tinput)</span><br><span class="line">        <span class="keyword">return</span> res[:k]</span><br></pre></td></tr></table></figure>
<h3 id="30-连续子数组的最大和-flag"><a href="#30-连续子数组的最大和-flag" class="headerlink" title="30.连续子数组的最大和(flag)"></a>30.连续子数组的最大和(flag)</h3><p><strong>题目：</strong>HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。你会不会被他忽悠住？(子向量的长度至少是1)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(self, array)</span>:</span></span><br><span class="line">        <span class="comment"># write code here  只需要返回最大数，下标不管</span></span><br><span class="line">        <span class="comment"># 思路：创建一个列表储存要加入的元素，当累积和小于0则清空前面一段</span></span><br><span class="line">        <span class="comment"># 另外一个更简单的思路PART2</span></span><br><span class="line">        <span class="keyword">if</span> len(array)==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> array[<span class="number">0</span>]  </span><br><span class="line">        <span class="keyword">if</span> max(array)&lt;=<span class="number">0</span>:  <span class="comment">#全是负数</span></span><br><span class="line">            <span class="keyword">return</span> max(array)</span><br><span class="line">        <span class="keyword">if</span> min(array)&gt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> sum(array)</span><br><span class="line">        cum_max=<span class="number">0</span></span><br><span class="line">        maxnum=<span class="number">0</span></span><br><span class="line">        res=[]</span><br><span class="line">        <span class="keyword">for</span>  k, i <span class="keyword">in</span> enumerate(array):  </span><br><span class="line">            <span class="keyword">if</span> cum_max+i&gt;=<span class="number">0</span> <span class="keyword">and</span> max(array[k:])&gt;<span class="number">0</span>: <span class="comment"># 注意一点，当前数组后面全是负数，不能再加了</span></span><br><span class="line">                res.append(i)</span><br><span class="line">                cum_max=cum_max+i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment">#curmax=0  #此时可以记下标，这里不要求</span></span><br><span class="line">                cum_max=<span class="number">0</span></span><br><span class="line">                <span class="keyword">if</span> sum(res)&gt;maxnum:</span><br><span class="line">                    maxnum=sum(res)</span><br><span class="line">                res=[]</span><br><span class="line">        <span class="keyword">return</span> max(maxnum,sum(res))    <span class="comment">#sum(res)是最后数组res一直加入元素而没有更新maxnum </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># ======================part2：==========================</span></span><br><span class="line">    <span class="comment"># class Solution:</span></span><br><span class="line">    <span class="comment">#    def FindGreatestSumOfSubArray(self, array):</span></span><br><span class="line">    <span class="comment">#        maxnum= float(-inf)</span></span><br><span class="line">    <span class="comment">#        cum_max= 0</span></span><br><span class="line">    <span class="comment">#        for i in array:</span></span><br><span class="line">    <span class="comment">#            if cum_max+i&lt;0:</span></span><br><span class="line">    <span class="comment">#                cum_max=i        #这一句是精华，什么都不作处理，下一个值当做cum_max</span></span><br><span class="line">    <span class="comment">#            else:</span></span><br><span class="line">    <span class="comment">#                cum_max=cum_max+i</span></span><br><span class="line">    <span class="comment">#            if cum_max&gt;maxnum:</span></span><br><span class="line">    <span class="comment">#                maxnum=cum_max</span></span><br><span class="line">    <span class="comment">#            return maxnum</span></span><br></pre></td></tr></table></figure>
<h3 id="31-整数中1出现的次数"><a href="#31-整数中1出现的次数" class="headerlink" title="31.整数中1出现的次数"></a>31.整数中1出现的次数</h3><p><strong>题目：</strong>求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        count=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>+n):</span><br><span class="line">            count=count+str(i).count(<span class="string">'1'</span>)</span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>
<h3 id="32-把数组排成最小的数-flag"><a href="#32-把数组排成最小的数-flag" class="headerlink" title="32.把数组排成最小的数(flag)"></a>32.把数组排成最小的数(flag)</h3><p><strong>题目：</strong>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p>
<p><strong>思路：</strong>将数组转换成字符串之后，进行两两比较字符串的大小，比如3,32的大小由332和323确定，即3+32和32+3确定。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">PrintMinNumber</span><span class="params">(self, numbers)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> numbers:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">        cmp_def = <span class="keyword">lambda</span> x1,x2: int(str(x1)+str(x2))-int(str(x2)+str(x1))</span><br><span class="line">        a=sorted(numbers,cmp=cmp_def)  <span class="comment">#sortef创建副本，sort原地</span></span><br><span class="line">        b=list(map(<span class="keyword">lambda</span> x:str(x),a)) <span class="comment">#列表数字转字符串</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(b)  <span class="comment">#jion反馈一个字符串</span></span><br></pre></td></tr></table></figure>
<h3 id="33-丑数-flag"><a href="#33-丑数-flag" class="headerlink" title="33.丑数(flag)"></a>33.丑数(flag)</h3><p><strong>题目：</strong>把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p>
<p><strong>思路：</strong>每一个丑数必然是由之前的某个丑数与2，3或5的乘积得到的，这样下一个丑数就用之前的丑数分别乘以2，3，5，找出这三这种最小的并且大于当前最大丑数的值，即为下一个要求的丑数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        <span class="comment"># write code herei</span></span><br><span class="line">        <span class="comment"># 思路，创建一个数组存储丑数；创建三个丑数数组独立下标对应乘以235，最小为当前丑数</span></span><br><span class="line">        <span class="keyword">if</span> index==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> index==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        uglyarr=[<span class="number">1</span>]</span><br><span class="line">        a2,a3,a5=<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(index<span class="number">-1</span>):</span><br><span class="line">            n1,n2,n3=uglyarr[a2]*<span class="number">2</span>,uglyarr[a3]*<span class="number">3</span>,uglyarr[a5]*<span class="number">5</span>        </span><br><span class="line">            min_num=min(n1,n2,n3)</span><br><span class="line">            uglyarr.append(min_num)</span><br><span class="line">            <span class="keyword">if</span> min_num==n1:</span><br><span class="line">                a2=a2+<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> min_num==n2:</span><br><span class="line">                a3=a3+<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> min_num==n3:</span><br><span class="line">                a5=a5+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> uglyarr[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="34-第一个只出现一次的字符"><a href="#34-第一个只出现一次的字符" class="headerlink" title="34.第一个只出现一次的字符"></a>34.第一个只出现一次的字符</h3><p><strong>题目：</strong>在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        ss=list(s)</span><br><span class="line">        <span class="keyword">for</span> i,e <span class="keyword">in</span> enumerate(ss):</span><br><span class="line">            <span class="keyword">if</span> s.count(e)==<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h3 id="35-数组中的逆序对-Flag"><a href="#35-数组中的逆序对-Flag" class="headerlink" title="35.数组中的逆序对(Flag)"></a>35.数组中的逆序对(Flag)</h3><p><strong>题目描述：</strong>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007。</p>
<p><strong>输入描述：</strong>题目保证输入的数组中没有的相同的数字。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">/*</span></span><br><span class="line"><span class="string">归并排序的改进，把数据分成前后两个数组(递归分到每个数组仅有一个数据项)，合并数组，合并时，出现前面的数组值array[i]大于后面数组值array[j]时；则前面数组array[i]~array[mid]都是大于array[j]的，</span></span><br><span class="line"><span class="string">count += mid+1 - i参考剑指Offer，但是感觉剑指Offer归并过程少了一步拷贝过程。还有就是测试用例输出结果比较大，对每次返回的count mod(1000000007)求余</span></span><br><span class="line"><span class="string">*/</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">InversePairs</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> self.inverseCount(data[:], <span class="number">0</span>, len(data)<span class="number">-1</span>, data[:])%<span class="number">1000000007</span></span><br><span class="line">       </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inverseCount</span><span class="params">(self, tmp, start, end, data)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> end-start &lt;<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> end - start == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> data[start]&lt;=data[end]:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        mid = (start+end)//<span class="number">2</span></span><br><span class="line">        cnt = self.inverseCount(data, start, mid, tmp) + self.inverseCount(data, mid+<span class="number">1</span>, end, tmp)</span><br><span class="line">        <span class="comment"># print(start, mid, end, cnt, data)</span></span><br><span class="line">        i = start</span><br><span class="line">        j = mid + <span class="number">1</span></span><br><span class="line">        ind = start  <span class="comment"># 用于tmp的下标</span></span><br><span class="line">           </span><br><span class="line">        <span class="keyword">while</span>(i &lt;= mid <span class="keyword">and</span> j &lt;= end): <span class="comment"># tmp排序</span></span><br><span class="line">            <span class="keyword">if</span> data[i] &lt;= data[j]:</span><br><span class="line">                tmp[ind] = data[i]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tmp[ind] = data[j]</span><br><span class="line">                cnt += mid - i + <span class="number">1</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            ind += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid):</span><br><span class="line">            tmp[ind] = data[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            ind += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span>(j&lt;=end):</span><br><span class="line">            tmp[ind] = data[j]</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">            ind += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> cnt</span><br></pre></td></tr></table></figure>
<h3 id="36-两个链表的第一个公共节点"><a href="#36-两个链表的第一个公共节点" class="headerlink" title="36.两个链表的第一个公共节点"></a>36.两个链表的第一个公共节点</h3><p><strong>题目：</strong>输入两个链表，找出它们的第一个公共结点。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#有些题的输入指针，没有val属性，只有next</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindFirstCommonNode</span><span class="params">(self, pHead1, pHead2)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead1 <span class="keyword">or</span> <span class="keyword">not</span> pHead2:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> pHead1:</span><br><span class="line">            p2=pHead2  </span><br><span class="line">            <span class="keyword">while</span> p2:</span><br><span class="line">                <span class="keyword">if</span> pHead1==p2:</span><br><span class="line">                    <span class="keyword">return</span> pHead1</span><br><span class="line">                p2=p2.next</span><br><span class="line">            pHead1=pHead1.next</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<h3 id="37-数字在排序数组中出现的次数"><a href="#37-数字在排序数组中出现的次数" class="headerlink" title="37.数字在排序数组中出现的次数"></a>37.数字在排序数组中出现的次数</h3><p><strong>题目：</strong>统计一个数字在排序数组中出现的次数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetNumberOfK</span><span class="params">(self, data, k)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        count=<span class="number">0</span></span><br><span class="line">        flag=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> data:</span><br><span class="line">            <span class="keyword">if</span> i==k:</span><br><span class="line">                count=count+<span class="number">1</span></span><br><span class="line">                flag=<span class="number">1</span>  <span class="comment">#设置处在相同阶段的标志</span></span><br><span class="line">            <span class="keyword">if</span> count&gt;<span class="number">0</span> <span class="keyword">and</span> flag!=<span class="number">1</span>: <span class="comment">#不在相同阶段就break </span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>
<h3 id="38-二叉树的深度-flag"><a href="#38-二叉树的深度-flag" class="headerlink" title="38.二叉树的深度(flag)"></a>38.二叉树的深度(flag)</h3><p><strong>题目：</strong>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">TreeDepth</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left=self.TreeDepth(pRoot.left)  <span class="comment">#操作放在后面，想象后序遍历</span></span><br><span class="line">        right=self.TreeDepth(pRoot.right)</span><br><span class="line">        <span class="keyword">return</span> max(left,right)+<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="39-平衡二叉树-flag"><a href="#39-平衡二叉树-flag" class="headerlink" title="39.平衡二叉树(flag)"></a>39.平衡二叉树(flag)</h3><p><strong>题目：</strong>输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p>
<p><strong>题解：</strong>平衡二叉树是左右子数的距离不能大于1，因此递归左右子树，判断子树距离是否大于1。用Maxdeep递归求深度</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">IsBalanced_Solution</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment"># 递归且有一个实现求深度的递归函数</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> abs(self.Maxdeep(pRoot.left)-self.Maxdeep(pRoot.right))&gt;<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> self.IsBalanced_Solution(pRoot.left) <span class="keyword">and</span> self.IsBalanced_Solution(pRoot.right)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Maxdeep</span><span class="params">(self,pRoot)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left = self.Maxdeep(pRoot.left)</span><br><span class="line">        right = self.Maxdeep(pRoot.right)</span><br><span class="line">        <span class="keyword">return</span> max(left,right)+<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="40-数组中只出现一次的数字"><a href="#40-数组中只出现一次的数字" class="headerlink" title="40.数组中只出现一次的数字"></a>40.数组中只出现一次的数字</h3><p><strong>题目：</strong>一个整型数组里除了两个数字之外，其他的数字都出现了偶数次。请写程序找出这两个只出现一次的数字。</p>
<p><strong>题解：</strong>转为字符串；或者将数组中数转到set之中，然后利用dict存储每个数字出现的次数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回[a,b] 其中ab是出现一次的两个数字</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindNumsAppearOnce</span><span class="params">(self, array)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> array:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> len(array)==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> array[<span class="number">0</span>]</span><br><span class="line">        l=[]</span><br><span class="line">        arr_str_list=list(map(<span class="keyword">lambda</span> x:str(x),array))</span><br><span class="line">        arr_str=<span class="string">''</span>.join(arr_str_list) <span class="comment">#输入要为字符列表</span></span><br><span class="line">        <span class="keyword">for</span> i,e <span class="keyword">in</span> enumerate(arr_str_list):</span><br><span class="line">            <span class="keyword">if</span> arr_str.count(e)==<span class="number">1</span>:</span><br><span class="line">                l.append(i)</span><br><span class="line">        ll=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> l:</span><br><span class="line">            ll.append(array[i])</span><br><span class="line">        <span class="keyword">return</span> ll</span><br><span class="line"><span class="comment"># ====================================</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回[a,b] 其中ab是出现一次的两个数字</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindNumsAppearOnce</span><span class="params">(self, array)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        arrayset=set(array)</span><br><span class="line">        dict=&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> arrayset:</span><br><span class="line">            dict[num]=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(array)):</span><br><span class="line">            dict[array[i]]=dict[array[i]]+<span class="number">1</span></span><br><span class="line">        ans=[]</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> arrayset:</span><br><span class="line">            <span class="keyword">if</span> dict[num]==<span class="number">1</span>:</span><br><span class="line">                ans.append(num)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="41-和为S的连续正整数序列"><a href="#41-和为S的连续正整数序列" class="headerlink" title="41.和为S的连续正整数序列"></a>41.和为S的连续正整数序列</h3><p><strong>题目：</strong>小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!</p>
<p><strong>输出描述：</strong>输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindContinuousSequence</span><span class="params">(self, tsum)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment">#若是100,只需要从1：50找就可以了，+2是考虑到下标0开始，让搜索范围大一些</span></span><br><span class="line">        bitsum=tsum//<span class="number">2</span>+<span class="number">2</span> </span><br><span class="line">        ori=list(range(<span class="number">1</span>,bitsum)) </span><br><span class="line">        res=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,bitsum):</span><br><span class="line">            l=[]</span><br><span class="line">            summ=i <span class="comment">#累积总和</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,bitsum):</span><br><span class="line">                summ=summ+j</span><br><span class="line">                <span class="keyword">if</span> summ==tsum:</span><br><span class="line">                    l=ori[i<span class="number">-1</span>:j] <span class="comment">#i,j看做下标返回满足条件的数组</span></span><br><span class="line">                <span class="keyword">if</span> summ&gt;tsum:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> l:</span><br><span class="line">                res.append(l)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="42-和为S的两个数字-flag"><a href="#42-和为S的两个数字-flag" class="headerlink" title="42.和为S的两个数字(flag)"></a>42.和为S的两个数字(flag)</h3><p><strong>题目：</strong>输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。</p>
<p><strong>输出描述：</strong>对应每个测试案例，输出两个数，小的先输出</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindNumbersWithSum</span><span class="params">(self, array, tsum)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment"># 返回列表类型的，若不满足条件则[]</span></span><br><span class="line">        <span class="keyword">if</span> len(array)&lt;=<span class="number">1</span> <span class="keyword">or</span> min(array)&gt;tsum:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(array)):  <span class="comment"># 都是索引下标循环</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,len(array)): </span><br><span class="line">                <span class="keyword">if</span> array[i]+array[j]==tsum:</span><br><span class="line">                    <span class="comment"># 从头开始搜索这时候得到的应该是乘积最小的，可以直接退出外层循环</span></span><br><span class="line">                    res.append(array[i])</span><br><span class="line">                    res.append(array[j])</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> array[j]&gt;tsum:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment"># 上面循环正常结束才会执行，若上面循环执行break则这条语句不执行</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">if</span> res:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>
<h3 id="43-左旋字符子串"><a href="#43-左旋字符子串" class="headerlink" title="43.左旋字符子串"></a>43.左旋字符子串</h3><p><strong>题目：</strong>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">LeftRotateString</span><span class="params">(self, s, n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> len(s)&lt;n <span class="keyword">or</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        <span class="keyword">return</span> s[n:]+s[:n]</span><br></pre></td></tr></table></figure>
<h3 id="44-反转单词顺序-flag"><a href="#44-反转单词顺序-flag" class="headerlink" title="44.反转单词顺序(flag)"></a>44.反转单词顺序(flag)</h3><p><strong>题目：</strong>牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ReverseSentence</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        ss=s.split(<span class="string">' '</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">' '</span>.join(ss[::<span class="number">-1</span>])</span><br></pre></td></tr></table></figure>
<h3 id="45-扑克牌顺序"><a href="#45-扑克牌顺序" class="headerlink" title="45.扑克牌顺序"></a>45.扑克牌顺序</h3><p><strong>题目：</strong>LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\小王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">IsContinuous</span><span class="params">(self, numbers)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment"># 只需要判断没有0的数组里数值是唯一且max-min&lt;5即可</span></span><br><span class="line">        <span class="keyword">if</span> len(numbers)&lt;<span class="number">5</span> <span class="keyword">and</span> <span class="keyword">not</span> numbers:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        grost_num=<span class="number">0</span></span><br><span class="line">        without_gro=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> numbers:</span><br><span class="line">            <span class="keyword">if</span> i==<span class="number">0</span>:</span><br><span class="line">                grost_num+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> i <span class="keyword">in</span> without_gro <span class="keyword">and</span> i!=<span class="number">0</span>: <span class="comment">#唯一</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                without_gro.append(i)</span><br><span class="line">        <span class="keyword">if</span> max(without_gro)-min(without_gro)&lt;<span class="number">5</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h3 id="46-孩子们的圈圈-圈圈中最后剩下的数-flag"><a href="#46-孩子们的圈圈-圈圈中最后剩下的数-flag" class="headerlink" title="46.孩子们的圈圈(圈圈中最后剩下的数)(flag)"></a>46.孩子们的圈圈(圈圈中最后剩下的数)(flag)</h3><p><strong>题目：</strong>每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">LastRemaining_Solution</span><span class="params">(self, n, m)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment"># flag=0</span></span><br><span class="line">        <span class="comment"># 把index想象为连续拼接数组</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n <span class="keyword">or</span> <span class="keyword">not</span> m:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        num = list(range(n))</span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> len(num)&gt;<span class="number">1</span>: <span class="comment"># 剩余两个都要继续执行</span></span><br><span class="line">            index=(index+m<span class="number">-1</span>)%len(num) <span class="comment">#index为上一次停的地方，加上m-1为重新第m-1个出列</span></span><br><span class="line">            num.pop(index)</span><br><span class="line">        <span class="keyword">return</span> num[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h3 id="47-求1-2-3-…-n"><a href="#47-求1-2-3-…-n" class="headerlink" title="47.求1+2+3+…+n"></a>47.求1+2+3+…+n</h3><p><strong>题目：</strong>求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Sum_Solution</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> n+self.Sum_Solution(n<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>
<h3 id="48-不用加减乘除做加法"><a href="#48-不用加减乘除做加法" class="headerlink" title="48.不用加减乘除做加法"></a>48.不用加减乘除做加法</h3><p><strong>题目：</strong>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。</p>
<p><strong>思路：</strong>二进制异或进位。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Add</span><span class="params">(self, num1, num2)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment"># 位操作不懂</span></span><br><span class="line">        <span class="keyword">return</span> sum([num1,num2])</span><br><span class="line">        </span><br><span class="line"><span class="comment"># ============================</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">首先看十进制是如何做的： 5+7=12，三步走</span></span><br><span class="line"><span class="string">第一步：相加各位的值，不算进位，得到2。</span></span><br><span class="line"><span class="string">第二步：计算进位值，得到10. 如果这一步的进位值为0，那么第一步得到的值就是最终结果。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">第三步：重复上述两步，只是相加的值变成上述两步的得到的结果2和10，得到12。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">同样我们可以用三步走的方式计算二进制值相加： 5-101，7-111 第一步：相加各位的值，不算进位，得到010，二进制每位相加就相当于各位做异或操作，101^111。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">第二步：计算进位值，得到1010，相当于各位做与操作得到101，再向左移一位得到1010，(101&amp;111)&lt;&lt;1。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">第三步重复上述两步， 各位相加 010^1010=1000，进位值为100=(010&amp;1010)&lt;&lt;1。</span></span><br><span class="line"><span class="string">     继续重复上述两步：1000^100 = 1100，进位值为0，跳出循环，1100为最终结果。</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Add</span><span class="params">(self, num1, num2)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">while</span> num2!=<span class="number">0</span>:</span><br><span class="line">            sum=num1^num2</span><br><span class="line">            carry=(num1&amp;num2)&lt;&lt;<span class="number">1</span></span><br><span class="line">            num1=sum</span><br><span class="line">            num2=carry</span><br><span class="line">        <span class="keyword">return</span> num1</span><br></pre></td></tr></table></figure>
<h3 id="49-把字符串转换成整数"><a href="#49-把字符串转换成整数" class="headerlink" title="49.把字符串转换成整数"></a>49.把字符串转换成整数</h3><p><strong>题目：</strong>将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。</p>
<p><strong>输入描述：</strong>输入一个字符串,包括数字字母符号,可以为空输出描述:如果是合法的数值表达则返回该数字，否则返回0。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">StrToInt</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        l=[s]</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            num=list(map(eval,l))  </span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> num[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h3 id="50-数组中重复的数字"><a href="#50-数组中重复的数字" class="headerlink" title="50.数组中重复的数字"></a>50.数组中重复的数字</h3><p><strong>题目：</strong>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p>
<p><strong>思路：</strong>利用dict计算重复数字。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 这里要特别注意~找到任意重复的一个值并赋值到duplication[0]</span></span><br><span class="line">    <span class="comment"># 函数返回True/False</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">duplicate</span><span class="params">(self, numbers, duplication)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> numbers:</span><br><span class="line">            <span class="keyword">if</span> numbers.count(i)&gt;<span class="number">1</span>:</span><br><span class="line">                duplication[<span class="number">0</span>]=i</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h3 id="51-构建乘积数组"><a href="#51-构建乘积数组" class="headerlink" title="51.构建乘积数组"></a>51.构建乘积数组</h3><p><strong>题目</strong>:给定数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1];其中B中的元素B[i]=A[0]<em>A[1]…A[i-1]</em>A[i+1]…A[n-1]。不能使用除法。</p>
<p><strong>注意</strong>：没有A[i]</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">multiply</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> A:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> len(A)==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        B=[<span class="literal">None</span>]*len(A)</span><br><span class="line">        <span class="keyword">for</span> i,e <span class="keyword">in</span> enumerate(A):</span><br><span class="line">            cumpower=<span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> ii,ee <span class="keyword">in</span> enumerate(A):</span><br><span class="line">                <span class="keyword">if</span> ii!=i:</span><br><span class="line">                    cumpower=cumpower*ee</span><br><span class="line">            B[i]=cumpower</span><br><span class="line">        <span class="keyword">return</span> B</span><br></pre></td></tr></table></figure>
<h3 id="52-正则表达式匹配-flag"><a href="#52-正则表达式匹配-flag" class="headerlink" title="52.正则表达式匹配(flag)"></a>52.正则表达式匹配(flag)</h3><p><strong>题目：</strong>请实现一个函数用来匹配包括’ , ‘和’ * ‘的正则表达式。模式中的字符’ , ‘表示任意一个字符，而’ * ‘表示它前面的字符可以出现任意次（包含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但是与”aa.a”和”ab*a”均不匹配。</p>
<p> 思路: </p>
<blockquote>
<p>当模式中的第二个字符不是 *时：</p>
<ul>
<li>如果字符串第一个字符和模式中的第一个字符相匹配，那么字符串和模式都后移一个字符，然后匹配剩余的。</li>
<li>如果字符串第一个字符和模式中的第一个字符相不匹配，直接返回false。</li>
</ul>
<p>当模式中的第二个字符是 *时：</p>
<ul>
<li>如果字符串第一个字符跟模式第一个字符不匹配，则模式后移2个字符，继续匹配。</li>
<li>如果字符串第一个字符跟模式第一个字符匹配，可以有3种匹配方式。<ul>
<li>模式后移2字符，相当于 x<em>被忽略。即模式串中</em>与他前面的字符和字符串匹配0次。</li>
<li>字符串后移1字符，模式后移2字符。即模式串中*与他前面的字符和字符串匹配1次。</li>
<li>字符串后移1字符，模式不变，即继续匹配字符下一位，因为 <em>可以匹配多位。即模式串中</em>与他前面的字符和字符串匹配多次。</li>
</ul>
</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># s, pattern都是字符串</span></span><br><span class="line">    <span class="comment"># flag=0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">match</span><span class="params">(self, s, pattern)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> (len(s) == <span class="number">0</span> <span class="keyword">and</span> len(pattern) == <span class="number">0</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> (len(s) &gt; <span class="number">0</span> <span class="keyword">and</span> len(pattern) == <span class="number">0</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> (len(pattern) &gt; <span class="number">1</span> <span class="keyword">and</span> pattern[<span class="number">1</span>] == <span class="string">'*'</span>):</span><br><span class="line">            <span class="keyword">if</span> (len(s) &gt; <span class="number">0</span> <span class="keyword">and</span> (s[<span class="number">0</span>] == pattern[<span class="number">0</span>] <span class="keyword">or</span> pattern[<span class="number">0</span>] == <span class="string">'.'</span>)):</span><br><span class="line">                <span class="keyword">return</span> (self.match(s, pattern[<span class="number">2</span>:]) <span class="keyword">or</span> self.match(s[<span class="number">1</span>:], pattern[<span class="number">2</span>:]) <span class="keyword">or</span> self.match(s[<span class="number">1</span>:], pattern))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> self.match(s, pattern[<span class="number">2</span>:])</span><br><span class="line">        <span class="keyword">if</span> (len(s) &gt; <span class="number">0</span> <span class="keyword">and</span> (pattern[<span class="number">0</span>] == <span class="string">'.'</span> <span class="keyword">or</span> pattern[<span class="number">0</span>] == s[<span class="number">0</span>])):</span><br><span class="line">            <span class="keyword">return</span> self.match(s[<span class="number">1</span>:], pattern[<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h3 id="53-表示数值的字符串"><a href="#53-表示数值的字符串" class="headerlink" title="53.表示数值的字符串"></a>53.表示数值的字符串</h3><p><strong>题目：</strong>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># s字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isNumeric</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        l=[s]</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            b=float(s)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h3 id="54-字符流中第一个不重复的字符-flag"><a href="#54-字符流中第一个不重复的字符-flag" class="headerlink" title="54.字符流中第一个不重复的字符(flag)"></a>54.字符流中第一个不重复的字符(flag)</h3><p><strong>题目：</strong>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。</p>
<p><strong>输出描述：</strong>如果当前字符流没有存在出现一次的字符，返回#字符。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># flag=0</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回对应char</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.s=<span class="string">''</span></span><br><span class="line">        self.dict=&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FirstAppearingOnce</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> self.s:</span><br><span class="line">            <span class="keyword">if</span> self.dict[i]==<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'#'</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Insert</span><span class="params">(self, char)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        self.s+=char</span><br><span class="line">        <span class="keyword">if</span> char <span class="keyword">in</span> self.dict:</span><br><span class="line">            self.dict[char]+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.dict[char]=<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="55-链表中环的入口节点-flag"><a href="#55-链表中环的入口节点-flag" class="headerlink" title="55.链表中环的入口节点(flag)"></a>55.链表中环的入口节点(flag)</h3><p><strong>题目：</strong>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。</p>
<p><strong>思路：</strong>第一步，找环中相汇点。分别用p1，p2指向链表头部，p1每次走一步，p2每次走二步，直到p1==p2找到在环中的相汇点。第二步，找环的入口。接上步，当p1==p2时，p2所经过节点数为2x,p1所经过节点数为x,设环中有n个节点,p2比p1多走一圈有2x=n+x;n=x;可以看出p1实际走了一个环的步数，再让p2指向链表头部，p1位置不变，p1,p2每次走一步直到p1==p2; 此时p1指向环的入口：直线+小段环=整环，故p1再走整环-小段环到达起点。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">EntryNodeOfLoop</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        fast,slow=pHead,pHead</span><br><span class="line">        <span class="keyword">if</span> fast <span class="keyword">and</span> fast.next: </span><br><span class="line">            fast=fast.next.next</span><br><span class="line">            slow=slow.next</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.next <span class="keyword">and</span> fast!=slow:</span><br><span class="line">            fast=fast.next.next</span><br><span class="line">            slow=slow.next</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> fast.next: </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        fast=pHead</span><br><span class="line">        <span class="keyword">while</span> fast!=slow:</span><br><span class="line">            fast=fast.next</span><br><span class="line">            slow=slow.next</span><br><span class="line">        <span class="keyword">return</span> fast</span><br></pre></td></tr></table></figure>
<h3 id="56-删除链表中重复的节点-flag"><a href="#56-删除链表中重复的节点-flag" class="headerlink" title="56.删除链表中重复的节点(flag)"></a>56.删除链表中重复的节点(flag)</h3><p><strong>题目：</strong>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留(全部删除)，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplication</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        result = ListNode(<span class="number">0</span>)</span><br><span class="line">        res = result</span><br><span class="line">        tmp = pHead</span><br><span class="line">        <span class="keyword">while</span> tmp <span class="keyword">and</span> tmp.next:</span><br><span class="line">            <span class="keyword">if</span> tmp.val == tmp.next.val:</span><br><span class="line">                <span class="keyword">while</span> tmp.next <span class="keyword">and</span> tmp.val == tmp.next.val:</span><br><span class="line">                    tmp = tmp.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.next = tmp  <span class="comment">#把整个tmp之后的链表都接上去了</span></span><br><span class="line">                res = res.next</span><br><span class="line">            tmp = tmp.next</span><br><span class="line">        res.next = tmp</span><br><span class="line">        <span class="keyword">return</span> result.next</span><br><span class="line">            </span><br><span class="line"><span class="comment"># 一开始res为&#123;-1&#125;，1和2不同，res.next = tmp得到&#123;-1，1,2,3,3,4,4,5&#125;，res和tmp指针往下</span></span><br><span class="line"><span class="comment"># 第二次2和3不同，res.next = tmp得到&#123;-1，1，+，2,3,3,4,4,5&#125;，+号前为res指针位置</span></span><br><span class="line"><span class="comment"># 第三次3和3相同，tmp指针到4的位置，下一次res.next=tmp得到&#123;-1,1,2，+，4,4,5&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="57-二叉树中的下一个节点"><a href="#57-二叉树中的下一个节点" class="headerlink" title="57. 二叉树中的下一个节点"></a>57. 二叉树中的下一个节点</h3><p><strong>题目：</strong>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p>
<p><strong>思路：</strong>分析二叉树的下一个节点，一共有以下情况：1.二叉树为空，则返回空；2.节点右孩子存在，则设置一个指针从该节点的右孩子出发，一直沿着指向左子结点的指针找到的叶子节点即为下一个节点；3.节点不是根节点。如果该节点是其父节点的左孩子，则返回父节点；否则继续向上遍历其父节点的父节点，重复之前的判断，返回结果。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeLinkNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetNext</span><span class="params">(self, pNode)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pNode:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> pNode.right:</span><br><span class="line">            pNode=pNode.right</span><br><span class="line">            <span class="keyword">while</span> pNode.left:</span><br><span class="line">                pNode=pNode.left</span><br><span class="line">            <span class="keyword">return</span> pNode</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>: <span class="comment">#存在该节点在父节点右边，且一直递归，这时要找爷爷节点 型如"\"</span></span><br><span class="line">            <span class="keyword">while</span> pNode.next:</span><br><span class="line">                <span class="keyword">if</span> pNode.next.left==pNode:</span><br><span class="line">                    <span class="keyword">return</span> pNode.next</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    pNode=pNode.next</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<h3 id="58-对称的二叉树-flag"><a href="#58-对称的二叉树-flag" class="headerlink" title="58.对称的二叉树(flag)"></a>58.对称的二叉树(flag)</h3><p><strong>题目：</strong>请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p>
<p><strong>思路：</strong>采用递归的方法来判断两数是否相同。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"><span class="comment">#  设计一个递归求issame的函数,issame(root1.left,root2.right)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetrical</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot.left <span class="keyword">and</span> <span class="keyword">not</span> pRoot.right:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> pRoot.left <span class="keyword">and</span> pRoot.right:</span><br><span class="line">            <span class="keyword">return</span> self.issame(pRoot.left,pRoot.right)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">issame</span><span class="params">(self, root1, root2)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root1 <span class="keyword">and</span> <span class="keyword">not</span> root2:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> root1 <span class="keyword">and</span> root2:</span><br><span class="line">            <span class="keyword">if</span> root1.val==root2.val:</span><br><span class="line">                <span class="keyword">return</span> self.issame(root1.left,root2.right) <span class="keyword">and</span> self.issame(root2.left,root1.right)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h3 id="59-按之字形顺序打印二叉树-flag"><a href="#59-按之字形顺序打印二叉树-flag" class="headerlink" title="59.按之字形顺序打印二叉树(flag)"></a>59.按之字形顺序打印二叉树(flag)</h3><p><strong>题目：</strong>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Print</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        res=[]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        level=[pRoot]</span><br><span class="line">        reverseflag=<span class="literal">False</span></span><br><span class="line">        <span class="keyword">while</span> level:</span><br><span class="line">            levelvalue=[]</span><br><span class="line">            nextlevel=[]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> level:</span><br><span class="line">                levelvalue.append(i.val)</span><br><span class="line">                <span class="keyword">if</span> i.left:</span><br><span class="line">                    nextlevel.append(i.left)</span><br><span class="line">                <span class="keyword">if</span> i.right:</span><br><span class="line">                    nextlevel.append(i.right)</span><br><span class="line">            <span class="keyword">if</span> reverseflag:</span><br><span class="line">                levelvalue.reverse()</span><br><span class="line">            <span class="keyword">if</span> levelvalue:</span><br><span class="line">                res.append(levelvalue)</span><br><span class="line">                <span class="comment"># for j in levelvalue:</span></span><br><span class="line">                <span class="comment">#     res.append(j) </span></span><br><span class="line">            reverseflag = <span class="keyword">not</span> reverseflag</span><br><span class="line">            level=nextlevel</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="60-把二叉树打印成多行"><a href="#60-把二叉树打印成多行" class="headerlink" title="60.把二叉树打印成多行"></a>60.把二叉树打印成多行</h3><p><strong>题目：</strong>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回二维列表[[1,2],[4,5]]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Print</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res=[]</span><br><span class="line">        level = [pRoot]</span><br><span class="line">        <span class="keyword">while</span> level:</span><br><span class="line">            levelvalue=[]</span><br><span class="line">            nextlevel=[]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> level:</span><br><span class="line">                levelvalue.append(i.val)</span><br><span class="line">                <span class="keyword">if</span> i.left:</span><br><span class="line">                    nextlevel.append(i.left)</span><br><span class="line">                <span class="keyword">if</span> i.right:</span><br><span class="line">                    nextlevel.append(i.right)</span><br><span class="line">            <span class="keyword">if</span> levelvalue:</span><br><span class="line">                res.append(levelvalue)</span><br><span class="line">            level = nextlevel</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="61-序列化二叉树-flag"><a href="#61-序列化二叉树-flag" class="headerlink" title="61.序列化二叉树(flag)"></a>61.序列化二叉树(flag)</h3><p><strong>题目：</strong>请实现两个函数，分别用来序列化和反序列化二叉树。</p>
<p><strong>思路：</strong>转变成前序遍历，空元素利用”#”代替，然后进行解序列。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"><span class="comment">#序列化指的是遍历二叉树为字符串；所谓反序列化指的是依据字符串重新构造成二叉树。</span></span><br><span class="line"><span class="comment">#当在遍历二叉树时碰到Null指针时，这些Null指针被序列化为一个特殊的字符“#”,结点之间的数值用逗号隔开。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Serialize</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">Pre_Order</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> root:</span><br><span class="line">                result.append(str(root.val))</span><br><span class="line">                Pre_Order(root.left)</span><br><span class="line">                Pre_Order(root.right)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result.append(<span class="string">'#'</span>)</span><br><span class="line">        result = []</span><br><span class="line">        Pre_Order(root)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">','</span>.join(result)</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Deserialize</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        s = s.split(<span class="string">','</span>)</span><br><span class="line">         </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">Change</span><span class="params">(num)</span>:</span></span><br><span class="line">            num[<span class="number">0</span>] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> num[<span class="number">0</span>] &lt; len(s):</span><br><span class="line">                <span class="keyword">if</span> s[num[<span class="number">0</span>]] == <span class="string">'#'</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">                root = TreeNode(int(s[num[<span class="number">0</span>]]))</span><br><span class="line">                root.left = Change(num)</span><br><span class="line">                root.right = Change(num)</span><br><span class="line">                <span class="keyword">return</span> root</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        num = [<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> Change(num)</span><br></pre></td></tr></table></figure>
<h3 id="62-二叉搜索树中的第K个节点"><a href="#62-二叉搜索树中的第K个节点" class="headerlink" title="62.二叉搜索树中的第K个节点"></a>62.二叉搜索树中的第K个节点</h3><p><strong>题目：</strong>给定一棵二叉搜索树，请找出其中的第k小的结点。例如（5，3，7，2，4，6，8）中，按结点数值大小顺序第三小结点的值为4。</p>
<p><strong>思路：</strong>中序遍历后，返回第K个节点值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回对应节点TreeNode</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.res = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">KthNode</span><span class="params">(self, pRoot, k)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment">#pnode=pRoot  # 为啥要加这一句呢？</span></span><br><span class="line">        self.sorttree(pRoot)</span><br><span class="line">        <span class="keyword">if</span> len(self.res)&lt;k <span class="keyword">or</span> k&lt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.res[k<span class="number">-1</span>]</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sorttree</span><span class="params">(self,pRoot)</span>:</span> <span class="comment"># 中序排序</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        left = self.sorttree(pRoot.left)</span><br><span class="line">        self.res.append(pRoot)</span><br><span class="line">        right = self.sorttree(pRoot.right)</span><br></pre></td></tr></table></figure>
<h3 id="63-数据流中的中位数"><a href="#63-数据流中的中位数" class="headerlink" title="63.数据流中的中位数"></a>63.数据流中的中位数</h3><p><strong>题目：</strong>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.arr=[]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Insert</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        self.arr.append(num)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetMedian</span><span class="params">(self,arr)</span>:</span> <span class="comment">#为啥这里要加 arr 作为输入,换为其他参数也行，必须要占位？</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        res=sorted(self.arr)</span><br><span class="line">        <span class="keyword">if</span> len(res)%<span class="number">2</span>==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> (res[len(res)//<span class="number">2</span><span class="number">-1</span>]+res[len(res)//<span class="number">2</span>])/<span class="number">2.0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> res[len(res)//<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<h3 id="64-滑动窗口的最大值"><a href="#64-滑动窗口的最大值" class="headerlink" title="64.滑动窗口的最大值"></a>64.滑动窗口的最大值</h3><p><strong>题目：</strong>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}，{2,3,4,2,6,[2,5,1]}。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxInWindows</span><span class="params">(self, num, size)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> size&lt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">if</span> size==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> num</span><br><span class="line">        res=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(num)-size+<span class="number">1</span>):</span><br><span class="line">            res.append(max(num[i:i+size]))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="65-矩阵中的路径-flag"><a href="#65-矩阵中的路径-flag" class="headerlink" title="65.矩阵中的路径(flag)"></a>65.矩阵中的路径(flag)</h3><p><strong>题目：</strong>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。例如 a b c e s f c s a d e e 这样的3 X 4 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</p>
<p><strong>思路：</strong>当起点第一个字符相同时，开始进行递归搜索，设计搜索函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPath</span><span class="params">(self, matrix, rows, cols, path)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(rows):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(cols):</span><br><span class="line">                <span class="keyword">if</span> matrix[i*cols+j]==path[<span class="number">0</span>]:</span><br><span class="line">                    <span class="keyword">if</span> self.findpath(list(matrix),rows,cols,path[<span class="number">1</span>:],i,j):</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findpath</span><span class="params">(self, matrix, rows, cols, path ,i ,j)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> path:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        matrix[i*cols+j]=<span class="string">'0'</span></span><br><span class="line">        <span class="keyword">if</span> j+<span class="number">1</span>&lt;cols <span class="keyword">and</span> matrix[i*cols+j+<span class="number">1</span>]==path[<span class="number">0</span>]:  <span class="comment">#j+1&lt;cols 这里是下标，不能等于</span></span><br><span class="line">            <span class="keyword">return</span> self.findpath(matrix, rows, cols, path[<span class="number">1</span>:],i,j+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">elif</span> j<span class="number">-1</span>&gt;=<span class="number">0</span> <span class="keyword">and</span> matrix[i*cols+j<span class="number">-1</span>]==path[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> self.findpath(matrix, rows, cols, path[<span class="number">1</span>:],i,j<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">elif</span> i+<span class="number">1</span>&lt;rows <span class="keyword">and</span> matrix[(i+<span class="number">1</span>)*cols+j]==path[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> self.findpath(matrix, rows, cols, path[<span class="number">1</span>:],i+<span class="number">1</span>,j)</span><br><span class="line">        <span class="keyword">elif</span> i<span class="number">-1</span>&gt;=<span class="number">0</span> <span class="keyword">and</span> matrix[(i<span class="number">-1</span>)*cols+j]==path[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> self.findpath(matrix, rows, cols, path[<span class="number">1</span>:],i<span class="number">-1</span>,j)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h3 id="66-机器人的运动范围"><a href="#66-机器人的运动范围" class="headerlink" title="66.机器人的运动范围"></a>66.机器人的运动范围</h3><p><strong>题目：</strong>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">movingCount</span><span class="params">(self, threshold, rows, cols)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment"># 回溯的出口 ： 所有self.findgrid回溯出口的不满足if条件就停止</span></span><br><span class="line">        matrix = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(cols)] <span class="keyword">for</span> j <span class="keyword">in</span> range(rows)]</span><br><span class="line">        count = self.findgrid(threshold,rows,cols,matrix,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findgrid</span><span class="params">(self,threshold,rows,cols,matrix,i,j)</span>:</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span>&lt;=i&lt;rows <span class="keyword">and</span> <span class="number">0</span>&lt;=j&lt;cols <span class="keyword">and</span> (sum(map(int, str(i) + str(j))) &lt;= threshold) <span class="keyword">and</span> matrix[i][j]==<span class="number">0</span>:</span><br><span class="line">            matrix[i][j] = <span class="number">1</span></span><br><span class="line">            count = <span class="number">1</span> + self.findgrid(threshold,rows,cols,matrix,i,j<span class="number">-1</span>)\</span><br><span class="line">            + self.findgrid(threshold,rows,cols,matrix,i,j+<span class="number">1</span>)\</span><br><span class="line">            + self.findgrid(threshold,rows,cols,matrix,i+<span class="number">1</span>,j)\</span><br><span class="line">            + self.findgrid(threshold,rows,cols,matrix,i<span class="number">-1</span>,j)</span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>朴素贝叶斯</title>
    <url>/2018/08/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/</url>
    <content><![CDATA[<blockquote>
<p>注：这篇文章原文出处放在了下面的连接，原文已经写得非常清晰明了，这里有适当的修改和增加内容，写在这里是为了更好地查阅巩固。</p>
</blockquote>
<p><a href="https://plushunter.github.io/2017/02/15/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%EF%BC%8810%EF%BC%89%EF%BC%9A%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/" target="_blank" rel="noopener">戳我原文</a></p>
<p>朴素贝叶斯（Naive Bayes）是基于贝叶斯定理与特征条件假设的分类方法。</p>
<p>对于给定的训练数据集，首先基于特征条件独立假设学习输入、输出的联合分布；然后基于此模型，对给定的输入x，利用贝叶斯定理求出后验概率最大的输出y。</p>
<p>朴素贝叶斯实现简单，学习与预测的效率都很高，是一种常用的方法。</p>
<h1 id="朴素贝叶斯的学习与分类"><a href="#朴素贝叶斯的学习与分类" class="headerlink" title="朴素贝叶斯的学习与分类"></a>朴素贝叶斯的学习与分类</h1><h2 id="贝叶斯定理"><a href="#贝叶斯定理" class="headerlink" title="贝叶斯定理"></a>贝叶斯定理</h2><p>先看什么是条件概率</p>
<p>P(A|B)表示事件B已经发生的前提下，事件A发生的概率，叫做事件B发生下事件A的条件概率。其基本求解公式为</p>
<script type="math/tex; mode=display">
P\left(A|B\right)=\frac{P\left(AB\right)}{P\left(B\right)}</script><p>贝叶斯定理便是基于条件概率，通过P(A|B)来求P(B|A)：</p>
<script type="math/tex; mode=display">
P\left(B|A\right)=\frac{P\left(A|B\right)·P\left(B\right)}{P\left(A\right)}</script><p>顺便提一下，<strong>上式中的分母，可以根据全概率公式分解为</strong>：</p>
<script type="math/tex; mode=display">
P\left(A\right)=\sum_{i=1}^n{P\left(B_i\right)P\left(A|B_i\right)}</script><h2 id="特征条件独立假设"><a href="#特征条件独立假设" class="headerlink" title="特征条件独立假设"></a>特征条件独立假设</h2><p>这一部分开始朴素贝叶斯的理论推导，从中你会深刻地理解什么是特征条件独立假设。</p>
<p>给定训练数据集(X,Y)，其中每个样本X都包括nn维特征，即$x=(x_1,x_2,···,x_n)$，类标记集合含有K种类别，即$y=(y_1,y_2,···,y_k)$ </p>
<p>如果现在来了一个新样本x我们要怎么判断它的类别?从概率的角度来看，这个问题就是给定x，它属于哪个类别的概率更大。<strong>那么问题就转化为求解$P(y_1|x),P(y_2|x),P(y_k|x)$中最大的那个，即求后验概率最大的输出</strong>：$arg\underset{y_k}{\max}P\left(y_k|x\right)$ 。那$P(y_k|x)$怎么求解？答案就是贝叶斯定理</p>
<script type="math/tex; mode=display">
P\left(y_k|x\right)=\frac{P\left(x|y_k\right)·P\left(y_k\right)}{P\left(x\right)}</script><p>根据全概率公式，可以进一步分解上式中的分母：</p>
<script type="math/tex; mode=display">
P\left(y_k|x\right)=\frac{P\left(x|y_k\right)·P\left(y_k\right)}{\sum_{i=1}^n{P\left(x|y_k\right)P\left(y_k\right)}}
（公式1）</script><p><strong>先不管分母，分子中的$P(y_k)$是先验概率，根据训练集就可以简单地计算出来</strong>，而条件概率$P(x|y<em>k)=P(x_1,x_2,···,x_n|y_k)$它的参数规模是指数数量级别的，假设第$i$维特征$x_i$可取值的个数有$S_i$个，类别取值个数为k个，那么参数个数为$k\prod</em>{j=1}^n{S_j}$ </p>
<p>这显然是不可行的。针对这个问题，<strong>朴素贝叶斯算法对条件概率分布做了独立性的假设，通俗地讲就是说假设各个维度的特征 $x_1,x_2,···,x_n$互相独立，由于这是一个较强的假设</strong>，朴素贝叶斯算法也因此得名。在这个假设的前提上，条件概率可以转化为：</p>
<script type="math/tex; mode=display">
P\left(x|y_i\right)=P\left(x_1,x_2,···,x_n|y_i\right)=\prod_{i=1}^n{P\left(x_i|y_i\right)}
    （公式2）</script><p>这样参数规模就降到了$\sum_{i=1}^n{S_ik}$</p>
<p>以上就是针对条件概率所作出的特征条件独立性假设，至此，先验概率$P(y_k)$和条件概率$P(x|y_k)$的求解问题就都解决了，那么我们是不是可以求解我们所需要的后验概率$P(y_k|x)$了？</p>
<p>答案是肯定的。我们继续上面关于$P(y_k|x)$的推导，将公式2代入公式1中得到：</p>
<script type="math/tex; mode=display">
P\left(y_k|x\right)=\frac{P\left(y_k\right)\prod_{i=1}^n{P\left(x_i|y_k\right)}}{\sum_k{P\left(y_k\right)\prod_{i=1}^n{P\left(x_i|y_k\right)}}}</script><p>于是朴素贝叶斯分类器可表示为：</p>
<script type="math/tex; mode=display">
f\left(x\right)=arg\underset{y_k}{\max}P\left(y_k|x\right)=arg\underset{y_k}{\max}\frac{P\left(y_k\right)\prod_{i=1}^n{P\left(x_i|y_k\right)}}{\sum_k{P\left(y_k\right)\prod_{i=1}^n{P\left(x_i|y_k\right)}}}</script><p>因为对于所有的$y_k$，上式中的分母的值都是一样的（为什么？注意到全加符号就容易理解了），<strong>所以可以忽略分母部分，朴素贝叶斯分裂期最终表示为：</strong></p>
<script type="math/tex; mode=display">
f\left(x\right)=arg\underset{y_k}{\max}P\left(y_k\right)\prod_{i=1}^n{P\left(x_i|y_k\right)}</script><h1 id="朴素贝叶斯法的参数估计"><a href="#朴素贝叶斯法的参数估计" class="headerlink" title="朴素贝叶斯法的参数估计"></a>朴素贝叶斯法的参数估计</h1><h2 id="极大似然估计"><a href="#极大似然估计" class="headerlink" title="极大似然估计"></a>极大似然估计</h2><p>根据上述，可知朴素贝叶斯要学习的东西就是$P(Y=c<em>k)$和$P(X^{j}=a</em>{jl}|Y=c_k)$可以应用极大似然估计法估计相应的概率（简单讲，就是用样本来推断模型的参数，或者说是使得似然函数最大的参数）</p>
<p><strong>先验概率$P(Y=c_k)$的极大似然估计是</strong></p>
<script type="math/tex; mode=display">
P\left(Y=c_k\right)=\frac{\sum_{i=1}^N{I\left(y_i=c_k\right)}}{N},\,\,k=1,2,···,K</script><p><strong>也就是用样本中$c_k$的出现次数除以样本容量</strong>。</p>
<p>设第$j$个特征$x^{(j)}$可能取值的集合为${a<em>{j1},a</em>{j2},···,a<em>{jl}}$，**条件概率 $P(X^{j}=a</em>{jl}|Y=c_k)$的极大似然估计是**：</p>
<script type="math/tex; mode=display">
P\left(X^{\left(j\right)}=a_{jl}|Y=c_k\right)=\frac{\sum_{i=1}^N{I\left(x_{i}^{\left(j\right)}=a_{jl},y_{i=}c_k\right)}}{\sum_{i=1}^N{I\left(y_i=c_k\right)}}</script><p>式中，$x_i^j$是第$i$个样本的第$j$个特征。</p>
<h1 id="一个例题"><a href="#一个例题" class="headerlink" title="一个例题"></a>一个例题</h1><p>例题如下</p>
<p><img src="/2018/08/28/机器学习专题/朴素贝叶斯/01.png" alt></p>
<p><img src="/2018/08/28/机器学习专题/朴素贝叶斯/02.png" alt></p>
<h2 id="贝叶斯估计"><a href="#贝叶斯估计" class="headerlink" title="贝叶斯估计"></a>贝叶斯估计</h2><p>极大似然估计有一个隐患，假设训练数据中没有出现某种参数与类别的组合怎么办？比如上例中当Y=1对应的$X^{(1)}$的取值只有1和2。这样可能会出现所要估计的概率值为0的情况，但是这不代表真实数据中就没有这样的组合。这时会影响到后验概率的计算结果，使分类产生偏差。解决办法是贝叶斯估计。</p>
<p><strong>条件概率的贝叶斯估计</strong>：</p>
<script type="math/tex; mode=display">
P_{\lambda}\left(X^{\left(j\right)}=a_{jl}\parallel Y=c_k\right)=\frac{\sum_{i=1}^N{I\left(x_{i}^{\left(j\right)}=a_{jl},y_{i=}c_k\right)}+\lambda}{\sum_{i=1}^N{I\left(y_i=c_k\right)}+S_j\lambda}</script><p>其中$\lambda≥0$，<strong>$S_j$表示第$x_j$个特征可能取值的个数</strong>。<strong>分子和分母分别比极大似然估计多了一点东西</strong>，其意义为在随机变量各个取值的频数上赋予一个正数$λ≥0$。<strong>当$λ=0$时就是极大似然估计。常取$λ=1$，这时称为拉普拉斯平滑。</strong></p>
<p>先验概率的贝叶斯估计：（K为类别个数）</p>
<script type="math/tex; mode=display">
P_{\lambda}\left(Y=c_k\right)=\frac{\sum_{i=1}^N{I\left(y_i=c_k\right)}+\lambda}{N+K\lambda}</script><p>例题如下：套入公式计算即可</p>
<p><img src="/2018/08/28/机器学习专题/朴素贝叶斯/03.png" alt></p>
<p>上诉说的是$X<em>j$为普通离散型的情况。<strong>如果$X_j$是稀疏的离散值，即各个特征的出现概率很低</strong>，那么可以假设$X_j$服从伯努利分布，即特征$X_j$出现记为1，不出现记为0。**即我们只关注$X_j$是否出现，不关注$X_j$出现的次数，这样得到的$P\left(X^{\left(j\right)}=a</em>{jl}|Y=c<em>k\right)$是在是在样本类别$c_k$中$a</em>{jl}$出现的频率**，公式如下所示。其中$a_{jl}$取值为0和1。</p>
<script type="math/tex; mode=display">
P(X_j=a_{jl}|Y=C_k)=P(X_j|Y=C_k)a_{jl}+(1-P(X_j|Y=C_k))(1-a_{jl})</script><p><strong>如果$X_j$是连续值</strong>，那么假设$X<em>j$的先验概率为高斯分布(正态分布)，这样假设$P\left(X^{\left(j\right)}=a</em>{jl}|Y=c<em>k\right)$的概率分布公式如下所示。其**中$\mu_k$和$\sigma</em>{k}^2$是正态分布的期望和方差**，$\mu<em>k$为样本类别$C_k$中，所有$X_j$的平均值，$\sigma</em>{k}^2$为样本类别$C<em>k$中，所有$X_j$的方差，$\mu_k$和$\sigma</em>{k}^2$可以通过极大似然估计求得。</p>
<script type="math/tex; mode=display">
P(X_j=a_{jl}|Y=C_k)=\frac{1}{\sqrt{2 \pi \sigma^2}}exp(-\frac{(a_{jl}- \mu_k)^2}{2\sigma_{k}^{2}})</script><h1 id="python代码实现"><a href="#python代码实现" class="headerlink" title="python代码实现"></a>python代码实现</h1><h2 id="朴素贝叶斯文档分类"><a href="#朴素贝叶斯文档分类" class="headerlink" title="朴素贝叶斯文档分类"></a>朴素贝叶斯文档分类</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Created on 下午5:28 22 03 2017</span></span><br><span class="line"><span class="string">bayes algorithm: classify a words as good or bad   [text classify]</span></span><br><span class="line"><span class="string">@author: plushunter</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Naive_Bayes</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._creteria = <span class="string">"NB"</span></span><br><span class="line">    <span class="comment">#创建不重复词集</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_creatVocabList</span><span class="params">(self,dataSet)</span>:</span></span><br><span class="line">        vocabSet = set([])  <span class="comment"># 创建一个空的SET</span></span><br><span class="line">        <span class="keyword">for</span> document <span class="keyword">in</span> dataSet:</span><br><span class="line">            vocabSet = vocabSet | set(document)  <span class="comment"># 并集</span></span><br><span class="line">        <span class="keyword">return</span> list(vocabSet)  <span class="comment"># 返回不重复词表（SET的特性）</span></span><br><span class="line">    <span class="comment">#文档词集向量模型</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_setOfWordToVec</span><span class="params">(self,vocabList, inputSet)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        功能:给定一行词向量inputSet，将其映射至词库向量vocabList，出现则标记为1，否则标记为0.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        returnVec = [<span class="number">0</span>] * len(vocabList)</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> inputSet:</span><br><span class="line">            <span class="keyword">if</span> word <span class="keyword">in</span> vocabList:</span><br><span class="line">                returnVec[vocabList.index(word)] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> returnVec</span><br><span class="line">    <span class="comment">#文档词袋模型</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_bagOfsetOfWordToVec</span><span class="params">(self,vocabList, inputSet)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        功能：对每行词使用第二种统计策略，统计单个词的个数，然后映射到此库中</span></span><br><span class="line"><span class="string">        输出：一个n维向量，n为词库的长度，每个取值为单词出现的次数</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        returnVec = [<span class="number">0</span>] * len(vocabList)</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> inputSet:</span><br><span class="line">            <span class="keyword">if</span> word <span class="keyword">in</span> vocabList:</span><br><span class="line">                returnVec[vocabList.index(word)] += <span class="number">1</span> <span class="comment">#更新此处代码</span></span><br><span class="line">        <span class="keyword">return</span> returnVec</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_trainNB0</span><span class="params">(self,trainMatrix, trainCategory)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        输入：训练词矩阵trainMatrix与类别标签trainCategory,格式为Numpy矩阵格式</span></span><br><span class="line"><span class="string">        功能：计算条件概率p0Vect、p1Vect和类标签概率pAbusive</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        numTrainDocs = len(trainMatrix)<span class="comment">#样本个数</span></span><br><span class="line">        numWords = len(trainMatrix[<span class="number">0</span>])<span class="comment">#特征个数，此处为词库长度</span></span><br><span class="line">        pAbusive = sum(trainCategory) / float(numTrainDocs)<span class="comment">#计算负样本出现概率（先验概率）</span></span><br><span class="line">        p0Num = ones(numWords)<span class="comment">#初始词的出现次数为1，以防条件概率为0，影响结果</span></span><br><span class="line">        p1Num = ones(numWords)<span class="comment">#同上</span></span><br><span class="line">        p0Denom = <span class="number">2.0</span><span class="comment">#类标记为2，使用拉普拉斯平滑法,</span></span><br><span class="line">        p1Denom = <span class="number">2.0</span></span><br><span class="line">        <span class="comment">#按类标记进行聚合各个词向量</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(numTrainDocs):</span><br><span class="line">            <span class="keyword">if</span> trainCategory[i] == <span class="number">0</span>:</span><br><span class="line">                p0Num += trainMatrix[i]</span><br><span class="line">                p0Denom += sum(trainMatrix[i])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p1Num += trainMatrix[i]</span><br><span class="line">                p1Denom += sum(trainMatrix[i])</span><br><span class="line">        p1Vect = log(p1Num / p1Denom)<span class="comment">#计算给定类标记下，词库中出现某个单词的概率</span></span><br><span class="line">        p0Vect = log(p0Num / p0Denom)<span class="comment">#取log对数，防止条件概率乘积过小而发生下溢</span></span><br><span class="line">        <span class="keyword">return</span> p0Vect, p1Vect, pAbusive</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_classifyNB</span><span class="params">(self,vec2Classify, p0Vec, p1Vec, pClass1)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        该算法包含四个输入:</span></span><br><span class="line"><span class="string">        vec2Classify表示待分类的样本在词库中的映射集合，</span></span><br><span class="line"><span class="string">        p0Vec表示条件概率P(wi|c=0)P(wi|c=0)，</span></span><br><span class="line"><span class="string">        p1Vec表示条件概率P(wi|c=1)P(wi|c=1)，</span></span><br><span class="line"><span class="string">        pClass1表示类标签为1时的概率P(c=1)P(c=1)。</span></span><br><span class="line"><span class="string">        p1=ln[p(w1|c=1)p(w2|c=1)…p(wn|c=1)p(c=1)]</span></span><br><span class="line"><span class="string">        p0=ln[p(w1|c=0)p(w2|c=0)…p(wn|c=0)p(c=0)]</span></span><br><span class="line"><span class="string">        log取对数为防止向下溢出</span></span><br><span class="line"><span class="string">        功能:使用朴素贝叶斯进行分类,返回结果为0/1</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        p1 = sum(vec2Classify * p1Vec) + log(pClass1)</span><br><span class="line">        p0 = sum(vec2Classify * p0Vec) + log(<span class="number">1</span> - pClass1)</span><br><span class="line">        <span class="keyword">if</span> p1 &gt; p0:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="comment">#test</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">testingNB</span><span class="params">(self,testSample)</span>:</span></span><br><span class="line">        <span class="string">"step1：加载数据集与类标号"</span></span><br><span class="line">        listOPosts, listClasses = loadDataSet()</span><br><span class="line">        <span class="string">"step2：创建词库"</span></span><br><span class="line">        vocabList = self._creatVocabList(listOPosts)</span><br><span class="line">        <span class="string">"step3：计算每个样本在词库中出现的情况"</span></span><br><span class="line">        trainMat = []</span><br><span class="line">        <span class="keyword">for</span> postinDoc <span class="keyword">in</span> listOPosts:</span><br><span class="line">            trainMat.append(self._bagOfsetOfWordToVec(vocabList, postinDoc))</span><br><span class="line">        p0V, p1V, pAb = self._trainNB0(trainMat, listClasses)</span><br><span class="line">        <span class="string">"step4：测试"</span></span><br><span class="line">        thisDoc = array(self._bagOfsetOfWordToVec(vocabList, testSample))</span><br><span class="line">        result=self._classifyNB(thisDoc, p0V, p1V, pAb)</span><br><span class="line">        <span class="keyword">print</span> testSample, <span class="string">'classified as:'</span>, result</span><br><span class="line">        <span class="comment"># return result</span></span><br><span class="line"><span class="comment">###</span></span><br><span class="line"><span class="comment"># 加载数据集</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loadDataSet</span><span class="params">()</span>:</span></span><br><span class="line">    postingList = [[<span class="string">'my'</span>, <span class="string">'dog'</span>, <span class="string">'has'</span>, <span class="string">'flea'</span>, <span class="string">'problems'</span>, <span class="string">'help'</span>, <span class="string">'please'</span>],</span><br><span class="line">                   [<span class="string">'maybe'</span>, <span class="string">'not'</span>, <span class="string">'take'</span>, <span class="string">'him'</span>, <span class="string">'to'</span>, <span class="string">'dog'</span>, <span class="string">'park'</span>, <span class="string">'stupid'</span>],</span><br><span class="line">                   [<span class="string">'my'</span>, <span class="string">'dalmation'</span>, <span class="string">'is'</span>, <span class="string">'so'</span>, <span class="string">'cute'</span>, <span class="string">'I'</span>, <span class="string">'love'</span>, <span class="string">'him'</span>],</span><br><span class="line">                   [<span class="string">'stop'</span>, <span class="string">'posting'</span>, <span class="string">'stupid'</span>, <span class="string">'worthless'</span>, <span class="string">'garbage'</span>],</span><br><span class="line">                   [<span class="string">'mr'</span>, <span class="string">'licks'</span>, <span class="string">'ate'</span>, <span class="string">'my'</span>, <span class="string">'steak'</span>, <span class="string">'how'</span>, <span class="string">'to'</span>, <span class="string">'stop'</span>, <span class="string">'him'</span>],</span><br><span class="line">                   [<span class="string">'quit'</span>, <span class="string">'buying'</span>, <span class="string">'worthless'</span>, <span class="string">'dog'</span>, <span class="string">'food'</span>, <span class="string">'stupid'</span>]]</span><br><span class="line">    classVec = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]  <span class="comment"># 1 is abusive, 0 not</span></span><br><span class="line">    <span class="keyword">return</span> postingList, classVec</span><br><span class="line"><span class="comment">#测试</span></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    clf = Naive_Bayes()</span><br><span class="line">    testEntry = [[<span class="string">'love'</span>, <span class="string">'my'</span>, <span class="string">'girl'</span>, <span class="string">'friend'</span>],</span><br><span class="line">                 [<span class="string">'stupid'</span>, <span class="string">'garbage'</span>],</span><br><span class="line">                 [<span class="string">'Haha'</span>, <span class="string">'I'</span>, <span class="string">'really'</span>, <span class="string">"Love"</span>, <span class="string">"You"</span>],</span><br><span class="line">                 [<span class="string">'This'</span>, <span class="string">'is'</span>, <span class="string">"my"</span>, <span class="string">"dog"</span>],</span><br><span class="line">                 [<span class="string">'maybe'</span>,<span class="string">'stupid'</span>,<span class="string">'worthless'</span>]]</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> testEntry:</span><br><span class="line">        clf.testingNB(item)</span><br></pre></td></tr></table></figure>
<h2 id="使用朴素贝叶斯过滤垃圾邮件"><a href="#使用朴素贝叶斯过滤垃圾邮件" class="headerlink" title="使用朴素贝叶斯过滤垃圾邮件"></a>使用朴素贝叶斯过滤垃圾邮件</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Created on 下午8:47 22 03 2017</span></span><br><span class="line"><span class="string">Email_Classify </span></span><br><span class="line"><span class="string">@author: plushunter </span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> Bayes</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># mysent='This book is the best book on Python or M.L I have ever laid eyes upon.'</span></span><br><span class="line"><span class="comment"># regEx = re.compile('\\W*')</span></span><br><span class="line"><span class="comment"># listOfTokens=regEx.split(mysent)</span></span><br><span class="line"><span class="comment"># tok=[tok.upper() for tok in listOfTokens if len(tok)&gt;0]</span></span><br><span class="line"><span class="comment"># print tok</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># emailText=open('email/ham/6.txt').read()</span></span><br><span class="line"><span class="comment"># listOfTokens=regEx.split(emailText)</span></span><br><span class="line"><span class="comment"># print listOfTokens</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">textParse</span><span class="params">(bigString)</span>:</span></span><br><span class="line">    <span class="keyword">import</span> re</span><br><span class="line">    listOfTokens=re.split(<span class="string">r'\w*'</span>,bigString)</span><br><span class="line">    <span class="keyword">return</span> [tok.lower() <span class="keyword">for</span> tok <span class="keyword">in</span> listOfTokens <span class="keyword">if</span> len(tok)&gt;<span class="number">2</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spamTest</span><span class="params">()</span>:</span></span><br><span class="line">    clf = Bayes.Naive_Bayes()</span><br><span class="line">    docList=[]</span><br><span class="line">    classList=[]</span><br><span class="line">    fullText=[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">26</span>):</span><br><span class="line">        wordList=textParse(open(<span class="string">'email/spam/%d.txt'</span>%i).read())</span><br><span class="line">        docList.append(wordList)</span><br><span class="line">        fullText.extend(wordList)</span><br><span class="line">        classList.append(<span class="number">1</span>)</span><br><span class="line">        wordList=textParse(open(<span class="string">'email/ham/%i.txt'</span>%i).read())</span><br><span class="line">        docList.append(wordList)</span><br><span class="line">        fullText.extend(wordList)</span><br><span class="line">        classList.append(<span class="number">0</span>)</span><br><span class="line">    vocabList=clf._creatVocabList(docList)</span><br><span class="line">    trainingSet=range(<span class="number">50</span>);testSet=[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        randIndex=int(random.uniform(<span class="number">0</span>,len(trainingSet)))</span><br><span class="line">        testSet.append(trainingSet[randIndex])</span><br><span class="line">        <span class="keyword">del</span>(trainingSet[randIndex])</span><br><span class="line">    trainMatix=[];trainClasses=[]</span><br><span class="line">    <span class="keyword">for</span> docIndex <span class="keyword">in</span> trainingSet:</span><br><span class="line">        trainMatix.append(clf._bagOfsetOfWordToVec(vocabList,docList[docIndex]))</span><br><span class="line">        trainClasses.append(classList[docIndex])</span><br><span class="line">    p0V,p1V,pSpam=clf._trainNB0(array(trainMatix),array(trainClasses))</span><br><span class="line">    errorCount = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> docIndex <span class="keyword">in</span> testSet:</span><br><span class="line">        wordVector = clf._bagOfsetOfWordToVec(vocabList,docList[docIndex])</span><br><span class="line">        <span class="keyword">if</span> clf._classifyNB(array(wordVector), p0V, p1V, pSpam)!=classList[docIndex]:</span><br><span class="line">            errorCount+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'the error rate is :'</span>,float(errorCount)/len(testSet)</span><br></pre></td></tr></table></figure>
<h1 id="朴素贝叶斯优缺点"><a href="#朴素贝叶斯优缺点" class="headerlink" title="朴素贝叶斯优缺点"></a>朴素贝叶斯优缺点</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li>具有稳定的分类效率。</li>
<li>对缺失数据不敏感，算法也比较简单。</li>
<li>对小规模数据表现良好，能处理多分类任务，适合增量式训练。尤其是数据量超出内存后，我们可以一批批的去增量训练。</li>
</ul>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li>对输入数据的表达形式比较敏感，需针对不同类型数据采用不同模型。</li>
<li>由于我们是使用数据加先验概率预测后验概率，所以分类决策存在一定的错误率。</li>
<li>假设各特征之间相互独立，但实际生活中往往不成立，因此对特征个数比较多或特征之间相关性比较大的数据来说，分类效果可能不是太好。</li>
</ul>
]]></content>
      <categories>
        <category>机器学习专题</category>
      </categories>
      <tags>
        <tag>朴素贝叶斯</tag>
      </tags>
  </entry>
  <entry>
    <title>最大期望算法</title>
    <url>/2018/08/27/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/%E6%9C%80%E5%A4%A7%E6%9C%9F%E6%9C%9B%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>注：这篇文章原文出处放在了下面的连接，有适当的修改和增加内容，写在这里是为了更好地查阅巩固。</p>
</blockquote>
<p><a href="https://weizhixiaoyi.com/2018/05/09/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%9C%80%E5%A4%A7%E6%9C%9F%E6%9C%9B-EM-%E7%AE%97%E6%B3%95/" target="_blank" rel="noopener">戳我原文</a></p>
<h1 id="EM算法简介"><a href="#EM算法简介" class="headerlink" title="EM算法简介"></a>EM算法简介</h1><p>最大期望算法（Expectation Maximization，简称EM算法）是在<strong>概率模型中寻找参数最大似然估计</strong>或者最大后验估计的算法，<strong>其中概率模型依赖于无法观测的隐藏变量</strong>。其主要思想就是通过迭代来建立完整数据的对数似然函数的期望界限，然后最大化不完整数据的对数似然函数。最大期望算法是一种迭代优化算法，其计算方法是每次迭代分为期望(E)步和最大(M)步。</p>
<h1 id="EM算法实例"><a href="#EM算法实例" class="headerlink" title="EM算法实例"></a>EM算法实例</h1><p>假如现在我们有两枚硬币1和2，随机抛掷后面朝上概率分别为P1，P2。为了估计两硬币概率，我们做如下实验，每次取一枚硬币，连掷5次后得到如下结果。</p>
<p><img src="/2018/08/27/机器学习专题/最大期望算法/01.jpg" alt></p>
<p>我们可以很方便的估计出硬币1概率P1=0.4，硬币2概率P2=0.5。</p>
<script type="math/tex; mode=display">
P1=\frac{3+1+2}{15}=0.4</script><script type="math/tex; mode=display">
P2=\frac{2+3}{10}=0.5</script><p>下面我们增加问题难度。如果并不知道每次投掷时所使用的硬币标记，那么如何估计P1和P2呢?</p>
<p><img src="/2018/08/27/机器学习专题/最大期望算法/02.jpg" alt></p>
<p>此时我们加入<strong>隐含变量z</strong>，可以把它认为是一个5维的向量(z1,z2,z3,z4,z5)，代表每次投掷时所使用的硬币。比如z1就代表第一轮投掷时所使用的是硬币1还是2，<strong>我们必须先估计出z，然后才能进一步估计P1和P2</strong></p>
<p><strong>我们先随机初始化一个P1和P2，用它来估计z，然后基于z按照最大似然概率方法去估计新的P1和P2.</strong>例如假设P1=0.2和P2=0.7，然后我们看看第一轮投掷的最可能是哪个硬币。如果是硬币1，得出3正2反的概率为0.2×0.2×0.2×0.8×0.8=0.00512，如果是硬币2，得出3正2反的概率为0.7×0.7×0.7×0.3×0.3=0.03087。然后依次求出其他4轮中的相应概率，接下来便可根据最大似然方法得到每轮中最有可能的硬币。</p>
<p><img src="/2018/08/27/机器学习专题/最大期望算法/03.jpg" alt></p>
<p>我们把上面的值作为z的估计值(2,1,1,2,1)，然后按照最大似然概率方法来估计新的P1和P2。得到</p>
<script type="math/tex; mode=display">
P1=\frac{2+1+2}{15}=0.33</script><script type="math/tex; mode=display">
P2=\frac{3+3}{10}=0.6</script><p>可以预估，我们继续按照上面思路，用估计出的P1和P2再来估计z，再用z来估计新的P1和P2，反复迭代下去，可以最终得到P1=0.4，P2=0.5。然后无论怎样迭代，P1和P2的值都会保持0.4和0.5不变，于是我们就找到P1和P2的最大似然估计。</p>
<p>上面我们用最大似然方法估计出z值，然后再用z值按照最大似然概率方法估计新的P1和P2。也就是说，我们使用了最有可能的z值，而不是所有的z值。如果考虑所有可能的z值，对每一个z值都估计出新的P1和P2，将每一个z值概率大小作为权重，将所有新的P1和P2分别加权相加，这样估计出的P1和P2是否会更优呢?</p>
<p>但所有的z值共有2^5=32种，我们是否进行32次估计呢？<strong>当然不是，我们利用期望来简化运算</strong>。</p>
<p><img src="/2018/08/27/机器学习专题/最大期望算法/04.jpg" alt></p>
<p>利用上面表格，我们可以算出每轮投掷种使用硬币1或者使用硬币2的概率。比如第一轮使用硬币1的概率</p>
<script type="math/tex; mode=display">
z_1=\frac{0.00512}{0.00512+0.03087}=0.14</script><p>相应的算出其他4轮的概率。</p>
<p><img src="/2018/08/27/机器学习专题/最大期望算法/05.jpg" alt></p>
<p><strong>上表中表示期望值</strong>，例如0.86表示此轮中使用硬币2的概率是0.86。前面方法我们按照最大似然概率直接将第一轮估计为硬币2，此时我们更加严谨，只说有0.14的概率是硬币1，有0.86的概率是硬币2。<strong>这样我们在估计P1或者P2时，就可以用上全部的数据，而不是部分的数据。此步我们实际上是估计出z的概率分布，称为E步。</strong></p>
<p>按照期望最大似然概率的法则来<strong>估计出新的P1和P2</strong>。以P1估计为例，第一轮的3正2反相当于有0.14×3=0.42的概率为正，有0.14×2的概率为反。然后依次计算出其他四轮。那么我们可以得到P1概率，可以看到改变了z的估计方法后，<strong>新估计出的P1要更加接近0.4，原因是我们使用了所有抛掷的数据，而不是部分的数据。此步中我们根据E步中求出z的概率分布，依据最大似然概率法则去估计P1和P2，称为M步</strong>。</p>
<p><img src="/2018/08/27/机器学习专题/最大期望算法/06.jpg" alt></p>
<script type="math/tex; mode=display">
P1=\frac{4.22}{4.22+7.98}=0.35</script><p>上面我们是通过迭代来得到P1和P2，结果更接近真实的P1和P2。</p>
<h1 id="EM算法推导"><a href="#EM算法推导" class="headerlink" title="EM算法推导"></a>EM算法推导</h1><h2 id="Jensen不等式"><a href="#Jensen不等式" class="headerlink" title="Jensen不等式"></a>Jensen不等式</h2><p>Jensen不等式表述如下：</p>
<p>如果f是凸函数，x是随机变量，那么：$E[f(x)]\geq f(E[x])$ ,特别地，如果f是严格凸函数，那么当且仅当$P(x=E[x])=1$(也就是说x是常量)，$E[f(x)]=f(E[x])$ </p>
<p>通过下面这张图，我们可以加深理解：</p>
<p><img src="/2018/08/27/机器学习专题/最大期望算法/07.jpg" alt></p>
<p>上图中，函数f是凸函数，X是随机变量，有0.5的概率为a，有0.5的概率是b（就像抛硬币一样）。X的期望值就是a和b的中值了，图中可以看到$E[f(x)]\geq f(E[x])$成立.</p>
<h2 id="极大似然估计"><a href="#极大似然估计" class="headerlink" title="极大似然估计"></a>极大似然估计</h2><p>EM算法推导过程中，会使用到极大似然估计参数。</p>
<p>极大似然估计是一种概率论在统计学的应用。<strong>已知某个随机样本满足某种概率分布，但是其中具体的参数不清楚，参数估计就是通过若干次试验，观察结果，利用结果推出参数的大概值</strong>。极大似然估计建立在这样的思想上：已知某个参数能使这个样本出现的概率最大，我们当然不会再去选择其他小概率的样本，所以干脆就把这个参数作为估计的真实值。</p>
<p>这里再给出求极大似然估计值的一般步骤：</p>
<ul>
<li>1）写出似然函数；</li>
<li>2）对似然函数取对数，并整理；</li>
<li>3）求导数，令导数为0，得到似然方程；</li>
<li>4）解似然方程，得到的参数即为所求；</li>
</ul>
<h2 id="EM算法推导-1"><a href="#EM算法推导-1" class="headerlink" title="EM算法推导"></a>EM算法推导</h2><p>对于m个样本观察数据$x=(x^{(1)},x^{(2)},x^{(3)},…,x^{(m)})$，找出样本的模型参数θ，极大化模型分布的对数似然函数如下所示</p>
<script type="math/tex; mode=display">
\theta =\arg \max_{\theta} \sum _{i=1}^{m}logP(x^{(i)};\theta)</script><p>如果我们得到的观察数据有未观察到的隐含数据$z=(z^{(1)},z^{(2)},z^{(3)},…,z^{(m)})$，此时我们极大化模型分布的对数似然函数如下</p>
<script type="math/tex; mode=display">
\theta =\arg \max_{\theta} \sum _{i=1}^{m}logP(x^{(i)};\theta) \\ \\ \\ =\arg \max_{\theta} \sum _{i=1}^{m}log\sum _{z^{(i)}}P(x^{(i)},z^{(i)};\theta)</script><p>上面方程是无法直接求出θ的，因此需要一些特殊技巧，在此我们引入<strong>Jensen不等式</strong>。</p>
<p>我们再回到上述推导过程，得到如下方程式。</p>
<script type="math/tex; mode=display">
\sum _{i=1}^{m}log\sum _{z^{(i)}}P(x^{(i)},z^{(i)};\theta) \\ \\ \\ =\sum _{i=1}^{m}log\sum _{z^{(i)}}Q_i(z^{(i)})\frac{P(x^{(i)},z^{(i)};\theta) }{Q_i(z^{(i)})}\ \ \ \ \ \ \ (1) \\ \\ \\ \ge \sum _{i=1}^{m}\sum _{z^{(i)}}Q_i(z^{(i)})log\frac{P(x^{(i)},z^{(i)};\theta) }{Q_i(z^{(i)})} \ \ \ \ \ \ \ (2)</script><p>我们来解释下怎样得到的方程式(1)和方程式(2)，上面(1)式中引入一个未知的新的分布$Q_i(z^{(i)})$，第二式用到Jensen不等式。</p>
<p>首先log函数是凹函数，那么E[f(X)]≤f(E[X])，也就是f(E(X))≥E(f(X))。其中$\sum <em>{z^{(i)}}Q_i(z^{(i)})\frac{P(x^{(i)},z^{(i)};\theta) }{Q_i(z^{(i)})}$ 是$\frac{P(x^{(i)},z^{(i);\theta})}{Q_i(z^{(i)})}$的数学期望，那么$log\sum </em>{z^{(i)}}Q<em>i(z^{(i)})\frac{P(x^{(i)},z^{(i)};\theta) }{Q_i(z^{(i)})}$ 便相当于f(E(X))，同时$\sum </em>{z^{(i)}}Q_i(z^{(i)})log\frac{P(x^{(i)},z^{(i)};\theta) }{Q_i(z^{(i)})}$相当于E(f(X))，因此我们便得到上述方程式(1)(2)。</p>
<p>如果要满足Jensen不等式的等号，那么需要满足X为常量，即为</p>
<script type="math/tex; mode=display">
\frac{P(x^{(i)},z^{(i)};\theta)}{Q_i(z^{(i)})}=c,\ c为常量</script><p>那么稍加改变能够得到</p>
<script type="math/tex; mode=display">
c Q_i(z^{(i)})=P(x^{(i)},z^{(i)};\theta)\ ,c为常量</script><script type="math/tex; mode=display">
\sum_z c\  Q_i(z^{(i)})= \sum _z P(x^{(i)},z^{(i)};\theta)= c</script><p>因此得到下列方程，<strong>其中方程(3)利用到条件概率公式</strong>。</p>
<script type="math/tex; mode=display">
Q_i(z^{(i)})=\frac{P(x^{(i)},z^{(i)};\theta)}{c}=\frac{P(x^{(i)},z^{(i)};\theta)}{\sum _z P(x^{(i)},z^{(i)};\theta)}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \</script><script type="math/tex; mode=display">
=\frac{P(x^{(i)},z^{(i)};\theta)}{ P(x^{(i)};\theta)}=P(z^{(i)}|x^{(i)};\theta)  \ \ \ \ \ \ \ \  \ \ \ \ \ \   (3)</script><p>如果$Q_i(z^{(i)})=P(z^{(i)}|x^{(i)};\theta)$ 那么第(2)式就是我们隐藏数据的对数似然的下界。<strong>如果我们能极大化方程式(2)的下界，则也在尝试极大化我们的方程式(1)</strong>。即我们需要最大化下式</p>
<script type="math/tex; mode=display">
\arg \max _{\theta} \sum _{i=1}^{m}\sum _{z^{(i)}}Q_i(z^{(i)})log\frac{P(x^{(i)},z^{(i)};\theta) }{Q_i(z^{(i)})}</script><p>去掉上式中常数部分，则我们需要极大化的对数似然下界为</p>
<script type="math/tex; mode=display">
\arg \max _{\theta} \sum _{i=1}^{m}\sum _{z^{(i)}}Q_i(z^{(i)})[log P(x^{(i)},z^{(i)};\theta)-log {Q_i(z^{(i)})}]</script><script type="math/tex; mode=display">
=\arg \max _{\theta} \sum _{i=1}^{m}\sum _{z^{(i)}}Q_i(z^{(i)})log P(x^{(i)},z^{(i)};\theta)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (4)</script><p>注意到上式中$Q<em>i(z^{(i)})$ 是一个分布，因此$\sum </em>{z^{(i)}}Q_i(z^{(i)})log P(x^{(i)},z^{(i)};\theta)$ 可以理解为$logP(x^{(i)},z^{(i)};\theta)$ 基于条件概率分布$Q_i(z^{(i)})$的期望，也就是我们EM算法中<strong>E步</strong>。极大化方程式(4)也就是我们EM算法中的<strong>M步</strong>。</p>
<p>到这里，<strong>我们推出了在固定参数θ后，使下界拉升的Q(z)的计算公式就是后验概率（条件概率），解决了Q(z)如何选择的问题。此步就是EM算法的E步，目的是建立L(θ)的下界。接下来的M步，目的是在给定Q(z)后，调整θ，从而极大化L(θ)的下界J（在固定Q(z)后，下界还可以调整的更大）</strong>。那么一般的EM算法的步骤如下：</p>
<ul>
<li><p>第一步：初始化分布参数θ；</p>
</li>
<li><p>第二步：重复E步和M步直到收敛：</p>
<p>E步：根据参数的初始值或上一次迭代的模型参数来计算出的因变量的后验概率（条件概率），其实就是隐变量的期望值，来作为隐变量的当前估计值：</p>
<script type="math/tex; mode=display">
 Q_i\left(z^{\left(i\right)}\right)=p\left(z^{\left(i\right)}|x^{\left(i\right)};\theta\right)</script><p>M步：最大化似然函数从而获得新的参数值：</p>
<script type="math/tex; mode=display">
\theta :=arg\underset{\theta}{\max}\sum_i{\sum_{z^{\left(i\right)}}{Q_i\left(z^{\left(i\right)}\right)\log\frac{p\left(x^{\left(i\right)},z^{\left(i\right)};\theta\right)}{Q_i\left(z^{\left(i\right)}\right)}}}</script></li>
</ul>
<p>EM算法可以保证收敛到一个稳定点，但是却不能保证收敛到全局的极大值点，因此它是局部最优的算法。当然，如果我们的优化目标L(θ,θj)是凸的，则EM算法可以保证收敛到全局最大值，这点和梯度下降法中迭代算法相同。</p>
<h1 id="Sklearn实现EM算法"><a href="#Sklearn实现EM算法" class="headerlink" title="Sklearn实现EM算法"></a>Sklearn实现EM算法</h1><p>高斯混合模型(GMM)使用高斯分布作为参数模型，利用期望最大(EM)算法进行训练，有兴趣了解高斯混合模型的同学可以去<a href="https://mp.weixin.qq.com/s?src=11&amp;timestamp=1525932817&amp;ver=867&amp;signature=U4UxviydVELD71Ju*bRWvh0ziFU57aNoPTZkVu5ShBEH7lxe1PLqxQnZ-xVSFgXdw5GcsWcYF5W1llR4dQ2yrsj0t2syeXgEggjm*budZlpZdMQMLOcXB-FnvKKlkV2H&amp;new=1" target="_blank" rel="noopener">这儿</a>。下列代码来自于<a href="http://scikit-learn.org/stable/auto_examples/mixture/plot_gmm_covariances.html#sphx-glr-auto-examples-mixture-plot-gmm-covariances-py" target="_blank" rel="noopener">Sklearn官网GMM模块</a>，利用高斯混合模型确定iris聚类。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib <span class="keyword">as</span> mpl</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">from</span> sklearn.mixture <span class="keyword">import</span> GaussianMixture</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> StratifiedKFold</span><br><span class="line"></span><br><span class="line">colors = [<span class="string">'navy'</span>, <span class="string">'turquoise'</span>, <span class="string">'darkorange'</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_ellipses</span><span class="params">(gmm, ax)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> n, color <span class="keyword">in</span> enumerate(colors):</span><br><span class="line">        <span class="keyword">if</span> gmm.covariance_type == <span class="string">'full'</span>:</span><br><span class="line">            covariances = gmm.covariances_[n][:<span class="number">2</span>, :<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">elif</span> gmm.covariance_type == <span class="string">'tied'</span>:</span><br><span class="line">            covariances = gmm.covariances_[:<span class="number">2</span>, :<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">elif</span> gmm.covariance_type == <span class="string">'diag'</span>:</span><br><span class="line">            covariances = np.diag(gmm.covariances_[n][:<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">elif</span> gmm.covariance_type == <span class="string">'spherical'</span>:</span><br><span class="line">            covariances = np.eye(gmm.means_.shape[<span class="number">1</span>]) * gmm.covariances_[n]</span><br><span class="line">        v, w = np.linalg.eigh(covariances)</span><br><span class="line">        u = w[<span class="number">0</span>] / np.linalg.norm(w[<span class="number">0</span>])</span><br><span class="line">        angle = np.arctan2(u[<span class="number">1</span>], u[<span class="number">0</span>])</span><br><span class="line">        angle = <span class="number">180</span> * angle / np.pi  <span class="comment"># convert to degrees</span></span><br><span class="line">        v = <span class="number">2.</span> * np.sqrt(<span class="number">2.</span>) * np.sqrt(v)</span><br><span class="line">        ell = mpl.patches.Ellipse(gmm.means_[n, :<span class="number">2</span>], v[<span class="number">0</span>], v[<span class="number">1</span>],</span><br><span class="line">                                  <span class="number">180</span> + angle, color=color)</span><br><span class="line">        ell.set_clip_box(ax.bbox)</span><br><span class="line">        ell.set_alpha(<span class="number">0.5</span>)</span><br><span class="line">        ax.add_artist(ell)</span><br><span class="line"></span><br><span class="line">iris = datasets.load_iris()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Break up the dataset into non-overlapping training (75%)</span></span><br><span class="line"><span class="comment"># and testing (25%) sets.</span></span><br><span class="line">skf = StratifiedKFold(n_splits=<span class="number">4</span>)</span><br><span class="line"><span class="comment"># Only take the first fold.</span></span><br><span class="line">train_index, test_index = next(iter(skf.split(iris.data, iris.target)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">X_train = iris.data[train_index]</span><br><span class="line">y_train = iris.target[train_index]</span><br><span class="line">X_test = iris.data[test_index]</span><br><span class="line">y_test = iris.target[test_index]</span><br><span class="line"></span><br><span class="line">n_classes = len(np.unique(y_train))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Try GMMs using different types of covariances.</span></span><br><span class="line">estimators = dict((cov_type, GaussianMixture(n_components=n_classes,</span><br><span class="line">                   covariance_type=cov_type, max_iter=<span class="number">20</span>, random_state=<span class="number">0</span>))</span><br><span class="line">                  <span class="keyword">for</span> cov_type <span class="keyword">in</span> [<span class="string">'spherical'</span>, <span class="string">'diag'</span>, <span class="string">'tied'</span>, <span class="string">'full'</span>])</span><br><span class="line"></span><br><span class="line">n_estimators = len(estimators)</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">3</span> * n_estimators // <span class="number">2</span>, <span class="number">6</span>))</span><br><span class="line">plt.subplots_adjust(bottom=<span class="number">.01</span>, top=<span class="number">0.95</span>, hspace=<span class="number">.15</span>, wspace=<span class="number">.05</span>,</span><br><span class="line">                    left=<span class="number">.01</span>, right=<span class="number">.99</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index, (name, estimator) <span class="keyword">in</span> enumerate(estimators.items()):</span><br><span class="line">    <span class="comment"># Since we have class labels for the training data, we can</span></span><br><span class="line">    <span class="comment"># initialize the GMM parameters in a supervised manner.</span></span><br><span class="line">    estimator.means_init = np.array([X_train[y_train == i].mean(axis=<span class="number">0</span>)</span><br><span class="line">                                    <span class="keyword">for</span> i <span class="keyword">in</span> range(n_classes)])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Train the other parameters using the EM algorithm.</span></span><br><span class="line">    estimator.fit(X_train)</span><br><span class="line"></span><br><span class="line">    h = plt.subplot(<span class="number">2</span>, n_estimators // <span class="number">2</span>, index + <span class="number">1</span>)</span><br><span class="line">    make_ellipses(estimator, h)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> n, color <span class="keyword">in</span> enumerate(colors):</span><br><span class="line">        data = iris.data[iris.target == n]</span><br><span class="line">        plt.scatter(data[:, <span class="number">0</span>], data[:, <span class="number">1</span>], s=<span class="number">0.8</span>, color=color,</span><br><span class="line">                    label=iris.target_names[n])</span><br><span class="line">    <span class="comment"># Plot the test data with crosses</span></span><br><span class="line">    <span class="keyword">for</span> n, color <span class="keyword">in</span> enumerate(colors):</span><br><span class="line">        data = X_test[y_test == n]</span><br><span class="line">        plt.scatter(data[:, <span class="number">0</span>], data[:, <span class="number">1</span>], marker=<span class="string">'x'</span>, color=color)</span><br><span class="line"></span><br><span class="line">    y_train_pred = estimator.predict(X_train)</span><br><span class="line">    train_accuracy = np.mean(y_train_pred.ravel() == y_train.ravel()) * <span class="number">100</span></span><br><span class="line">    plt.text(<span class="number">0.05</span>, <span class="number">0.9</span>, <span class="string">'Train accuracy: %.1f'</span> % train_accuracy,</span><br><span class="line">             transform=h.transAxes)</span><br><span class="line"></span><br><span class="line">    y_test_pred = estimator.predict(X_test)</span><br><span class="line">    test_accuracy = np.mean(y_test_pred.ravel() == y_test.ravel()) * <span class="number">100</span></span><br><span class="line">    plt.text(<span class="number">0.05</span>, <span class="number">0.8</span>, <span class="string">'Test accuracy: %.1f'</span> % test_accuracy,</span><br><span class="line">             transform=h.transAxes)</span><br><span class="line"></span><br><span class="line">    plt.xticks(())</span><br><span class="line">    plt.yticks(())</span><br><span class="line">    plt.title(name)</span><br><span class="line"></span><br><span class="line">plt.legend(scatterpoints=<span class="number">1</span>, loc=<span class="string">'lower right'</span>, prop=dict(size=<span class="number">12</span>))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2018/08/27/机器学习专题/最大期望算法/08.jpg" alt></p>
<h1 id="EM算法优缺点"><a href="#EM算法优缺点" class="headerlink" title="EM算法优缺点"></a>EM算法优缺点</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li>聚类。</li>
<li>算法计算结果稳定、准确。</li>
<li>EM算法自收敛，既不需要事先设定类别，也不需要数据间的两两比较合并等操作。</li>
</ul>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li>对初始化数据敏感。</li>
<li>EM算法计算复杂，收敛较慢，不适于大规模数据集和高维数据。</li>
<li>当所要优化的函数不是凸函数时，EM算法容易给出局部最优解，而不是全局最优解。</li>
</ul>
]]></content>
      <categories>
        <category>机器学习专题</category>
      </categories>
      <tags>
        <tag>EM</tag>
      </tags>
  </entry>
  <entry>
    <title>浴室沉思（二）</title>
    <url>/2018/08/20/%E6%B5%B4%E5%AE%A4%E6%B2%89%E6%80%9D/%E6%B5%B4%E5%AE%A4%E6%B2%89%E6%80%9D%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>1.</p>
<blockquote>
<p>地球那么大，为什么月亮的倒影能够准确地投映在我家院子里的一口井里？ </p>
</blockquote>
<p>2.</p>
<blockquote>
<p>你可以通过逃跑解决肥胖问题。</p>
</blockquote>
<p>3.</p>
<blockquote>
<p>你看不见你的脖子，你也离不开它。</p>
</blockquote>
<p>4.</p>
<blockquote>
<p>现金是电子支付的离线缓存。</p>
</blockquote>
<p>5.</p>
<blockquote>
<p>给水果剥皮，就像是拆来自大地的礼物。</p>
</blockquote>
<p>6.</p>
<blockquote>
<p>酒店房间里收费的饮品就像是手机应用的内购。</p>
</blockquote>
<p>7.</p>
<blockquote>
<p>你不能想象一种不存在的颜色。</p>
</blockquote>
<p>8.</p>
<blockquote>
<p>火山：睡上一万年，生起床气，到处乱丢东西，再睡上一万年。</p>
</blockquote>
<p>9.</p>
<blockquote>
<p>如果你每天“带薪拉屎”十分钟，一年下来就能相当于休了个一周的“带薪拉屎假”。</p>
</blockquote>
<p>10.</p>
<blockquote>
<p>如果你的手臂可以拆卸，你也没办法自己把它们互换位置。。</p>
</blockquote>
]]></content>
      <categories>
        <category>浴室沉思</category>
      </categories>
      <tags>
        <tag>showerthoughts</tag>
      </tags>
  </entry>
  <entry>
    <title>浴室沉思（一）</title>
    <url>/2018/08/20/%E6%B5%B4%E5%AE%A4%E6%B2%89%E6%80%9D/%E6%B5%B4%E5%AE%A4%E6%B2%89%E6%80%9D%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>1.</p>
<blockquote>
<p> 总有一天，你会完全忘记你读到过这句话。</p>
</blockquote>
<p>2.</p>
<blockquote>
<p>音乐是颤抖的风。</p>
</blockquote>
<p>3.</p>
<blockquote>
<p>狗狗可能并不喜欢叼球回来，只是不想看到东西弄丢了。</p>
</blockquote>
<p>4.</p>
<blockquote>
<p>根据美国的法律，在合法地饮用第一杯酒之前，你要先绕太阳飞行21圈。</p>
</blockquote>
<p>5.</p>
<blockquote>
<p>人类殖民火星，就像是通过空气传播的病毒。</p>
</blockquote>
<p>6.</p>
<blockquote>
<p>因为脑海里的声音不需要换气，脑海里可以一直在尖叫。</p>
</blockquote>
<p>7.</p>
<blockquote>
<p>同义词没有同义词，但是反义词的反义词是同义词。</p>
</blockquote>
<p>8.</p>
<blockquote>
<p>闪电是有人躲在云里偷拍我们，但忘了关闪光灯。</p>
</blockquote>
<p>9.</p>
<blockquote>
<p>氧气有最严重的戒断症状。</p>
</blockquote>
<p>10.</p>
<blockquote>
<p>火车是一种在三维世界中建立在二维平面上只能一维移动的物体。</p>
</blockquote>
]]></content>
      <categories>
        <category>浴室沉思</category>
      </categories>
      <tags>
        <tag>showerthoughts</tag>
      </tags>
  </entry>
  <entry>
    <title>浴室沉思101</title>
    <url>/2018/08/19/%E6%B5%B4%E5%AE%A4%E6%B2%89%E6%80%9D/%E6%B5%B4%E5%AE%A4%E6%B2%89%E6%80%9D101/</url>
    <content><![CDATA[<p>原帖地址：<a href="https://www.reddit.com/r/Showerthoughts/comments/7xde4g/what_is_a_showerthought/" target="_blank" rel="noopener">戳我</a></p>
<p>欢迎来到r/showerthoughts, 我们很高兴在这里见到你，并且希望你玩得开心。这个帖子是一个关于showerthoughts 是什么/不是什么的简介。</p>
<blockquote>
<p>什么是Showerthoughts?</p>
</blockquote>
<p>简单来说，Showerthoughts 就是那些让庸常生活充满趣味的想法。这些想法往往是“另一个角度看待日常生活”的结果，而”另一个角度看待日常生活“往往又会让大家看到新的细节。这些想法可能十分可笑，也可能有些苦涩，可能会给你带来思想上的启迪，或者仅仅就是傻乎乎的而已。但他总应该是让人感到“啊，我怎么就没发现呢。“</p>
<p>Showerthoughts, 这个词指的是我们在日常生活中做无脑无聊时候事情时候产生的想法，并不一定要发生在浴室，也可以是在通勤中，在开车，或者是在等客服接你的电话的时候。</p>
<p>这里有一些Showerthoughts的例子：</p>
<ul>
<li>“你的胃觉得所有的土豆都是土豆泥。”</li>
<li>“当人们提到穿越回过去的时候，总是担心会导致改变今天的世界；但是他们却没有觉得，今天做的一切都会改变未来的世界。“</li>
<li>”如果你够蠢，所有的飞行物都是不明飞行物。”</li>
<li>“C3PO的确是卢克天行者的哥哥。”</li>
<li>“天鹅是一种聒噪，暴力，有进攻性的恐怖生物，同时也是爱情的象征。”</li>
</ul>
<blockquote>
<p>什么不是Showerthoughts？</p>
</blockquote>
<p>就像上面说的那样，Showerthoughts 应该让人从一个新的角度看待已经存在的现象或者事物。它不应该是一个个人意见或者观点，或者是一种产品的改进建议，或者是某些能快速通过Google 解决的问题。Showerthoughts 应该是一个命题，而不是一个假设。 R/showerthoughts 里面的内容应该文字流畅，内容新颖。如果某个post 过于泛滥，或者说文字水平太低，抑或者太过粗鲁，管理员将会将其移出。<br>这些例子里的内容不是Showerthoughts：</p>
<ul>
<li>“淦！我要买些肥皂了！”</li>
</ul>
<p>（这是一条浴室观察，不是一条浴室沉思）</p>
<ul>
<li>“我讨厌开车的时候被别人加塞，但是看着别人被加塞还蛮开心的。“</li>
</ul>
<p>（这是个人观点）</p>
<ul>
<li>“有人试过珠穆朗玛峰顶的味道嘛？“</li>
</ul>
<p>（这已经很接近showerthoughts 了，但是这是一个疑问句，应该改写成一个陈述句。）</p>
<ul>
<li>“地球每一天都再心的地方”</li>
</ul>
<p>（文字不流畅，而且还有错别字）</p>
<ul>
<li>“有没有可能有一群蜜蜂真的有蜂群思维呢？“</li>
</ul>
<p>（这是个假设，而且还是个文字游戏）</p>
<p>很多时候，我们很难找到一个完全原创，文字流畅，充满洞见的想法，不过这才让showerthoughts 变得好玩：它让你发现在你无意识的时候，你也是在思考的；而且这些想法也让你的无聊日常变得有趣起来。</p>
<blockquote>
<p>为什么要把Showerthoughts加入到自己的博客当中？</p>
</blockquote>
<p>Showerthoughts是我在Reddit里面最喜欢的一个版块，也是个人很喜欢的一种文化。看似简单的句子里蕴藏了许多奇思妙想，看待事物的角度时常让人耳目一新。看过许多有趣的Showerthoughts之后，偶尔也会自己进行创作，虽然质量不高，但都会发在饭否上面记录。但由于没有统一地方记录这些Showerthoughts，许多之前写的Showerthoughts已经很难找到了。所以，打算在博客里专门创建一个Showerthoughts的Tag，记录收藏有趣的Showerthoughts。</p>
<p>这些Showerthoughts绝大多数会在Reddit上面的r/showerthoughts版块中找到完整的原句，自己只搬运翻译一些感兴趣的Showerthoughts；另外还会摘录一些关注的饭友写的showerthoughts；最后也会自己偶尔写一些较低质量的Showerthoughts。</p>
<p>希望大家在码完代码疲惫之后，可以看到一些有趣的Showerthoughts，消除倦意，继续战斗。</p>
<p>注：微博上也有相关的Showerthoughts搬运博主，偶尔会转发一些网友有趣的Showerthoughts：<a href="https://weibo.com/u/2964236717?topnav=1&amp;wvr=6&amp;topsug=1&amp;is_all=1" target="_blank" rel="noopener">浴室沉思</a></p>
]]></content>
      <categories>
        <category>浴室沉思</category>
      </categories>
      <tags>
        <tag>showerthoughts</tag>
      </tags>
  </entry>
  <entry>
    <title>浴室沉思101</title>
    <url>/2018/08/19/%E7%AE%97%E6%B3%95%E6%AF%94%E8%B5%9B/kaggle_house_prices/</url>
    <content><![CDATA[<p>思路</p>
<p>1、拆分数据集 ，验证集，测试集</p>
]]></content>
      <categories>
        <category>浴室沉思</category>
      </categories>
      <tags>
        <tag>showerthoughts</tag>
      </tags>
  </entry>
  <entry>
    <title>Sklearn 与 TensorFlow 机器学习实用指南（七）：降维</title>
    <url>/2018/08/07/Sklearn%20%E4%B8%8E%20TensorFlow%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E7%94%A8%E6%8C%87%E5%8D%97/Sklearn-%E4%B8%8E-TensorFlow-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E7%94%A8%E6%8C%87%E5%8D%97%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E9%99%8D%E7%BB%B4/</url>
    <content><![CDATA[<p>先来了解一张降维汇总图，降维的算法比较多，这里就只简单说MDS，PCA以及流行学习的Isomap和LLE。</p>
<p><img src="/2018/08/07/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（七）：降维/01.png" alt></p>
<hr>
<h1 id="多维缩放MDS：Multiple-Dimensional-Scaling"><a href="#多维缩放MDS：Multiple-Dimensional-Scaling" class="headerlink" title="多维缩放MDS：Multiple Dimensional Scaling"></a>多维缩放MDS：Multiple Dimensional Scaling</h1><p>低维嵌入：在很多时候， 人们观测或收集到的数据样本虽是高维的，但与学习任务密切相关的也许仅是某个低维分布，即高维空间中的一个低维”嵌入” (embedding) . 图 10.2 给出 了 一个直观的例子. 原始高维空间中的样本点，在这个低维嵌入子空间中更容易进行学习。</p>
<p><img src="/2018/08/07/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（七）：降维/02.png" alt></p>
<p>MDS的目标是在降维的过程中将数据的dissimilarity(差异性)保持下来，也可以理解降维让高维空间中的距离关系与低维空间中距离关系保持不变。这里的距离用矩阵表示，<strong>N个样本的两两距离用矩阵D的每一项$dist_{ij}$ 表示</strong>，并且假设在低维空间中的距离是欧式距离。<strong>而降维后的数据表示为$Z_i$</strong>,那么就有</p>
<script type="math/tex; mode=display">
dist_{ij}^2 = \left | \mathbf{z_i-z_j} \right |^2 = \left | \mathbf{z_i} \right |^2 + \left | \mathbf{z_j} \right |^2 - 2\mathbf{z_i}\mathbf{z_j}^T</script><p>令$B=ZZ^T$ ,右边的三项统一用<strong>内积矩阵B</strong>来表示$b_{ij}=z_iz_j^T$ ,所以有</p>
<script type="math/tex; mode=display">
dist_{ij}^2=b_{ii}+b_{jj}-2b_{ij} \quad(1)</script><p><strong>这时只要求出内积矩阵B即可求出降为后的矩阵Z（思路D-B-Z）</strong>。<strong>距离矩阵D去中心化之后(减去均值)，內积矩阵B的每一行每一列之和都是0</strong>，可以推导得出</p>
<p><img src="/2018/08/07/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（七）：降维/03.png" alt></p>
<p>其中 tr(.) 表示矩阵的迹(trace),$tr(E)=\sum<em>{i=1}^m\Vert z_i \Vert^2=\sum</em>{i=1}^mb_{ii}$,令</p>
<p><img src="/2018/08/07/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（七）：降维/04.png" alt></p>
<p>联立上(1)-(7),消除$b<em>{ii},b</em>{jj}$后，可以得到</p>
<script type="math/tex; mode=display">
b_{ij} = -\frac{1}{2}(dist_{ij}^2-dist_{i\cdot} - dist_{\cdot j}-dist_{\cdot\cdot}^2)</script><p>​i⋅与⋅j是指某列或者某列总和，从而建立了距离矩阵D与内积矩阵B之间的关系.由此即可通过降维前后保持不变的距离矩阵 D 求取内积矩阵 B。对矩阵 B 做特征值分解(eigenvalue decomposition)，$B=VAV^T$，其中$A=diag(λ<em>1,λ_2,…λ_d)$为特征值构成的对角矩阵,$λ_1\geq λ_2\geq …\geq λ_d$，V 为特征向量矩阵.假定其中有d* 个非零特征值，它们构成对角矩阵$A*=diag(λ_1,λ_2,…λ</em>{d<em>})$,令 V\</em>表示相应的特征向量矩阵，联立之前的$B=ZZ^T$,则最后Z可表达为</p>
<script type="math/tex; mode=display">
Z=A_*^{1/2}V_*^T</script><p>在现实应用中为了有效降维，往往仅需降维后的距离与原始空间中的距离尽可能接近?而不必严格相等.此时可取 d’&lt;&lt; d 个最大特征值构成对角矩阵。</p>
<p><img src="/2018/08/07/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（七）：降维/05.png" alt></p>
<h1 id="主成分分析PCA-Principal-Component-Analysis"><a href="#主成分分析PCA-Principal-Component-Analysis" class="headerlink" title="主成分分析PCA: Principal Component Analysis"></a>主成分分析PCA: Principal Component Analysis</h1><h2 id="向量內积"><a href="#向量內积" class="headerlink" title="向量內积"></a>向量內积</h2><p>由$A⋅B=|A||B|cos(a)$, A与B的内积等于A到B的投影长度乘以B的模。再进一步，如果我们假设B的模为1，则A与B的内积值等于A向B所在直线投影的矢量长度！</p>
<p><img src="/2018/08/07/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（七）：降维/06.png" alt></p>
<h2 id="基"><a href="#基" class="headerlink" title="基"></a>基</h2><p>向量(x,y)实际上表示线性组合，$x(1,0)^T+y(0,1)^T$,不难证明所有二维向量都可以表示为这样的线性组合。此处（1，0）和（0，1）叫做二维空间中的一组基。但实际上任何两个线性无关的二维向量都可以成为一组基，所谓线性无关在二维平面内可以直观认为是两个不在一条直线上的向量.例如，(1,1)和(−1,1)也可以成为一组基。一般来说，我们希望基的模是1,实际上，对应任何一个向量我们总可以找到其同方向上模为1的向量，只要让两个分量分别除以模就好了。例如，上面的基可以变为$(\frac{1}{\sqrt{2}},\frac{1}{\sqrt{2}})$和$(-\frac{1}{\sqrt{2}},\frac{1}{\sqrt{2}})$ </p>
<h2 id="基变换的矩阵表示："><a href="#基变换的矩阵表示：" class="headerlink" title="基变换的矩阵表示："></a>基变换的矩阵表示：</h2><p>下面我们找一种简便的方式来表示基变换。还是拿上面的例子，想一下，将(3,2)变换为新基上的坐标，就是用(3,2)与第一个基做内积运算，作为第一个新的坐标分量，然后用(3,2)与第二个基做内积运算，作为第二个新坐标的分量。实际上，我们可以用矩阵相乘的形式简洁的表示这个变换，其中矩阵的两行分别为两个基，乘以原向量，其结果刚好为新基的坐标：</p>
<p><img src="/2018/08/07/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（七）：降维/07.png" alt></p>
<h2 id="协方差矩阵及优化目标"><a href="#协方差矩阵及优化目标" class="headerlink" title="协方差矩阵及优化目标"></a>协方差矩阵及优化目标</h2><p>面我们讨论了选择不同的基可以对同样一组数据给出不同的表示，而且如果基的数量少于向量本身的维数，则可以达到降维的效果。但是我们还没有回答一个最最关键的问题：如何选择基才是最优的。或者说，如果我们有一组N维向量，现在要将其降到K维（K小于N），那么我们应该如何选择K个基才能最大程度保留原有的信息？</p>
<p><img src="/2018/08/07/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（七）：降维/08.png" alt></p>
<p>现在问题来了：如果我们必须使用一维来表示上面这些数据，又希望尽量保留原始的信息，你要如何选择？</p>
<p>通过上一节对基变换的讨论我们知道，这个问题实际上是要在二维平面中选择一个方向，将所有数据都投影到这个方向所在直线上，用投影值表示原始记录。这是一个实际的二维降到一维的问题。</p>
<p>那么如何选择这个方向（或者说基）才能尽量保留最多的原始信息呢？一种直观的看法是：希望投影后的投影值尽可能分散。</p>
<p>我们希望投影后投影值尽可能分散，而这种分散程度，可以用数学上的方差来表述。此处，一个字段的方差可以看做是每个元素与字段均值的差的平方和的均值，即：</p>
<script type="math/tex; mode=display">
Var(a)=\frac{1}{m}\sum^m_{i=1}(a_i-\mu)^2</script><p>通过去中心化（字段所有数值减去字段均值），将每个字段的均值都化为0了，因此方差可以直接用每个元素的平方和除以元素个数表示：</p>
<script type="math/tex; mode=display">
Var(a)=\frac{1}{m}\sum^m_{i=1}a_i^2</script><p>于是上面的问题被形式化表述为：寻找一个一维基，使得所有数据变换为这个基上的坐标表示后，方差值最大.</p>
<h2 id="协方差"><a href="#协方差" class="headerlink" title="协方差"></a>协方差</h2><p>对于上面二维降成一维的问题来说，找到那个使得方差最大的方向就可以了。不过对于更高维，还有一个问题需要解决。考虑三维降到二维问题。与之前相同，首先我们希望找到一个方向使得投影后方差最大，这样就完成了第一个方向的选择，继而我们选择第二个投影方向。</p>
<p>如果我们还是单纯只选择方差最大的方向，很明显，这个方向与第一个方向应该是“几乎重合在一起”，显然这样的维度是没有用的，因此，应该有其他约束条件。从直观上说，让两个字段尽可能表示更多的原始信息，我们是不希望它们之间存在（线性）相关性的，因为相关性意味着两个字段不是完全独立，必然存在重复表示的信息。</p>
<p>数学上可以用两个字段的协方差表示其相关性，由于已经让每个字段均值为0，则：</p>
<script type="math/tex; mode=display">
Cov(a,b) = \frac{1}{m}\sum_{i=1}^ma_ib_i</script><p>可以看到，在字段均值为0的情况下，两个字段的协方差简洁的表示为其内积除以元素数m。</p>
<p>当协方差为0时，表示两个字段完全独立。为了让协方差为0，我们选择第二个基时只能在与第一个基正交的方向上选择。因此最终选择的两个方向一定是正交的。</p>
<p>至此，我们得到了降维问题的优化目标：将一组N维向量降为K维（K大于0，小于N），其目标是选择K个单位（模为1）正交基，使得原始数据变换到这组基上后，<strong>各字段两两间协方差为0，而字段的方差则尽可能大</strong>（在正交的约束下，取最大的K个方差）。</p>
<h2 id="协方差矩阵"><a href="#协方差矩阵" class="headerlink" title="协方差矩阵"></a>协方差矩阵</h2><p>我们看到，最终要达到的目的与字段内方差及字段间协方差有密切关系。因此我们希望能将两者统一表示，仔细观察发现，两者均可以表示为内积的形式，而内积又与矩阵相乘密切相关。</p>
<p>假设我们只有a和b两个字段，那么我们将它们按行组成矩阵X：</p>
<p><img src="/2018/08/07/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（七）：降维/09.png" alt></p>
<p>然后我们用X乘以X的转置，并乘上系数1/m：</p>
<p><img src="/2018/08/07/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（七）：降维/10.png" alt></p>
<p>奇迹出现了！这个对角线上的两个元素分别是两个字段的方差，而其它元素是a和b的协方差。两者被统一到了一个矩阵的。</p>
<p>根据矩阵相乘的运算法则，这个结论很容易被推广到一般情况：设我们有m个n维数据记录，将其按列排成n乘m的矩阵X，设$C=\frac{1}{m}XX^𝖳$ ，则C是一个对称矩阵，其对角线分别个各个字段的方差，而第i行j列和j行i列元素相同，表示i和j两个字段的协方差。</p>
<h2 id="协方差矩阵对角化"><a href="#协方差矩阵对角化" class="headerlink" title="协方差矩阵对角化"></a>协方差矩阵对角化</h2><p>根据上述推导，我们发现要达到优化条件，等价于将协方差对角化：即除对角线外的其它元素化为0，并且在对角线上将元素按大小从上到下排列，这样我们就达到了优化目的。这样说可能还不是很明晰，我们进一步看下原矩阵与基变换后矩阵协方差矩阵的关系：</p>
<p>设<strong>原始数据矩阵X</strong>对应的<strong>协方差矩阵为C</strong>，而P是一组基按行组成的矩阵，设$Y=PX$，则<strong>Y为X对P做基变换后的数据</strong>。设<strong>Y的协方差矩阵为D</strong>，我们推导一下D与C的关系：</p>
<script type="math/tex; mode=display">
D = \frac{1}{m}YY^T\\ \quad =\frac{1}{m}(PX)(PX)^T\\ =\frac{1}{m}PXX^TP\\=PCP^T</script><p><strong>现在事情很明白了，我们要找的P不是别的，而是能让原始协方差矩阵对角化的P</strong>。换句话说，优化目标变成了寻找一个矩阵P，满足$PCP^T$是一个对角矩阵，并且对角元素按从小到大依次排列，那么<strong>P的前K行就是要寻找的基</strong>，<strong>用P的前K行组成的矩阵乘以X</strong>就使得X从N维降到了K维并满足上述优化条件。</p>
<p>现在所有焦点都聚焦在了协方差矩阵对角化问题上，由上文知道，<strong>协方差矩阵C是一个是对称矩阵</strong>，在线性代数上，实对称矩阵有一系列非常好的性质：</p>
<ul>
<li>1）实对称矩阵不同特征值对应的特征向量必然正交。</li>
<li>2）设特征向量λ重数为r，则必然存在r个线性无关的特征向量对应于λ，因此可以将这r个特征向量单位正交化。</li>
</ul>
<p>由上面两条可知，一个n行n列的实对称矩阵一定可以找到n个单位正交特征向量，设这n个特征向量为$e_1,e_2,⋯,e_n$，我们将其按列组成矩阵：</p>
<script type="math/tex; mode=display">
E = (e_1\ e_2 \ ··· \ e_n)</script><p>则对协方差矩阵C有如下结论：</p>
<script type="math/tex; mode=display">
E^TCE =
\varLambda\ =\left[\begin{matrix}
    \lambda_1&        &        &        \\
    &        \lambda_2&        &        \\
    &        &        ···&        \\
    &        &        &        \lambda_n\\
\end{matrix}\right]</script><p>其中Λ为对角矩阵，其对角元素为各特征向量对应的特征值（可能有重复）。以上结论不再给出严格的数学证明，对证明感兴趣的朋友可以参考线性代数书籍关于“实对称矩阵对角化”的内容。</p>
<p>到这里，我们发现我们已经找到了需要的矩阵P：P是协方差矩阵的特征向量单位化后按行排列出的矩阵，其中每一行都是C的一个特征向量。如果设P按照Λ中特征值的从大到小，将特征向量从上到下排列，则用P的前K行组成的矩阵乘以原始数据矩阵X，就得到了我们需要的降维后的数据矩阵Y</p>
<p>于是，只需对协方差矩阵$XX^T$进行特征值分解，将求得的特征值排序:$λ_1\geq λ_2\geq …\geq λ_d$,再再取前 d’ 个特征值对应的特征向量构成 $W=(w_1,w_2,..,w_d’)$.这就是主成分分析的解.要注意降维后低维空间的维数 d’ 通常是由用户事先指定。</p>
<p>简单回顾一下：给定原始数据矩阵X，其协方差矩阵$C=\frac{1}{M}XX^T$对角元素代表了方差，其余元素代表相关性。假定降维后的数据矩阵为Y，其协方差D会满足对角元素最大，其余元素为0，这样才会代表降维后的要求。设Y=PX，P代表要与矩阵相乘的基，有$D=PCP^T$的关系。这个等式的形式与实对称矩阵对角化一样，这时候只要找出C的特征值对应的特征向量，组合起来即为我们需要求得P。最后Y=PX得到降维后的数据矩阵。</p>
<p><img src="/2018/08/07/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（七）：降维/11.png" alt></p>
<p>PCA 仅需保留 W 与 样本 的均值向 量即可通过简单的向量减法和矩阵”向量乘法将新样本投影至低维空间中 . 显然，低维空间与原始高维空间必有不同，因为对应于最小的d-d’个特征值的特征 向量被舍弃了，这是降维导致的结果.但舍弃这部分信息往往是必要的- 一方面舍弃这部分信息之后能使样本的采样密度增大，这正是降维 的重要动机; 另一方面，当数据受到 噪声影响时， 最小的特征值所对应的特征 向量往往与噪声有关?将它们舍弃能在一定程度上起到去噪的效果.</p>
<h1 id="流行学习算法Isomap：等度量映射"><a href="#流行学习算法Isomap：等度量映射" class="headerlink" title="流行学习算法Isomap：等度量映射"></a>流行学习算法Isomap：等度量映射</h1><p>等度量映射(Isometric Mapping，简称 Isomap) 的基本 出发点，是认为低维流Î~嵌入到 高维空 间之后，直接在高维空间 中计算直线距离具有误导性，因为高维空间中的直线距离在低维嵌入流形上是不可达的.如图 所示，低维嵌入流形上两点间的距离是”测地线” (geodesic)距离。</p>
<p><img src="/2018/08/07/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（七）：降维/12.png" alt></p>
<p>那么，如何计算测地线距离呢?这时我们可利用流形在局部上与 欧氏空间同胚这个性质，对每个点基于欧 氏距离找出其近邻点，然后就能建立一个近邻连接图，图中近邻点之间存在连接，而非近邻点之间不存在连接， 于是，计算两点之间测地线距离的问题就转变为计算近邻连接图上两点之间的最短路径问题.</p>
<p>在近邻连接图上计算两点间的最短路径?可采用著名的Dijkstra算法或Floyd算法，在得到任意两点的距离之后，就可通过MDS 方法来获得样本点在低维空间中的坐标。</p>
<p><img src="/2018/08/07/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（七）：降维/13.png" alt></p>
<h1 id="流行学习算法LLE：局部线性嵌入"><a href="#流行学习算法LLE：局部线性嵌入" class="headerlink" title="流行学习算法LLE：局部线性嵌入"></a>流行学习算法LLE：局部线性嵌入</h1><p>LLE首先假设数据在较小的局部是线性的，也就是说，某一个数据可以由它邻域中的几个样本来线性表示。比如我们有一个样本x1,我们在它的原始高维邻域里用K-近邻思想找到和它最近的三个样本x2,x3,x4. 然后我们假设x1可以由x2,x3,x4线性表示，即</p>
<script type="math/tex; mode=display">
x_1 = w_{12}x_2 + w_{13}x_3 +w_{14}x_4</script><p>其中，w12，w13，w14为权重系数。在我们通过LLE降维后，我们希望x1在低维空间对应的投影x′1和x2,x3,x4对应的投影x′2,x′3,x′4也尽量保持同样的线性关系，即</p>
<script type="math/tex; mode=display">
x_1' \approx w_{12}x_2' + w_{13}x_3' +w_{14}x_4'</script><p>也就是说，投影前后线性关系的权重系数w12，w13，w14是尽量不变或者最小改变的。</p>
<p>从上面可以看出，线性关系只在样本的附近起作用，离样本远的样本对局部的线性关系没有影响，因此降维的复杂度降低了很多。</p>
<p>对于LLE算法，我们首先要确定邻域大小的选择，即我们需要多少个邻域样本来线性表示某个样本。假设这个值为k。我们可以通过和KNN一样的思想通过距离度量比如欧式距离来选择某样本的k个最近邻。</p>
<p>在寻找到某个样本的xi的k个最近邻之后我们就需要找到找到xi和这k个最近邻之间的线性关系，也就是要找到线性关系的权重系数。找线性关系，这显然是一个回归问题。假设我们有m个n维样本{x1,x2,…,xm},我们可以用均方差作为回归问题的损失函数：即：</p>
<script type="math/tex; mode=display">
J(w) = \sum\limits_{i=1}^{m}||x_i-\sum\limits_{j=1}^{k}w_{ij}x_j||_2^2</script><p>一般我们也会对权重系数$w_{ij}$做归一化的限制，即权重系数需要满足</p>
<script type="math/tex; mode=display">
\sum\limits_{j=1}^{k}w_{ij} = 1</script><p>对于不在样本$x<em>i$邻域内的样本$x_j$，我们令对应的$w</em>{ij}=0$.也就是我们需要通过上面两个式子求出我们的权重系数。一般我们可以通过矩阵和拉格朗日子乘法来求解这个最优化问题。(这个推导就不写了）</p>
<p>最后得到</p>
<script type="math/tex; mode=display">
W_i = \frac{Z_i^{-1}1_k}{1_k^TZ_i^{-1}1_k}</script><p>其中$W<em>i=(w</em>{i1},w<em>{i2},…w</em>{ik})^T$ ,矩阵$Z_i=(x_i−x_j)^T(x_i−x_j)$,其中$1_k$ 为k维全1向量。</p>
<p>在我们得到了高维的权重系数，那么我们希望这些权重系数对应的线性关系在降维后的低维一样得到保持。假设我们的n维样本集{x1,x2,…,xm}在低维的d维度对应投影为{y1,y2,…,ym}, 则我们希望保持线性关系，也就是希望对应的均方差损失函数最小，即最小化损失函数J(Y)如下：</p>
<script type="math/tex; mode=display">
J(y) = \sum\limits_{i=1}^{m}||y_i-\sum\limits_{j=1}^{k}w_{ij}y_j||_2^2</script><p>这个优化目标与之前的同形，唯一的区别是之前需要确定权重系数$w_i$，而现在是知道权重系数，需要确定的是$x_i$对应的低维空间坐标$y_i$。</p>
<p>令$M=(I-W)^T(I-W)$ ,则优化函数转变为最小化下式：$J(Y) = tr(Y^TMY)$,tr为迹函数。约束函数矩阵化为：$Y^TY=mI$ </p>
<p>上式可通过特征值分解求解:M 最小的 d’ 个特征值对应的特征向量组成的矩阵即为 $Z^T$.<br>算法流程：</p>
<p><img src="/2018/08/07/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（七）：降维/14.png" alt></p>
<p>从图中可以看出，LLE算法主要分为三步，第一步是求K近邻的过程，这个过程使用了和KNN算法一样的求最近邻的方法。第二步，就是对每个样本求它在邻域里的K个近邻的线性关系，得到线性关系权重系数W，第三步就是利用权重系数来在低维里重构样本数据。</p>
<p><img src="/2018/08/07/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（七）：降维/15.png" alt></p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>我们将会展示两种主要的降维方法：投影（projection）和流形学习（Manifold Learning），同时我们还会介绍三种流行的降维技术：主成分分析（PCA），核主成分分析（Kernel PCA）和局部线性嵌入（LLE）。</p>
<h2 id="主成分分析（PCA）"><a href="#主成分分析（PCA）" class="headerlink" title="主成分分析（PCA）"></a>主成分分析（PCA）</h2><p>主成分分析（Principal Component Analysis）是目前为止最流行的降维算法。首先它找到接近数据集分布的超平面，然后将所有的数据都投影到这个超平面上。</p>
<h3 id="保留（最大）方差"><a href="#保留（最大）方差" class="headerlink" title="保留（最大）方差"></a>保留（最大）方差</h3><p>在将训练集投影到较低维超平面之前，您首先需要选择正确的超平面。例如图左侧是一个简单的二维数据集，以及三个不同的轴（即一维超平面）。图右边是将数据集投影到每个轴上的结果。正如你所看到的，投影到实线上保留了最大方差，而在点线上的投影只保留了非常小的方差，投影到虚线上保留的方差则处于上述两者之间。</p>
<p><img src="/2018/08/07/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（七）：降维/16.png" alt></p>
<p><strong>选择保持最大方差的轴看起来是合理的，因为它很可能比其他投影损失更少的信息。证明这种选择的另一种方法是，选择这个轴使得将原始数据集投影到该轴上的均方距离最小。这是就 PCA 背后的思想，相当简单</strong>。</p>
<h3 id="主成分（Principle-Componets）"><a href="#主成分（Principle-Componets）" class="headerlink" title="主成分（Principle Componets）"></a>主成分（Principle Componets）</h3><p>PCA 寻找训练集中可获得最大方差的轴。在上图中，它是一条实线。<strong>它还发现了一个与第一个轴正交的第二个轴，选择它可以获得最大的残差</strong>。在这个 2D 例子中，没有选择：就只有这条点线。但如果在一个更高维的数据集中，PCA 也可以找到与前两个轴正交的第三个轴，以及与数据集中维数相同的第四个轴，第五个轴等。 定义第i个轴的单位矢量被称为第i个主成分（PC）。在图中，第一个 PC 是c1，第二个 PC 是c2。在投影图中，前两个 PC 用平面中的正交箭头表示，第三个 PC 与上述 PC 形成的平面正交（指向上或下）</p>
<blockquote>
<p>概述： 主成分的方向不稳定：如果您稍微打乱一下训练集并再次运行 PCA，则某些新 PC 可能会指向与原始 PC 方向相反。但是，它们通常仍位于同一轴线上。在某些情况下，一对 PC 甚至可能会旋转或交换，但它们定义的平面通常保持不变。</p>
</blockquote>
<p>那么如何找到训练集的主成分呢？幸运的是，<strong>有一种称为奇异值分解（SVD）的标准矩阵分解技术</strong>，可以将训练集矩阵X分解为三个矩阵$U·Σ·V^T$的点积，其中$V^T$$包含我们想要的所有主成分，如下所示。</p>
<p><img src="/2018/08/07/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（七）：降维/17.png" alt></p>
<p>下面的 Python 代码使用了 Numpy 提供的svd()函数获得训练集的所有主成分，然后提取前两个 PC:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X_centered=X-X.mean(axis=<span class="number">0</span>)    <span class="comment"># 中心化</span></span><br><span class="line">U,s,V=np.linalg.svd(X_centered)</span><br><span class="line">c1=V.T[:,<span class="number">0</span>]</span><br><span class="line">c2=V.T[:,<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>警告：PCA 假定数据集以原点为中心。正如我们将看到的，Scikit-Learn 的PCA类负责为您的数据集中心化处理。但是，如果您自己实现 PCA（如前面的示例所示），或者如果您使用其他库，不要忘记首先要先对数据做中心化处理。</p>
</blockquote>
<p><strong>投影到d维空间：</strong><br>一旦确定了所有的主成分，你就可以通过将数据集投影到由前d个主成分构成的超平面上，从而将数据集的维数降至d维。选择这个超平面可以确保投影将保留尽可能多的方差。</p>
<p><strong>为了将训练集投影到超平面上，可以简单地通过计算训练集矩阵X和Wd的点积，Wd定义为包含前d个主成分的矩阵（即由V^T的前d列组成的矩阵）</strong></p>
<p>将训练集投影到d维空间的公式：</p>
<script type="math/tex; mode=display">X_{d-proj} = X \cdot W_d</script><p>下面的 Python 代码将训练集投影到由前两个主成分定义的超平面上：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">W2=V.T[:,:<span class="number">2</span>]    <span class="comment"># 降为2维</span></span><br><span class="line">X2D=X_centered.dot(W2)</span><br></pre></td></tr></table></figure>
<p><strong>使用 Scikit-Learn</strong><br>Scikit-Learn 的 PCA 类使用 SVD 分解来实现，就像我们之前做的那样。以下代码应用 PCA 将数据集的维度降至两维（请注意，它会自动处理数据的中心化）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA</span><br><span class="line"></span><br><span class="line">pca=PCA(n_components=<span class="number">2</span>)</span><br><span class="line">X2D=pca.fit_transform(X)</span><br></pre></td></tr></table></figure>
<p>将 PCA 转化器应用于数据集后，可以使用components_访问每一个主成分（注意，它返回以 PC 作为水平向量的矩阵，因此，如果我们想要获得第一个主成分则可以写成pca.components_.T[:,0]）。</p>
<h3 id="方差解释率（Explained-Variance-Ratio）"><a href="#方差解释率（Explained-Variance-Ratio）" class="headerlink" title="方差解释率（Explained Variance Ratio）"></a>方差解释率（Explained Variance Ratio）</h3><p><strong>另一个非常有用的信息是每个主成分的方差解释率，可通过explained<em>variance_ratio</em>变量获得。它表示位于每个主成分轴上的数据集方差的比例</strong>。例如，让我们看下图中表示的三维数据集前两个分量的方差解释率：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(pca.explained_variance_ratio_)</span><br><span class="line">array([<span class="number">0.84248607</span>, <span class="number">0.14631839</span>])</span><br></pre></td></tr></table></figure>
<p>这表明，84.2% 的数据集方差位于第一轴，14.6% 的方差位于第二轴。第三轴的这一比例不到1.2％，因此可以认为它可能没有包含什么信息</p>
<p><strong>选择正确的维度</strong><br><strong>通常我们倾向于选择加起来到方差解释率能够达到足够占比（例如 95%）的维度的数量，而不是任意选择要降低到的维度数量。</strong>当然，除非您正在为数据可视化而降低维度 — 在这种情况下，您通常希望将维度降低到 2 或 3。</p>
<p>下面的代码在不降维的情况下进行 PCA，然后计算出保留训练集方差 95% 所需的最小维数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pca=PCA()</span><br><span class="line">pac.fit(X)</span><br><span class="line">cumsum=np.cumsum(pca.explained_variance_ratio_)</span><br><span class="line">d=np.argmax(cumsum&gt;=<span class="number">0.95</span>)+<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>你可以设置n_components = d并再次运行 PCA。但是，<strong>有一个更好的选择：不指定你想要保留的主成分个数，而是将n_components设置为 0.0 到 1.0 之间的浮点数，表明您希望保留的方差比率：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pca=PCA(n_components=<span class="number">0.95</span>)</span><br><span class="line">X_reduced=pca.fit_transform(X)</span><br></pre></td></tr></table></figure>
<p>另一种选择是画出方差解释率关于维数的函数（简单地绘制cumsum）。曲线中通常会有一个肘部，方差解释率停止快速增长。您可以将其视为数据集的真正的维度。在这种情况下，您可以看到将维度降低到大约100个维度不会失去太多的可解释方差。</p>
<h3 id="PCA-压缩"><a href="#PCA-压缩" class="headerlink" title="PCA 压缩"></a>PCA 压缩</h3><p>显然，在降维之后，训练集占用的空间要少得多。例如，尝试将 PCA 应用于 MNIST 数据集，同时保留 95% 的方差。你应该发现每个实例只有 150 多个特征，而不是原来的 784 个特征。因此，尽管大部分方差都保留下来，但数据集现在还不到其原始大小的 20%！这是一个合理的压缩比率，您可以看到这可以如何极大地加快分类算法（如 SVM 分类器）的速度。</p>
<p><strong>通过应用 PCA 投影的逆变换，也可以将缩小的数据集解压缩回 784 维。当然这并不会返回给你最原始的数据，因为投影丢失了一些信息（在5％的方差内），但它可能非常接近原始数据</strong>。原始数据和重构数据之间的均方距离（压缩然后解压缩）被称为重构误差（reconstruction error）。例如，下面的代码将 MNIST 数据集压缩到 154 维，然<strong>后使用inverse_transform()方法将其解压缩回 784 维</strong>。图 8-9 显示了原始训练集（左侧）的几位数字在压缩并解压缩后（右侧）的对应数字。您可以看到有轻微的图像质量降低，但数字仍然大部分完好无损。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pca=PCA(n_components=<span class="number">154</span>)</span><br><span class="line">X_mnist_reduced=pca.fit_transform(X_mnist)</span><br><span class="line">X_mnist_recovered=pca.inverse_transform(X_mnist_reduced)</span><br></pre></td></tr></table></figure>
<p><img src="/2018/08/07/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（七）：降维/19.png" alt></p>
<p>PCA逆变换公式，回退到原来的数据维度</p>
<script type="math/tex; mode=display">
X_{recovered} = X_{d-proj} \cdot W_d^T</script><h3 id="增量-PCA（Incremental-PCA）"><a href="#增量-PCA（Incremental-PCA）" class="headerlink" title="增量 PCA（Incremental PCA）"></a>增量 PCA（Incremental PCA）</h3><p><strong>先前 PCA 实现的一个问题是它需要在内存中处理整个训练集以便 SVD 算法运行。幸运的是，我们已经开发了增量 PCA（IPCA）算法：您可以将训练集分批，并一次只对一个批量使用 IPCA 算法。这对大型训练集非常有用</strong>，并且可以在线应用 PCA（即在新实例到达时即时运行）。</p>
<p><strong>下面的代码将 MNIST 数据集分成 100 个小批量（使用 NumPy 的array_split()函数），并将它们提供给 Scikit-Learn 的IncrementalPCA类，以将 MNIST 数据集的维度降低到 154 维（就像以前一样）。请注意，您必须对每个最小批次调用partial_fit()方法，而不是对整个训练集使用fit()方法</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> IncrementalPCA</span><br><span class="line"></span><br><span class="line">n_batches=<span class="number">100</span></span><br><span class="line">inc_pca=IncrementalPCA(n_components=<span class="number">154</span>)</span><br><span class="line"><span class="keyword">for</span> X_batch <span class="keyword">in</span> np.array_spplit(X_mnist,n_batches): <span class="comment">#分100批次数据</span></span><br><span class="line">    inc_pca.partial_fit(X_batch)    <span class="comment"># 必须批次调用partial_fit()方法</span></span><br><span class="line">X_mnist_reduced=inc_pca.transform(X_mnist)</span><br></pre></td></tr></table></figure>
<p>或者，您可以使用 NumPy 的memmap类，它允许您操作存储在磁盘上二进制文件中的大型数组，就好像它完全在内存中；该类仅在需要时加载内存中所需的数据。由于增量 PCA 类在任何时间内仅使用数组的一小部分，因此内存使用量仍受到控制。这可以调用通常的fit()方法，如下面的代码所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X_mm=np.memmap(filename,dtype=<span class="string">'float32'</span>,mode=<span class="string">'readonly'</span>,shape=(m,n))</span><br><span class="line">batch_size=m//n_batches</span><br><span class="line">inc_pca=IncrementalPCA(n_components=<span class="number">154</span>,batch_size=batch_size)</span><br><span class="line">inc_pca.fit(X_mm)</span><br></pre></td></tr></table></figure>
<h3 id="随机-PCA（Randomized-PCA）"><a href="#随机-PCA（Randomized-PCA）" class="headerlink" title="随机 PCA（Randomized PCA）"></a>随机 PCA（Randomized PCA）</h3><p>Scikit-Learn 提供了另一种执行 PCA 的选择，称为随机 PCA。这是一种随机算法，可以快速找到前d个主成分的近似值。它的计算复杂度是O(m × d^2) + O(d^3)，而不是O(m × n^2) + O(n^3)，所以当d远小于n时，<strong>它比之前的算法快得多。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rnd_pca=PCA(n_components=<span class="number">154</span>,svd_solver=<span class="string">'randomized'</span>)</span><br><span class="line">X_reduced=rnd_pca.fit_transform(X_mnist)</span><br></pre></td></tr></table></figure>
<h2 id="核-PCA（Kernel-PCA）"><a href="#核-PCA（Kernel-PCA）" class="headerlink" title="核 PCA（Kernel PCA）"></a>核 PCA（Kernel PCA）</h2><p>例如，下面的代码使用 Scikit-Learn 的KernelPCA类来执行带有 RBF 核的 kPCA</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> KernelPCA</span><br><span class="line"></span><br><span class="line">rbf_pca=KernelPCA(n_components=<span class="number">2</span>,kernel=<span class="string">'rbf'</span>,gamma=<span class="number">0.04</span>)</span><br><span class="line">X_reduced=rbf_pca.fit_transform(X)</span><br></pre></td></tr></table></figure>
<p><img src="/2018/08/07/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（七）：降维/20.png" alt></p>
<p><strong>选择一种核并调整超参数</strong><br><strong>由于 kPCA 是无监督学习算法，因此没有明显的性能指标可以帮助您选择最佳的核方法和超参数值。但是，降维通常是监督学习任务（例如分类）的准备步骤，因此您可以简单地使用网格搜索来选择可以让该任务达到最佳表现的核方法和超参数</strong>。例如，下面的代码创建了一个两步的流水线，首先使用 kPCA 将维度降至两维，然后应用 Logistic 回归进行分类。然后它<strong>使用Grid SearchCV为 kPCA 找到最佳的核和gamma值</strong>，以便在最后获得最佳的分类准确性：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> GridSearchCV <span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression <span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> Pipeline</span><br><span class="line">clf = Pipeline([</span><br><span class="line">        (<span class="string">"kpca"</span>, KernelPCA(n_components=<span class="number">2</span>)),</span><br><span class="line">        (<span class="string">"log_reg"</span>, LogisticRegression())</span><br><span class="line">])</span><br><span class="line">param_grid = [&#123;</span><br><span class="line">        <span class="string">"kpca__gamma"</span>: np.linspace(<span class="number">0.03</span>, <span class="number">0.05</span>, <span class="number">10</span>),</span><br><span class="line">        <span class="string">"kpca__kernel"</span>: [<span class="string">"rbf"</span>, <span class="string">"sigmoid"</span>]</span><br><span class="line">    &#125;]</span><br><span class="line">grid_search = GridSearchCV(clf, param_grid, cv=<span class="number">3</span>)</span><br><span class="line">grid_search.fit(X, y)</span><br></pre></td></tr></table></figure>
<p>你可以通过调用best<em>params</em>变量来查看使模型效果最好的核和超参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(grid_search.best_params_)</span><br><span class="line">&#123;<span class="string">'kpca__gamma'</span>: <span class="number">0.043333333333333335</span>, <span class="string">'kpca__kernel'</span>: <span class="string">'rbf'</span>&#125;</span><br></pre></td></tr></table></figure>
<p><strong>另一种完全为非监督的方法，是选择产生最低重建误差的核和超参数</strong>。但是，重建并不像线性 PCA 那样容易。这里是原因：图 8-11 显示了原始瑞士卷 3D 数据集（左上角），并且使用 RBF 核应用 kPCA 后生成的二维数据集（右上角）。由于核技巧，这在数学上等同于使用特征映射φ将训练集映射到无限维特征空间（右下），然后使用线性 PCA 将变换的训练集投影到 2D。请注意，如果我们可以在缩减空间中对给定实例实现反向线性 PCA 步骤，则重构点将位于特征空间中，而不是位于原始空间中（例如，如图中由x表示的那样）。由于特征空间是无限维的，我们不能找出重建点，因此我们无法计算真实的重建误差。<strong>幸运的是，可以在原始空间中找到一个贴近重建点的点。这被称为重建前图像（reconstruction pre-image）。一旦你有这个前图像，你就可以测量其与原始实例的平方距离。然后，您可以选择最小化重建前图像错误的核和超参数。</strong></p>
<p><img src="/2018/08/07/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（七）：降维/21.png" alt></p>
<p><strong>您可能想知道如何进行这种重建。一种解决方案是训练一个监督回归模型，将预计实例作为训练集，并将原始实例作为训练目标</strong>。如果您设置了fit_inverse_transform = True，Scikit-Learn 将自动执行此操作，代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rbf_pca = KernelPCA(n_components = <span class="number">2</span>, kernel=<span class="string">"rbf"</span>, gamma=<span class="number">0.0433</span>,fit_inverse_transform=<span class="literal">True</span>)</span><br><span class="line">X_reduced = rbf_pca.fit_transform(X)</span><br><span class="line">X_preimage = rbf_pca.inverse_transform(X_reduced)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>概述：默认条件下，fit_inverse_transform = False并且KernelPCA没有inverse_tranfrom()方法。这种方法仅仅当fit_inverse_transform = True的情况下才会创建。</p>
</blockquote>
<p>你可以计算重建前图像误差：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> mean_squared_error</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mean_squared_error(X, X_preimage) <span class="number">32.786308795766132</span></span><br></pre></td></tr></table></figure>
<p>现在你可以使用交叉验证的方格搜索来寻找可以最小化重建前图像误差的核方法和超参数。</p>
<h2 id="局部线性嵌入LLE"><a href="#局部线性嵌入LLE" class="headerlink" title="局部线性嵌入LLE"></a>局部线性嵌入LLE</h2><p>局部线性嵌入（Locally Linear Embedding）是另一种非常有效的非线性降维（NLDR）方法。这是一种流形学习技术，不依赖于像以前算法那样的投影。简而言之，LLE 首先测量每个训练实例与其最近邻（c.n.）之间的线性关系，然后寻找能最好地保留这些局部关系的训练集的低维表示（稍后会详细介绍） 。这使得它特别擅长展开扭曲的流形，尤其是在没有太多噪音的情况下。</p>
<p>例如，以下代码使用 Scikit-Learn 的LocallyLinearEmbedding类来展开瑞士卷。得到的二维数据集如图所示。正如您所看到的，瑞士卷被完全展开，实例之间的距离保存得很好。<strong>但是，距离不能在较大范围内保留的很好：展开的瑞士卷的左侧被挤压，而右侧的部分被拉长</strong>。尽管如此，LLE 在对流形建模方面做得非常好。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.manifold <span class="keyword">import</span> LocallyLinearEmbedding</span><br><span class="line"></span><br><span class="line">lle=LocallyLinearEmbedding(n_components=<span class="number">2</span>,n_neighbors=<span class="number">10</span>)</span><br><span class="line">X_reduced=lle.fit_transform(X)</span><br></pre></td></tr></table></figure>
<p><img src="/2018/08/07/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（七）：降维/22.png" alt></p>
<h2 id="其他降维方法"><a href="#其他降维方法" class="headerlink" title="其他降维方法"></a>其他降维方法</h2><p>多维缩放（MDS）在尝试保持实例之间距离的同时降低了维度</p>
<p>Isomap 通过将每个实例连接到最近的邻居来创建图形，然后在尝试保持实例之间的测地距离时降低维度。</p>
<p>t-分布随机邻域嵌入（t-Distributed Stochastic Neighbor Embedding，t-SNE）可以用于降低维​​度，同时试图保持相似的实例临近并将不相似的实例分开。它主要用于可视化，尤其是用于可视化高维空间中的实例（例如，可以将MNIST图像降维到 2D 可视化）。</p>
<p>线性判别分析（Linear Discriminant Analysis，LDA）实际上是一种分类算法，但在训练过程中，它会学习类之间最有区别的轴，然后使用这些轴来定义用于投影数据的超平面。LDA 的好处是投影会尽可能地保持各个类之间距离，所以在运行另一种分类算法（如 SVM 分类器）之前，LDA 是很好的降维技术。</p>
<p><img src="/2018/08/07/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（七）：降维/23.png" alt></p>
<h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><ol>
<li>减少数据集维度的主要动机是什么？主要缺点是什么？</li>
<li>什么是维度爆炸？</li>
<li>一旦对某数据集降维，我们可能恢复它吗？如果可以，怎样做才能恢复？如果不可以，为什么？</li>
<li>PCA 可以用于降低一个高度非线性对数据集吗？</li>
<li>假设你对一个 1000 维的数据集应用 PCA，同时设置方差解释率为 95%，你的最终数据集将会有多少维？</li>
<li>在什么情况下你会使用普通的 PCA，增量 PCA，随机 PCA 和核 PCA？</li>
<li>你该如何评价你的降维算法在你数据集上的表现？</li>
<li>将两个不同的降维算法串联使用有意义吗？</li>
</ol>
<hr>
<p>1、动机：为了加速后续训练算法（在某些情况下，它甚至可以消除噪声和冗余特征，使训练算法表现更好）； 通过可视化数据深入了解最重要的特征； 节省空间（压缩）。缺点：某些信息丢失，可能会降低后续训练算法的性能； 计算密集； 为机器学习管道增加了一些复杂性；转换后的功能通常难以解释。</p>
<p>2、在机器学习中，一个常见的表现是随机采样的高维向量通常非常稀疏，增加了过拟合的风险，并且在没有足够的训练数据的情况下很难识别数据中的模式。</p>
<p>3、一旦使用我们讨论过的算法减少了数据集的维数，几乎总是不可能完全逆转操作，因为在降维期间某些信息会丢失。 此外，虽然一些算法（例如PCA）具有可以重建与原始数据相对类似的数据集的简单反向变换过程，但是其他算法（例如T-SNE）则不然。</p>
<p>4、PCA可用于显着降低大多数数据集的维度，即使它们是高度非线性的，因为它至少可以消除无用的维度。 但是，如果没有无用的维度 - 例如，瑞士卷 - 那么使用PCA降低维数将失去太多信息。 你想要展开瑞士卷，而不是挤压它。</p>
<p>5、这是一个棘手的问题：它取决于数据集。 让我们看看两个极端的例子。 首先，假设数据集由几乎完全对齐的点组成。 在这种情况下，PCA可以将数据集减少到一维，同时仍然保留95％的方差。 现在想象一下，数据集由完全随机的点组成，分散在1000个维度周围。 在这种情况下，需要所有1,000个维度来保持95％的方差。 所以答案是，它取决于数据集，它可以是1到1,000之间的任何数字。 将解释的方差绘制为维数的函数是一种粗略了解数据集内在维度的方法。</p>
<p>6、常规PCA是默认值，但仅当数据集有足够内存时才有效。 当您需要在每次新实例到达时动态应用PCA，增量PCA对于在线任务很有用。 当您想要显着降低维度并且有足够内存时，随机PCA非常有用; 在这种情况下，它比普通PCA快得多。 最后，Kernel PCA对非线性数据集非常有用。</p>
<p>7、直观地说，如果从数据集中消除了大量维度而不会丢失太多信息，则降维算法表现良好。 衡量这种情况的一种方法是应用反向变换并测量重建误差。 但是，并非所有降维算法都提供逆向变换。</p>
<p>8、链接两个不同的降维算法绝对有意义。 一个常见的例子是使用PCA快速摆脱大量无用的维度，然后应用另一个慢得多的降维算法，如LLE。 这种两步法可能会产生与仅使用LLE相同的性能，但只需要很短的时间。</p>
]]></content>
      <categories>
        <category>Sklearn 与 TensorFlow 机器学习实用指南</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>PCA</tag>
        <tag>MDS</tag>
        <tag>LLE</tag>
        <tag>Isomap</tag>
      </tags>
  </entry>
  <entry>
    <title>Sklearn 与 TensorFlow 机器学习实用指南（六）：集成学习</title>
    <url>/2018/08/04/Sklearn%20%E4%B8%8E%20TensorFlow%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E7%94%A8%E6%8C%87%E5%8D%97/Sklearn-%E4%B8%8E-TensorFlow-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E7%94%A8%E6%8C%87%E5%8D%97%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>集成学习(ensemble learning)通过构建并结合多个学习器来完成学习任务，<strong>比单一学习器获得显著优越的泛化性能</strong>。想要获得好的集成，个体学习器应”<strong>好而不同</strong>“，要保证准确性和多样性。要产生好而不同的个体学习器，恰是集成学习研究的核心</p>
<p><strong>目前集成学习可分为两大类，即个体学习器之间有依赖关系，必须串行生成的序列化方法；以及个体学习器不存在强依赖关系，可同时生成的并行化方法。前者的代表是Boosting，最著名的是代表有Adaboost, GBDT和XGBOOST;后者的代表是Bagging和随机森林。对于学习器的结合策略有三大类：投票法（分类），平均法（连续数值），学习法（Stacking）</strong></p>
<h1 id="Boosting"><a href="#Boosting" class="headerlink" title="Boosting"></a>Boosting</h1><h2 id="Adaboost"><a href="#Adaboost" class="headerlink" title="Adaboost"></a>Adaboost</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>Adaboost提升方法是改变训练数据的概率分布（训练数据的权值分布），针对不同的训练数据分布调用弱学习算法学习一系列弱分类器。AdaBoost的做法是，<strong>提高那些被前一轮弱分类器错误分类样本的权值，而降低那些被正确分类样本的权值</strong>。这样一来，那些没有得到正确分类的数据，由于其权值的加大而受到后一轮的弱分类器的更大关注，于是，分类问题就被一系列的弱分类器“分而治之”。另外，对于弱分类器的组合，AdaBoost采取加权多数表决的方法。具体地，<strong>加大分类误差率小的弱分类器的权值，使其在表决中起较大的作用，减小分类误差率较大的弱分类器的权值，使其在表决中起较小的作用。</strong>(两个权重，一个是样本权重，另外一个是分类器的权重)</p>
<p>AdaboostBoost的算法的框架如下图所示</p>
<p><img src="/2018/08/04/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（六）：集成学习/01.png" alt></p>
<h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><p>具体算法流程如下图所示：</p>
<p><img src="/2018/08/04/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（六）：集成学习/02.png" alt></p>
<ul>
<li>step2. 预期迭代T轮</li>
<li>step4. 计算分类器$h_t$的误差率$\epsilon_t$ </li>
</ul>
<script type="math/tex; mode=display">
\epsilon_t=P\left(h_t\left(x\right)\ne y_i\right)=\frac{\sum_{i=1}^m{w_{ki}I\left(h_t\left(x_i\right)\ne y_i\right)}}{\sum_{i=1}^m{w_{ki}}}=\sum_{i=1}^m{w_{ki}I\left(G_m\left(x_i\right)\ne y_i\right)}</script><p>这里$w<em>{ki}$表示第k轮（第k个分类器）中第i个实例的权重，$\sum</em>{i=1}^m{w_{ki}=1}$，I表示指示函数，代表满足条件的样本。这表明，误差率是被$h_t$分类错误的样本的权重之和。（这些样本的权重会在后面归一化）</p>
<ul>
<li>step5. 分类器比随机分类效果还差则停止</li>
<li>step6. 根据误差率计算分类器的权重，表示最终分类器的重要程度。由表达式可知，当误差率小于等于1/2时，$\alpha_k$大于等于0。并且$\alpha_k$随着误差率的减小而增大，意味着误差越小的分类器最后的重要程度越大。</li>
<li>step7. 更新样本权重，$Z_k$为归一化因子，把最后的全部样本权重求和即可。</li>
</ul>
<script type="math/tex; mode=display">
w_{k+1,i}=\frac{w_{ki}}{Z_k}exp(-\alpha_k y_i G_k(x_i))</script><h3 id="Adaboost算法优缺点"><a href="#Adaboost算法优缺点" class="headerlink" title="Adaboost算法优缺点"></a>Adaboost算法优缺点</h3><h4 id="Adaboost优点"><a href="#Adaboost优点" class="headerlink" title="Adaboost优点"></a>Adaboost优点</h4><ul>
<li>不容易发生过拟合。</li>
<li>Adaboost是一种有很高精度的分类器。</li>
<li>当使用简单分类器时，计算出的结果是可理解的。</li>
<li>可以使用各种方法构建子分类器，Adaboost算法提供的是框架。</li>
</ul>
<h4 id="Adaboost缺点"><a href="#Adaboost缺点" class="headerlink" title="Adaboost缺点"></a>Adaboost缺点</h4><ul>
<li>训练时间过长。</li>
<li>执行效果依赖于弱分类器的选择。</li>
<li>对样本敏感，异常样本在迭代中可能会获得较高的权重，影响最终的强学习器的预测准确性。</li>
</ul>
<h2 id="GBTD"><a href="#GBTD" class="headerlink" title="GBTD"></a>GBTD</h2><p>GBDT（Gradient Boosting Decision Tree）是一种迭代的决策树算法，又叫 MART（Multiple Additive Regression Tree)，它通过构造一组弱的学习器（树），并把多颗决策树的结果累加起来作为最终的预测输出。该算法将决策树与集成思想进行了有效的结合。并且GBDT每一棵树都是回归树CART.。由于GBDT的核心在与累加所有树的结果作为最终结果，而分类树得到的离散分类结果对于预测分类并不是这么的容易叠加。这是区别于分类树的一个显著特征（毕竟男+女=是男是女?，这样的运算是毫无道理的），GBDT在运行时就使用到了回归树的这个性质，它将累加所有树的结果作为最终结果。所以GBDT中的树都是回归树，而不是分类树，它用来做回归预测，当然回归树经过调整之后也能用来做分类。</p>
<p>这里要先介绍GBDT简单版本的提升树Boosting Decision Tree，后面再介绍GBDT。</p>
<h3 id="提升树Boosting-Decision-Tree"><a href="#提升树Boosting-Decision-Tree" class="headerlink" title="提升树Boosting Decision Tree"></a>提升树Boosting Decision Tree</h3><p>提升树(Boosting Decision Tree)由于输出样本是连续值，因此我们通过迭代<strong>多棵</strong>回归树来共同决策（之前CART只是拟合一颗完整的回归树）。回归树的构造在上一节已经介绍过了，不再赘述。</p>
<p>我们利用平方误差来表示损失函数，其中每一棵回归树学习的是之前所有树的结论和残差，拟合得到一个当前的残差回归树。其中残差=真实值-预测值，提升树即是整个迭代过程生成的回归树的累加。提升树模型可以表示为决策树的加法模型：</p>
<script type="math/tex; mode=display">
f_M\left(x\right)=\sum_{m=1}^M{T\left(x;\varTheta_m\right)}</script><p>其中$T\left(x;\varTheta_m\right)$表示决策树；$\varTheta_m$为决策树的参数；M为树的个数。</p>
<p>提升树的过程如下，节点下所有点的均值作为该节点的预测值，例如左图的15与25。（这里是将特征分开处理并缩小了树的规模，若用CART可能会出现深度为3的回归树）</p>
<p><img src="/2018/08/04/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（六）：集成学习/03.png" alt></p>
<p>回归问题的提升树算法叙述如下：</p>
<p><img src="/2018/08/04/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（六）：集成学习/04.png" alt></p>
<p>对比初始的CART回归树与GBDT所生成的回归树，可以发现，最终的结果可能是相同的，那我们为什么还要使用GBDT呢？</p>
<ul>
<li>答案就是对模型过拟合的考虑。过拟合是指为了让训练集精度更高，学到了很多“仅在训练集上成立的规律”，导致换一个数据集后，当前规律的预测精度就不足以使人满意了。毕竟，在训练精度和实际精度（或测试精度）之间，后者才是我们想要真正得到的。</li>
<li>在上面这个例子中，初始的回归树为达到100%精度使用了3个特征（上网时长、时段、网购金额），但观察发现，分枝“上网时长&gt;1.1h”很显然过拟合了，不排除恰好A上网1.5h, B上网1小时，所以用上网时间是不是&gt;1.1小时来判断所有人的年龄很显然是有悖常识的。</li>
<li>而在GBDT中，两棵回归树仅使用了两个特征（购物金额与对百度知道的使用方式）就实现了100%的预测精度，其分枝依据更合乎逻辑（当然这里是相比较于上网时长特征而言），算法在运行中也体现了“如无必要，勿增实体”的奥卡姆剃刀原理</li>
</ul>
<h3 id="梯度提升决策树Gradient-Boosting-Decision-Tree"><a href="#梯度提升决策树Gradient-Boosting-Decision-Tree" class="headerlink" title="梯度提升决策树Gradient Boosting Decision Tree"></a>梯度提升决策树Gradient Boosting Decision Tree</h3><h4 id="GBDT回归算法"><a href="#GBDT回归算法" class="headerlink" title="GBDT回归算法"></a>GBDT回归算法</h4><p>提升树利用加法模型与向前分布算法实现学习的优化过程，即是通过迭代得到一系列的弱分类器，进而通过不同的组合策略得到相应的强学习器。在GBDT的迭代中，<strong>假设前一轮得到的强学习器为</strong>$f<em>{t−1}(x)$ ，对应的损失函数则为$L(y,f</em>{t−1}(x))$ 。<strong>因此新一轮迭代的目的就是找到一个弱学习器</strong>$h<em>t(x)$ ，<strong>使得损失函</strong>$L(y,f</em>{t−1}(x)+h_t(x))$ <strong>达到最小</strong>。<strong>因此问题的关键就在于对损失函数的度量，这也正是难点所在。当损失函数是平方损失和指数损失时，每一步优化是很简单的。但对一般损失函数而言，往往每一步优化没那么容易，如绝对值损失函数和Huber损失函数</strong>。常见的损失函数及其梯度如下表所示：</p>
<p><img src="/2018/08/04/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（六）：集成学习/05.png" alt></p>
<p>那我们怎么样才能找到一种通用的拟合方法呢？针对这一问题，Freidman提出了梯度提升算法：利用最速下降的近似方法，<strong>即利用损失函数的负梯度在当前模型的值</strong>，进而拟合一个CART回归树。其中第t轮的第i个样本的损失函数的扶梯度表示为，右下角的等式是求偏导后带入计算的</p>
<script type="math/tex; mode=display">
r_{ti}=-\left[\frac{\partial L\left(y,f\left(x_i\right)\right)}{\partial f\left(x_i\right)}\right]_{f\left(x\right)=f_{t-1}\;\,\left(x\right)}</script><p><strong>负梯度作为回归问题中提升树算法的残差的近似值</strong>（与其说负梯度作为残差的近似值，不如说残差是负梯度的一种特例，拟合一个回归树），这就是梯度提升决策树。假设样本数据为m，最大的迭代次数为T。其算法过程如下：</p>
<p><img src="/2018/08/04/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（六）：集成学习/06.png" alt></p>
<ul>
<li>step1. 初始化弱分类器，计算出使损失函数极小化的一个常数值c，此时树仅有一个根结点。c的均值可取样本y的均值。这个初始化得到的c将用于第一次计算负梯度$f(x<em>i)=f(t-1)=f(0)$的代入计算得到残差近似值$r</em>{ti}$。(第t代第i个样本)</li>
<li>step2(a) .计算每个样本的$r_{ti}$</li>
<li>step2(b). 利用$(x<em>i,r</em>{ti})i=1,2,3,…,m$，我们可以拟合一颗CART回归树，得到第t棵回归树（注意回归树节点内的均值求法不再是我们想要的了），其对应的叶节点区域为$R_{tj},j=1,2,3,…,J$，其中J为叶子节点的个数。</li>
<li>step2(c). 接下来，针对每一个叶子节点中的样本，要拟合叶子结点最好的输出值$c<em>{tj}$(不再是简单的求节点均值)，使得求出的损失函数最小。回顾之前写的新一轮迭代的目的，这时候的输出值$c</em>{tj}$组成就是我们想要的第t棵弱学习器$h_t(x)$。其实就是在上一棵强学习器树稍加改变决策树中叶节点值，希望拟合的误差越来越小。</li>
</ul>
<script type="math/tex; mode=display">
c_{tj}=\underset{c}{\underbrace{\arg\min}} \sum_{x_i \in R_{tj}}L(y_i,f_{t-1}(x_i)+c)</script><p>这样我们便得到本轮的弱学习器决策树拟合函数</p>
<script type="math/tex; mode=display">
h_t(x)=\sum _{j=1} ^{J} c_{tj},I(x \in R_{tj})</script><ul>
<li>step2(d). 更新强学习器，上一个强学习器+弱学习器</li>
</ul>
<script type="math/tex; mode=display">
f_t(x)=f_{t-1}(x)+\sum_{j=1}^{J}c_{tj},I(x\in R_{tj})</script><ul>
<li>step3. 得到输出的最后一轮的最终强学习器模型（最大迭代T轮）</li>
</ul>
<script type="math/tex; mode=display">
f(x)=f_T(x)=f_0(x)+\sum_{t=1}^{T}\sum_{j=1}^{J}c_{tj},I(x\in R_{tj})</script><h4 id="GBDT分类算法"><a href="#GBDT分类算法" class="headerlink" title="GBDT分类算法"></a>GBDT分类算法</h4><p>GBDT分类算法在思想上和回归算法没有区别，但是由于样本输出不是连续的值，而是离散的类别，导致我们无法直接从输出类别去拟合类别输出的误差。为解决此问题，我们尝试用类似于逻辑回归的对数似然损失函数的方法,也就是说我们用的是类别的预测概率值和真实概率值来拟合损失函数。对于对数似然损失函数，我们有二元分类和多元分类的区别。</p>
<h5 id="二元GBDT分类算法"><a href="#二元GBDT分类算法" class="headerlink" title="二元GBDT分类算法"></a>二元GBDT分类算法</h5><p>对于二元GBDT，如果用类似于逻辑回归的对数似然损失函数，则损失函数表示为</p>
<script type="math/tex; mode=display">
L(y,f(x))=log(1+exp(-yf(x)))</script><p>其中y∈{−1,1}。则此时的负梯度误差为</p>
<script type="math/tex; mode=display">
r_{ti}=-\left[\frac{\partial L(y_i,f(x_i))}{\partial f(x_i)} \right]_{f(x)=f_{t-1}(x)}=\frac{y_i}{1+exp(y_if(x_i))}</script><p>对于生成的决策树，我们各个叶子节点的最佳残差拟合值为</p>
<script type="math/tex; mode=display">
c_{tj}=\underset{c}{\underbrace{\arg\min}} \sum _{x_i\in R_{tj}}log(1+exp(-y_i(f_{t-1}(x_i)+c)))</script><p>由于上式比较难优化，我们一般使用近似值代替</p>
<script type="math/tex; mode=display">
c_{tj}=\frac{\sum _{x_i\in R_{tj}}r_{ti}}{\sum _{x_i \in R_{tj}}|r_{ti}|(1-|r_{ti}|)}</script><p>除了负梯度计算和叶子节点的最佳残差拟合的线性搜索外，二元GBDT分类和GBDT回归算法过程相同。</p>
<h5 id="多元GBDT分类算法"><a href="#多元GBDT分类算法" class="headerlink" title="多元GBDT分类算法"></a>多元GBDT分类算法</h5><p>多元GBDT要比二元GBDT复杂一些，对应的是多元逻辑回归和二元逻辑回归的复杂度差别。假如类别数为K，则我们的对数似然函数为</p>
<script type="math/tex; mode=display">
L(y,f(x))=-\sum_{k=1}^{K}y_k log(p_k(x))</script><p>其中如果样本输出类别为k，则$y_k=1$。第k类的概率$p_k(x)$的表达式为</p>
<script type="math/tex; mode=display">
p_k(x)=\frac {exp(f_k(x))}{\sum _{l=1}^{K}exp(f_l(x))}</script><p>集合上两式，我们可以计算出第t轮的第i个样本对应类别l的负梯度误差为</p>
<script type="math/tex; mode=display">
r_{til}=-\left[\frac{\partial L(y_i,f(x_i))}{\partial f(x_i)} \right]_{f_k(x)=f_{t-1,l}(x)}=y_{il}-p_{t-1,l}(x_i)</script><p>其实这里的误差就是样本i对应类别l的真实概率和t-1轮预测概率的差值。对于生成的决策树，我们各个叶子节点的最佳残差拟合值为</p>
<script type="math/tex; mode=display">
c_{tjl}=\underset{cjl}{\underbrace{\arg\min}} \sum_{i=1}^{m} \sum_{k=1}^{K}L(y_k,f_{t-1,l}(x))+\sum _{j=1}^{J}c_{jl},I(x_i\in R_{tj})</script><p>由于上式比较难优化，我们用近似值代替</p>
<script type="math/tex; mode=display">
c_{tjl}=\frac{K-1}{K}=\frac{\sum_{x_i\in R_{tjl}}r_{til}}{\sum _{x_i\in R_{til}}|r_{til}|(1-|r_{til}|)}</script><p>除了负梯度计算和叶子节点的最佳残差拟合的线性搜索，多元GBDT分类和二元GBDT分类以及GBDT回归算法过程相同。</p>
<h2 id="XGBoost"><a href="#XGBoost" class="headerlink" title="XGBoost"></a>XGBoost</h2><p>数据建模中，经常采用Boosting方法通过将成百上千个分类准确率较低的树模型组合起来，成为一个准确率很高的预测模型。这个模型会不断地迭代，每次迭代就生成一颗新的树。但在数据集较复杂的时候，可能需要几千次迭代运算，这将造成巨大的计算瓶颈。</p>
<p>针对这个问题。华盛顿大学的陈天奇博士开发的XGBoost（eXtreme Gradient Boosting）基于C++通过多线程实现了回归树的并行构建，并在原有Gradient Boosting算法基础上加以改进，从而极大地提升了模型训练速度和预测精度.</p>
<h3 id="梯度下降与牛顿法"><a href="#梯度下降与牛顿法" class="headerlink" title="梯度下降与牛顿法"></a>梯度下降与牛顿法</h3><p>在机器学习任务中，需要最小化损失函数L(θ)，其中θ是要求解的模型参数。梯度下降法常用来求解这种无约束最优化问题，它是一种迭代方法：选取初值$θ^0$ ,不断迭代，更新θ的值，进行损失函数的极小化。</p>
<ul>
<li>迭代公式：$θ^t = θ_{t-1}+△θ$ </li>
</ul>
<p><strong>梯度下降</strong>：将$L(θ^t)$ 在$θ^{t-1}$ 处进行一阶泰勒展开:</p>
<script type="math/tex; mode=display">L(θ^t)=L(θ^{t-1}+△θ)\approx L(θ^{t-1})+L'(θ^{t-1})△θ</script><p>要使得$L(θ^t)&lt;L(θ^{t-1})$ ,可取$△θ=-\alpha L’(θ^{t-1})$ ，则$θ^t = θ^{t-1}-\alpha L’(θ^{t-1})$<br>这里$\alpha$ 是步长，可通过line search确定，但一般直接赋一个小的数</p>
<p><strong>牛顿法</strong>：将$L(θ^t)$ 在$θ^{t-1}$ 处进行二阶泰勒展开:</p>
<script type="math/tex; mode=display">L(θ^t)\approx L(θ^{t-1})+L'(θ^{t-1})△θ+L''(θ^{t-1})\frac{(△θ)^2}{2}</script><p>可将一阶和二阶导数分别记为g 和 h,则:</p>
<script type="math/tex; mode=display">L(θ^t)\approx L(θ^{t-1})+g△θ+h\frac{(△θ)^2}{2}</script><p>要使得$L(θ^t)$极小，即让$g△θ+h\frac{(△θ)^2}{2}$ 极小，可令其对△θ求偏导值为0，求得$△θ=-\frac{g}{h}$ ,故$θ^t = θ^{t-1}+△θ=θ^{t-1}-\frac{g}{h}$ ,将其推广到向量形式，有$θ^t = θ^{t-1}-H^{-1}g$ </p>
<p>GBDT 在函数空间中利用梯度下降法进行优化<br>XGBoost 在函数空间中用牛顿法进行优化</p>
<h3 id="XGBoost的推导过程"><a href="#XGBoost的推导过程" class="headerlink" title="XGBoost的推导过程"></a>XGBoost的推导过程</h3><h4 id="定义目标函数"><a href="#定义目标函数" class="headerlink" title="定义目标函数"></a>定义目标函数</h4><p><strong>相比原始的GBDT，XGBoost的目标函数多了正则项，使得学习出来的模型更加不容易过拟</strong>合。有哪些指标可以衡量树的复杂度？树的深度，内部节点个数，<strong>叶子节点个数(T)，叶节点分数(w)</strong>…<br>XGBoost采用的是：T代表叶子数量，w代表叶子预测权值</p>
<p><img src="/2018/08/04/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（六）：集成学习/07.png" alt></p>
<p><strong>而XGBoost第t次迭代后，模型的预测等于前t-1次的模型预测加上第t棵树的预测</strong></p>
<p><img src="/2018/08/04/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（六）：集成学习/08.png" alt></p>
<p>即每次迭代生成一棵新的回归树，从而使预测值不断逼近真实值（即进一步最小化目标函数）。每一次保留原来的模型不变，加入一个新的函数f到模型里面。其中$\hat{y}_i\left(t-1\right)$就是t-1轮的模型预测，$f_t{(x_i)}$为新t轮加入的预测函数。选取的$f_t{(x_i)}$必须使我们的目标函数尽量最大地降低（这里应用到了Boosting的基本思想，即当前的基学习器重点关注以前所有学习器犯错误的那些数据样本，以此来达到提升的效果）</p>
<p>此时目标损失函数可写作：</p>
<p><img src="/2018/08/04/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（六）：集成学习/09.png" alt></p>
<p>如果我们考虑平方误差作为损失函数，公式可改写为：</p>
<p><img src="/2018/08/04/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（六）：集成学习/10.png" alt></p>
<blockquote>
<p>这里的化简没有看懂，感觉少了一项残差的平方。不过原等式$+f_t{(x_i)}$看做泰勒展开的$+\bigtriangleup x$ .</p>
</blockquote>
<p>公式中$y_i,\widehat y_i$ 都是已知的，<strong>模型要学习的只有第t棵树</strong>$f_t$ .另外对于损失函数不是平方误差的情况，我们可以采用如下的泰勒展开近似来定义一个近似的目标函数，方便我们进行下一步的计算。其中$g_i$和$h_i$为损失函数对$\widehat y_i^{t-1}$的一阶和二阶倒数。</p>
<p><img src="/2018/08/04/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（六）：集成学习/11.png" alt></p>
<p>这时候，所有东西都准备好了，<strong>最后我们怎么定义</strong>$f_t$呢？<strong>它可以代表一颗具有预测结果的树</strong>，即叶子节点有预测权重。我们定义w为树叶的权重序列，q为树的结构，那么q(x)代表样本x落在树叶的位置。</p>
<p><img src="/2018/08/04/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（六）：集成学习/12.png" alt></p>
<h4 id="目标函数的最小化"><a href="#目标函数的最小化" class="headerlink" title="目标函数的最小化"></a>目标函数的最小化</h4><p>得到了目标函数，接下来是最关键的一步，在这种新的定义下，我们可以把目标函数进行如下改写，其中$I$被定义为每个叶子上面样本集合$I_j={i| q(x_i)=j}$ 。$L(y_i,\widehat y_i^{t-1})$为真实值与前一个函数计算所得残差是已知的(我们都是在已知前一个树的情况下计算下一颗树的)，同时，在同一个叶子节点上的数的函数值是相同的，可以做合并，于是：</p>
<p><img src="/2018/08/04/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（六）：集成学习/13.jpg" alt></p>
<p>对上诉目标函数求导等于0，可以得到最后的结果：</p>
<p><img src="/2018/08/04/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（六）：集成学习/14.png" alt></p>
<p>得到这个目标函数，乍一看目标函数的计算与回归树的结构q函数没有什么关系，但是如果我们仔细回看目标函数的构成，就会发现<strong>其中$G_j$和$H_j$的取值是由第j个树叶上数据样本所决定的</strong>。而第jj个树上所具有的数据样本则是由树结构q函数决定的。也<strong>就是说，一旦回归树的结构q确定，那么相应的目标函数就能够根据上式计算出来。那么回归树的生成问题也就转换为找到一个最优的树结构q，使得它具有最小的目标函数。</strong></p>
<p><strong>计算求得的Obj目标函数代表了当指定一个树的结构的时候，目标函数上面最多减少多少</strong>。我们可以把它叫做<strong>结构分数</strong>（structure score）。可以把它认为是类似于基尼系数一样更加一般的对于树结构进行打分的函数。</p>
<p><strong>当回归树的结构确定时，我们前面已经推导出其最优的叶节点分数以及对应的最小损失值，问题是怎么确定树的结构？才能让得到的结构分数最好，目标函数损失降低最大</strong> 。主要有以下两种方法</p>
<ul>
<li>暴力枚举所有可能的树结构，选择损失值最小的 - NP难问题（树的结构有无穷种）</li>
<li>贪心法，每次尝试分裂一个叶节点，计算分裂前后的增益，选择增益最大的（主要）</li>
</ul>
<h4 id="确定树的结构（贪心法）"><a href="#确定树的结构（贪心法）" class="headerlink" title="确定树的结构（贪心法）"></a>确定树的结构（贪心法）</h4><p>分裂前后的增益怎么计算？</p>
<ul>
<li>ID3算法采用信息增益</li>
<li>C4.5算法采用信息增益比</li>
<li>CART采用Gini系数</li>
<li>XGBoost采用上诉优化函数的打分</li>
</ul>
<p>即每一次尝试区队已有的叶子加入一个分割。对于一个剧透的分割方案，我们可以获得的增益可以由如下公式计算得到：</p>
<p><img src="/2018/08/04/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（六）：集成学习/15.png" alt></p>
<p>这个公式形式上跟ID3算法（采用信息熵计算增益）或者CART算法（采用基尼指数计算增益） 是一致的，都是用分裂后的某种值减去分裂前的某种值，从而得到增益。<strong>为了限制树的生长</strong>，我们可以加入阈值，当增益大于阈值时才让节点分裂，上式中的$\gamma$即阈值，它是正则项里叶子节点数T的系数，<strong>所以xgboost在优化目标函数的同时相当于做了预剪枝</strong>。另外，<strong>上式中还有一个系数$\lambda$，是正则项里leaf score的L2模平方的系数，对leaf score做了平滑，也起到了防止过拟合的作用</strong>，这个是传统GBDT里不具备的特性。</p>
<blockquote>
<p> 但需要注意是：引入的分割不一定会使得情况变好，因为在引入分割的同时也引入新叶子的惩罚项。所以通常需要设定一个阈值，如果引入的分割带来的增益小于一个阀值的时候，我们可以剪掉这个分割。此外在XGBoost的具体实践中，通常会设置树的深度来控制树的复杂度，避免单个树过于复杂带来的过拟合问题。</p>
</blockquote>
<h4 id="如何使用及参数"><a href="#如何使用及参数" class="headerlink" title="如何使用及参数"></a>如何使用及参数</h4><p><img src="/2018/08/04/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（六）：集成学习/16.png" alt></p>
<p><img src="/2018/08/04/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（六）：集成学习/17.png" alt></p>
<h4 id="一些常见的问题"><a href="#一些常见的问题" class="headerlink" title="一些常见的问题"></a>一些常见的问题</h4><p>1、机器学习算法中GBDT和XGBOOST的区别有哪些？</p>
<p>2、为什么在实际的 kaggle 比赛中 gbdt 和 random forest 效果非常好？</p>
<p>3、 为什么xgboost/gbdt在调参时为什么树的深度很少就能达到很高的精度？</p>
<blockquote>
<p>这里就不花时间写了，可以参考知乎和一些博客文章。</p>
</blockquote>
<h1 id="Bagging和随机森林"><a href="#Bagging和随机森林" class="headerlink" title="Bagging和随机森林"></a>Bagging和随机森林</h1><p>如果采样出的每个子集都完全不同，则每个基学习器只用到一小部分训练数据，甚至不足以进行有效学习，这显然无法确保产生出比较好的基学习器。为了解决这个问题，我们可考虑使用相互有交叠的采样子集。</p>
<h2 id="Bagging"><a href="#Bagging" class="headerlink" title="Bagging"></a>Bagging</h2><p>随机取出一个样本放入采样集中，再把该样本放回初始数据集。这样的自助采样过程还给 Bagging带来了另一个优点：由于每个基学习器只使用了初始训练集中约 63.2%的样本，剩下约 36.8%的样本可用作验证集来对泛化性能进行包外估计(out-of-bag estimate)。Bagging通常对分类任务使用简单的投票法，对回归任务使用简单平均法。<br>Bagging的算法描述如下所诉($D_{bs}$是自助采样产生的样本分布,输出采用投票法)：</p>
<p><img src="/2018/08/04/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（六）：集成学习/18.png" alt></p>
<h2 id="随机森林"><a href="#随机森林" class="headerlink" title="随机森林"></a>随机森林</h2><p>随机森林(Random Forest)是Bagging的一个扩展变体。随机森林在以决策树为基学习器构建 Bagging集成的基础上，进一步在决策树的训练过程中引入了随机属性选择。具体来说，传统决策树在选择划分属性时是在当前结点的属性集合（假定有d个属性）中选择一个最优属性；而在随机森林中，对基决策树的每个结点，先从该结点的属性集合中随机选择一个包含k个属性的子集，然后再从这个子集中选择一个最优属性用于划分。这里的参数k控制了随机性的引入程度：若令 k=d，则基决策树的构建与传统决策树相同；若令k=1,则是随机选择一个属性用于划分；一般情况下，推荐值 k=log2d.随机森林简单、容易实现、计算开销小.</p>
<p>随机森林的训练效率常优于 Bagging，因为在个体决策树的构建过程中，Bagging使用的是“确定型”决策树，在选择划分属性时要对结点的所有属性进行考察，而随机森林使用的“随机型”决策树则只需考察一个属性子集。</p>
<p>由于这些树是随机生成的，大部分的树对解决分类或回归问题是没有意义的，那么生成上万的树有什么好处呢？好处便是生成的决策树中有少数非常好的决策树。当你要做预测的时候，新的观察值随着决策树自上而下的预测并被赋予一个预测值或标签。一旦森林中的每棵树都有了预测值或标签，所有的预测结果将被归总到一起，所有树的投票做为最终的预测结果。简单来说，会像大数原理一样，抛硬币的次数接近无穷，其正反概率会越接近真实概率1/2。大部分的树会相互抵消，最后得到一个泛化较好的结果，从而得到一个好的预测结果。</p>
<h1 id="学习器结合策略"><a href="#学习器结合策略" class="headerlink" title="学习器结合策略"></a>学习器结合策略</h1><p>假定集成包含 T 个基学习器h1,h2,…ht,其中hi在示例x上的输出为hi(x)下面介绍几种对hi进行结合的常见策略。</p>
<ul>
<li>投票法 1）硬投票  2）相对多数投票 3）加权投票</li>
<li>平均法 1）简单平均法 2）加权平均法（较好）</li>
<li>学习法 1）Stacking</li>
</ul>
<p><strong>Stacking</strong><br>当训练数据很多时，一种更为强大的结合策略是使用“学习法”，即通过另一个学习器来进行结合。Stacking是学习法的典型代表。这里我们把个体学习器称为初级学习器，用于结合的学习器称为次级学习器或元学习(metalearner)。</p>
<p><strong>Stacking先从初始数据集训练出初级学习器，然后“生成”一个新数据集用于训练次级学习器。在这个新数据集中，初级学习器的输出被当做样例输入特征，而初始样本的标记仍被当作样例标记</strong>。Stacking的算法描述如下，这里假定初级学习器使用不同的学习算法产生，即初级集成是异质的（初级学习器也可是同质的）。</p>
<p><img src="/2018/08/04/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（六）：集成学习/19.png" alt></p>
<p>train数据是初级训练器5折交叉得到的输出，test是初级训练器预测test后的均值</p>
<p><img src="/2018/08/04/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（六）：集成学习/27.jpg" alt></p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="投票分类"><a href="#投票分类" class="headerlink" title="投票分类"></a>投票分类</h2><p>像我们之前讨论的一样，我们会在一个项目快结束的时候使用集成算法，一旦你建立了一些好的分类器，就把他们合并为一个更好的分类器。事实上，在机器学习竞赛中获得胜利的算法经常会包含一些集成方法。</p>
<p>接下来的代码创建和训练了在 sklearn 中的投票分类器。这个分类器由三个不同的分类器组成（训练集是第五章中的 moons 数据集）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> VotingClassifier </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>log_clf = LogisticRegression() </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rnd_clf = RandomForestClassifier() </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>svm_clf = SVC()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>voting_clf = VotingClassifier(estimators=[(<span class="string">'lr'</span>, log_clf), (<span class="string">'rf'</span>, rnd_clf), &gt;&gt;&gt; (<span class="string">'svc'</span>, svm_clf)],voting=<span class="string">'hard'</span>) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>voting_clf.fit(X_train, y_train)</span><br></pre></td></tr></table></figure>
<p>让我们看一下在测试集上的准确率：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> clf <span class="keyword">in</span> (log_clf, rnd_clf, svm_clf, voting_clf): </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>    clf.fit(X_train, y_train) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>    y_pred = clf.predict(X_test) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>    print(clf.__class__.__name__, accuracy_score(y_test, y_pred)) </span><br><span class="line">LogisticRegression <span class="number">0.864</span> </span><br><span class="line">RandomForestClassifier <span class="number">0.872</span> </span><br><span class="line">SVC <span class="number">0.888</span> </span><br><span class="line">VotingClassifier <span class="number">0.896</span></span><br></pre></td></tr></table></figure>
<p><strong>你看！投票分类器比其他单独的分类器表现的都要好。</strong></p>
<p>如果所有的分类器都能够预测类别的概率（例如他们有一个predict_proba()方法），那么你就可以让 sklearn 以最高的类概率来预测这个类，平均在所有的分类器上。这种方式叫做<strong>软投票</strong>。<strong>他经常比硬投票表现的更好，因为它给予高自信的投票更大的权重。你可以通过把voting=”hard”设置为voting=”soft”来保证分类器可以预测类别概率。然而这不是 SVC 类的分类器默认的选项，所以你需要把它的probability hyperparameter设置为True</strong>（<strong>这会使 SVC 使用交叉验证去预测类别概率，其降低了训练速度，但会添加predict_proba()方法</strong>）。如果你修改了之前的代码去使用软投票，你会发现投票分类器正确率高达 91%</p>
<h2 id="Bagging-和-Pasting"><a href="#Bagging-和-Pasting" class="headerlink" title="Bagging 和 Pasting"></a>Bagging 和 Pasting</h2><p>就像之前讲到的，可以通过使用不同的训练算法去得到一些不同的分类器。另一种方法就是对每一个分类器都使用相同的训练算法，但是在不同的训练集上去训练它们。<strong>有放回采样被称为装袋（Bagging，是 bootstrap aggregating 的缩写）。无放回采样称为粘贴（pasting）</strong></p>
<p>换句话说，Bagging 和 Pasting 都允许在多个分类器上对训练集进行多次采样，但只有 Bagging 允许对同一种分类器上对训练集进行进行多次采样。</p>
<p><strong>当所有的分类器被训练后，集成可以通过对所有分类器结果的简单聚合来对新的实例进行预测。聚合函数通常对分类是统计模式（例如硬投票分类器）或者对回归是平均</strong>。<strong>每一个单独的分类器在如果在原始训练集上都是高偏差，但是聚合降低了偏差和方差</strong>。通常情况下，集成的结果是有一个相似的偏差，但是对比与在原始训练集上的单一分类器来讲<strong>有更小的方差</strong>。</p>
<h2 id="sklearn-中的-Bagging-和-Pasting"><a href="#sklearn-中的-Bagging-和-Pasting" class="headerlink" title="sklearn 中的 Bagging 和 Pasting"></a>sklearn 中的 Bagging 和 Pasting</h2><p>sklearn 为 Bagging 和 Pasting 提供了一个简单的API：BaggingClassifier类（或者对于回归可以是BaggingRegressor。接下来的代码训练了一个 500 个决策树分类器的集成，每一个都是在数据集上有放回采样 100 个训练实例下进行训练（<strong>这是 Bagging 的例子，如果你想尝试 Pasting，就设置bootstrap=False</strong>）。<strong>n_jobs参数告诉 sklearn 用于训练和预测所需要 CPU 核的数量。（-1 代表着 sklearn 会使用所有空闲核）：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> BaggingClassifier </span><br><span class="line">&gt;&gt;&gt;<span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line">&gt;&gt;&gt;bag_clf = BaggingClassifier(DecisionTreeClassifier(), n_estimators=<span class="number">500</span>, 	max_samples=<span class="number">100</span>, bootstrap=<span class="literal">True</span>, n_jobs=<span class="number">-1</span>) </span><br><span class="line">&gt;&gt;&gt;bag_clf.fit(X_train, y_train) </span><br><span class="line">&gt;&gt;&gt;y_pred = bag_clf.predict(X_test)</span><br></pre></td></tr></table></figure>
<p><strong>如果基分类器可以预测类别概率（例如它拥有predict_proba()方法），那么BaggingClassifier会自动的运行软投票，这是决策树分类器的情况。</strong></p>
<p>下图对比了单一决策树的决策边界和 Bagging 集成 500 个树的决策边界，两者都在 moons 数据集上训练。正如你所看到的，集成的分类比起单一决策树的分类产生情况更好：集成有一个可比较的偏差但是有一个较小的方差（它在训练集上的错误数目大致相同，但决策边界较不规则）。</p>
<p><img src="/2018/08/04/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（六）：集成学习/20.png" alt></p>
<p><strong>Bootstrap 在每个预测器被训练的子集中引入了更多的分集，所以 Bagging 结束时的偏差比 Pasting 更高，但这也意味着预测因子最终变得不相关，从而减少了集合的方差。总体而言，Bagging 通常会导致更好的模型，这就解释了为什么它通常是首选的</strong>。然而，如果你有空闲时间和 CPU 功率，可以使用交叉验证来评估 Bagging 和 Pasting 哪一个更好。</p>
<h2 id="Out-of-Bag-评价"><a href="#Out-of-Bag-评价" class="headerlink" title="Out-of-Bag 评价"></a>Out-of-Bag 评价</h2><p>对于 Bagging 来说，一些实例可能被一些分类器重复采样，但其他的有可能不会被采样。BaggingClassifier默认采样。<strong>BaggingClassifier默认是有放回的采样m个实例 （bootstrap=True），其中m是训练集的大小</strong>，这意味着平均下来只有63%的训练实例被每个分类器采样，<strong>剩下的37%个没有被采样的训练实例就叫做 Out-of-Bag 实例。注意对于每一个的分类器它们的 37% 不是相同的</strong>。</p>
<p><strong>因为在训练中分类器从来没有看到过 oob 实例，所以它可以在这些实例上进行评估，而不需要单独的验证集或交叉验证</strong>。你可以拿出每一个分类器的 oob 来评估集成本身。</p>
<p>在 sklearn 中，你可以在训练后需要创建一个BaggingClassifier来自动评估时设置oob<em>score=True来自动评估。接下来的代码展示了这个操作。评估结果通过变量oob_score</em>来显示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bag_clf = BaggingClassifier(DecisionTreeClassifier(), n_estimators=<span class="number">500</span>,bootstrap=<span class="literal">True</span>, n_jobs=<span class="number">-1</span>, oob_score=<span class="literal">True</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bag_clf.fit(X_train, y_train) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bag_clf.oob_score_ </span><br><span class="line"><span class="number">0.93066666666666664</span></span><br></pre></td></tr></table></figure>
<p>根据这个 obb 评估，BaggingClassifier可以再测试集上达到93.1%的准确率，让我们修改一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y_pred = bag_clf.predict(X_test) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>accuracy_score(y_test, y_pred) </span><br><span class="line"><span class="number">0.93600000000000005</span></span><br></pre></td></tr></table></figure>
<p>我们在测试集上得到了 93.6% 的准确率，足够接近了！</p>
<p><strong>对于每个训练实例 oob 决策函数也可通过oob<em>decision_function</em>变量来展示</strong>。在这种情况下（当基决策器有predict_proba()时）决策函数会对每个训练实例返回类别概率。例如，oob 评估预测第二个训练实例有 60.6% 的概率属于正类（39.4% 属于负类）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bag_clf.oob_decision_function_ </span><br><span class="line">array([[ <span class="number">0.</span>,  <span class="number">1.</span>], [ <span class="number">0.60588235</span>,  <span class="number">0.39411765</span>],[ <span class="number">1.</span>, <span class="number">0.</span> ], </span><br><span class="line"><span class="meta">... </span> [ <span class="number">1.</span> ,  <span class="number">0.</span> ],[ <span class="number">0.</span>,  <span class="number">1.</span>],[ <span class="number">0.48958333</span>,  <span class="number">0.51041667</span>]])</span><br></pre></td></tr></table></figure>
<h2 id="随机森林-1"><a href="#随机森林-1" class="headerlink" title="随机森林"></a>随机森林</h2><p>正如我们所讨论的，随机森林是决策树的一种集成，通常是通过 bagging 方法（有时是 pasting 方法）进行训练，通常用max_samples设置为训练集的大小。与建立一个BaggingClassifier然后把它放入 DecisionTreeClassifier 相反，你可以使用更方便的也是对决策树优化够的RandomForestClassifier（对于回归是RandomForestRegressor）。接下来的代码训练了带有 500 个树（每个被限制为 16 叶子结点）的决策森林，使用所有空闲的 CPU 核：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier</span><br><span class="line">&gt;&gt;&gt;rnd_clf = RandomForestClassifier(n_estimators=<span class="number">500</span>, max_leaf_nodes=<span class="number">16</span>, n_jobs=<span class="number">-1</span>) </span><br><span class="line">&gt;&gt;&gt;rnd_clf.fit(X_train, y_train)</span><br><span class="line">&gt;&gt;&gt;y_pred_rf = rnd_clf.predict(X_test)</span><br></pre></td></tr></table></figure>
<p>除了一些例外，RandomForestClassifier使用DecisionTreeClassifier的所有超参数（决定数怎么生长），把BaggingClassifier的超参数加起来来控制集成本身</p>
<p><strong>随机森林算法在树生长时引入了额外的随机；与在节点分裂时需要找到最好分裂特征相反，它在一个随机的特征集中找最好的特征。它导致了树的差异性，并且再一次用高偏差换低方差，总的来说是一个更好的模型</strong>。以下是BaggingClassifier大致相当于之前的randomforestclassifier：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;bag_clf = BaggingClassifier(DecisionTreeClassifier(splitter=<span class="string">"random"</span>, max_leaf_nodes=<span class="number">16</span>),n_estimators=<span class="number">500</span>, max_samples=<span class="number">1.0</span>, bootstrap=<span class="literal">True</span>, n_jobs=<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>
<h2 id="极端随机树"><a href="#极端随机树" class="headerlink" title="极端随机树"></a>极端随机树</h2><p><strong>当你在随机森林上生长树时，在每个结点分裂时只考虑随机特征集上的特征（正如之前讨论过的一样）。相比于找到更好的特征我们可以通过使用对特征使用随机阈值使树更加随机（像规则决策树一样）。</strong></p>
<p>这种极端随机的树被简称为 Extremely Randomized Trees（极端随机树），或者更简单的称为 Extra-Tree。再一次用高偏差换低方差。它还使得 Extra-Tree 比规则的随机森林更快地训练，因为在每个节点上找到每个特征的最佳阈值是生长树最耗时的任务之一。</p>
<p>你可以使用 sklearn 的ExtraTreesClassifier来创建一个 Extra-Tree 分类器。他的 API 跟RandomForestClassifier是相同的，相似的， ExtraTreesRegressor 跟RandomForestRegressor也是相同的 API。</p>
<p><strong>我们很难去分辨ExtraTreesClassifier和RandomForestClassifier到底哪个更好。通常情况下是通过交叉验证来比较它们（使用网格搜索调整超参数）</strong></p>
<h2 id="特征重要度"><a href="#特征重要度" class="headerlink" title="特征重要度"></a>特征重要度</h2><p><strong>最后，如果你观察一个单一决策树，重要的特征会出现在更靠近根部的位置，而不重要的特征会经常出现在靠近叶子的位置。因此我们可以通过计算一个特征在森林的全部树中出现的平均深度来预测特征的重要性</strong>。sklearn 在训练后会自动计算每个特征的重要度。你可以通过feature<em>importances</em>变量来查看结果。例如如下代码在 iris 数据集（第四章介绍）上训练了一个RandomForestClassifier模型，然后输出了每个特征的重要性。看来，最重要的特征是花瓣长度（44%）和宽度（42%），而萼片长度和宽度相对比较是不重要的（分别为 11% 和 2%）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>iris = load_iris() </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rnd_clf = RandomForestClassifier(n_estimators=<span class="number">500</span>, n_jobs=<span class="number">-1</span>) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rnd_clf.fit(iris[<span class="string">"data"</span>], iris[<span class="string">"target"</span>]) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> name, score <span class="keyword">in</span> zip(iris[<span class="string">"feature_names"</span>], rnd_clf.feature_importances_): </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>    print(name, score) </span><br><span class="line">sepal length (cm) <span class="number">0.112492250999</span></span><br><span class="line">sepal width (cm) <span class="number">0.0231192882825</span> </span><br><span class="line">petal length (cm) <span class="number">0.441030464364</span> </span><br><span class="line">petal width (cm) <span class="number">0.423357996355</span></span><br></pre></td></tr></table></figure>
<p>相似的，如果你在 MNIST 数据及上训练随机森林分类器（在第三章上介绍），然后画出每个像素的重要性，你可以得到下图</p>
<p><img src="/2018/08/04/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（六）：集成学习/21.png" alt></p>
<p>随机森林可以非常方便快速得了解哪些特征实际上是重要的，特别是你需要进行特征选择的时候</p>
<h2 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h2><p>下图显示连续五次预测的 moons 数据集的决策边界（在本例中，每一个分类器都是高度正则化带有 RBF 核的 SVM）。<strong>第一个分类器误分类了很多实例，所以它们的权重被提升了。第二个分类器因此对这些误分类的实例分类效果更好，以此类推</strong>。右边的图代表了除了学习率减半外（误分类实例权重每次迭代上升一半）相同的预测序列（误分类的样本权重提升速率即学习率）。你可以看出，序列学习技术与梯度下降很相似，除了调整单个预测因子的参数以最小化代价函数之外，AdaBoost 增加了集合的预测器，逐渐使其更好。</p>
<p><img src="/2018/08/04/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（六）：集成学习/22.png" alt></p>
<p><strong>klearn 通常使用 Adaboost 的多分类版本 SAMME（这就代表了 分段加建模使用多类指数损失函数）。如果只有两类别，那么 SAMME 是与 Adaboost 相同的。如果分类器可以预测类别概率（例如如果它们有predict_proba()），如果 sklearn 可以使用 SAMME 叫做SAMME.R的变量（R 代表“REAL”），这种依赖于类别概率的通常比依赖于分类器的更好。</strong></p>
<p>接下来的代码训练了使用 sklearn 的AdaBoostClassifier基于 200 个决策树桩 Adaboost 分类器（正如你说期待的，对于回归也有AdaBoostRegressor）。<strong>一个决策树桩是max_depth=1的决策树-换句话说，是一个单一的决策节点加上两个叶子结点。这就是AdaBoostClassifier的默认基分类器</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> AdaBoostClassifier</span><br><span class="line">&gt;&gt;&gt;ada_clf = AdaBoostClassifier(DecisionTreeClassifier(max_depth=<span class="number">1</span>), n_estimators=<span class="number">200</span>,algorithm=<span class="string">"SAMME.R"</span>, learning_rate=<span class="number">0.5</span>) </span><br><span class="line">&gt;&gt;&gt;ada_clf.fit(X_train, y_train)</span><br></pre></td></tr></table></figure>
<p><strong>如果你的 Adaboost 集成过拟合了训练集，你可以尝试减少基分类器的数量或者对基分类器使用更强的正则化。</strong></p>
<h2 id="梯度提升"><a href="#梯度提升" class="headerlink" title="梯度提升"></a>梯度提升</h2><p>另一个非常著名的提升算法是梯度提升。与 Adaboost 一样，梯度提升也是通过向集成中逐步增加分类器运行的，每一个分类器都修正之前的分类结果。然而，它并不像 Adaboost 那样每一次迭代都更改实例的权重，这个方法<strong>是去使用新的分类器去拟合前面分类器预测的残差 。</strong></p>
<p>让我们通过一个使用决策树当做基分类器的简单的回归例子（回归当然也可以使用梯度提升）。这被叫做梯度提升回归树（GBRT，Gradient Tree Boosting 或者 Gradient Boosted Regression Trees）。首先我们用DecisionTreeRegressor去拟合训练集（例如一个有噪二次训练集）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeRegressor </span><br><span class="line">&gt;&gt;&gt;tree_reg1 = DecisionTreeRegressor(max_depth=<span class="number">2</span>) </span><br><span class="line">&gt;&gt;&gt;tree_reg1.fit(X, y)</span><br></pre></td></tr></table></figure>
<p>现在在第一个分类器的残差上训练第二个分类器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;y2 = y - tree_reg1.predict(X) </span><br><span class="line">&gt;&gt;&gt;tree_reg2 = DecisionTreeRegressor(max_depth=<span class="number">2</span>) </span><br><span class="line">&gt;&gt;&gt;tree_reg2.fit(X, y2)</span><br></pre></td></tr></table></figure>
<p>随后在第二个分类器的残差上训练第三个分类器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;y3 = y2 - tree_reg1.predict(X) </span><br><span class="line">&gt;&gt;&gt;tree_reg3 = DecisionTreeRegressor(max_depth=<span class="number">2</span>) </span><br><span class="line">&gt;&gt;&gt;tree_reg3.fit(X, y3)</span><br></pre></td></tr></table></figure>
<p>现在我们有了一个包含三个回归器的集成。它可以通过集成所有树的预测来在一个新的实例上进行预测。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;y_pred = sum(tree.predict(X_new) <span class="keyword">for</span> tree <span class="keyword">in</span> (tree_reg1, tree_reg2, tree_reg3))</span><br></pre></td></tr></table></figure>
<p><strong>下图左栏展示了这三个树的预测，在右栏展示了集成的预测。在第一行，集成只有一个树，所以它与第一个树的预测相似。在第二行，一个新的树在第一个树的残差上进行训练。在右边栏可以看出集成的预测等于前两个树预测的和</strong>。相同的，在第三行另一个树在第二个数的残差上训练。你可以看到集成的预测会变的更好。</p>
<p><img src="/2018/08/04/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（六）：集成学习/23.png" alt></p>
<p><strong>我们可以使用 sklean 中的GradientBoostingRegressor来训练 GBRT 集成。与RandomForestClassifier相似，它也有超参数去控制决策树的生长（例如max_depth，min_samples_leaf等等），也有超参数去控制集成训练，例如基分类器的数量（n_estimators）</strong>。接下来的代码创建了与之前相同的集成：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> GradientBoostingRegressor</span><br><span class="line">&gt;&gt;&gt;gbrt = GradientBoostingRegressor(max_depth=<span class="number">2</span>, n_estimators=<span class="number">3</span>, learning_rate=<span class="number">1.0</span>) </span><br><span class="line">&gt;&gt;&gt;gbrt.fit(X, y)</span><br></pre></td></tr></table></figure>
<p><strong>超参数learning_rate 确立了每个树的贡献。如果你把它设置为一个很小的树，例如 0.1，在集成中就需要更多的树去拟合训练集，但预测通常会更好。这个正则化技术叫做 shrinkage。</strong>下图 展示了两个在低学习率上训练的 GBRT 集成：其中左面是一个没有足够树去拟合训练集的树，右面是有过多的树过拟合训练集的树。</p>
<p><img src="/2018/08/04/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（六）：集成学习/24.png" alt></p>
<p><strong>为了找到树的最优数量，你可以使用早停技术。最简单使用这个技术的方法就是使用staged_predict()：它在训练的每个阶段（用一棵树，两棵树等）返回一个迭代器。加下来的代码用 120 个树训练了一个 GBRT 集成，然后在训练的每个阶段验证错误以找到树的最佳数量，最后使用 GBRT 树的最优数量训练另一个集成</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line">&gt;&gt;&gt;<span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line">&gt;&gt;&gt;<span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> mean_squared_error</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;X_train, X_val, y_train, y_val = train_test_split(X, y)</span><br><span class="line">&gt;&gt;&gt;gbrt = GradientBoostingRegressor(max_depth=<span class="number">2</span>, n_estimators=<span class="number">120</span>) </span><br><span class="line">&gt;&gt;&gt;gbrt.fit(X_train, y_train)</span><br><span class="line">&gt;&gt;&gt;errors = [mean_squared_error(y_val, y_pred)         </span><br><span class="line">     <span class="keyword">for</span> y_pred <span class="keyword">in</span> gbrt.staged_predict(X_val)] </span><br><span class="line">&gt;&gt;&gt;bst_n_estimators = np.argmin(errors)</span><br><span class="line">&gt;&gt;&gt;gbrt_best = GradientBoostingRegressor(max_depth=<span class="number">2</span>,n_estimators=bst_n_estimators) </span><br><span class="line">&gt;&gt;&gt;gbrt_best.fit(X_train, y_train)</span><br></pre></td></tr></table></figure>
<p>验证错误在图的左面展示，最优模型预测被展示在右面</p>
<p><img src="/2018/08/04/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（六）：集成学习/25.png" alt></p>
<p><strong>你也可以早早的停止训练来实现早停（与先在一大堆树中训练，然后再回头去找最优数目相反）</strong>。你可以通过设置warm_start=True来实现 ，这使得当fit()方法被调用时 sklearn 保留现有树，并允许增量训练。接下来的代码在当一行中的五次迭代验证错误没有改善时会停止训练：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;gbrt = GradientBoostingRegressor(max_depth=<span class="number">2</span>, warm_start=<span class="literal">True</span>)</span><br><span class="line">min_val_error = float(<span class="string">"inf"</span>) </span><br><span class="line">error_going_up = <span class="number">0</span> </span><br><span class="line"><span class="keyword">for</span> n_estimators <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">120</span>):    </span><br><span class="line">    gbrt.n_estimators = n_estimators    </span><br><span class="line">    gbrt.fit(X_train, y_train)    </span><br><span class="line">    y_pred = gbrt.predict(X_val)    </span><br><span class="line">    val_error = mean_squared_error(y_val, y_pred)    </span><br><span class="line">    <span class="keyword">if</span> val_error &lt; min_val_error:        </span><br><span class="line">        min_val_error = val_error        </span><br><span class="line">        error_going_up = <span class="number">0</span>    </span><br><span class="line">    <span class="keyword">else</span>:        </span><br><span class="line">        error_going_up += <span class="number">1</span>        </span><br><span class="line">        <span class="keyword">if</span> error_going_up == <span class="number">5</span>:            </span><br><span class="line">            <span class="keyword">break</span>  <span class="comment"># early stopping</span></span><br></pre></td></tr></table></figure>
<p><strong>GradientBoostingRegressor也支持指定用于训练每棵树的训练实例比例的超参数subsample。例如如果subsample=0.25，那么每个树都会在 25% 随机选择的训练实例上训练。你现在也能猜出来，这也是个高偏差换低方差的作用。它同样也加速了训练。这个技术叫做随机梯度提升。</strong></p>
<p>也可能对其他损失函数使用梯度提升。这是由损失超参数控制（见 sklearn 文档）。</p>
<h2 id="Stacking"><a href="#Stacking" class="headerlink" title="Stacking"></a>Stacking</h2><p>本章讨论的最后一个集成方法叫做 Stacking（stacked generalization 的缩写）。这个算法基于一个简单的想法：不使用琐碎的函数（如硬投票）来聚合集合中所有分类器的预测，我们为什么不训练一个模型来执行这个聚合？图 展示了这样一个在新的回归实例上预测的集成。底部三个分类器每一个都有不同的值（3.1，2.7 和 2.9），然后最后一个分类器（叫做 blender 或者 meta learner ）把这三个分类器的结果当做输入然后做出最终决策（3.0）</p>
<p><img src="/2018/08/04/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（六）：集成学习/26.png" alt></p>
<h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><ol>
<li>如果你在相同训练集上训练 5 个不同的模型，它们都有 95% 的准确率，那么你是否可以通过组合这个模型来得到更好的结果？如果可以那怎么做呢？如果不可以请给出理由。</li>
<li>软投票和硬投票分类器之间有什么区别？</li>
<li>是否有可能通过分配多个服务器来加速 bagging 集成系统的训练？pasting 集成，boosting 集成，随机森林，或 stacking 集成怎么样？</li>
<li>out-of-bag 评价的好处是什么？</li>
<li>是什么使 极端随机树Extra-Tree 比规则随机森林更随机呢？这个额外的随机有什么帮助呢？那这个 Extra-Tree 比规则随机森林谁更快呢？</li>
<li>如果你的 Adaboost 模型欠拟合，那么你需要怎么调整超参数？</li>
<li>如果你的梯度提升过拟合，那么你应该调高还是调低学习率呢？</li>
</ol>
<hr>
<p>1、只要模型间多样性较大，组合成一个集合模型，会起到一定的效果。</p>
<p>2、硬投票分类器只计算集成中每个分类器的投票数，并选择得票最多的类。 软投票分类器计算每个类的平均估计概率，并选择具有最高概率的类。 软投票使概率大的类别权重更高，通常表现更好，但只有在可以估计类概率的分类器时才有效（例如，对于Scikit-Learn中的SVM分类器，您必须设置probability = True）。</p>
<p>3、 bagging，pasting，随机森林是可以的。boosting 集成因为学习器需要基于先前的学习器构建，因此训练是连续的，故不适合。至于stacking 集成，给定层中的所有预测变量彼此独立，因此可以在多个服务器上并行训练它们。 但是，一层中的预测变量只能在前一层中的预测变量都经过训练后才能进行训练。</p>
<p>4、未被训练过得实例可以当做验证集</p>
<p>5、在随机森林中，只考虑特征的随机子集并在每个节点处进行分割。 对于Extra-Trees也是如此，但它们更进一步：不是像常规决策树一样搜索最佳阈值，而是为每个特征使用随机阈值。 这种额外的随机性就像一种正则化的形式：如果随机森林过度拟合训练数据，极端随机树可能表现更好。 此外，由于Extra-Trees不会搜索最佳阈值，因此它们比随机森林训练要快得多。 然而，在做出预测时，它们既不比随机森林更快也不慢。</p>
<p>6、如果您的AdaBoost集合欠拟合，可以尝试增加学习器的数量或减少基本学习器的正则化超参数。 也可以尝试稍微提高学习率。</p>
<p>7、如果您的Gradient Boosting过拟合，应该尝试降低学习率。 你也可以使用早期停止法。</p>
]]></content>
      <categories>
        <category>Sklearn 与 TensorFlow 机器学习实用指南</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>CART</tag>
        <tag>Adaboost</tag>
        <tag>GBDT</tag>
        <tag>XGBoost</tag>
        <tag>Bagging</tag>
        <tag>随机森林</tag>
        <tag>Stacking</tag>
      </tags>
  </entry>
  <entry>
    <title>Sklearn 与 TensorFlow 机器学习实用指南（五）：决策树</title>
    <url>/2018/07/23/Sklearn%20%E4%B8%8E%20TensorFlow%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E7%94%A8%E6%8C%87%E5%8D%97/Sklearn-%E4%B8%8E-TensorFlow-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E7%94%A8%E6%8C%87%E5%8D%97%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E5%86%B3%E7%AD%96%E6%A0%91/</url>
    <content><![CDATA[<h1 id="一些基本概念"><a href="#一些基本概念" class="headerlink" title="一些基本概念"></a>一些基本概念</h1><h2 id="决策树简述"><a href="#决策树简述" class="headerlink" title="决策树简述"></a>决策树简述</h2><p>决策树（Decision Tree）是数据挖掘中一种基本的分类和回归方法，它呈树形结构，在分类问题中，表示基于特征对实例进行分类的过程，可以认为是if−thenif−then规则的集合。决策树模型的主要优点是模型具有可读性，分类速度快。在学习时，利用训练数据，根据损失函数最小化原则建立决策树模型；而在预测时，对新的数据，利用决策树模型进行分类。主要的决策树算法有ID3算法、C4.5算法和CART算法。一个决策树的学习过程包括三个步骤：特征选择、决策树的生成以及决策树的修剪。</p>
<h2 id="信息熵"><a href="#信息熵" class="headerlink" title="信息熵"></a>信息熵</h2><p>信息熵是衡量样本纯度的一种指标，嘉定当前样本集合D中第k类样本所占的比例为$p_k(k=1,2,…,|y|)$,则D的信息熵定义为</p>
<script type="math/tex; mode=display">
Ent(D)=-\sum_{k=1}^{\vert y\vert}p_klog_2{p_k}</script><p>Ent(D)的值越小，则D的纯度越高。</p>
<p>以周志华西瓜书P76的西瓜数据集中的17个样本数据为例子。</p>
<p><img src="/2018/07/23/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（五）：决策树/01.jpg" alt></p>
<p>显然，标签类别|y|=2.其中正例占$p_1$=8/17，反例占$p_2$=9/17。于是根节点的信息熵为</p>
<script type="math/tex; mode=display">
Ent(D)=-\sum_{k=1}^2p_klog_2^{p_k}=-(\frac{8}{17}log_2\frac{8}{17}+\frac{9}{17}log_2\frac{9}{17})=0.998</script><h2 id="条件熵"><a href="#条件熵" class="headerlink" title="条件熵"></a>条件熵</h2><p>$Ent(Y|X)$表示在已知随机变量X的条件下随机变量Y的不确定性，定义为X给定条件下Y的条件概率分布的熵对X的数学期望</p>
<script type="math/tex; mode=display">
Ent\left( Y|X \right) =\sum_{i=1}^n{p_iEnt\left( Y|X=x_i \right)}</script><h1 id="特征选择"><a href="#特征选择" class="headerlink" title="特征选择"></a>特征选择</h1><h2 id="信息增益"><a href="#信息增益" class="headerlink" title="信息增益"></a>信息增益</h2><p><strong>信息增益表示得知特征X的信息而使得类Y的信息的不确定性减少的程度</strong>。特征A对训练数据集D的信息增益Gain(D,a)定义为集合D的经验熵$Ent(D)$与特征A给定条件下D的经验条件熵$Ent(Y | X)$之差，即假定离散属性a有n个可能的取值${a^1,a^2,…a^n}$，若使用属性a的取值来对样本集合划分，则会产生n个分支节点子集$D_1,D_2,..,Dn$，$|D_i|$ 为$D_i$的样本个数。(考虑不同的分支节点所包含的样本数不同，用$\frac{|D^i|}{|D|}$代替期望概率$p_i$，即样本越多的分支节点的影响越大)</p>
<script type="math/tex; mode=display">
Gain(D,a)=Ent(D)-\sum_{i=1}^n\frac{|D^i|}{|D|}End(D^i)</script><p>以西瓜数据集的“色泽”属性为例，它有3个可能的取值{青绿，乌黑，浅白}。若使用该属性对D角线划分，则可以得到三个子集，分布记为$D^1$(色泽=青绿)={1,4,6,10,13,17}，正反例率分别为$p_1=\frac{3}{6}$，$p_2=\frac{3}{6}$；$D^2$(色泽=乌黑)={2,3,7,8,9,15}，正反例率分别为$p_1=\frac{4}{6}$，$p_2=\frac{2}{6}$ ；$D^3$(色泽=乌黑)={5,11,12,14,16}，正反例率分别为$p_1=\frac{1}{5}$，$p_2=\frac{4}{5}$。</p>
<p>首先，根据信息熵公式可计算出“色泽”划分之后所获得的3个分支节点的信息熵为</p>
<script type="math/tex; mode=display">
Ent(D^1)=-(\frac{3}{6}log_2\frac{3}{6}+\frac{3}{6}log_2\frac{3}{6})=1.000 \\ \\ \\ Ent(D^2)=-(\frac{4}{6}log_2\frac{4}{6}+\frac{2}{6}log_2\frac{2}{6})=0.918 \\ \\ \\ Ent(D^3)=-(\frac{1}{5}log_2\frac{1}{5}+\frac{4}{5}log_2\frac{4}{5})=0.722</script><p>之后根据上面公式可计算出属性“色泽”的信息增益为</p>
<script type="math/tex; mode=display">
Gain(D,色泽)=Ent(D)-\sum_{i=1}^3\frac{|D^i|}{|D|}Ent(D^i)  \\ \\ \\ =0.998-((\frac{6}{17}\times1.000+\frac{6}{17}\times0.918+\frac{5}{17}\times0.722)=0.109</script><p>一般而言，信息增益越大，则意味着使用属性a来进行划分所获得的“纯度提升”越大。其中ID3决策树就是以信息增益为准则来选择划分属性。根据得到的属性最大信息增益来划分结果示例如下所示。之后再根据子集样本进一步划分，直到只有一个样本个体或者样本个体都为同一类标签为止。</p>
<p><img src="/2018/07/23/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（五）：决策树/02.jpg" alt></p>
<p>若我们把样本编号1-17也作为一个划分属性，则根据信息增益公式可计算出它的信息增益为0.998，远大于其他候选划分属性。这很容易理解，“编号”将产生17个分支，每个分支仅包含一个样本，这些分支节点纯度已打最大。然而这些侧介绍显然不具有泛化能力。</p>
<p><strong>所以实际上，信息增益准则对可取数目较多的属性有所偏好</strong>；为了减少这种偏好，著名的C4.5决策树算法不直接采用信息增益，而是使用增益率来做最优划分属性。</p>
<h2 id="增益率"><a href="#增益率" class="headerlink" title="增益率"></a>增益率</h2><p>增益率定义为其信息增益Gain(D，a)与训练数据集D关于特征a样本数的信息熵之比，增益率的数学定义为</p>
<script type="math/tex; mode=display">
Gain_{ratio}(D,a)=\frac{Gain(D,a)}{IV(a)}</script><script type="math/tex; mode=display">
IV(a)=-\sum_{v=1}^n\frac{|D^i|}{|D|}log_2\frac{|D^i|}{|D|}</script><p>（<strong>注意子集的划分是属性a样本的可取类别数目n，而不是标签类别|y|了啊</strong>），IV(a)可以成为属性a的内在信息，若属性a的可取数目越大，则IV(a)的值通常越大。这样就可以一定程度平衡信息增益对可取数目较多的属性的偏好。以“色泽”为例</p>
<script type="math/tex; mode=display">
IV(色泽)=-\frac{6}{17}log_2\frac{6}{17}-\frac{6}{17}log_2\frac{6}{17}-\frac{5}{17}log_2\frac{5}{17}=1.580</script><p>另外，需要注意的是，增益率准则对可取数值数目较少的属性有所偏好，因此，C4.5算法并不是直接选择增益率最大的候选划分属性，而是先从候选划分属性中找出信息增益高于平均水平的属性，再从中选择增益率的最高的。</p>
<h2 id="基尼指数"><a href="#基尼指数" class="headerlink" title="基尼指数"></a>基尼指数</h2><p>数据集D的纯度可以用基尼指数来度量，Gini（D）越小，则数据集D的纯度越高。假设有K个类，样本点属于第k类的概率为$p_k$，则概率分布的基尼系数定义为</p>
<script type="math/tex; mode=display">
Gini\left( p \right) =\sum_{k=1}^K{p_k\left( 1-p_k \right) =1-\sum_{k=1}^K{p_k^2}}</script><p>根据基尼指数定义，可以得到样本集合D的基尼指数，其中$D_k$表示数据集D中属于第k类的样本子集</p>
<script type="math/tex; mode=display">
Gini(D)=1-\sum_{k=1}^{K}\left(\frac{|D_k|}{|D|} \right)^2</script><p>若样本集合D根据特征A是否取某一可能值a被分割成$D_1$和$D_2$两部分，即</p>
<script type="math/tex; mode=display">
D_1=\left\{ \left( x,y \right) \in D|A\left( x \right) =0 \right\} \mathrm{，}D_2=D-D_1</script><p>则在特征A的条件下，集合D的基尼指数定义为</p>
<script type="math/tex; mode=display">
Gini\left( D,A \right) =\frac{|D_1|}{|D|}Gini\left( D_1 \right) +\frac{|D_2|}{|D|}Gini\left( D_2 \right)</script><p>基尼系数Gini(D)表示集合D的不确定性，基尼系数Gini(D,A)表示A=a分割后集合D的不确定性。基尼指数越大，样本集合的不确定性越大。<strong>对于属性A，分别计算任意属性值将数据集划分为两部分之后的Gain_Gini</strong>，选取其中的最小值，作为属性A得到的<strong>最优二分方案</strong>。<strong>然后对于训练集S，计算所有属性的最优二分方案，选取其中的最小值，作为样本及S的最优二分方案</strong>。</p>
<script type="math/tex; mode=display">
\min_{i\epsilon A}(Gain\_Gini(D,A))</script><script type="math/tex; mode=display">
\min_{A\epsilon Attribute}(\min_{i\epsilon A}(Gain\_Gini(D,A)))</script><h1 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h1><p>剪枝是决策树学习算法对付“过拟合”的主要手段。在决策树学习中，为了尽可能正确分类样本，节点划分过程不断重复，有时会造成决策树分支过多，这时有时候把自身特点当做所有数据都具有的一般性质而导致过拟合，因此，可以通过主动去掉一些分支来降低过拟合的风险</p>
<p>基本策略有预剪枝和后剪枝，预剪枝是指在决策树生成过程中，对每个节点在划分前先进行估计，若当前节点的划分不能带来决策树泛化性能的提升，则停止划分当前节点标记为叶节点；后剪枝则是先从训练集生成一颗完整的决策树，然后自底向上地对非叶节点进行考察，若将该节点对应的字数替换为叶节点能带来决策树泛化性能提升，则将该子树替换为叶节点。</p>
<h1 id="CART决策树的生成"><a href="#CART决策树的生成" class="headerlink" title="CART决策树的生成"></a>CART决策树的生成</h1><p> ID3算法和C4.5按照信息增益和增益率最大的特征作为节点特征，然后递归构建。比较简单，还要注意这两种方法都容易过拟合。这里主要讲一下CART分类与回归树。</p>
<p>分类树与回归树（classification and regression tree，CART）模型（Breiman）由特征选择、树生成及剪枝组成，既可用于分类也可用于回归。CART算法采用<strong>二分递归分割的技术</strong>将当前样本集分为两个子样本集，使得生成的每个非叶子节点都有两个分支。因此CART算法生成的决策树是结构简洁的二叉树。CART可以处理连续型变量和离散型变量，利用训练数据递归的划分特征空间进行建树，用验证数据进行剪枝。利用训练数据递归的划分特征空间进行建树，用验证数据进行剪枝。</p>
<ul>
<li>如果待预测分类是离散型数据，则CART生成分类决策树。</li>
<li>如果待预测分类是连续性数据，则CART生成回归决策树。</li>
</ul>
<h2 id="CART分类树"><a href="#CART分类树" class="headerlink" title="CART分类树"></a>CART分类树</h2><p>对分类树用基尼系数（Gini index）最小化准则，进行特征选择，生成二叉树。</p>
<p>具体算法步骤如下：</p>
<ul>
<li>1）设结点的训练数据集为D，计算现有特征对该数据集的基尼指数。此时，对每一个特征A，对其可能取的每个值a，根据样本点对A=a的测试为”是”或者“否”将D分割为D1和D2两部分，计算其基尼系数。</li>
<li>2）在所有可能的特征A以及他们所有可能的切分点a中，选择基尼系数最小的特征及其对应的切分点作为最优特征与最优切分点。依最优特征与最优切分点，从现结点生成两个子结点，将训练数据集依特征分配到两个子结点中去。</li>
<li>3）对两个子结点递归地调用上述两个步骤，直至满足停止条件。</li>
<li>4）生成CART决策树</li>
</ul>
<p>以生物特征分类数据为例</p>
<p><img src="/2018/07/23/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（五）：决策树/03.jpg" alt></p>
<p>针对上述离散型数据，按照<strong>体温为恒温和非恒温</strong>(多类别属性也按’非’分成两类别)进行划分。其中恒温时包括哺乳类5个、鸟类2个，非恒温时包括爬行类3个、鱼类3个、两栖类2个，如下所示我们计算以体温为划分特征D1,D2的基尼指数。</p>
<script type="math/tex; mode=display">
Gini(D_1)=1-[ (\frac{5}{7})^2+(\frac{2}{7})^2]=\frac{20}{49}</script><script type="math/tex; mode=display">
Gini(D_2)=1-[ (\frac{3}{8})^2+(\frac{3}{8})^2+(\frac{2}{8})^2]=\frac{42}{64}</script><p>然后计算得到特征<strong>体温</strong>下数据集的Gini指数，最后我们选择Gain_Gini最小的特征和相应的划分</p>
<script type="math/tex; mode=display">
Gain\_Gini(D,体温)=\frac{7}{15}*\frac{20}{49}+\frac{8}{15}*\frac{42}{64}</script><p>在所有可能的特征A以及他们所有可能的切分点a中的二分划分中，选择基尼系数最小的特征及其对应的切分点作为最优特征与最优切分点，依次递归。</p>
<h2 id="CART回归树"><a href="#CART回归树" class="headerlink" title="CART回归树"></a>CART回归树</h2><p>回归树衡量最好的标准不再是最大熵，而是<strong>最小化均方差</strong>。而且在每个节点（不一定是叶子节点）都会得一个预测值，这个预测值可为所有样本的平均值。我们利用最小二乘回归树生成算法来生成回归树f(x)，即在训练数据集所在的输入空间中，递归地将每个区域分为两个子区域并决定每个子区域上的输出值，构建二叉决策树。</p>
<p><strong>回归树算法流程：j为选定的某个特征属性，s为在这个特征上的切分数值（需要遍历所有特征和切分点来选到最小化均方差），R1R2为切分的样本，C1C2为切分区域样本中的特征均值。</strong></p>
<p><img src="/2018/07/23/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（五）：决策树/04.jpg" alt></p>
<p><strong>实例详解：</strong></p>
<p><img src="/2018/07/23/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（五）：决策树/05.jpg" alt></p>
<p>考虑如上所示的连续性变量，根据给定的数据点，考虑<strong>1.5,2.5,3.5,4.5,5.5,6.5,7.5,8.5,9.5</strong>共9个自定均分的切分点。对各切分点依次求出<strong>R1,R2,c1,c2及m(s)</strong>，例如当切分点s=1.5时，得到R1={1},R2={2,3,4,5,6,7,8,9,10}，其中c1,c2,m(s)如下所示</p>
<script type="math/tex; mode=display">
c_1=\frac{1}{N_m}\sum_{x_i\epsilon R_m(j,s)}y_i=\frac{1}{1}\sum_{x_i\epsilon R_1(1,1.5)}5.56=5.56</script><script type="math/tex; mode=display">
c_2=\frac{1}{N_m}\sum_{x_i\epsilon R_m(j,s)}y_i=\frac{1}{9}\sum_{x_i\epsilon R_2(1,1.5)}(5.70+5.91+...+9.05)=7.50</script><script type="math/tex; mode=display">
m(s)=\min_{j,s}[\min_{c_1}\sum _{x_i\epsilon R_i(j,s)}(y_i-c_1)^2+\min_{c_2}\sum _{x_i\epsilon R_i(j,s)}(y_i-c_1)^2]=0+15.72=15.72</script><p><strong>依次改变(j,s)对，可以得到s及m(s)的计算结果</strong>，如下表所示。</p>
<p><img src="/2018/07/23/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（五）：决策树/06.jpg" alt></p>
<p>当x=6.5时，此时R1={1,2,3,4,5,6},R2={7,8,9,10},c1=6.24,c2=8.9。<strong>回归树T1(x)</strong>为</p>
<script type="math/tex; mode=display">
T_1(x)=\begin{cases}
 & 6.24,x<6.5 \\ 
 & 8.91,x\ge 6.5
\end{cases}</script><script type="math/tex; mode=display">
f_1(x)=T_1(x)</script><p><strong>然后我们利用f1(x)拟合训练数据的残差</strong>(各目标值减去对应的c1,c2)，如下表所示</p>
<p><img src="/2018/07/23/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（五）：决策树/07.jpg" alt></p>
<p><strong>用f1(x)拟合训练数据得到平方误差</strong></p>
<script type="math/tex; mode=display">
L(y,f_1(x))=\sum_{i=1}^{10}(y_i-f_1(x_i))^2=1.93</script><p>第二步求T2(x)与求T1(x)方法相同，只是拟合的数据是上表的残差。可以得到</p>
<script type="math/tex; mode=display">
T_2(x)=\begin{cases}
 & -0.52,x<3.5 \\ 
 & 0.22,x\ge 3.5
\end{cases}</script><script type="math/tex; mode=display">
f_2(x)=f_1(x)+T_2(x)=
\begin{cases}
 & 5.72,x<3.5 \\ 
 & 6.46,3.5\le x \le 6.5 \\
 & 9.13,x\ge 6.5
\end{cases}</script><p>用f2(x)拟合训练数据的平方误差</p>
<script type="math/tex; mode=display">
L(y,f_2(x))=\sum_{i=1}^{10}(y_i-f_2(x_i))^2=0.79</script><p>继续求得T3(x)、T4(x)、T5(x)、T6(x)，如下所示</p>
<script type="math/tex; mode=display">
T_3(x)=\begin{cases}
 & 0.15,x<6.5 \\ 
 & -0.22,x\ge 6.5
\end{cases}
L(y,f_3(x))=0.47</script><script type="math/tex; mode=display">
T_4(x)=\begin{cases}
 & -0.16,x<4.5 \\ 
 & 0.11,x\ge 4.5
\end{cases}
L(y,f_4(x))=0.30</script><script type="math/tex; mode=display">
T_5(x)=\begin{cases}
 & 0.07,x<6.5 \\ 
 & -0.11,x\ge 6.5
\end{cases}
L(y,f_5(x))=0.23</script><script type="math/tex; mode=display">
T_6(x)=\begin{cases}
 & -0.15,x<2.5 \\ 
 & 0.04,x\ge 2.5
\end{cases}</script><script type="math/tex; mode=display">
f_6(x)=f_5(x)+T_6(x)=T_1(x)+...+T_6(x)=
\begin{cases}
 & 5.63,x<2.5 \\ 
 & 5.82,2.5\le x \le 3.5 \\
  & 6.56,3.5\le x \le 4.5 \\
 & 6.83,4.5\le x \le 6.5 \\
  & 8.95,x\ge 6.5 
\end{cases}</script><p>用f6(x)拟合训练数据的平方损失误差如下所示，假设此时已经满足误差要求，那么f(x)=f6(x)便是所求的回归树。</p>
<script type="math/tex; mode=display">
L(y,f_6(x))=\sum_{i=1}^{10}(y_i-f_6(x_i))^2=0.71</script><h2 id="CART剪枝"><a href="#CART剪枝" class="headerlink" title="CART剪枝"></a>CART剪枝</h2><p>们将一颗充分生长的树称为<strong>T0</strong> ，希望减少树的大小来防止过拟化。但同时<strong>去掉一些节点后预测的误差可能会增大</strong>，<strong>即完整树T0拟合的损失是最小的</strong>。那么如何达到这两个变量之间的平衡则是问题的关键。因此我们用一个变量α 来平衡，定义损失函数如下</p>
<script type="math/tex; mode=display">
C_\alpha(T)=C(T)+\alpha|T|</script><ul>
<li>T为任意子树，|T|为子树T的叶子节点个数。</li>
<li>α是参数，权衡拟合程度与树的复杂度。</li>
<li>C(T)为<strong>预测误差</strong>，可以是平方误差也可以是基尼指数，C(T)衡量训练数据的拟合程度。</li>
</ul>
<p><strong>那么我们如何找到这个合适的α来使拟合程度与复杂度之间达到最好的平衡呢？</strong>准确的方法就是将α从0取到正无穷，对于每一个固定的α，我们都可以找到使得$C_\alpha(T)$最小的最优子树T(α)。</p>
<ul>
<li>当α很小的时候(相当于弱化正则)，T0 完整树是这样的最优子树.</li>
<li>当α很大的时候(相当于强化正则)，单独一个根节点就是最优子树。</li>
</ul>
<p>Breiman等人证明：可以用递归地方法对树进行剪枝。将a从小增大，$0=a_0&lt;a_1&lt;…..a_n&lt;+∞$产生一系列的区间$[a_i,a_i+1),i=0,1,…,n$剪枝得到的子树序列对应着区间$a∈[a_i,a_i+1)，i=0,1,2,…,n$的最优子树序列为${T_0,T_1,T_2,…,T_n}$,序列的子树是嵌套的。</p>
<p>具体地，从整体树$T_0$开始剪枝，对$T_0$的人以内部结点t，<strong>以t为单结点树</strong>的损失函数是</p>
<script type="math/tex; mode=display">
C_a\left( t \right) =C\left( t \right) +a</script><p><strong>以t为根结点的子树</strong>$T_t$的损失函数是</p>
<script type="math/tex; mode=display">
C_a(T_t)=C(T_t)+a|T_t|</script><p>到这里，我们的目的就变得很明确了，当t为单节点树的损失比以t为根节点的子树$T_t$损失相等的时候，损失相同，而t的节点少，就进行剪枝操作。其过程会随a由0逐渐增大，单节点树t损失一开始大于子树$T_t$，随后不断减少，直到大于子树损失。具体的，当$\alpha =\frac{C\left( t \right) -C\left( T_t \right)}{|T_t|-1}$ ，$T_t$和t有相同的损失。</p>
<p>为此，对$T_0$中的每一个内部结点t，计算</p>
<script type="math/tex; mode=display">
g\left( t \right) =\frac{C\left( t \right) -C\left( T_t \right)}{|T_t|-1}</script><p>它表示剪枝后整体损失函数减少的程度。在$T_0$中减去g(t)最小的$T_t$，将得到的子树作为$T_1$，同时将最小的g(t)设为$a_1$，$T_1$为区间$[a_1,a_2)$的最优子树。如此剪枝下去，直至得到根结点。在这一过程中，不断得增加a的值，产生新的区间。</p>
<p>然后，在剪枝得到的子树序列$T_0,T_1,…,T_n$中通过交叉验证选取最优子树$T_a$.</p>
<p>具体地，利用独立的验证数据集，测试子树序列$T_0,T_1,…,T_n$中各棵子树的平方误差或基尼指数。平方误差或基尼指数最小的决策树被认为是最优的决策树。在子树序列中，每棵子树$T_0,T_1,…,T_n$都对应一个参数$a_1,a_2,…,a_n$。所以当最优子树$T_k$确定时，对应的$a_k$也就确定了，即得到最由决策树$T_a$.</p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="决策树分类边界"><a href="#决策树分类边界" class="headerlink" title="决策树分类边界"></a>决策树分类边界</h2><p>另外，决策树所形成的分类边界有一个明显的特点：轴平行，即它的分类边界有若干个与坐标轴平行的分段组成。</p>
<p><img src="/2018/07/23/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（五）：决策树/08.png" alt></p>
<h2 id="决策树的训练和可视化"><a href="#决策树的训练和可视化" class="headerlink" title="决策树的训练和可视化"></a>决策树的训练和可视化</h2><p>下面的代码就是在我们熟知的鸢尾花数据集上进行一个决策树分类器的训练</p>
<blockquote>
<p>决策树的众多特性之一就是， 它不需要太多的数据预处理， 尤其是不需要进行特征的缩放或者归一化。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line">iris = load_iris()</span><br><span class="line">X = iris.data[:, <span class="number">2</span>:] <span class="comment"># petal length and width y = iris.target</span></span><br><span class="line">    tree_clf = DecisionTreeClassifier(max_depth=<span class="number">2</span>)</span><br><span class="line">    tree_clf.fit(X, y)</span><br></pre></td></tr></table></figure>
<p>你可以通过使用export_graphviz()方法，通过生成一个叫做iris_tree.dot的图形定义文件将一个训练好的决策树模型可视化</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> export_graphviz</span><br><span class="line">    export_graphviz(</span><br><span class="line">            tree_clf,</span><br><span class="line">            out_file=image_path(<span class="string">"iris_tree.dot"</span>),</span><br><span class="line">            feature_names=iris.feature_names[<span class="number">2</span>:],</span><br><span class="line">            class_names=iris.target_names,</span><br><span class="line">            rounded=<span class="literal">True</span>,</span><br><span class="line">            filled=<span class="literal">True</span></span><br><span class="line">        )</span><br></pre></td></tr></table></figure>
<p>然后，我们可以利用graphviz package 中的dot命令行，将.dot文件转换成 PDF 或 PNG 等多种数据格式。例如，使用命令行将.dot文件转换成.png文件的命令如下：</p>
<blockquote>
<p>Graphviz是一款开源图形可视化软件包，<a href="http://www.graphviz.org/" target="_blank" rel="noopener">http://www.graphviz.org/</a></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ dot -Tpng iris_tree.dot -o iris_tree.png</span><br></pre></td></tr></table></figure>
<p>我们的第一个决策树如图</p>
<p><img src="/2018/07/23/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（五）：决策树/09.png" alt></p>
<p>节点的samples属性统计出它应用于多少个训练样本实例，例如，我们有一百个训练实例是花瓣长度大于 2.45 里面的（深度为 1， 右侧），在这 100 个样例中又有 54 个花瓣宽度小于 1.75cm（深度为 2，左侧）；节点的value属性告诉你这个节点对于每一个类别的样例有多少个，例如：右下角的节点中包含 0 个 Iris-Setosa，1 个 Iris-Versicolor 和 45 个 Iris-Virginica；最后，节点的Gini属性用于测量它的纯度：如果一个节点包含的所有训练样例全都是同一类别的，我们就说这个节点是纯的（Gini=0）</p>
<p>下面公式显示了训练算法如何计算第i个节点的 gini 分数 。例如， 深度为 2 的左侧节点基尼指数为：</p>
<script type="math/tex; mode=display">G_i=\sum_{k=1}^nP_{i,k}^2</script><p> $p_{i,k}$ 是第i个节点中训练实例为的k类实例的比例</p>
<blockquote>
<p>Scikit-Learn 用的是 CART 算法， CART 算法仅产生二叉树：每一个非叶节点总是只有两个子节点（只有是或否两个结果）。然而，像 ID3 这样的算法可以产生超过两个子节点的决策树模型</p>
</blockquote>
<p>下图显示了决策树的决策边界。粗的垂直线代表根节点（深度为 0）的决定边界：花瓣长度为 2.45 厘米。由于左侧区域是纯的（只有 Iris-Setosa），所以不能再进一步分裂。然而，右边的区域是不纯的，所以深度为 1 的右边节点在花瓣宽度为 1.75 厘米处分裂（用虚线表示）。又由于max_depth设置为 2，决策树在那里停了下来。但是，如果将max_depth设置为 3，两个深度为 2 的节点，每个都将会添加另一个决策边界（用虚线表示）</p>
<p><img src="/2018/07/23/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（五）：决策树/10.png" alt></p>
<h2 id="估计分类概率"><a href="#估计分类概率" class="headerlink" title="估计分类概率"></a>估计分类概率</h2><p>决策树还可以估计某个实例属于特定类k的概率：首先遍历树来查找此实例的叶节点，然后它返回此节点中类k的训练实例的比例。</p>
<p>例如，假设你发现了一个花瓣长 5 厘米，宽 1.5 厘米的花朵。相应的叶节点是深度为 2 的左节点，因此决策树应该输出以下概率：Iris-Setosa 为 0%（0/54），Iris-Versicolor 为 90.7%（49/54），Iris-Virginica 为 9.3%（5/54）。当然，如果你要求它预测具体的类，它应该输出 Iris-Versicolor（类别 1），因为它具有最高的概率。我们了测试一下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>tree_clf.predict_proba([[<span class="number">5</span>, <span class="number">1.5</span>]])</span><br><span class="line">array([[ <span class="number">0.</span> , <span class="number">0.90740741</span>, <span class="number">0.09259259</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tree_clf.predict([[<span class="number">5</span>, <span class="number">1.5</span>]])</span><br><span class="line">array([<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<h2 id="CART-训练算法"><a href="#CART-训练算法" class="headerlink" title="CART 训练算法"></a>CART 训练算法</h2><p>Scikit-Learn 用分裂回归树（Classification And Regression Tree，简称 CART）算法训练决策树（也叫“增长树”）。这种算法思想真的非常简单：</p>
<p>首先使用单个特征k和阈值$t_k$ (例如，“花瓣长度≤2.45cm”）将训练集分成两个子集。它如何选择k和$t_k$ 呢？它寻找到能够产生最纯粹的子集一对(k,$t_k$) ，然后通过子集大小加权计算.</p>
<p>算法会尝试最小化成本函数。方法如公式</p>
<p><img src="/2018/07/23/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（五）：决策树/11.png" alt></p>
<p>当它成功的将训练集分成两部分之后， 它将会继续使用相同的递归式逻辑继续的分割子集，然后是子集的子集。当达到预定的最大深度之后将会停止分裂（由max_depth超参数决定），或者是它找不到可以继续降低不纯度的分裂方法的时候。几个其他超参数（之后介绍）控制了其他的停止生长条件（min_samples_split，min_samples_leaf，min_weight_fraction_leaf，max_leaf_nodes）。</p>
<blockquote>
<p>正如您所看到的，CART 算法是一种贪婪算法：它贪婪地搜索最高级别的最佳分割方式，然后在每个深度重复该过程。 它不检查分割是否能够在几个级别中的全部分割可能中找到最佳方法。贪婪算法通常会产生一个相当好的解决方法，但它不保证这是全局中的最佳解决方案</p>
</blockquote>
<h2 id="计算复杂度"><a href="#计算复杂度" class="headerlink" title="计算复杂度"></a>计算复杂度</h2><p>在建立好决策树模型后， 做出预测需要遍历决策树， 从根节点一直到叶节点。决策树通常近似左右平衡，因此遍历决策树需要经历大致 $O(log_2^m)$ 个节点。由于每个节点只需要检查一个特征的值，因此总体预测复杂度仅为$O(log_2^m)$ ，与特征的数量无关。 所以即使在处理大型训练集时，预测速度也非常快.</p>
<p>然而，训练算法的时候（训练和预测不同）需要比较所有特征（如果设置了max_features会更少一些）<br>在每个节点的所有样本上。就有了$O(nmlog_2^m)$的训练复杂度。对于小型训练集（少于几千例），Scikit-Learn 可以通过预先设置数据（presort = True）来加速训练，但是这对于较大训练集来说会显着减慢训练速度。</p>
<h2 id="基尼不纯度或是信息熵"><a href="#基尼不纯度或是信息熵" class="headerlink" title="基尼不纯度或是信息熵"></a>基尼不纯度或是信息熵</h2><p>通常，算法使用 Gini 不纯度来进行检测， 但是你也可以通过将标准超参数设置为”entropy”来使用熵不纯度进行检测。这里熵的概念是源于热力学中分子混乱程度的概念，当分子井然有序的时候，熵值接近于 0</p>
<p>那么我们到底应该使用 Gini 指数还是熵(ID3,C4.5决策树)呢？ 事实上大部分情况都没有多大的差别：他们会生成类似的决策树。 基尼指数计算稍微快一点，所以这是一个很好的默认值。但是，也有的时候它们会产生不同的树，基尼指数会趋于在树的分支中将最多的类隔离出来，而熵指数趋向于产生略微平衡一些的决策树模型。</p>
<h2 id="正则化超参数"><a href="#正则化超参数" class="headerlink" title="正则化超参数"></a>正则化超参数</h2><p>决策树几乎不对训练数据做任何假设（于此相反的是线性回归等模型，这类模型通常会假设数据是符合线性关系的）。</p>
<p>如果不添加约束，树结构模型通常将根据训练数据调整自己，使自身能够很好的拟合数据，而这种情况下大多数会导致模型过拟合。</p>
<p>这一类的模型通常会被称为非参数模型，这不是因为它没有任何参数（通常也有很多），而是因为在训练之前没有确定参数的具体数量，所以模型结构可以根据数据的特性自由生长。</p>
<p>DecisionTreeClassifier类还有一些其他的参数用于限制树模型的形状:</p>
<blockquote>
<p>min_samples_split（节点在被分裂之前必须具有的最小样本数），min_samples_leaf（叶节点必须具有的最小样本数），min_weight_fraction_leaf（和min_samples_leaf相同，但表示为加权总数的一小部分实例），max_leaf_nodes（叶节点的最大数量）和max_features（在每个节点被评估是否分裂的时候，具有的最大特征数量）。增加min_hyperparameters或者减少max_hyperparameters会使模型正则化</p>
<p>预剪枝与后剪枝</p>
</blockquote>
<p>下图显示了对moons数据集进行训练生成的两个决策树模型，左侧的图形对应的决策树使用默认超参数生成（没有限制生长条件），右边的决策树模型设置为min_samples_leaf=4。很明显，左边的模型过拟合了，而右边的模型泛用性更好。</p>
<p><img src="/2018/07/23/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（五）：决策树/12.png" alt></p>
<h2 id="回归"><a href="#回归" class="headerlink" title="回归"></a>回归</h2><p>决策树也能够执行回归任务，让我们使用 Scikit-Learn 的DecisionTreeRegressor类构建一个回归树，让我们用max_depth = 2在具有噪声的二次项数据集上进行训练。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeRegressor</span><br><span class="line">tree_reg = DecisionTreeRegressor(max_depth=<span class="number">2</span>)</span><br><span class="line">tree_reg.fit(X, y)</span><br></pre></td></tr></table></figure>
<p>结果如图：</p>
<p><img src="/2018/07/23/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（五）：决策树/13.png" alt></p>
<p>这棵树看起来非常类似于你之前建立的分类树，它的主要区别在于，它不是预测每个节点中的样本所属的分类，而是预测一个具体的数值。例如，假设您想对  的新实例进行预测。从根开始遍历树，最终到达预测值等于 0.1106 的叶节点。该预测仅仅是与该叶节点相关的 110 个训练实例的平均目标值。而这个预测结果在对应的 110 个实例上的均方误差（MSE）等于 0.0151</p>
<p>下图的左侧显示的是模型的预测结果，如果你将max_depth=3设置为 3，模型就会如 6-5 图右侧显示的那样.注意每个区域的预测值总是该区域中实例的平均目标值。算法以一种使大多数训练实例尽可能接近该预测值的方式分割每个区域。</p>
<blockquote>
<p>译者注：图里面的红线就是训练实例的平均目标值，对应上图中的value</p>
</blockquote>
<p><img src="/2018/07/23/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（五）：决策树/14.png" alt></p>
<p>CART 算法的工作方式与之前处理分类模型基本一样，不同之处在于，现在不再以最小化不纯度的方式分割训练集，而是试图以最小化 MSE 的方式分割训练集</p>
<p>下面公式显示了成本函数，该算法试图最小化这个成本函数。</p>
<p><img src="/2018/07/23/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（五）：决策树/15.png" alt></p>
<p>和处理分类任务时一样，决策树在处理回归问题的时候也容易过拟合。如果不添加任何正则化（默认的超参数），你就会得到图 6-6 左侧的预测结果，显然，过度拟合的程度非常严重。而当我们设置了min_samples_leaf = 10，相对就会产生一个更加合适的模型了，就如图 6-6 所示的那样</p>
<p><img src="/2018/07/23/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（五）：决策树/16.png" alt></p>
<h2 id="不稳定性"><a href="#不稳定性" class="headerlink" title="不稳定性"></a>不稳定性</h2><p>它很容易理解和解释，易于使用且功能丰富而强大。然而，它也有一些限制，首先，你可能已经注意到了，决策树很喜欢设定正交化的决策边界，（所有边界都是和某一个轴相垂直的），这使得它对训练数据集的旋转很敏感，例如图 6-7 显示了一个简单的线性可分数据集。在左图中，决策树可以轻易的将数据分隔开，但是在右图中，当我们把数据旋转了 45° 之后，决策树的边界看起来变的格外复杂。尽管两个决策树都完美的拟合了训练数据，右边模型的泛化能力很可能非常差。</p>
<p>解决这个难题的一种方式是使用 PCA 主成分分析，这样通常能使训练结果变得更好一些。</p>
<p><img src="/2018/07/23/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（五）：决策树/17.png" alt></p>
<p>更加通俗的讲，决策时的主要问题是它对训练数据的微小变化非常敏感，举例来说，我们仅仅从鸢尾花训练数据中将最宽的 Iris-Versicolor 拿掉（花瓣长 4.8 厘米，宽 1.8 厘米），然后重新训练决策树模型，你可能就会得到图 6-8 中的模型。正如我们看到的那样，决策树有了非常大的变化（原来的如图 6-2），事实上，由于 Scikit-Learn 的训练算法是非常随机的，即使是相同的训练数据你也可能得到差别很大的模型（除非你设置了随机数种子）</p>
<p><img src="/2018/07/23/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（五）：决策树/18.png" alt></p>
<h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><ol>
<li>在 100 万例训练集上训练（没有限制）的决策树的近似深度是多少？</li>
<li>节点的基尼指数比起它的父节点是更高还是更低？它是通常情况下更高/更低，还是永远更高/更低？</li>
<li>如果决策树过拟合了，减少最大深度是一个好的方法吗？</li>
<li>如果决策树对训练集欠拟合了，尝试缩放输入特征是否是一个好主意？</li>
<li>如果对包含 100 万个实例的数据集训练决策树模型需要一个小时，在包含 1000 万个实例的培训集上训练另一个决策树大概需要多少时间呢？</li>
<li>如果你的训练集包含 100,000 个实例，设置<code>presort=True</code>会加快训练的速度吗？</li>
</ol>
<hr>
<p>1、$log_210^6\approx20$</p>
<p>2、子节点的基尼指数通常比父节点更低，这是由CART训练树损失函数决定的，它只会每次减少子节点权重求和后的Gini指数。然而子节点的Gini并不会永远小于父节点，比如现在根节点包括{A B A A A}五个样本，其Gini为$1-\frac{1}{5}^2-\frac{4}{5}^2=0.32$，划分样本后为{A B}和 {A A A} ，Gini分别为0.5和0。权重求和后的Gini为$\frac{2}{5}\times0.5+\frac{3}{5}\times0=0.2$，其Gini指数划分后只会比原来的更小。</p>
<p>3、如果决策树过度拟合训练集，那么减少max_depth是个不错的选择。</p>
<p>4、决策树不关心训练数据是否缩放或居中，这是他们的优势之一。 因此，如果决策树如果欠拟合，缩放输入功能只会浪费时间。</p>
<p>5、训练决策树的时间复杂度为$O(nmlog_2m)$，m为样本数，n为特征数。所以训练样本增加十倍，其训练时间会增加$K=(n\cdot 10m\cdot log_2(10m))=10\times log(10m)/log(m)$.如果m=10^6,则K$\approx$11.7</p>
<p>6、仅当数据集小于几千个实例时，预先训练训练集能加速训练。 如果它包含100,000个实例，则设置presort = True将大大减慢训练速度。</p>
]]></content>
      <categories>
        <category>Sklearn 与 TensorFlow 机器学习实用指南</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>决策树</tag>
        <tag>CART</tag>
      </tags>
  </entry>
  <entry>
    <title>Sklearn 与 TensorFlow 机器学习实用指南（四）：支持向量机</title>
    <url>/2018/07/18/Sklearn%20%E4%B8%8E%20TensorFlow%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E7%94%A8%E6%8C%87%E5%8D%97/Sklearn-%E4%B8%8E-TensorFlow-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E7%94%A8%E6%8C%87%E5%8D%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/</url>
    <content><![CDATA[<h1 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h1><h2 id="支持向量机条件描述"><a href="#支持向量机条件描述" class="headerlink" title="支持向量机条件描述"></a>支持向量机条件描述</h2><h3 id="样本分类"><a href="#样本分类" class="headerlink" title="样本分类"></a>样本分类</h3><p>Y∈{+1， -1}是样本的标签，分别代表两个不同的类。这里我们需要用这些样本去训练学习一个线性分类器（超平面）：$f(x)=sgn(w^Tx + b)$，也就是$w^Tx + b$大于0的时候，输出+1，小于0的时候，输出-1。sgn()表示取符号。而$g(x) =w^Tx + b=0$就是我们要寻找的分类超平面</p>
<p>也就是，对于任何一个正样本$y_i$=+1，它都要处于超平面的一边，也就是要保证：$y= w^Tx + b&gt;0$。对于任何一个负样本$y_i=-1$，它都要处于超平面的另一边，也就是要保证：$y = w^Tx + b&lt;0$这两个约束，其实可以合并成同一个式子：$y_i (w^Tx_i+b)\geq0$</p>
<h3 id="最大间隔"><a href="#最大间隔" class="headerlink" title="最大间隔"></a>最大间隔</h3><p>点到直线距离距离引理：设直线 L 的方程为Ax+By+C=0，点 P 的坐标为（Xo，Yo），则点 P 到直线 L 的距离为</p>
<script type="math/tex; mode=display">
\frac{\vert Ax_0+By_0+c\vert}{\sqrt{A^2+B^2}}</script><p><strong>间隔:间隔表示距离划分超平面最近的样本到划分超平面距离的两倍</strong>,即($x_i$为离直线最近的样本i)</p>
<script type="math/tex; mode=display">
\gamma=2\min_i \frac{1}{\Vert w \Vert}\vert w^Tx_i+b \vert</script><h3 id="约束条件"><a href="#约束条件" class="headerlink" title="约束条件"></a>约束条件</h3><p>所以，线性支持向量机的目标是找到一组合适的参数(<strong>w</strong>, b), 在满足分割样本的条件下，使得上诉间隔最大</p>
<script type="math/tex; mode=display">
\max_{w,b} \min_i \frac{2}{\Vert w \Vert}\vert w^Tx_i+b \vert \\ \\ \\s.t. \quad y_i(w^T+b)>0, i=1,2,...,m</script><p><strong>上面的优化问题十分复杂, 难以处理. 为了能在现实中应用, 我们希望能对其做一些简化, 使其变为可以求解的, 经典的凸二次规划 (QP) 问题</strong></p>
<blockquote>
<p>凸二次规划的优化问题是指目标函数是凸二次函数, 约束是线性约束的一类优化问题</p>
</blockquote>
<p>支持向量机的缩放引理：若（w* ,b*）是上面优化问题的解，那么对任何的r&gt;0,(rw*,rb*)仍是该问题的解。</p>
<p>由于对 (w, b) 的放缩不影响解, 为了简化优化问题,我们约束 (w, b) 使得最短距离固定为1.</p>
<script type="math/tex; mode=display">
\min_i \quad \vert w^Tx_i+b \vert = 1</script><p><strong>所以最后我们的优化目标可以等价为下面优化目标</strong>：</p>
<script type="math/tex; mode=display">
\min_{w,b} \quad \frac{1}{2}w^Tw \\ \\ \\s.t. \quad y_i(w^T+b)\geq1, i=1,2,...,m</script><p><strong>这是一个凸二次规划问题，除了用解决QP问题的常规方法之外，还可以应用拉格朗日对偶性，通过求解对偶问题得到最优解，这就是线性可分条件下支持向量机的对偶算法，这样做的优点在于：一是对偶问题往往更容易求解；二者可以自然的引入核函数，进而推广到非线性分类问题</strong>。</p>
<h2 id="拉格朗日函数与对偶形式"><a href="#拉格朗日函数与对偶形式" class="headerlink" title="拉格朗日函数与对偶形式"></a>拉格朗日函数与对偶形式</h2><h4 id="拉格朗日函数"><a href="#拉格朗日函数" class="headerlink" title="拉格朗日函数"></a>拉格朗日函数</h4><p>对于优化问题</p>
<script type="math/tex; mode=display">
\min_{u} \quad f(u) \\ \\ \\s.t. \quad g_i(u)\leq 0, i=1,2,...,m \\ \\ \\ \qquad  \ \ \ h_j(u)=0, j=1,2,...,n \qquad（6）</script><p>定义其拉格朗日函数为</p>
<script type="math/tex; mode=display">
L(u,\alpha,\beta):=f(u)+\sum_{i=1}^m\alpha_ig_i(u)+\sum_{j=1}^n\beta_jh_j(u)\\ \\ \\s.t.\quad \alpha_i\geq0</script><p><strong>公式6的优化问题等价于</strong></p>
<script type="math/tex; mode=display">
\min \limits_{u} \max \limits_{\alpha,\beta} \quad L(u,\alpha,\beta) \\ \\ \\ s.t. \alpha_i\geq0, \ \ i=1,2,...,m \qquad(8)</script><p>其证明过程如下</p>
<p><img src="/2018/07/18/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（四）：支持向量机/08.jpg" alt></p>
<p>其中，当$g_i$不满足约束时，即$g_i(u)&gt;0$,我们可以取$\alpha_i=\infty $;当$h_j$不满足约束时, 即$h_j(u)\neq 0$, 我们可以取$\beta_j=sign(h_j(u))\infty$，使得$\beta_jh_j(u)=\infty$. 当u满足约束时，由于$\alpha_i\geq 0,g_i(u)\leq 0$,则$\alpha_ig_i(u) \leq 0$.因此$\alpha_ig_i(u)$的最大值为0.</p>
<h4 id="KKT条件和对偶形式"><a href="#KKT条件和对偶形式" class="headerlink" title="KKT条件和对偶形式"></a>KKT条件和对偶形式</h4><p>公式8描述的优化问题在最优值必须满足如下条件(KKT完整条件放后面)</p>
<ul>
<li>主问题可行：$g_i(u)\leq 0,h_i(u)=0$;</li>
<li>对偶问题可行：$\alpha_i \geq 0$;</li>
<li>互补松弛：$\alpha_i g_i(u)=0$.</li>
</ul>
<p>主问题可行和对偶问题可行是公式6和公式8描述的优化问题的约束项。松弛互补是在主问题和对偶问题都可行的条件下的最大值</p>
<p>在对偶问题里，公式6描述的优化问题，其等价形式公式8称为主问题，其对偶问题为(最大最小条件互换)</p>
<script type="math/tex; mode=display">
\max \limits_{\alpha,\beta} \min \limits_{u}  \quad L(u,\alpha,\beta) \\ \\ \\ s.t. \alpha_i\geq0, \ \ i=1,2,...,m</script><ul>
<li>引理一：对偶问题是主 (primal) 问题的下界（最大值里取最小值肯定会大于最小值里取最大值）</li>
</ul>
<script type="math/tex; mode=display">
\max \limits_{\alpha,\beta} \min \limits_{u}  \quad L(u,\alpha,\beta)\leq \min \limits_{u} \max \limits_{\alpha,\beta} \quad L(u,\alpha,\beta)</script><ul>
<li>引理二(Slater条件)：当主问题为凸优化问题，即$f$和$g_i$ 为凸函数，$h_j$为仿射函数(类似于kx+b的一类函数)，且可行域中至少有一点使不等式约束严格成立时，对偶问题等价于原问题。(支持向量机的优化函数和约束函数都为凸函数)</li>
</ul>
<h2 id="线性支持向量机"><a href="#线性支持向量机" class="headerlink" title="线性支持向量机"></a>线性支持向量机</h2><p>线性支持向量机的拉格朗日函数为</p>
<script type="math/tex; mode=display">
L(w,b,\alpha):=\frac{1}{2}w^tw+\sum_{i=1}^m\alpha_i(1-y_i(w^Tx_i+b))</script><p>其对偶问题为（并非主问题）</p>
<script type="math/tex; mode=display">
\max \limits_{\alpha}\min\limits_{w,b}\frac{1}{2}w^Tw+\sum_{i=1}^m\alpha_i(1-y_i(w^Tx_i+b)) \\ \\ \\ s.t.\quad \alpha_i\geq0,\quad i=1,2,...,m. \qquad(12)</script><p>因为其内层的(w,b)属于无约束优化问题，我们可以通过令偏导等于0的方法得到(w,b)的最优值</p>
<script type="math/tex; mode=display">
\frac{\partial L}{\partial w}=0\Rightarrow w=\sum_{i=1}^m{a_iy_ix_i}</script><script type="math/tex; mode=display">
\frac{\partial L}{\partial b}=0\Rightarrow \sum_{i=1}^m{a_iy_i=0}</script><p>将上面公式带入(12)消去(w,b)即可得(变为min是因为化简过程有个负号，转为求最小)</p>
<script type="math/tex; mode=display">
L\left( w,b,a \right) =\frac{1}{2}\sum_{i=1}^m{\sum_{j=1}^m{a_ia_jy_iy_j\left( x_i·x_j \right) -\sum_{i=1}^m{a_iy_i\left( \left( \sum_{j=1}^m{a_jy_jx_j} \right) ·x_i+b \right) +\sum_{i=1}^m{a_i}}}}  \\ \\ \\ =-\frac{1}{2}\sum_{i=1}^m{\sum_{j=1}^m{a_ia_jy_iy_j\left( x_i·x_j \right) +\sum_{i=1}^m{a_i}}}</script><p><strong>故最终化简得到线性支持向量机对偶型</strong></p>
<script type="math/tex; mode=display">
\min \limits_{\alpha} \frac{1}{2}\sum_{i=1}^m\sum_{j=1}^m\alpha_i\alpha_jy_iy_jx_i^Tx_j-\sum_{i=1}^m\alpha_i \\ \\ \\ s.t.\sum_{i=1}^m\alpha_iy_i=0, \\ \\ \\ \alpha_i\geq 0,\quad i=1,2,...,m.</script><p>上诉为线性支持向量机的最终化简对偶问题，其优化模型还要满足以下的KKT条件</p>
<ul>
<li>主问题可行：$1-y_i(w^Tx_i+b)\leq0$</li>
<li>对偶问题可行：$\alpha_i\geq0$</li>
<li>互补松弛：$\alpha_i(1-y_i(w^Tx_i+b))=0$</li>
</ul>
<p>根据KKT条件，我们可以得到两个非常重要的结论（这么多证明得出两个结论，不容易啊）</p>
<ul>
<li>结论一：落在间隔边界上的支持向量，其对应的样本的对偶变量$\alpha_i&gt;0$</li>
</ul>
<p>证明：由KKT可知，根据$\alpha_i(1-y_i(w^Tx_i+b))=0$ 当;$\alpha_i&gt;0$时，有$1-y_i(w^Tx_i+b)=0$ ，即$y_i(w^Tx_i+b)=1$</p>
<ul>
<li>结论二：支持向量机的参数(w,b)仅仅由支持向量决定，与其他样本无关</li>
</ul>
<p>证明：由于对偶变量$\alpha_i&gt;0$对应的样本是支持向量，</p>
<script type="math/tex; mode=display">
w=\sum_{i=1}^m\alpha_iy_ix_i=\sum_{i:\alpha_i=0}^m0\cdot y_ix_i+\sum_{i:\alpha_i>0}^m\alpha_iy_ix_i=\sum_{i\in SV}\alpha_iy_ix_i</script><p>其中SV代表所有支持向量的集合.b可以由互补松弛算出，对于某一支持向量$x_s$ 及其标记$y_s$，由于$y_s(w^Tx_s+b)=1$,</p>
<p>则有</p>
<script type="math/tex; mode=display">
b=y_s-w^Tx_s=y_s-\sum_{i\in SV}\alpha_iy_ix_i^Tx_s</script><p><strong>根据对偶公式(16)先计算最优解$\alpha_1,\alpha_2,…,\alpha_m$， 然后可以得到w和b，这样我们就可以写出分类超平面$w^\ast\cdot x+b^\ast=0$ 和分类决策函数$f(x)=sign(w^\ast·x+b^\ast)$</strong> </p>
<blockquote>
<p> 在实践中，为了得到对b更稳健的估计,通常使用对所有支持向量求解得到b的平均值</p>
</blockquote>
<h2 id="软间隔支持向量机"><a href="#软间隔支持向量机" class="headerlink" title="软间隔支持向量机"></a>软间隔支持向量机</h2><p>对每个样本点引进一个松弛变量$\xi \geqslant 0 $，使函数间隔加上松弛变量大于等于1.这样，<strong>约束条件</strong>变成</p>
<script type="math/tex; mode=display">
y_i\left( w·x_i+b \right) \geqslant 1-\xi _i</script><p>当然，如果我们允许$\xi \geqslant 0 $任意大的话，那任意的超平面都是符合条件的了。这里我们引入松弛变量$\xi$，松弛变量值越大，当样本违背约束的程度越大，当松弛变量为0时，样本分类正确。所以，我们在原来的目标函数后面加上一项，使得这些 $\xi \geqslant 0 $的总和也要最小，<strong>优化最大间隔和违背约束程度越小</strong>，<strong>目标函数</strong>由原来的$\frac{1}{2}||w||^2$变成</p>
<script type="math/tex; mode=display">
\frac{1}{2}||w||^2+C\sum_{i=1}^N{\xi _i}</script><p>这里，$C&gt;0$称为惩罚参数，一般事先由应用问题决定，用于权衡优化间隔和少量样本违背大间隔约束这两个目标，C越大时(看重这一项)对误分类的惩罚增大，，有更多的样本满足大间隔约束。C值小时对误分类的惩罚减小，允许有一些样本不满足大间隔约束.。最小化目标函数包含两层含义：使$\frac{1}{2}||w||^2$尽量最小间隔尽量大，同时使误分类点的个数尽量小，C是调和二者的系数。</p>
<p><strong>则有软间隔支持向量机基本型</strong>：软间隔支持向量机旨在找到一组合适的参数 (w, b), 使得</p>
<script type="math/tex; mode=display">
\underset{w,b,\xi}{\min}\ \frac{1}{2}||w||^2+C\sum_{i=1}^m{\xi _i} \\ \\ \\ s.t.\ \ y_i\left( w^T·x_i+b \right) \geqslant 1-\xi _i\ ,\ i=1,2,···,m \\ \\ \\ \xi _i\geqslant 0,\ i=1,2,···\mathrm{，}m  \qquad(21)</script><p>可证明w的解是唯一的，但b的解不唯一，b的解存在于一个区间。</p>
<p>用之前的方法将限制加入到目标函数中，得到如下<strong>原始最优化问题的拉格朗日函数</strong>(不等式为大于转为负号形式)：</p>
<script type="math/tex; mode=display">
L\left( w,b,\xi ,\alpha,\beta \right) =\frac{1}{2}||w||^2+C\sum_{i=1}^m{\xi _i-\sum_{i=1}^m{\alpha_i\left( y_i\left( w^T·x_i+b \right) -1+\xi _i \right) -\sum_{i=1}^m{\beta_i\xi _i}}} \\ \\ \\ s.t.\alpha\geq0 ,\beta\geq0.</script><p>其对偶问题为</p>
<script type="math/tex; mode=display">
\max_\limits{\alpha,\beta}\min_\limits{w,b,\xi} L\left( \alpha,\beta,w,b,\xi \right) \qquad(23)</script><p>首先求拉格朗日函数针对$w,b,\xi$求极小</p>
<script type="math/tex; mode=display">
\frac{\partial L}{\partial w}=0\Rightarrow w=\sum_{i=1}^m{a_iy_ix_i} \\ \\ \\ \frac{\partial L}{\partial b}=0\Rightarrow \sum_{i=1}^m{\alpha_iy_i=0} \\ \\ \\ \frac{\partial L}{\partial \xi _i}=0\Rightarrow C-\alpha_i-\beta_i=0，i=1,2,3···,m \qquad(24)</script><p>其中，有$\alpha\geq0,\beta\geq0$。因为$\beta_i=C-\alpha_i\geq0$，不失一般性，我们可以约束$0\leq\alpha_i\leq C$，从而<strong>去掉变量</strong>$\beta_i$.将这些求解变量带入拉格朗日对偶型即公式(23)，得到和原来一样的目标函数，唯一的区别就是现在拉格朗日乘子$\alpha$多了一个上限C。</p>
<p><strong>最终化简的软间隔支持向量机对偶型</strong>问题(软间隔支持向量机的对偶问题等价于找到一组合适的$\alpha$使得)</p>
<script type="math/tex; mode=display">
\underset{\alpha}{\min}\ \ \frac{1}{2}\sum_{i=1}^m{\sum_{j=1}^m{\alpha_i\alpha_jy_iy_j⟨x_i·x_j ⟩-\sum_{i=1}^m{\alpha_i}}} \\ \\ \\ s.t.\ \sum_{i=1}^m{a_iy_i=0} \\ \\ \\ 0\le a_i\le C\ ,\ \ i=1,2,···,m</script><p>上诉为最终化简的软间隔支持向量机对偶型问题，其优化模型还要满足以下的KKT条件</p>
<ul>
<li>主问题可行：$1-\xi_i-y_i(w^Tx_i+b)\leq0$,$-\xi\leq0$;</li>
<li>对偶问题可行：$\alpha_i\geq0$, $\beta_i\geq0$;</li>
<li>互补松弛：$\alpha_i(1-\xi_i-y_i(w^Tx_i+b))=0$,$\beta_i\xi_i=0$.</li>
</ul>
<p>根据KKT条件，我们也可以得到两个结论：</p>
<ul>
<li>结论一：软间隔支持向量机中, 支持向量落在最大间隔边界, 内部, 或被错误分类的样本</li>
</ul>
<p>证明：由软间隔支持向量机的 KKT 条件可知，$\alpha_i(1-\xi_i-y_i(w^Tx_i+b))=0$且$\beta_i\xi_i=0$。当$\alpha_i&gt;0$时，$1-\xi_i-y_i(w^Tx_i+b)=0$，进一步可以分为两种情况：</p>
<p>第一：$0&lt;\alpha_i&lt;’C$， 此时$\beta_i$=C-$\alpha_i$&gt;0(公式24的偏导约束)。因此$\xi_i$=0，即样本恰好落在最大间隔边界上。</p>
<p>第二：$\alpha_i=C$， 此时$\beta_i=C-\alpha_i=0$. 若$\xi$ &lt;1’则分类正确，该样本落在最大间隔内部(间隔边界与分离超平面之间)；若$\xi$=1，该样本在分隔超面上。若$\xi$&gt;0样本位于分离超平面误分的一侧。</p>
<ul>
<li>结论二：支持向量机的参数 (w, b) 仅由支持向量决定,与其他样本无关。</li>
</ul>
<p>证明：和线性支持向量机证明方式相同.</p>
<p>求解w，b的方式也与线性支持向量机相同。注意：对任一适合条件0&lt;a&lt;C都可求得一个$b^∗$，即这些点正好是位于分隔边界上的点来求出b点的。但是由于原始问题对b的求解并不唯一，所以实际计算时可以取在所有符合条件的样本点上的平均值。</p>
<script type="math/tex; mode=display">
w^*=\sum_{i=1}^N{a_{i}^{*}y_ix_i}</script><p>选择a的一个分量的一个分量$a_i$适合约束条件适合约束条件0&lt;$a_i$&lt;C,计算</p>
<script type="math/tex; mode=display">
b^*=y_j-\sum_{i=1}^N{a_{i}^{*}y_i⟨x_i·x_j ⟩}</script><h2 id="Hinge损失函数"><a href="#Hinge损失函数" class="headerlink" title="Hinge损失函数"></a>Hinge损失函数</h2><p>线性支持向量机学习除了原始最优化问题，还有另外一种解释，就是最优化以下目标函数.下标”+”表示以下取正值的函数z=max(0，z)：</p>
<script type="math/tex; mode=display">
\sum_i^{m}[1-y_i(w·x_i+b)]_++\lambda||w||^2</script><p>目标函数的第一项是经验损失或经验风险，函数$L(y·(w·x+b))=[1-y(w·x+b)]_+$ ,称为<strong>合页损失函数（hinge loss function）</strong>.这就是说，当样本点$(x_i,y_i)$被分类正确且函数间隔（确信度）$y_i(w\cdot x_i+b)$大于1时，损失是0，否则损失是$1-y_i(w\cdot x_i+b)$。目标函数目标函数的第二项是系数的L2范数，是正则项。下面要证明上面的公式等价于线性支持向量机原始最优化问题，即(公式21)</p>
<p>证明：先令$[1-y<em>i(w·x_i+b)]</em>+=\xi_i$， 则可以写成$\xi_i=\max(0,\ 1-y_i(w·x_i+b) )$ 。当样本满足约束分类正确时，$y_i(w\cdot x_i+b)&gt;1$， 有$1-y_i(w\cdot x_i+b)\leq0$，得$\xi_i=0$; 当当样本不满足约束时分类错误时， 有$\xi_i=1-y_i(w\cdot x_i+b)$ </p>
<p>故公式21的两个约束条件满足，其最优问题可以写作</p>
<script type="math/tex; mode=display">
\underset{w,b}{min}\sum_{i=1}^m\xi_i+\lambda||w||^2</script><p>若取$\lambda =\frac{1}{2C}$， 则$\underset{w,b}{min} \frac{1}{C}(\frac{1}{2} ||w||^2+C\sum_{i=1}^N \xi_i)$ 与原始最优问题等价</p>
<p><img src="/2018/07/18/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（四）：支持向量机/09.png" alt></p>
<p>图中还画出了0-1损失函数，可以认为它是一个二类分类问题的真正的损失函数，而合页损失函数是0-1损失函数的上界。由于0-1损失函数不是连续可导的，直接优化其构成的目标函数比较困难，可以认为线性支持向量机是优化由0-1损失函数的上界（合页损失函数）构成的目标函数。这时的上界损失函数又称为代理损失函数（surrogate function）。</p>
<p>图中虚线显示的是感知机的损失函数，相比之下，合页损失函数不仅要分类正确，而且确信度足够高时损失才是0，也就是说，合页损失函数对学习有更高的要求。</p>
<h2 id="核函数"><a href="#核函数" class="headerlink" title="核函数"></a>核函数</h2><p>线性可分问题：既然在原始的特征空间$R^d$不是线性可分的, 支持向量机希望通过一个映射 $\phi$ :$R^d$ →<br> $R^{\widetilde{d}}$,使得数据在新的空间 $R^{\widetilde{d}}$ 是线性可分的.</p>
<p>令 $\phi$(x)代表将样本 x 映射到 $R^{\widetilde{d}}$中的特征向量,参数 w 的维数也要相应变为 $\widetilde{d}$维.</p>
<p>在上面的支持向量机对偶公式中，注意到，被映射到高维的特征向量总是以成对内积的形式存在，即 $\phi (x_i)^T\phi(x_j)$ ,如果先计算特征在$R^{\widetilde{d}}$ 空间的映射, 再计算内积, 复杂度是O($\widetilde{d}$) ,当特征被映射到非常高维的空间, 甚至是无穷维空间时, 这将会是沉重的存储和计算负担.</p>
<p>核技巧旨在将特征映射和内积这两步运算压缩为一步, 并且使复杂度由O($\widetilde{d}$)降为O($d$),即, 核技巧希望构造一个核函数 $\kappa (x_i,x_j) $ ,使得</p>
<script type="math/tex; mode=display">
\kappa(x_i,x_j)=\phi (x_i)^T\phi(x_j)</script><p>并且，$\kappa (x_i,x_j) $ 的计算复杂度是 O($d$) .</p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="软间隔分类"><a href="#软间隔分类" class="headerlink" title="软间隔分类"></a>软间隔分类</h2><p>如果我们严格地规定所有的数据都不在“街道”上，都在正确地两边，称为<strong>硬间隔分类</strong>，硬间隔分类有两个问题，第一，只对线性可分的数据起作用，第二，对异常点敏感。</p>
<p>为了避免上述的问题，我们更倾向于使用更加软性的模型。目的在保持“街道”尽可能大和避免间隔违规（例如：数据点出现在“街道”中央或者甚至在错误的一边）之间找到一个良好的平衡。这就是软间隔分类。</p>
<p><strong>在 Scikit-Learn 库的 SVM 类，你可以用C超参数（惩罚系数）来控制这种平衡：较小的C会导致更宽的“街道”，但更多的间隔违规</strong>。下图显示了在非线性可分隔的数据集上，两个软间隔SVM分类器的判定边界。左边图中，使用了较大的C值，导致更少的间隔违规，但是间隔较小。右边的图，使用了较小的C值，间隔变大了，但是许多数据点出现在了“街道”上。然而，<strong>第二个分类器似乎泛化地更好</strong>：事实上，在这个训练数据集上减少了预测错误，因为实际上大部分的间隔违规点出现在了判定边界正确的一侧</p>
<p><img src="/2018/07/18/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（四）：支持向量机/01.jpg" alt></p>
<blockquote>
<p>如果你的 SVM 模型过拟合，你可以尝试通过减小超参数C去调整(街道更宽)</p>
<p>SVM 特别适合复杂的分类，而中小型的数据集分类中很少用到。另外，SVM 对特征缩放比较敏感，要先做数据缩放处理。</p>
</blockquote>
<p>以下的 Scikit-Learn 代码加载了内置的鸢尾花（Iris）数据集，缩放特征，并训练一个线性 SVM 模型（使用<code>LinearSVC</code>类，超参数<code>C=1</code>，hinge 损失函数）来检测 Virginica 鸢尾花。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> Pipeline</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> LinearSVC</span><br><span class="line"></span><br><span class="line">iris = datasets.load_iris()</span><br><span class="line">X = iris[<span class="string">"data"</span>][:, (<span class="number">2</span>, <span class="number">3</span>)] <span class="comment"># petal length, petal width</span></span><br><span class="line">y = (iris[<span class="string">"target"</span>] == <span class="number">2</span>).astype(np.float64) <span class="comment"># Iris-Virginica</span></span><br><span class="line"></span><br><span class="line">svm_clf = Pipeline((</span><br><span class="line">        (<span class="string">"scaler"</span>, StandardScaler()),</span><br><span class="line">        (<span class="string">"linear_svc"</span>, LinearSVC(C=<span class="number">1</span>, loss=<span class="string">"hinge"</span>)),</span><br><span class="line">    ))</span><br><span class="line"></span><br><span class="line">svm_clf.fit(X_scaled, y)</span><br><span class="line"></span><br><span class="line">Then, <span class="keyword">as</span> usual, you can use the model to make predictions:</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>svm_clf.predict([[<span class="number">5.5</span>, <span class="number">1.7</span>]])</span><br><span class="line">array([ <span class="number">1.</span>])</span><br></pre></td></tr></table></figure>
<blockquote>
<p>不同于 Logistic 回归分类器，SVM 分类器不会输出每个类别的概率。</p>
<p>SVM的分类器为SVC类，回归则为SVR类。</p>
</blockquote>
<p>作为一种选择，你可以在 SVC 类，使用<code>SVC(kernel=&quot;linear&quot;, C=1)</code>，但是它比较慢，尤其在较大的训练集上，所以一般不被推荐。另一个选择是使用<code>SGDClassifier</code>类，即<code>SGDClassifier(loss=&quot;hinge&quot;, alpha=1/(m*C))</code>。它应用了随机梯度下降（SGD 见第四章）来训练一个线性 SVM 分类器。尽管它不会和<code>LinearSVC</code>一样快速收敛，但是对于处理那些不适合放在内存的大数据集是非常有用的，或者处理在线分类任务同样有用。</p>
<blockquote>
<p><code>LinearSVC</code>要使偏置项规范化，首先你应该集中训练集减去它的平均数，完成数据中心化。如果你使用了<code>StandardScaler</code>，那么它会自动处理。此外，确保你设置<code>loss</code>参数为<code>hinge</code>，因为它不是默认值。最后，为了得到更好的效果，你需要将<code>dual</code>参数设置为<code>False</code>，除非特征数比样本量多。</p>
</blockquote>
<h2 id="常用损失函数"><a href="#常用损失函数" class="headerlink" title="常用损失函数"></a>常用损失函数</h2><ol>
<li><strong>铰链损失（Hinge Loss）</strong>：主要用于支持向量机（SVM） 中， 二分类<em>SVM</em>等于Hinge损失+ L2正则化。</li>
<li><strong>互熵损失 （Cross Entropy Loss，Softmax Loss ）</strong>：用于Logistic 回归与Softmax 分类中； </li>
<li><strong>平方损失（Square Loss）</strong>：主要是最小二乘法（OLS）中； </li>
<li><strong>指数损失（Exponential Loss）</strong> ：主要用于Adaboost 集成学习算法中； </li>
</ol>
<p>Hinge loss 的叫法来源于其损失函数的图形，为一个折线，通用的函数表达式为：</p>
<script type="math/tex; mode=display">
L(m_i) = max(0,1-m_i(w)) =\max(0, 1-y\tilde{y}), 其中y=\pm 1</script><p>表示如果被正确分类，损失是0，否则损失就是 $1-m_i(w)​$</p>
<p><img src="/2018/07/18/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（四）：支持向量机/02.JPG" alt></p>
<p>在机器学习中，Hing 可以用来解 <strong>间距最大化</strong> 的问题，最有代表性的就是SVM 问题，最初的SVM 优化函数如下： </p>
<script type="math/tex; mode=display">
\underset{w,\zeta}{argmin} \frac{1}{2}||w||^2+ C\sum_i \zeta_i \\
st.\quad \forall y_iw^Tx_i \geq 1- \zeta_i \\
\zeta_i \geq 0</script><p>将约束项进行变形，则为： </p>
<script type="math/tex; mode=display">
\zeta_i \geq 1-y_iw^Tx_i</script><p>则损失函数可以进一步写为： </p>
<script type="math/tex; mode=display">
\begin{equation}\begin{split}J(w)&=\frac{1}{2}||w||^2 + C\sum_i max(0,1-y_iw^Tx_i) \\
&= \frac{1}{2}||w||^2 + C\sum_i max(0,1-m_i(w)) \\
&= \frac{1}{2}||w||^2 + C\sum_i L_{Hinge}(m_i)
\end{split}\end{equation}</script><p>因此， <strong>SVM 的损失函数可以看作是 L2-norm 和 Hinge loss 之和</strong>。</p>
<h2 id="非线性支持向量机分类"><a href="#非线性支持向量机分类" class="headerlink" title="非线性支持向量机分类"></a>非线性支持向量机分类</h2><h3 id="创建多项式特征"><a href="#创建多项式特征" class="headerlink" title="创建多项式特征"></a>创建多项式特征</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_moons</span><br><span class="line"><span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> Pipeline</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> PolynomialFeatures</span><br><span class="line"></span><br><span class="line">polynomial_svm_clf = Pipeline((</span><br><span class="line">        (<span class="string">"poly_features"</span>, PolynomialFeatures(degree=<span class="number">3</span>)),</span><br><span class="line">        (<span class="string">"scaler"</span>, StandardScaler()),</span><br><span class="line">        (<span class="string">"svm_clf"</span>, LinearSVC(C=<span class="number">10</span>, loss=<span class="string">"hinge"</span>))</span><br><span class="line">    ))</span><br><span class="line"></span><br><span class="line">polynomial_svm_clf.fit(X, y)</span><br></pre></td></tr></table></figure>
<h3 id="多项式核"><a href="#多项式核" class="headerlink" title="多项式核"></a>多项式核</h3><p>添加多项式特征很容易实现，不仅仅在 SVM，在各种机器学习算法都有不错的表现，但是<strong>低次数的多项式不能处理非常复杂的数据集，而高次数的多项式却产生了大量的特征，会使模型变得慢.</strong></p>
<p>幸运的是，当你使用 SVM 时，你可<strong>以运用一个被称为“核技巧”（kernel trick）的神奇数学技巧。它可以取得就像你添加了许多多项式，甚至有高次数的多项式，一样好的结果。所以不会大量特征导致的组合爆炸，因为你并没有增加任何特征</strong>。超参数<code>coef0</code>控制了高阶多项式与低阶多项式对模型的影响。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line">poly_kernel_svm_clf = Pipeline((</span><br><span class="line">        (<span class="string">"scaler"</span>, StandardScaler()),</span><br><span class="line">        (<span class="string">"svm_clf"</span>, SVC(kernel=<span class="string">"poly"</span>, degree=<span class="number">3</span>, coef0=<span class="number">1</span>, C=<span class="number">5</span>))</span><br><span class="line">    ))</span><br><span class="line">poly_kernel_svm_clf.fit(X, y)</span><br></pre></td></tr></table></figure>
<h3 id="增加相似特征"><a href="#增加相似特征" class="headerlink" title="增加相似特征"></a>增加相似特征</h3><p><strong>另一种解决非线性问题的方法是使用相似函数（similarity funtion）计算每个样本与特定地标（landmark）的相似度。</strong>例如，让我们来看看前面讨论过的一维数据集，<strong>并在x1=-2和x1=1之间增加两个地标</strong>。接下来，我们定义一个相似函数，即高斯径向基函数（Gaussian Radial Basis Function，RBF），设置γ = 0.3。</p>
<script type="math/tex; mode=display">
RBF:\quad \phi_{\gamma}(x, \ell) = exp(-\gamma \|x - \ell \|^2)</script><p>它是个从 0 到 1 的钟型函数，值为 0 的离地标很远，值为 1 的在地标上。<strong>现在我们准备计算新特征。例如，我们看一下样本x0=-1：它距离第一个地标距离(x1=-2)是 1，距离第二个地标(x1=1)是 2。因此它的新特征为x2=exp((-0.3 × 1)^2)≈0.74和x3=exp((-0.3 × 2)^2)≈0.30</strong>。右边的图显示了特征转换后的数据集（删除了原始特征），正如你看到的，它现在是线性可分了。</p>
<p><img src="/2018/07/18/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（四）：支持向量机/03.jpg" alt></p>
<p><strong>你可能想知道如何选择地标。最简单的方法是在数据集中的每一个样本的位置创建地标。这将产生更多的维度从而增加了转换后数据集是线性可分的可能性</strong>。<strong>但缺点是，m个样本，n个特征的训练集被转换成了m个实例，m个特征的训练集（假设你删除了原始特征）。这样一来，如果你的训练集非常大，你最终会得到同样大的特征</strong></p>
<h3 id="高斯-RBF-核"><a href="#高斯-RBF-核" class="headerlink" title="高斯 RBF 核"></a>高斯 RBF 核</h3><p>就像多项式特征法一样，相似特征法对各种机器学习算法同样也有不错的表现。但是在所有额外特征上的计算成本可能很高，特别是在大规模的训练集上。然而，“核” 技巧再一次显现了它在 SVM 上的神奇之处：<strong>高斯核让你可以获得同样好的结果成为可能，就像你在相似特征法添加了许多相似特征一样</strong>，但事实上，你并不需要在RBF添加它们。我们使用 SVC 类的高斯 RBF 核来检验一下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rbf_kernel_svm_clf = Pipeline((</span><br><span class="line">        (<span class="string">"scaler"</span>, StandardScaler()),</span><br><span class="line">        (<span class="string">"svm_clf"</span>, SVC(kernel=<span class="string">"rbf"</span>, gamma=<span class="number">5</span>, C=<span class="number">0.001</span>))</span><br><span class="line">    ))</span><br><span class="line">rbf_kernel_svm_clf.fit(X, y)</span><br></pre></td></tr></table></figure>
<p>下图显示了用不同的超参数gamma (γ)和C训练的模型<strong>。增大γ使钟型曲线更窄，导致每个样本的影响范围变得更小：即判定边界最终变得更不规则，在单个样本周围环绕。相反的，较小的γ值使钟型曲线更宽，样本有更大的影响范围，判定边界最终则更加平滑。所以γ是可调整的超参数：如果你的模型过拟合，你应该减小γ值，若欠拟合，则增大γ（与超参数C相似）。</strong></p>
<p><img src="/2018/07/18/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（四）：支持向量机/04.JPG" alt></p>
<p>还有其他的核函数，但很少使用。例如，一些核函数是专门用于特定的数据结构。在对文本文档或者 DNA 序列进行分类时，有时会使用字符串核（String kernels）（例如，使用 SSK 核（string subsequence kernel）或者基于编辑距离（Levenshtein distance）的核函数）</p>
<blockquote>
<p>这么多可供选择的核函数，你如何决定使用哪一个？一般来说，你应该先尝试线性核函数（记住LinearSVC比SVC(kernel=”linear”)要快得多），尤其是当训练集很大或者有大量的特征的情况下。如果训练集不太大，你也可以尝试高斯径向基核（Gaussian RBF Kernel），它在大多数情况下都很有效。如果你有空闲的时间和计算能力，你还可以使用交叉验证和网格搜索来试验其他的核函数，特别是有专门用于你的训练集数据结构的核函数</p>
</blockquote>
<h2 id="计算复杂性"><a href="#计算复杂性" class="headerlink" title="计算复杂性"></a>计算复杂性</h2><p><strong>LinearSVC类基于liblinear库，它实现了线性 SVM 的优化算法。它并不支持核技巧</strong>，但是它样本和特征的数量几乎是线性的：训练时间复杂度大约为O(m × n)。</p>
<p>如果你要非常高的精度，这个算法需要花费更多时间。这是由容差值超参数ϵ（在 Scikit-learn 称为tol）控制的。大多数分类任务中，使用默认容差值的效果是已经可以满足一般要求。</p>
<p><strong>SVC 类基于libsvm库，它实现了支持核技巧的算法</strong>。训练时间复杂度通常介于O(m^2 × n)和O(m^3 × n)之间。不幸的是，<strong>这意味着当训练样本变大时，它将变得极其慢</strong>（例如，成千上万个样本）。这个算法对于复杂但小型或中等数量的数据集表现是完美的。然而，它能对特征数量很好的缩放，尤其对稀疏特征来说（sparse features）（即每个样本都有一些非零特征）。在这个情况下，算法对每个样本的非零特征的平均数量进行大概的缩放。下表对 Scikit-learn 的 SVM 分类模型进行比较。</p>
<p><img src="/2018/07/18/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（四）：支持向量机/05.jpg" alt></p>
<h2 id="SVM-回归"><a href="#SVM-回归" class="headerlink" title="SVM 回归"></a>SVM 回归</h2><p>正如我们之前提到的，<strong>SVM 算法应用广泛：不仅仅支持线性和非线性的分类任务，还支持线性和非线性的回归任务</strong>。技巧在于逆转我们的目标：限制间隔违规的情况下，<strong>不是试图在两个类别之间找到尽可能大的“街道”（即间隔）。SVM 回归任务是限制间隔违规情况下，尽量放置更多的样本在“街道”上</strong>。“街道”的宽度由超参数ϵ控制。下图显示了在一些随机生成的线性数据上，两个线性 SVM 回归模型的训练情况。一个有较大的间隔（ϵ=1.5），另一个间隔较小（ϵ=0.5）</p>
<p><img src="/2018/07/18/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（四）：支持向量机/06.jpg" alt></p>
<p>添加更多的数据样本在间隔之内并不会影响模型的预测，因此，这个模型认为是不敏感的（ϵ-insensitive）。</p>
<p>你可以使用 Scikit-Learn 的LinearSVR类去实现线性 SVM 回归。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> LinearSVR</span><br><span class="line">svm_reg = LinearSVR(epsilon=<span class="number">1.5</span>)</span><br><span class="line">svm_reg.fit(X, y)</span><br></pre></td></tr></table></figure>
<p><strong>处理非线性回归任务，你可以使用核化的 SVM 模型</strong>。比如，图显示了在随机二次方的训练集，使用二次方多项式核函数的 SVM 回归。左图是较小的正则化（即更大的C值），右图则是更大的正则化（即小的C值）。</p>
<p><img src="/2018/07/18/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（四）：支持向量机/07.jpg" alt></p>
<p>下面的代码使用了 Scikit-Learn 的SVR类（支持核技巧）。在回归任务上，SVR类和SVC类是一样的，并且LinearSVR是和LinearSVC等价。LinearSVR类和训练集的大小成线性（就像LinearSVC类），当训练集变大，SVR会变的很慢（就像SVC类）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVR</span><br><span class="line"></span><br><span class="line">svm_poly_reg = SVR(kernel=<span class="string">"poly"</span>, degree=<span class="number">2</span>, C=<span class="number">100</span>, epsilon=<span class="number">0.1</span>)</span><br><span class="line">svm_poly_reg.fit(X, y)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>SVM 也可以用来做异常值检测，详情见 Scikit-Learn 文档</p>
</blockquote>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="拉格朗日子乘与KKT"><a href="#拉格朗日子乘与KKT" class="headerlink" title="拉格朗日子乘与KKT"></a>拉格朗日子乘与KKT</h2><h3 id="等式约束问题"><a href="#等式约束问题" class="headerlink" title="等式约束问题"></a>等式约束问题</h3><p><img src="/2018/07/18/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（四）：支持向量机/10.png" alt></p>
<p><img src="/2018/07/18/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（四）：支持向量机/11.png" alt></p>
<p><strong>可以得到一个重要的结论：▽f(x)一定与▽h(x)平行，故其关系可以写成▽f(x) =λ ▽h(x).</strong></p>
<p>扩展到高维度等式：f(x)为目标优化函数，hi(x)为约束等式，其表达式恒等于0。F(x)为等价的拉格朗日子乘函数。</p>
<p><img src="/2018/07/18/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（四）：支持向量机/12.png" alt></p>
<p>计算 F 对x与$\lambda$ 的偏导数并令其为零，可得最优解的必要条件：</p>
<p><img src="/2018/07/18/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（四）：支持向量机/13.png" alt></p>
<p><strong>其中第一式为定常方程式(stationary equation)</strong>，第二式为约束条件。也就是之前已经证明过得结果</p>
<p><strong>故等式约束要满足的条件</strong>为</p>
<p><img src="/2018/07/18/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（四）：支持向量机/14.png" alt></p>
<h3 id="不等式约束问题"><a href="#不等式约束问题" class="headerlink" title="不等式约束问题"></a>不等式约束问题</h3><p><img src="/2018/07/18/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（四）：支持向量机/15.jpg" alt></p>
<p>这两种情况的最佳解具有两种不同的必要条件</p>
<ol>
<li>内部解：h(x)&lt;0，不满足h(x)的等式约束，故不在边界上，在可行域的内部。在约束条件无效的情形下， h(x)不起作用，约束优化问题退化为无约束优化问题，因此驻点(最优解)<strong>满足▽f(x)=0且$\lambda$=0</strong> ($\lambda$为0才能消去F(x)的约束项)。</li>
<li>边界解：在约束条件有效的情形下，约束不等式变成等式约束，有h(x)=0。和等式约束做相同的处理。另外，存在$\lambda$ 使得$\bigtriangledown f=-\lambda \bigtriangledown g$，但这里$\lambda$ 的正负号是有其意义的。<strong>因为我们希望最小化</strong> f，梯度$\bigtriangledown f$ <strong>(函数</strong> f<strong>在点</strong>x<strong>的最陡上升方向)应该指向可行域的内部(因为你的最优解最小值是在边界取得的)，但</strong> $\bigtriangledown g$<strong>指向可行域的的外部(即 g(x)&gt;0的区域，因为你的约束是小于等于0)，因此$\lambda \geq0$，称为对偶可行性(dual feasibility)</strong>。</li>
</ol>
<p>所以，不论是内部解或边界解，$\lambda h(x)=0$恒成立(不同情况总有一个为0)，称为互补松弛性(complementary slackness)。整合上述两种情况，最佳解的必要条件包括拉格朗日函数常定方程式、主问题可行，对偶可行，和互补松弛。</p>
<p><img src="/2018/07/18/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（四）：支持向量机/16.jpg" alt></p>
<h2 id="对偶性"><a href="#对偶性" class="headerlink" title="对偶性"></a>对偶性</h2><p>一个优化问题，通过求出它的 dual problem ，在只有 weak duality 成立的情况下，我们至少可以得到原始问题的一个下界。而如果 strong duality 成立，则可以直接求解 dual problem 来解决原始问题，就如同经典的 SVM 的求解过程一样。有可能 dual problem 比 primal problem 更容易求解，或者 dual problem 有一些优良的结构（例如 SVM 中通过 dual problem 我们可以将问题表示成数据的内积形式从而使得 kernel trick 的应用成为可能）。此外，还有一些情况会同时求解 dual 和 primal problem ，比如在迭代求解的过程中，通过判断 duality gap 的大小，可以得出一个有效的迭代停止条件.</p>
<h2 id="支持向量机的其他变体"><a href="#支持向量机的其他变体" class="headerlink" title="支持向量机的其他变体"></a>支持向量机的其他变体</h2><h3 id="Prob-SVM"><a href="#Prob-SVM" class="headerlink" title="Prob SVM."></a>Prob SVM.</h3><p><strong>Prob SVM</strong>. 对数几率回归可以估计出样本属于正类的概率, 而支持向量机只能判断样本属于正类或负类,无法得到概率.Prob SVM 先训练一个支持向量机, 得到参数(w,b)。再令$s_i:=y_iw^Tx_i+b$，将${(s_1,y_1),(s_2,y_2),…,(s_m,y_m)}$当做新的训练数据训练一个对数几率回归模型，得到参数$(\theta_1,\theta_0)$.因此，ProbSVM 的假设函数为</p>
<script type="math/tex; mode=display">
h(x):=sigm(\theta_1(w^Tx_i+b)+\theta_0)</script><p>对数几率回归模型可以认为是对训练得到的支持向量机的微调, 包括尺度 (对应$\theta_1)$和平移(对应$\theta_0$).</p>
<h3 id="多分类支持向量机"><a href="#多分类支持向量机" class="headerlink" title="多分类支持向量机"></a>多分类支持向量机</h3><p>支持向量机也可以扩展到多分类问题中. 对于 K 分类问题, 多分类支持向量机有 K组参数 ${(w_1,b_1),(w_2,b_2),…,(w_K,b_K)}$并希望模型对于属于正确标记的结果以 1 的间隔高于其他类的结果, 形式化如下</p>
<script type="math/tex; mode=display">
\min \limits_{W,b} \frac{1}{m}\sum_{i=1}^m\sum_{k=1}^Kmax(0,(w_{yi}^Tx_i+b_{yi})-(w_{k}^Tx_i+b_{k}+1)+\frac{2}{\lambda}\sum_{k=1}^Kw_k^Tw_k</script><h3 id="支持向量回归-SVR"><a href="#支持向量回归-SVR" class="headerlink" title="支持向量回归 (SVR)"></a>支持向量回归 (SVR)</h3><p>支持向量回归 (SVR). 经典回归模型的损失函数度量了模型的预测 $h(x_i)$与$y_i$的差别, 支持向量回归能够容忍$h(x_i)$与$y_i$之间小于$\epsilon$ 的偏差.令$s:=y-w^Tx+b$，我们定义$\epsilon$不敏感损失为</p>
<p><img src="/2018/07/18/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（四）：支持向量机/17.jpg" alt></p>
<h2 id="支持向量机和LR的异同"><a href="#支持向量机和LR的异同" class="headerlink" title="支持向量机和LR的异同"></a>支持向量机和LR的异同</h2><h3 id="SVM与LR的相同点"><a href="#SVM与LR的相同点" class="headerlink" title="SVM与LR的相同点"></a>SVM与LR的相同点</h3><ol>
<li>LR和SVM都是分类算法，都是监督学习算法。</li>
<li>如果不考虑核函数，LR和SVM都是线性分类算法，也就是说他们的分类决策面都是线性的。LR也是可以用核函数的，至于为什么通常在SVM中运用核函数而不在LR中运用，后面讲到他们之间区别的时候会重点分析。总之，原始的LR和SVM都是线性分类器，这也是为什么通常没人问你决策树和LR什么区别，决策树和SVM什么区别，你说一个非线性分类器和一个线性分类器有什么区别？</li>
<li>LR和SVM都是判别模型。判别模型会生成一个表示P(Y|X)的判别函数（或预测模型），而生成模型先计算联合概率p(Y,X)然后通过贝叶斯公式转化为条件概率。简单来说，在计算判别模型时，不会计算联合概率，而在计算生成模型时，必须先计算联合概率。或者这样理解：生成算法尝试去找到底这个数据是怎么生成的（产生的），然后再对一个信号进行分类。基于你的生成假设，那么那个类别最有可能产生这个信号，这个信号就属于那个类别。判别模型不关心数据是怎么生成的，它只关心信号之间的差别，然后用差别来简单对给定的一个信号进行分类。常见的判别模型有：KNN、SVM、LR，常见的生成模型有：朴素贝叶斯，隐马尔可夫模型。当然，这也是为什么很少有人问你朴素贝叶斯和LR以及朴素贝叶斯和SVM有什么区别。</li>
<li>LR和SVM在学术界和工业界都广为人知并且应用广泛。</li>
</ol>
<h3 id="SVM与LR的不同点"><a href="#SVM与LR的不同点" class="headerlink" title="SVM与LR的不同点"></a>SVM与LR的不同点</h3><p>1.损失函数</p>
<p>SVM的处理方法是只考虑support vectors，也就是和分类最相关的少数点，去学习分类器。而逻辑回归通过非线性映射，大大减小了离分类平面较远的点的权重，相对提升了与分类最相关的数据点的权重,两者的根本目的都是一样的。即支持向量机只考虑局部的边界线附近的点，而逻辑回归考虑全局（远离的点对边界线的确定也起作用）。</p>
<p>影响SVM决策面的样本点只有少数的支持向量，当在支持向量外添加或减少任何样本点对分类决策面没有任何影响；而在LR中，每个样本点都会影响决策面的结果</p>
<p>2.核技巧</p>
<p>在解决非线性问题时，支持向量机采用核函数的机制，而LR通常不采用核函数的方法。</p>
<p>这个问题理解起来非常简单。分类模型的结果就是计算决策面，模型训练的过程就是决策面的计算过程。通过上面的第二点不同点可以了解，在计算决策面时，SVM转化为对偶问题后，只有少数几个代表支持向量的样本参与了计算，也就是只有少数几个样本需要参与核计算（即kernal machine解的系数是稀疏的），这个在进行复杂核函数计算时优势很明显，能够大大简化模型和计算量。。然而，LR算法里，每个样本点都必须参与决策面的计算过程，也就是说，假设我们在LR里也运用核函数的原理，那么每个样本点都必须参与核计算，这带来的计算复杂度是相当高的。所以，在具体应用时，LR很少运用核函数机制。</p>
<p>3.正则项</p>
<p>根据需要，两个方法都可以增加不同的正则化项，如l1,l2等等。所以在很多实验中，两种算法的结果是很接近的。但是逻辑回归相对来说模型更简单，好理解，实现起来，特别是大规模线性分类时比较方便。而SVM的理解和优化相对来说复杂一些。但是SVM的理论基础更加牢固，有一套结构化风险最小化的理论基础，虽然一般使用的人不太会去关注。</p>
<p>4.异常值</p>
<p>两者对异常的敏感度也不一样。同样的线性分类情况下，如果异常点较多的话，无法剔除，首先LR，LR中每个样本都是有贡献的，最大似然后会自动压制异常的贡献，SVM+软间隔对异常还是比较敏感，因为其训练只需要支持向量，有效样本本来就不高，一旦被干扰，预测结果难以预料。</p>
<p>5.normalization</p>
<p>两个模型对数据和参数的敏感程度不同，Linear SVM比较依赖penalty的系数和数据表达空间的测度，而（带正则项的）LR比较依赖对参数做L1 regularization的系数。但是由于他们或多或少都是线性分类器，所以实际上对低维度数据overfitting的能力都比较有限，相比之下对高维度数据，LR的表现会更加稳定，为什么呢？</p>
<p>因为Linear SVM在计算margin有多“宽”的时候是依赖数据表达上的距离测度的，换句话说如果这个测度不好（badly scaled，这种情况在高维数据尤为显著），所求得的所谓Large margin就没有意义了，这个问题即使换用kernel trick（比如用Gaussian kernel）也无法完全避免。所以使用Linear SVM之前一般都需要先对数据做normalization，而求解LR（without regularization）时则不需要或者结果不敏感。</p>
<h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><ol>
<li>支持向量机背后的基本思想是什么</li>
<li>什么是支持向量</li>
<li>当使用 SVM 时，为什么标准化输入很重要？</li>
<li>分类一个样本时，SVM 分类器能够输出一个置信值吗？概率呢？</li>
<li>在一个有数百万训练样本和数百特征的训练集上，你是否应该使用 SVM 原始形式或对偶形式来训练一个模型？</li>
<li>假设你用 RBF 核来训练一个 SVM 分类器，如果对训练集欠拟合：你应该增大或者减小<code>γ</code>吗？调整参数<code>C</code>呢？</li>
</ol>
<hr>
<p>1、支持向量机背后的基本目标是在训练实例中分隔两个类的决策边界之间具有最大可能的间隔。 当执行软间隔分类时，SVM在完全分离两个类和具有尽可能宽的街道之间搜索折衷。 另一个关键思想是在训练非线性数据集时使用核技巧。</p>
<p>2、在训练SVM之后，支持向量是位于“街道”上的任何实例，包括其边界。 决策边界完全由支持向量决定。 任何不是支持向量的实例（即街道外）都没有任何影响; 你可以删除它们，添加更多实例或移动它们，只要它们离开街道它们就不会影响决策边界。 计算预测仅涉及支持向量，而不是整个训练集。</p>
<p>3、SVM尝试适应类之间最大可能的“街道”，因此如果训练集未缩放，SVM将倾向于忽略数值小的特征。</p>
<p>4、SVM分类器可以输出测试实例与决策边界之间的距离，您可以将其用作置信度分数。 但是，这个分数不能直接转换为类概率的估计。 如果在Scikit-Learn中创建SVM时设置probability = True，则在训练之后，它将使用SVM分数的Logistic回归校准概率（通过对训练数据进行额外的5折交叉验证进行训练）。 这会将predict_proba（）和predict_log_proba（）方法添加到SVM。</p>
<p>5、此问题仅适用于线性SVM，因为进行核化kernelized需要用到对偶形式(对偶问题就是为了可以进行核化)。 SVM问题的原始形式的计算复杂度与训练实例m的数量成比例，而对偶形式的计算复杂度与m2和m3之间的数量成比例。 所以如果有数百万个实例，你肯定应该使用原始形式，因为对偶形式会太慢。</p>
<p>6、如果使用RBF内核训练的SVM分类器不适合训练集，则可能存在正则化强度过高。 要减少它，您需要增加gamma或C（或两者）。</p>
]]></content>
      <categories>
        <category>Sklearn 与 TensorFlow 机器学习实用指南</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>SVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Sklearn 与 TensorFlow 机器学习实用指南（三）：回归</title>
    <url>/2018/07/14/Sklearn%20%E4%B8%8E%20TensorFlow%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E7%94%A8%E6%8C%87%E5%8D%97/Sklearn-%E4%B8%8E-TensorFlow-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E7%94%A8%E6%8C%87%E5%8D%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%9B%9E%E5%BD%92/</url>
    <content><![CDATA[<h1 id="线性回归："><a href="#线性回归：" class="headerlink" title="线性回归："></a>线性回归：</h1><h2 id="线性回归模型"><a href="#线性回归模型" class="headerlink" title="线性回归模型"></a>线性回归模型</h2><script type="math/tex; mode=display">
\hat{y} = h _{\theta} (\mathbf{x})= \theta^T  \cdot \mathbf{x} = \theta _{0} + \theta _{1}x _{1}+\theta _{2}x _{2}+\dots+\theta _{n}x _{n}</script><ul>
<li><strong>x</strong> 为每个样例中特征值的向量形式，包括 $x_1$ 到 $x_n$  ，而且$x_0$ 恒为1。<strong>矩阵点乘，相同规模对应相乘</strong>。</li>
</ul>
<h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><script type="math/tex; mode=display">
MSE (\mathbf{X},h _{\theta}) = \frac{1}{m} \sum\limits_{i=1}^m{\left(\theta^T \cdot \mathbf{x}^{(i)}-y^{(i)}\right)}^2</script><h2 id="矩阵形式"><a href="#矩阵形式" class="headerlink" title="矩阵形式"></a>矩阵形式</h2><p>一行为一个实例</p>
<script type="math/tex; mode=display">
\left(\begin{matrix}
    1&        x_{1}^{\left(1\right)}&        x_{1}^{\left(2\right)}&        ···&        x_{1}^{\left(n\right)}\\
    1&        x_{2}^{\left(1\right)}&        x_{2}^{\left(2\right)}&        ···&        x_{2}^{\left(n\right)}\\
    ···&        ···&        ···&        &        \\
    1&        x_{m}^{\left(1\right)}&        x_{m}^{\left(2\right)}&        ···&        x_{m}^{\left(n\right)}\\
\end{matrix}\right)</script><p>优化线性回归损失函数的两种方法：1）最小二乘法原理的正态方程 2）梯度下降</p>
<h2 id="正态方程"><a href="#正态方程" class="headerlink" title="正态方程"></a>正态方程</h2><script type="math/tex; mode=display">
\frac{\partial }{\partial \theta}MSE(\theta) = \frac{1}{m}(2X^TX\theta-2X^Ty)</script><script type="math/tex; mode=display">
\hat{\theta} = ({\mathbf{X}}^T\cdot\mathbf{X})^{-1}\cdot{\mathbf{X}}^T\cdot\mathbf{y}</script><p><img src="/2018/07/14/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（三）：回归/01.png" alt></p>
<blockquote>
<p>这里的$X^TX$要满足满秩矩阵，然而，现实大多数任务不会满足这个条件。好像只有线性回归能用正态方程求解。优点是一次计算；缺点是矩阵的逆计算慢，尤其是特征数量很多的情况下就更糟糕了，但是一旦你得到了线性回归模型（通过解正态方程或者其他的算法），进行预测是非常快的。</p>
</blockquote>
<h2 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h2><h3 id="批量梯度下降"><a href="#批量梯度下降" class="headerlink" title="批量梯度下降"></a>批量梯度下降</h3><p><strong>批量梯度下降：使用梯度下降的过程中，你需要计算每一个</strong>θj 下代价函数的梯度<br>代价函数的偏导数: 利用公式2对θj求导，其余 θ看做常数。</p>
<script type="math/tex; mode=display">
\frac{\partial }{\partial \theta_j}MSE(\theta)=\frac{2}{m} \sum\limits_{i=1}^m{\left(\theta^T \cdot \mathbf{x}^{(i)}-y^{(i)}\right)}{x_j}^{(i)}</script><p>更新：</p>
<script type="math/tex; mode=display">
\theta :=\theta_j-\lambda\frac{\partial }{\partial \theta_j}MSE(\theta)</script><p>为了避免单独计算每一个梯度，你也可以使用下面的公式来一起计算它们。梯度向量记为$\nabla_{\theta}MSE(\theta) $ ，其包含了代价函数所有的偏导数(每个模型参数只出现一次)。利用正态方程最后的推导即可）</p>
<p><img src="/2018/07/14/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（三）：回归/02.jpg" alt></p>
<blockquote>
<p><strong>在这个方程中每一步计算时都包含了整个训练集X ，这也是为什么这个算法称为批量梯度下降：</strong>每一次训练过程都使用所有的的训练数据。因此，在大数据集上，其会变得相当的慢（但是我们接下来将会介绍更快的梯度下降算法）。然而，梯度下降的运算规模和特征的数量成正比。训练一个数千数量特征的线性回归模型使用梯度下降要比使用正态方程快的多.</p>
</blockquote>
<p>更新：</p>
<script type="math/tex; mode=display">
\theta^{(next\ step)}=\theta - \eta\nabla_{\theta}MSE(\theta)</script><p>我们来看一下这个算法的应用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">eta = <span class="number">0.03</span></span><br><span class="line">n_iterations = <span class="number">15000</span></span><br><span class="line">m = <span class="number">100</span>    <span class="comment"># 样本数目，</span></span><br><span class="line"></span><br><span class="line">X = <span class="number">2</span> * np.random.rand(<span class="number">100</span>, <span class="number">1</span>)    <span class="comment"># 产生100行1列的0~2的数值</span></span><br><span class="line">y = <span class="number">4</span> + <span class="number">3</span> * X + np.random.randn(<span class="number">100</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment"># np.c_表示按列操作拼接，np.r_表示按行操作拼接</span></span><br><span class="line">X_b = np.c_[np.ones((<span class="number">100</span>, <span class="number">1</span>)), X]     <span class="comment"># x0 = 1</span></span><br><span class="line">theta = np.random.randn(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> iteration <span class="keyword">in</span> range(n_iterations):</span><br><span class="line">    gradients = <span class="number">2</span>/m * X_b.T.dot(X_b.dot(theta) - y)</span><br><span class="line">    theta = theta - eta * gradients    <span class="comment"># 最后输出的是所有系数矩阵</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>theta</span><br><span class="line">array([[<span class="number">4.11509616</span>],[<span class="number">2.87011339</span>]])	<span class="comment"># 理论θ_0=4, θ_3, 由于噪声会有点误差</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>梯度下降的一些要点：</p>
<ul>
<li>应该确保所有的特征有着相近的尺度范围（例如：使用Scikit_Learn的 StandardScaler类）</li>
<li>学习率$\lambda $ 要自适应</li>
</ul>
</blockquote>
<h3 id="随机梯度下降"><a href="#随机梯度下降" class="headerlink" title="随机梯度下降"></a>随机梯度下降</h3><p>批量梯度下降的最要问题是计算每一步的梯度时都需要使用整个训练集，这导致在规模较大的数据集上，其会变得非常的慢。<strong>与其完全相反的随机梯度下降，在每一步的梯度计算上只随机选取训练集中的一个样例</strong>。</p>
<p><strong>虽然随机性可以很好的跳过局部最优值，但同时它却不能达到最小值。解决这个难题的一个办法是逐渐降低学习率。</strong>开始时，走的每一步较大（这有助于快速前进同时跳过局部最小值），然后变得越来越小，从而使算法到达全局最小值。 <strong>这个过程被称为模拟退火</strong></p>
<p><img src="/2018/07/14/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（三）：回归/03.jpg" alt></p>
<p>下面的代码使用一个简单的learning schedule来实现<strong>随机梯度下降</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n_epochs = <span class="number">50</span> </span><br><span class="line">t0, t1 = <span class="number">5</span>, <span class="number">50</span>  <span class="comment">#learning_schedule的超参数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">learning_schedule</span><span class="params">(t)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> t0 / (t + t1)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># np.random.randn返回2行1列符合标准正态分布的数；</span></span><br><span class="line"><span class="comment"># np.random.rand返回[0,1）的随机数；</span></span><br><span class="line"><span class="comment"># randint返回范围内的整数</span></span><br><span class="line">theta = np.random.randn(<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(n_epochs):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">        random_index = np.random.randint(m)    <span class="comment"># m个样本随机选一个样本</span></span><br><span class="line">        xi = X_b[random_index:random_index+<span class="number">1</span>]</span><br><span class="line">        yi = y[random_index:random_index+<span class="number">1</span>]</span><br><span class="line">        gradients = <span class="number">2</span> * xi.T.dot(xi.dot(theta)-yi)	<span class="comment"># 单个个体视为批量</span></span><br><span class="line">        eta = learning_schedule(epoch * m + i)    <span class="comment"># 根据迭代情况调整学习速率</span></span><br><span class="line">        theta = theta - eta * gradiens</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>theta</span><br><span class="line">array([[<span class="number">3.96100095</span>],[<span class="number">3.0580351</span> ]])</span><br></pre></td></tr></table></figure>
<p>通过使用Scikit-Learn完成<strong>线性回归的随机梯度下降，你需要使用SGDRegressor类，这个类默认优化的是均方差代价函数</strong>。下面的代码迭代了50代，其学习率eta为0.1，<strong>使用默认的learning schedule(与前面的不一样)</strong>，同时也没有添加任何正则项（penalty = None）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 因为这个函数需要的y是一个行向量，所以压扁;</span></span><br><span class="line"><span class="comment"># 另外，numpy.flatten() 与 numpy.ravel()将多维数组降位一维，前者会进行拷贝处理</span></span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> SGDRegressor</span><br><span class="line">sgd_reg = SGDRregressor(n_iter=<span class="number">50</span>, penalty=<span class="literal">None</span>, eta=<span class="number">0.1</span>)</span><br><span class="line">sgd_reg.fit(X,y.ravel())</span><br></pre></td></tr></table></figure>
<p>结果很接近正态方程的解</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sgd_reg.intercept_, sgd_reg.coef_</span><br><span class="line">(array([<span class="number">4.18380366</span>]),array([<span class="number">2.74205299</span>]))</span><br></pre></td></tr></table></figure>
<h3 id="小批量梯度下降"><a href="#小批量梯度下降" class="headerlink" title="小批量梯度下降"></a>小批量梯度下降</h3><p><strong>小批量梯度下降中，它则使用一个随机的小型实例集，小批量梯度下降在参数空间上的表现比随机梯度下降要好的多，尤其在有大量的小型实例集时，主要利用了矩阵运算的硬件优化</strong></p>
<p>也看一下这个算法的应用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">theta_path_mgd = []</span><br><span class="line"></span><br><span class="line">n_iterations = <span class="number">50</span></span><br><span class="line">minibatch_size = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">np.random.seed(<span class="number">42</span>)</span><br><span class="line">theta = np.random.randn(<span class="number">2</span>,<span class="number">1</span>)  <span class="comment"># random initialization</span></span><br><span class="line"></span><br><span class="line">t0, t1 = <span class="number">200</span>, <span class="number">1000</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">learning_schedule</span><span class="params">(t)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> t0 / (t + t1)</span><br><span class="line"></span><br><span class="line">t = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(n_iterations):</span><br><span class="line">    shuffled_indices = np.random.permutation(m)</span><br><span class="line">    X_b_shuffled = X_b[shuffled_indices]	<span class="comment"># 打乱所有样本顺序</span></span><br><span class="line">    y_shuffled = y[shuffled_indices]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, m, minibatch_size):</span><br><span class="line">        t += <span class="number">1</span></span><br><span class="line">        xi = X_b_shuffled[i:i+minibatch_size]</span><br><span class="line">        yi = y_shuffled[i:i+minibatch_size]</span><br><span class="line">        gradients = <span class="number">2</span>/minibatch_size * xi.T.dot(xi.dot(theta) - yi)</span><br><span class="line">        eta = learning_schedule(t)</span><br><span class="line">        theta = theta - eta * gradients</span><br><span class="line">        theta_path_mgd.append(theta)</span><br></pre></td></tr></table></figure>
<p><img src="/2018/07/14/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（三）：回归/04.jpg" alt></p>
<h1 id="多项式回归"><a href="#多项式回归" class="headerlink" title="多项式回归"></a>多项式回归</h1><p>如果你的数据实际上比简单的直线更复杂呢？ 令人惊讶的是，<strong>你依然可以使用线性模型来拟合非线性数据</strong>。 <strong>一个简单的方法是对每个特征进行加权后作为新的特征，然后训练一个线性模型在这个扩展的特征集。 这种方法称为多项式回归。</strong></p>
<p>于是，<strong>我们使用Scikit-Learning的PolynomialFeatures类进行训练数据集的转换，让训练集中每个特征的平方（2次多项式）作为新特征（在这种情况下，仅存在一个特征）</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> PolynomialFeatures</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>poly_features = PolynomialFeatures(degree=<span class="number">2</span>,include_bias=<span class="literal">False</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X_poly = poly_features.fit_transform(X)    <span class="comment"># 转换特征，包含原始特征和二次项特征</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X[<span class="number">0</span>]</span><br><span class="line">array([<span class="number">-0.75275929</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X_poly[<span class="number">0</span>]</span><br><span class="line">array([<span class="number">-0.75275929</span>, <span class="number">0.56664654</span>])</span><br></pre></td></tr></table></figure>
<p>现在包含原始特X并加上了这个特征的平方X^2。<strong>现在你可以在这个扩展训练集上使用LinearRegression模型进行拟合</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>lin_reg = LinearRegression()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lin_reg.fit(X_poly, y)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lin_reg.intercept_, lin_reg.coef_</span><br><span class="line">(array([ <span class="number">1.78134581</span>]), array([[ <span class="number">0.93366893</span>, <span class="number">0.56456263</span>]]))</span><br><span class="line"><span class="comment"># 模型预测函数y=0.56*x_1^2+0.93*x_1+1.78</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>请注意，当存在多个特征时，多项式回归能够找出特征之间的关系（这是普通线性回归模型无法做到的）。 这是因为LinearRegression会自动添加当前阶数下特征的所有组合。例如，如果有两个特征a,b，使用3阶（degree=3）的LinearRegression时，不仅仅只有a2,a3,b2,同时也会有它们的其他组合项ab,a2b,ab2。</p>
</blockquote>
<h1 id="学习曲线"><a href="#学习曲线" class="headerlink" title="学习曲线"></a>学习曲线</h1><p>我们可以使用交叉验证来估计一个模型的泛化能力。<strong>如果一个模型在训练集上表现良好，通过交叉验证指标却得出其泛化能力很差，那么你的模型就是过拟合了。如果在这两方面都表现不好，那么它就是欠拟合了</strong>。这种方法可以告诉我们，你的模型是太复杂了还是太简单了。</p>
<p><strong>另一种方法是观察学习曲线：画出模型在训练集上的表现，同时画出以训练集规模为自变量的训练集函数。为了得到图像，需要在训练集的不同规模子集上进行多次训练</strong>。下面的代码定义了一个函数，用来画出给定训练集后的模型学习曲线：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> mean_squared_error</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_learning_curves</span><span class="params">(model, X, y)</span>:</span></span><br><span class="line">    X_train, X_val, y_train, y_val = train_test_split(X, y, test_size=<span class="number">0.2</span>)</span><br><span class="line">    train_errors, val_errors = [], []</span><br><span class="line">    <span class="keyword">for</span> m <span class="keyword">in</span> range(<span class="number">1</span>, len(X_train)):    <span class="comment"># 根据样本规模画出模型的表现</span></span><br><span class="line">        model.fit(X_train[:m], y_train[:m])</span><br><span class="line">        y_train_predict = model.predict(X_train[:m])</span><br><span class="line">        y_val_predict = model.predict(X_val)</span><br><span class="line">        train_errors.append(mean_squared_error(y_train_predict, y_train[:m]))</span><br><span class="line">        val_errors.append(mean_squared_error(y_val_predict, y_val))</span><br><span class="line">plt.plot(np.sqrt(train_errors), <span class="string">"r-+"</span>, linewidth=<span class="number">2</span>, label=<span class="string">"train"</span>)    <span class="comment"># 训练损失</span></span><br><span class="line">plt.plot(np.sqrt(val_errors), <span class="string">"b-"</span>, linewidth=<span class="number">3</span>, label=<span class="string">"val"</span>)    <span class="comment"># 验证损失</span></span><br></pre></td></tr></table></figure>
<p>我们一起看一下简单线性回归模型的学习曲线</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lin_reg = LinearRegression()</span><br><span class="line">plot_learning_curves(lin_reg, X, y)</span><br></pre></td></tr></table></figure>
<p><img src="/2018/07/14/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（三）：回归/05.jpg" alt></p>
<p><strong>上面的曲线表现了一个典型的欠拟合模型，两条曲线都到达高原地带并趋于稳定，并且最后两条曲线非常接近，同时误差值非常大。</strong></p>
<blockquote>
<p>如果你的模型在训练集上是欠拟合的，添加更多的样例是没用的。你需要使用一个更复杂的模型或者找到更好的特征。</p>
</blockquote>
<p>现在让我们看一个在相同数据上10阶多项式模型拟合的学习曲线</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> Pipeline</span><br><span class="line"></span><br><span class="line">polynomial_regression = Pipeline((</span><br><span class="line">    (<span class="string">"poly_features"</span>, PolynomialFeatures(degree=<span class="number">10</span>, include_bias=<span class="literal">False</span>)),</span><br><span class="line">    (<span class="string">"sgd_reg"</span>, LinearRegression()),</span><br><span class="line">))</span><br><span class="line"></span><br><span class="line">plot_learning_curves(polynomial_regression, X, y)</span><br></pre></td></tr></table></figure>
<p><img src="/2018/07/14/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（三）：回归/06.jpg" alt></p>
<ul>
<li>在训练集上，误差要比线性回归模型低的多。</li>
<li>图中的两条曲线之间有间隔，这意味模型在训练集上的表现要比验证集上好的多，这也是模型过拟合的显著特点。当然，如果你使用了更大的训练数据，这两条曲线最后会非常的接近。</li>
</ul>
<blockquote>
<p>改善模型过拟合的一种方法是提供更多的训练数据，直到训练误差和验证误差相等</p>
</blockquote>
<p>在统计和机器学习领域有个重要的理论：一个模型的泛化误差由三个不同误差的和决定：</p>
<ul>
<li>偏差：泛化误差的这部分误差是由于错误的假设决定的。例如实际是一个二次模型，你却假设了一个线性模型。一个高偏差的模型最容易出现欠拟合。</li>
<li>方差：这部分误差是由于模型对训练数据的微小变化较为敏感，一个多自由度的模型更容易有高的方差（例如一个高阶多项式模型），因此会导致模型过拟合。</li>
<li>不可约误差：这部分误差是由于数据本身的噪声决定的。降低这部分误差的唯一方法就是进行数据清洗（例如：修复数据源，修复坏的传感器，识别和剔除异常值）。</li>
</ul>
<p>下图依次为欠拟合，过拟合，较合适。</p>
<p><img src="/2018/07/14/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（三）：回归/07.jpg" alt></p>
<h1 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h1><h2 id="范数"><a href="#范数" class="headerlink" title="范数"></a>范数</h2><p>器学习中有几个常用的范数，分别是：</p>
<ul>
<li>$L<em>1$−范数：$\Vert x\Vert_1 =\sum</em>{i=1}^n\vert x_i\vert$ </li>
<li>$L<em>2$−范数：$\Vert x\Vert</em> 2=(\sum_{i=1}^n\vert x_i^2\vert)^{\frac{1}{2}}$ </li>
<li>$L<em>p$−范数：$\Vert x\Vert_p =(\sum</em>{i=1}^n\vert x_i^p\vert)^{\frac{1}{p}}$ </li>
<li>$L<em>∞$−范数：$\Vert x\Vert</em>∞=lim<em>{p→∞}(\sum</em>{i=1}^n\vert x_i^p\vert)^{\frac{1}{p}}$</li>
</ul>
<h2 id="岭回归-Ridge"><a href="#岭回归-Ridge" class="headerlink" title="岭回归(Ridge)"></a>岭回归(Ridge)</h2><p>岭回归（也称为Tikhonov正则化）是线性回归的正则化版，是L2正则的基础，注意到这个正则项只有在训练过程中才会被加到代价函数。当得到完成训练的模型后，我们应该使用没有正则化的测量方法去评价模型的表现。</p>
<blockquote>
<p><strong>一般情况下，训练过程使用的代价函数和测试过程使用的评价函数不一样样的。除了正则化，还有一个不同：训练时的代价函数应该在优化过程中易于求导，而在测试过程中，评价函数更应该接近最后的客观表现</strong>。一个好的例子：在分类训练中我们使用对数损失（马上我们会讨论它）作为代价函数，但是我们却使用精确率/召回率来作为它的评价函数。</p>
</blockquote>
<p>岭回归代价函数:</p>
<script type="math/tex; mode=display">
J(\theta)=MSE(\theta)+\alpha\frac{1}{2}\sum\limits_{i=1}^n\theta_i^2</script><p><strong>超参数α 决定了你想正则化这个模型的强度,正则化强度越大，模型会越简单。如果α=0 那此时的岭回归便变为了线性回归。如果α 非常的大，所有的权重最后都接近与零，最后结果将是一条穿过数据平均值的水平直线</strong></p>
<p>值得注意的是偏差 $\theta_0$是没有被正则化的（累加运算的开始是 i=1而不是i=0）。如我定义<strong>$w$</strong>作为特征的权重向量($\theta_1$到$\theta_n$)，那么正则项可以简写成$\frac{1}{2} (\Vert w\Vert_2)^2$, 其中$\Vert \cdot \Vert_2$ 表示权重向量的L2范数。对于梯度下降来说仅仅在均方差梯度向量加上一项$\alpha w$ ,加上$\alpha\theta$是$1/2∗\alpha∗\theta^2$求偏导的结果</p>
<blockquote>
<p>在使用岭回归前，对<strong>数据进行放缩（可以使用StandardScaler）是非常重要的</strong>,算法对于输入特征的数值尺度（scale）非常敏感。<strong>大多数的正则化模型都是这样的</strong>。</p>
</blockquote>
<p>对线性回归来说，对于岭回归，我们可以使用封闭方程去计算，也可以使用梯度下降去处理.</p>
<p>岭回归的封闭方程的解</p>
<p>令</p>
<script type="math/tex; mode=display">
MES(\theta)=(X\theta-y)^T(X\theta-y)+\lambda \theta^T\theta</script><script type="math/tex; mode=display">
\frac{\partial }{\partial \theta}MSE(\theta) =X^TX\theta-X^Ty +\alpha\theta=0</script><p>求出</p>
<script type="math/tex; mode=display">
\hat{\theta} =({\mathbf{X}}^T\cdot\mathbf{X}+\alpha\mathbf{I})^{-1}\cdot{\mathbf{X}}^T\cdot\mathbf{y}</script><blockquote>
<p> 矩阵$I$是是一个除了左上角有一个0的n×n的<strong>单位矩阵</strong>，这个0代表偏差项。偏差$\theta_0$不被正则化的。</p>
</blockquote>
<p>下面是如何使用 Scikit-Learn 来进行封闭方程的求解（使用 Cholesky 法进行矩阵分解对上面公式进行变形）:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> Ridge</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ridge_reg = Ridge(alpha=<span class="number">1</span>, solver=<span class="string">"cholesky"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ridge_reg.fit(X, y)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ridge_reg.predict([[<span class="number">1.5</span>]])</span><br><span class="line">array([[ <span class="number">1.55071465</span>]]</span><br></pre></td></tr></table></figure>
<p>使用随机梯度法进行求解：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sgd_reg = SGDRegressor(penalty=<span class="string">"l2"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sgd_reg.fit(X, y.ravel())</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sgd_reg.predict([[<span class="number">1.5</span>]])</span><br><span class="line">array([[ <span class="number">1.13500145</span>]])</span><br></pre></td></tr></table></figure>
<p><code>penalty</code>参数指的是正则项的惩罚类型。指定“l2”表明你要在损失函数上添加一项：权重向量 L2范数平方的一半，这就是简单的岭回归。</p>
<h2 id="Lasso-回归"><a href="#Lasso-回归" class="headerlink" title="Lasso 回归"></a>Lasso 回归</h2><p>Lasso 回归（也称 Least Absolute Shrinkage，或者 Selection Operator Regression）是另一种正则化版的线性回归：L1正则的基础，就像岭回归那样，它也在损失函数上添加了一个正则化项，但是它使用权重向量的L1范数而不是权重向量L2范数的一半。</p>
<p>Lasso回归的代价函数:</p>
<script type="math/tex; mode=display">
J(\theta)=MSE(\theta)+\alpha\sum\limits_{i=1}^n\left|\theta_i \right|</script><blockquote>
<p><strong>Lasso回归的一个重要特征是它倾向于完全消除最不重要的特征的权重（即将它们设置为零）</strong></p>
</blockquote>
<p>下面是一个使用Lasso类的小Scikit-Learn示例。你也可以使用SGDRegressor(penalty=”l1”)来代替它</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> Lasso</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lasso_reg = Lasso(alpha=<span class="number">0.1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lasso_reg.fit(X, y)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lasso_reg.predict([[<span class="number">1.5</span>]])</span><br><span class="line">array([ <span class="number">1.53788174</span>]</span><br></pre></td></tr></table></figure>
<h2 id="弹性网络-ElasticNet"><a href="#弹性网络-ElasticNet" class="headerlink" title="弹性网络(ElasticNet)"></a>弹性网络(ElasticNet)</h2><p><strong>弹性网络介于Ridge回归和Lasso回归之间。它的正则项是Ridge回归和Lasso回归正则项的简单混合，同时你可以控制它们的混合率r，当r=0时，弹性网络就是Ridge回归，当r=1时，其就是Lasso回归</strong></p>
<p>弹性网络代价函数：</p>
<script type="math/tex; mode=display">
J(\theta)=MSE(\theta)+r\alpha\sum\limits_{i=1}^n\left|\theta_i \right|+\frac{1-r}{2}\alpha\sum\limits_{i=1}^n\theta_i^2</script><p>那么我们该如何选择线性回归，岭回归，Lasso回归，弹性网络呢？一般来说有一点正则项的表现更好，因此通常你应该避免使用简单的线性回归。<strong>岭回归是一个很好的首选项，但是如果你的特征仅有少数是真正有用的，你应该选择Lasso和弹性网络</strong>。就像我们讨论的那样，它两能够将无用特征的权重降为零。<strong>一般来说，弹性网络的表现要比Lasso好，因为当特征数量比样例的数量大的时候，或者特征之间有很强的相关性时，Lasso可能会表现的不规律</strong>。下面是一个使用Scikit-Learn 弹性网络ElasticNet（l1_ratio指的就是混合率r）的简单样例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> ElasticNet</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>elastic_net = ElasticNet(alpha=<span class="number">0.1</span>, l1_ratio=<span class="number">0.5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>elastic_net.fit(X, y)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>elastic_net.predict([[<span class="number">1.5</span>]])</span><br><span class="line">array([ <span class="number">1.54333232</span>])</span><br></pre></td></tr></table></figure>
<h2 id="正则化的作用"><a href="#正则化的作用" class="headerlink" title="正则化的作用"></a>正则化的作用</h2><p>那为什么正则化能起作用呢？首先L0范数（元素非零个数，严格上来说不能算是范数）和L1范数都可以实现权重稀疏。<strong>L1范数和L0范数可以实现稀疏，</strong>L1范数是L0范数的最优凸近似，<strong>L1因具有比L0更好的优化求解特性而被广泛应用</strong>。L1会趋向于产生少量的特征，而其他的特征都是0，<strong>而L2会选择更多的特征，这些特征都会接近于0</strong>。</p>
<p>L1范数的主要作用的实现稀疏特征，那么L2范数可以起什么样作用呢？</p>
<p>执行 L2 正则化对模型具有以下影响</p>
<ul>
<li>使权重的平均值接近于 0，且呈正态（钟形曲线或高斯曲线）分布。</li>
</ul>
<ul>
<li>使权重值接近于 0（但并非正好为 0）</li>
</ul>
<p><strong>L2 正则化可能会导致对于某些信息缺乏的特征，模型会学到适中的权重。L2 正则化降低较大权重的程度高于降低较小权重的程度。随着权重越来越接近于 0.0，L2 将权重“推”向 0.0 的力度越来越弱。L2 正则化会使相似度高(存在噪点)两个特征的权重几乎相同。按照我自己的理解，不同的权重会有不同程度的拟合效果，权重较小，低阶的w控制曲线的整体走势，权重较大，高阶的w控制曲线的局部形态，以此类推。这样看来L2正则项的作用就很明显了，要改变预测曲线的整体细节走势肯地会造成损失函数的不满，但是把曲线的形态熨平似乎并没有什么不妥，会降低过拟合的风险。</strong></p>
<p>L2除了能防止过拟合，提升模型的泛化能力。还有另外的一点好处：优化计算。  从优化或者数值计算的角度来说，L2范数有助于处理 condition number不好的情况下矩阵求逆很困难的问题。conditionnumber是一个矩阵（或者它所描述的线性系统）的稳定性或者敏感度的度量，如果一个矩阵的condition number在1附近，那么它就是well-conditioned的，如果远大于1，那么它就是ill-conditioned的，如果一个系统是ill-conditioned的，它的输出结果就不要太相信了。</p>
<p>然而，如果当我们的样本X的数目比每个样本的维度还要小的时候，矩阵XTX将会不是满秩的，也就是XTX会变得不可逆，所以w*就没办法直接计算出来了。或者更确切地说，将会有无穷多个解（因为我们方程组的个数小于未知数的个数）。也就是说，我们的数据不足以确定一个解，如果我们从所有可行解里随机选一个的话，很可能并不是真正好的解，总而言之，我们过拟合了。</p>
<p>但如果加上L2规则项，就变成了下面这种情况，就可以直接求逆了：</p>
<script type="math/tex; mode=display">
\hat{\theta} =({\mathbf{X}}^T\cdot\mathbf{X}+\alpha\mathbf{I})^{-1}\cdot{\mathbf{X}}^T\cdot\mathbf{y}</script><p> 这里面，专业点的描述是：要得到这个解，我们通常并不直接求矩阵的逆，而是通过解线性方程组的方式（例如高斯消元法）来计算。考虑没有规则项的时候，也就是λ=0的情况，如果矩阵XTX的 condition number 很大的话，解线性方程组就会在数值上相当不稳定，而这个规则项的引入则可以改善condition number。</p>
<h1 id="早期停止法（Early-Stopping）"><a href="#早期停止法（Early-Stopping）" class="headerlink" title="早期停止法（Early Stopping）"></a>早期停止法（Early Stopping）</h1><p>随着训练的进行，算法一直学习，它在训练集上的预测误差（RMSE）自然而然的下降。然而一段时间后，验证误差停止下降，并开始上升。这意味着模型在训练集上开始出现过拟合。一旦验证错误达到最小值，便提早停止训练.</p>
<p>随机梯度和小批量梯度下降不是平滑曲线，你可能很难知道它是否达到最小值。 一种解决方案是，只有<strong>在验证误差高于最小值一段时间后（你确信该模型不会变得更好了），才停止</strong>，<strong>之后将模型参数回滚到验证误差最小值</strong>。</p>
<p><img src="/2018/07/14/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（三）：回归/08.png" alt></p>
<p>下面是一个早期停止法的基础应用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.base <span class="keyword">import</span> clone</span><br><span class="line">sgd_reg = SGDRegressor(n_iter=<span class="number">1</span>, warm_start=<span class="literal">True</span>, penalty=<span class="literal">None</span>,learning_rate=<span class="string">"constant"</span>, eta0=<span class="number">0.0005</span>)</span><br><span class="line"></span><br><span class="line">minimum_val_error = float(<span class="string">"inf"</span>)</span><br><span class="line">best_epoch = <span class="literal">None</span></span><br><span class="line">best_model = <span class="literal">None</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">    sgd_reg.fit(X_train_poly_scaled, y_train)    <span class="comment"># 训练多项式的新特征，拟合非线性</span></span><br><span class="line">    y_val_predict = sgd_reg.predict(X_val_poly_scaled)</span><br><span class="line">    val_error = mean_squared_error(y_val_predict, y_val)</span><br><span class="line">    <span class="keyword">if</span> val_error &lt; minimum_val_error:</span><br><span class="line">        minimum_val_error = val_error</span><br><span class="line">        best_epoch = epoch</span><br><span class="line">        best_model = clone(sgd_reg)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：当warm_start=True时，调用fit()方法后，训练会从停下来的地方继续，而不是从头重新开始</p>
</blockquote>
<h1 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h1><p><strong>逻辑回归</strong>会生成一个<strong>介于 0 到 1 之间（不包括 0 和 1）的概率值</strong>，而不是确切地预测结果是 0 还是 1。以用于检测垃圾邮件的逻辑回归模型为例。如果此模型推断某一特定电子邮件的值为 0.932，则意味着该电子邮件是垃圾邮件的概率为 93.2%。<strong>更准确地说，这意味着在无限训练样本的极限情况下，模型预测其值为 0.932 的这组样本实际上有 93.2% 是垃圾邮件，其余的 6.8% 不是垃圾邮件。</strong></p>
<p>逻辑回归模型的概率估计（向量形式）：</p>
<script type="math/tex; mode=display">
\hat{p}=h_\theta(\mathbf{x})=\sigma(\theta^T  \cdot \mathbf{x})</script><p>Logistic函数（也称为logit），用σ() 表示，其是一个sigmoid函数（图像呈S型），它的输出是一个介于0和1之间的数字<br>逻辑函数(S函数)</p>
<script type="math/tex; mode=display">
\sigma(t)=\frac{1}{1+exp(-t)}</script><p>Logistic函数（也称为logit），用σ() 表示，其是一个sigmoid函数（图像呈S型），它的输出是一个介于0和1之间的数字<br>逻辑函数(S函数)</p>
<p><img src="/2018/07/14/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（三）：回归/09.jpg" alt></p>
<p>逻辑回归预测模型(σ() 概率输出以0.5作为二分类门槛):</p>
<p><img src="/2018/07/14/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（三）：回归/10.jpg" alt></p>
<p>单个样例的代价函数:</p>
<p><img src="/2018/07/14/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（三）：回归/11.jpg" alt></p>
<p><strong>这个代价函数是合理的，因为当t接近0时，-log(t)变得非常大，所以如果模型估计一个正例概率接近于0，那么代价函数将会很大，同时如果模型估计一个负例的概率接近1，那么代价函数同样会很大。 另一方面，当t接近于1时， -log(t)接近0，所以如果模型估计一个正例概率接近于0，那么代价函数接近于0，同时如果模型估计一个负例的概率接近0，那么代价函数同样会接近于0， 这正是我们想的.（简单来说,y=1时，概率p越接近1损失越小；相反y=0时，概率p越接近0时损失越小）</strong></p>
<p>整个训练集的代价函数只是所有训练实例的平均值。可以用一个表达式（你可以很容易证明）来统一表示，称为对数损失</p>
<p><strong>逻辑回归的代价函数（对数损失）：</strong></p>
<script type="math/tex; mode=display">
J(\theta)=-\frac{1}{m}\sum\limits_{i=1}^m\left[y^{(i)}log\left(\hat{p}^{(i)}\right)+\left(1-y^{(i)}\right)log\left(1-\hat{p}^{(i)}\right)\right]</script><p>但是这个代价函数对于求解最小化代价函数的θ 是没有公式解的（<strong>没有等价的正态方程</strong>）。 <strong>但好消息是，这个代价函数是凸的，所以梯度下降</strong>（或任何其他优化算法）一定能够找到全局最小值（如果学习速率不是太大，并且你等待足够长的时间）。下面公式给出了代价函数关于第j个模型参数θj 的偏导数。</p>
<p><img src="/2018/07/14/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（三）：回归/20.png" alt></p>
<p><img src="/2018/07/14/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（三）：回归/22.jpg" alt></p>
<p><img src="/2018/07/14/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（三）：回归/21.jpg" alt></p>
<p>逻辑回归代价函数的偏导数:</p>
<script type="math/tex; mode=display">
\frac{\partial}{\partial \theta_j}J(\theta_j)=\frac{1}{m} \sum\limits_{i=1}^m{\left(\sigma\left(\theta^T \cdot \mathbf{x}^{(i)}\right)-y^{(i)}\right)}{x_j}^{(i)}</script><p>这个公式首先计算每个样例的预测误差，然后误差项乘以第j项特征值，最后求出所有训练样例的平均值。 一旦你有了包含所有的偏导数的梯度向量，你便可以在梯度向量上使用批量梯度下降算法。 也就是说：你已经知道如何训练Logistic回归模型。 对于随机梯度下降，你当然只需要每一次使用一个实例，对于小批量梯度下降，你将每一次使用一个小型实例集。</p>
<h1 id="决策边界"><a href="#决策边界" class="headerlink" title="决策边界"></a>决策边界</h1><p>我们使用鸢尾花数据集来分析Logistic回归。 这是一个著名的数据集，其中包含150朵三种不同的鸢尾花的萼片和花瓣的长度和宽度。这三种鸢尾花为：Setosa，Versicolor，Virginica</p>
<p><img src="/2018/07/14/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（三）：回归/12.png" alt></p>
<p>让我们尝试建立一个分类器，仅仅<strong>使用花瓣的宽度特征来**</strong>识别Virginica**，首先让我们加载数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>iris = datasets.load_iris()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(iris.keys())</span><br><span class="line">[<span class="string">'data'</span>, <span class="string">'target_names'</span>, <span class="string">'feature_names'</span>, <span class="string">'target'</span>, <span class="string">'DESCR'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X = iris[<span class="string">"data"</span>][:, <span class="number">3</span>:] <span class="comment"># petal width</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = (iris[<span class="string">"target"</span>] == <span class="number">2</span>).astype(np.int)</span><br></pre></td></tr></table></figure>
<p>接下来，我们训练一个逻辑回归模型：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"></span><br><span class="line">log_reg = LogisticRegression()</span><br><span class="line">log_reg.fit(X, y) <span class="comment"># 训练模型</span></span><br></pre></td></tr></table></figure>
<p>我们来看看模型估计的花瓣宽度从0到3厘米的概率估计</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X_new = np.linspace(<span class="number">0</span>, <span class="number">3</span>, <span class="number">1000</span>).reshape(<span class="number">-1</span>, <span class="number">1</span>)    <span class="comment"># 构造花瓣宽度从0到3厘米的所有特征</span></span><br><span class="line">y_proba = log_reg.predict_proba(X_new)    <span class="comment"># 预测概率</span></span><br><span class="line">plt.plot(X_new, y_proba[:, <span class="number">1</span>], <span class="string">"g-"</span>, label=<span class="string">"Iris-Virginica"</span>)</span><br><span class="line">plt.plot(X_new, y_proba[:, <span class="number">0</span>], <span class="string">"b--"</span>, label=<span class="string">"Not Iris-Virginica"</span></span><br></pre></td></tr></table></figure>
<p><img src="/2018/07/14/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（三）：回归/13.png" alt></p>
<p>Virginica花的花瓣宽度（用三角形表示）在1.4厘米到2.5厘米之间，而其他种类的花（由正方形表示）通常具有较小的花瓣宽度，范围从0.1厘米到1.8厘米。注意，它们之间会有一些重叠。在大约2厘米以上时，分类器非常肯定这朵花是Virginica花（分类器此时输出一个非常高的概率值），而在1厘米以下时，它非常肯定这朵花不是Virginica花（不是Virginica花有非常高的概率）。在这两个极端之间，分类器是不确定的。但是，如果你使用它进行预测（使用predict()方法而不是predict_proba()方法），它将返回一个最可能的结果。<strong>因此，在1.6厘米左右存在一个决策边界，这时两类情况出现的概率都等于50％</strong>：如果花瓣宽度大于1.6厘米，则分类器将预测该花是Virginica，否则预测它不是（即使它有可能错了）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>log_reg.predict([[<span class="number">1.7</span>], [<span class="number">1.5</span>]])</span><br><span class="line">array([<span class="number">1</span>, <span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<p>下图的线性决策边界表示相同的数据集，<strong>但是这次使用了两个特征进行判断：花瓣的宽度和长度</strong>。 一旦训练完毕，Logistic回归分类器就可以根据这两个特征来估计一朵花是Virginica的可能性。 <strong>虚线表示这时两类情况出现的概率都等于50％：这是模型的决策边界。</strong> <strong>请注意，它是一个线性边界。每条平行线都代表一个分类标准下的两两个不同类的概率，从15％（左下角）到90％（右上角）。</strong>越过右上角分界线的点都有超过90％的概率是Virginica花</p>
<p><img src="/2018/07/14/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（三）：回归/14.png" alt></p>
<p>就像其他线性模型，逻辑回归模型也可以ℓ1或者ℓ2 惩罚使用进行正则化。Scikit-Learn默认添加了ℓ2 惩罚</p>
<blockquote>
<p>在Scikit-Learn的LogisticRegression模型中控制正则化强度的超参数不是α （与其他线性模型一样），而是是它的逆：C. C的值越大，模型正则化强度越低</p>
</blockquote>
<h1 id="Softmax回归"><a href="#Softmax回归" class="headerlink" title="Softmax回归"></a>Softmax回归</h1><p>Logistic回归模型可以直接推广到支持多类别分类，不必组合和训练多个二分类器， 其称为Softmax回归或多类别Logistic回归.</p>
<p>这个想法很简单：<strong>当给定一个实例x 时，Softmax回归模型首先计算k类的分数sk(x) ，然后将分数应用在Softmax函数（也称为归一化指数）上，估计出每类的概率</strong>。 计算sk(x) 的公式看起来很熟悉，因为它就像线性回归预测的公式一样</p>
<blockquote>
<p>k类的Softmax得分: $s_k(x)=θ^T⋅x$</p>
</blockquote>
<p>注意，每个类都有自己独一无二的参数向量θk 。 所有这些向量通常作为行放在参数矩阵Θ 中</p>
<p><strong>一旦你计算了样例x 的每一类的得分，你便可以通过Softmax函数估计出样例属于第k类的概率p^k ：通过计算e的sk(x) 次方，然后对它们进行归一化（除以所有分子的总和）</strong>。</p>
<p><img src="/2018/07/14/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（三）：回归/15.png" alt></p>
<p>和Logistic回归分类器一样，Softmax回归分类器将估计概率最高（它只是得分最高的类）的那类作为预测结果，如公式4-21所示</p>
<p><img src="/2018/07/14/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（三）：回归/16.png" alt></p>
<blockquote>
<p>Softmax回归分类器一次只能预测一个类（即它是多类的，但不是多输出的），因此它只能用于判断互斥的类别，如不同类型的植物。 你不能用它来识别一张照片中的多个人。</p>
</blockquote>
<p>现在我们知道这个模型如何估计概率并进行预测，接下来将介绍如何训练。<strong>我们的目标是建立一个模型在目标类别上有着较高的概率（因此其他类别的概率较低），最小化公式4-22可以达到这个目标，其表示了当前模型的代价函数，称为交叉熵，当模型对目标类得出了一个较低的概率，其会惩罚这个模型。 交叉熵通常用于衡量待测类别与目标类别的匹配程度（我们将在后面的章节中多次使用它）</strong></p>
<p><img src="/2018/07/14/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（三）：回归/17.png" alt></p>
<h1 id="交叉熵"><a href="#交叉熵" class="headerlink" title="交叉熵"></a>交叉熵</h1><p>熵的本质是香农信息量$log\frac{1}{p}$的期望。<strong>信息熵</strong>代表的是随机变量或整个系统的不确定性，熵越大，随机变量或系统的不确定性就越大。在给定的真实分布下，使用非真实分布所指定的策略消除系统的不确定性所需要付出的努力的大小（猜题次数、编码长度等），就是用<strong>交叉熵</strong>来衡量的。</p>
<p>现有关于样本集的2个概率分布p和q，其中p为真实分布，q非真实分布。按照真实分布p来衡量识别一个样本的所需要的编码长度的期望(即平均编码长度)为$H(p)=\sum \limits<em>{i=1}^n p(i)\cdot log\frac{1}{p(i)}$ 。如果使用错误分布q来表示来自真实分布p的平均编码长度，则应该是$H(p,q)=\sum\limits</em>{i=1}^n p(i)\cdot log\frac{1}{q(i)}$ 。因为用q来编码的样本来自分布p，所以期望H(p,q)中概率是p(i)。<strong>H(p,q)我们称之为“交叉熵”</strong>。<strong>当q为真实分布p时，交叉熵达到最小值1，否则将会大于1</strong>。我们将由q得到的平均编码长度比由p得到的平均编码长度多出的bit数称为“<strong>相对熵</strong>”：$D(p\Vert q)=H(p,q)-H(p)=\sum\limits_{i=1}^n p(i)\cdot log\frac{p(i)}{q(i)}$  ,其又被称为KL散度(Kullback–Leibler divergence，KLD)。<strong>它表示两个概率分布的差异性</strong>：差异越大则相对熵越大，差异越小则相对熵越小，特别地，若2者相同则熵为0。</p>
<p>另外，<strong>通常“相对熵”也可称为“交叉熵”</strong>，因为真实分布p是固定的，D(p||q)由H(p,q)决定。<strong>所以他们得到的相对效果是一样程度的</strong>。当然也有特殊情况，彼时两者须区别对待。</p>
<p><img src="/2018/07/14/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（三）：回归/18.png" alt></p>
<p><strong>上面这个公式由公式4-22求导得到，过程和逻辑回归损失函数一样，只不过将每个类别都纳入计算而已，当k=2则计算正负两类，与逻辑回归一模一样。现在你可以计算每一类的梯度向量，然后使用梯度下降（或者其他的优化算法）找到使得代价函数达到最小值的参数矩阵Θ</strong>。</p>
<p>让我们使用Softmax回归对三种鸢尾花进行分类。当你使用LogisticRregression对模型进行训练时，<strong>Scikit_Learn默认使用的是一对多模型，但是你可以设置multi_class参数为“multinomial”来把它改变为Softmax回归。你还必须指定一个支持Softmax回归的求解器，例如“lbfgs”求解器</strong>（有关更多详细信息，请参阅Scikit-Learn的文档）。<strong>其默认使用ℓ12 正则化，你可以使用超参数C控制它。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = iris[<span class="string">"data"</span>][:, (<span class="number">2</span>, <span class="number">3</span>)] <span class="comment"># petal length, petal width</span></span><br><span class="line">y = iris[<span class="string">"target"</span>]</span><br><span class="line"></span><br><span class="line">softmax_reg = LogisticRegression(multi_class=<span class="string">"multinomial"</span>,solver=<span class="string">"lbfgs"</span>, C=<span class="number">10</span>)</span><br><span class="line">softmax_reg.fit(X, y)</span><br></pre></td></tr></table></figure>
<p>所以下次你发现一个花瓣长为5厘米，宽为2厘米的鸢尾花时，你可以问你的模型你它是哪一类鸢尾花，它会回答94.2％是Virginica花（第二类），或者5.8％是其他鸢尾花</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>softmax_reg.predict([[<span class="number">5</span>, <span class="number">2</span>]])</span><br><span class="line">array([<span class="number">2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>softmax_reg.predict_proba([[<span class="number">5</span>, <span class="number">2</span>]])</span><br><span class="line">array([[ <span class="number">6.33134078e-07</span>, <span class="number">5.75276067e-02</span>, <span class="number">9.42471760e-01</span>]])是</span><br></pre></td></tr></table></figure>
<p><img src="/2018/07/14/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（三）：回归/19.png" alt></p>
<p>图4-25用不同背景色表示了结果的决策边界。注意，任何两个类之间的决策边界是线性的。 该图的曲线表示Versicolor类的概率（例如，用0.450标记的曲线表示45％的概率边界）。注意模型也可以预测一个概率低于50％的类。 例如，在所有决策边界相遇的地方，所有类的估计概率相等，分别为33％。</p>
<h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><ol>
<li>如果你有一个数百万特征的训练集，你应该选择哪种线性回归训练算法？</li>
<li>假设你训练集中特征的数值尺度（scale）有着非常大的差异，哪种算法会受到影响？有多大的影响？对于这些影响你可以做什么？</li>
<li>训练 Logistic 回归模型时，梯度下降是否会陷入局部最低点？</li>
<li>在有足够的训练时间下，是否所有的梯度下降都会得到相同的模型参数？</li>
<li>假设你使用批量梯度下降法，画出每一代的验证误差。当你发现验证误差一直增大，接下来会发生什么？你怎么解决这个问题？</li>
<li>当验证误差升高时，立即停止小批量梯度下降是否是一个好主意？</li>
<li>哪个梯度下降算法（在我们讨论的那些算法中）可以最快到达解的附近？哪个的确实会收敛？怎么使其他算法也收敛？</li>
<li>假设你使用多项式回归，画出学习曲线，在图上发现学习误差和验证误差之间有着很大的间隙。这表示发生了什么？有哪三种方法可以解决这个问题？</li>
<li>假设你使用岭回归，并发现训练误差和验证误差都很高，并且几乎相等。你的模型表现是高偏差还是高方差？这时你应该增大正则化参数$\alpha$ 还是降低它？</li>
<li>你为什么要这样做：</li>
</ol>
<ul>
<li>使用岭回归代替线性回归？</li>
<li>Lasso 回归代替岭回归？</li>
<li>弹性网络代替 Lasso 回归？</li>
</ul>
<ol>
<li>假设你想判断一副图片是室内还是室外，白天还是晚上。你应该选择二个逻辑回归分类器，还是一个 Softmax 分类器？</li>
</ol>
<hr>
<p>1、如果您拥有具有数百万个功能的训练集，则可以使用随机梯度下降或小批量梯度下降，如果计算内存足够的话，则可使用批量梯度下降。 但是你不能使用正态方程，因为计算复杂度随着特征数量的增长而快速增长（超过二次方），求矩阵特征的逆非常花时间。</p>
<p>2、如果训练集中的特征具有非常不同的比例，则损失函数将具有细长碗的形状，因此梯度下降优化将花费很长时间来收敛。 要解决此问题，您应该在训练模型之前缩放数据。 另外，正态方程在没有缩放的情况下可以正常工作。</p>
<p>3、在训练Logistic回归模型时，梯度下降不会陷入在局部最小值，因为它的损失函数是凸函数的。</p>
<p>4、如果优化问题是凸函数的（例如线性回归或逻辑回归），并且假设学习速率不是太高，则所有梯度下降算法将接近全局最优并最终产生相当类似的模型。 但是，除非你逐渐降低学习率，否则随机梯度下降和小批量GD将永远不会真正收敛; 相反，他们将继续围绕全局最佳状态来回跳跃。 这意味着即使你让它们运行很长时间，这些Gradient Descent算法也会产生略微不同的模型。</p>
<p>5、如果验证误差在每个时期之后一直上升，则一种可能性是学习速率太高并且算法发散。如果训练误差也会增加，那么这显然是问题，你应该降低学习率。 但是，如果训练错误没有增加，那么您的模型将过度拟合训练集，您应该停止训练。</p>
<p>6、由于随机性，随机梯度下降和小批量梯度下降都不能保证在每次训练迭代中都取得进展。 因此，如果在验证损失增加时立即停止训练，你可能会在达到最佳值之前过早停止。 更好的选择是定期保存模型，当它长时间没有改进时（意味着它可能永远不会超过记录），你可以恢复到最佳保存模型。</p>
<p>7、随机梯度下降具有最快的训练迭代，因为它一次只考虑一个训练实例，因此它通常是第一个到达全局最优值（或具有非常小的小批量大小的Minibatch GD）附近。 但是，如果有足够的训练时间，只有批量梯度下降实际上会收敛。 如上所述，除非你逐渐降低学习速度，否则随机指标GD和小批量GD将在最佳状态下反弹。</p>
<p>8、如果验证误差远远高于训练误差，则可能是因为你的模型过度拟合了训练集。 尝试解决此问题的一种方法是降低多项式度：具有较少自由度的模型不太可能过度拟合。 你可以尝试的另一件事是加入正则项，例如，通过在成本函数中添加ℓ2惩罚（岭）或ℓ1惩罚（Lasso）。 这也会降低模型的自由度。 最后，你还可以尝试增加训练集的大小。</p>
<p>9、如果训练误差和验证误差几乎相等且相当高，则模型可能欠拟合训练集，这意味着它具有高偏差。 你应该尝试减少正则化超参数α。</p>
<p>10、</p>
<ul>
<li>具有一些正则化的模型通常比没有任何正则化的模型表现更好，因此通常应该优先选择岭回归而不是简单的线性回归。</li>
<li>Lasso回归使用ℓ1惩罚，这往往会将权重降低到恰好为零。 这导致稀疏模型，除了最重要的权重之外，所有权重都为零。 这是一种自动执行特征选择的方法，如果你怀疑只有少数特征真正重要，这是很好的。 当你不确定时，你应该更偏向岭回归。</li>
<li>弹性网络常比Lasso更受欢迎，因为Lasso在某些情况下可能表现不稳定（当有些特征强烈相关或者特征数量比训练样本数量还要多）。 但是，它确实添加了一个额外的超参数来调整。 如果你想要具有稳定行为的Lasso，你可以使用弹性网络，并设置比率r接近1。</li>
</ul>
<p>11、如果你想将图片分类为室外/室内和白天/夜晚，因为这些不是专属类别（即，所有四种组合都是可能的），你应该训练两个Logistic回归分类器。</p>
]]></content>
      <categories>
        <category>Sklearn 与 TensorFlow 机器学习实用指南</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>线性回归</tag>
        <tag>逻辑回归</tag>
        <tag>softmax</tag>
        <tag>正则化</tag>
      </tags>
  </entry>
  <entry>
    <title>Sklearn 与 TensorFlow 机器学习实用指南（二）：分类</title>
    <url>/2018/07/11/Sklearn%20%E4%B8%8E%20TensorFlow%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E7%94%A8%E6%8C%87%E5%8D%97/Sklearn-%E4%B8%8E-TensorFlow-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E7%94%A8%E6%8C%87%E5%8D%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="MNIST：手写数字分类数据集"><a href="#MNIST：手写数字分类数据集" class="headerlink" title="MNIST：手写数字分类数据集"></a>MNIST：手写数字分类数据集</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> fetch_mldata</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mnist = fetch_mldata(<span class="string">'MNIST original'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mnist</span><br><span class="line">&#123;<span class="string">'COL_NAMES'</span>: [<span class="string">'label'</span>, <span class="string">'data'</span>],</span><br><span class="line"><span class="string">'DESCR'</span>: <span class="string">'mldata.org dataset: mnist-original'</span>,   <span class="comment"># DESCR键描述数据集</span></span><br><span class="line"><span class="string">'data'</span>: array([[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, ..., <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],    <span class="comment"># 数组的一行表示一个样例，一列表示一个特征</span></span><br><span class="line">                [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, ..., <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">                [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, ..., <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">                ...,</span><br><span class="line">                [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, ..., <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">                [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, ..., <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">                [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, ..., <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]], dtype=uint8),</span><br><span class="line"><span class="string">'target'</span>: array([ <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, ..., <span class="number">9.</span>, <span class="number">9.</span>, <span class="number">9.</span>])&#125;    <span class="comment"># target键存放一个标签数组</span></span><br><span class="line">X, y = mnist[<span class="string">"data"</span>], mnist[<span class="string">"target"</span>] <span class="comment"># 获取样本或标签</span></span><br></pre></td></tr></table></figure>
<p>MNIST 有 70000 张图片，每张图片有 784 个特征。<strong>这是因为每个图片都是28×28像素的，并且每个像素的值介于 0~255 之间</strong>。让我们看一看数据集的某一个数字。你只需要将某个实例的特征向量，reshape为28*28的数组，然后使用 Matplotlib 的imshow函数展示出来</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">some_digit = X[<span class="number">36000</span>]    </span><br><span class="line">some_digit_image = some_digit.reshape(<span class="number">28</span>, <span class="number">28</span>)    <span class="comment"># 将样本转为28大小的像素矩阵</span></span><br><span class="line"><span class="comment"># 按‘0’‘1’数值转为灰度图像 </span></span><br><span class="line"><span class="comment"># interpolation当小图像放大时,interpolation ='nearest'效果很好，否则用None。</span></span><br><span class="line">plt.imshow(some_digit_image, cmap = matplotlib.cm.binary, interpolation=<span class="string">"nearest"</span>)    </span><br><span class="line">plt.axis(<span class="string">"off"</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2018/07/11/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（二）：分类/01.jpg" alt></p>
<p>MNIST 数据集已经事先被分成了一个训练集（前 6000 张图片）和一个测试集（最后 10000 张图片）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X_train, X_test, y_train, y_test = X[:<span class="number">60000</span>], X[<span class="number">60000</span>:], y[:<span class="number">60000</span>], y[<span class="number">60000</span>:]</span><br></pre></td></tr></table></figure>
<p>打乱数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">shuffle_index = np.random.permutation(<span class="number">60000</span>)</span><br><span class="line">X_train, y_train = X_train[shuffle_index], y_train[shuffle_index]</span><br></pre></td></tr></table></figure>
<h2 id="训练一个二分类器"><a href="#训练一个二分类器" class="headerlink" title="训练一个二分类器"></a>训练一个二分类器</h2><p>现在我们简化一下问题，只尝试去识别一个数字，比如说，数字 5。这个“数字 5 检测器”就是一个二分类器，能够识别两类别，“是 5”和“非 5”。让我们为这个分类任务创建目标向量：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在训练和测试集上区分是否为5转为0,1标签矩阵</span></span><br><span class="line">y_train_5 = (y_train == <span class="number">5</span>) <span class="comment"># True for all 5s, False for all other digits.</span></span><br><span class="line">y_test_5 = (y_test == <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p><strong>采用随机梯度下降分类器</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> SGDClassifier</span><br><span class="line">sgd_clf = SGDClassifier(random_state=<span class="number">42</span>)    <span class="comment">#如果你想重现结果，你应该固定参数random_state </span></span><br><span class="line">sgd_clf.fit(X_train, y_train_5)</span><br></pre></td></tr></table></figure>
<p>输出预测结果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sgd_clf.predict([some_digit])</span><br><span class="line">array([ <span class="literal">True</span>], dtype=bool)</span><br></pre></td></tr></table></figure>
<p>分类器猜测这个数字代表 5（True）。看起来在这个例子当中，它猜对了。现在让我们评估这个模型的性能。</p>
<h2 id="使用交叉验证测量准确性"><a href="#使用交叉验证测量准确性" class="headerlink" title="使用交叉验证测量准确性"></a>使用交叉验证测量准确性</h2><p>评估一个模型的好方法是使用交叉验证，像之前提过一样。<strong>但有时为了有更好的控制权，可以写自己版本的交叉验证，以下代码粗略地做了和cross_val_score()相同的事情，并且输出相同的结果</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> StratifiedKFold</span><br><span class="line"><span class="keyword">from</span> sklearn.base <span class="keyword">import</span> clone</span><br><span class="line">skfolds = StratifiedKFold(n_splits=<span class="number">3</span>, random_state=<span class="number">42</span>)    <span class="comment"># 三组</span></span><br><span class="line"><span class="keyword">for</span> train_index, test_index <span class="keyword">in</span> skfolds.split(X_train, y_train_5):</span><br><span class="line">    clone_clf = clone(sgd_clf)</span><br><span class="line">    X_train_folds = X_train[train_index]</span><br><span class="line">    y_train_folds = (y_train_5[train_index])</span><br><span class="line">    X_test_fold = X_train[test_index]</span><br><span class="line">    y_test_fold = (y_train_5[test_index])</span><br><span class="line">    clone_clf.fit(X_train_folds, y_train_folds)</span><br><span class="line">    y_pred = clone_clf.predict(X_test_fold)</span><br><span class="line">    n_correct = sum(y_pred == y_test_fold)</span><br><span class="line">    print(n_correct / len(y_pred)) <span class="comment"># prints 0.9502, 0.96565 and 0.96495</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>StratifiedKFold类实现了分层采样，生成的折（fold）包含了各类相应比例的样例。在每一次迭代，上述代码生成分类器的一个克隆版本，在训练折（training folds）的克隆版本上进行训，在测试折（test folds）上进行预测。然后它计算出被正确预测的数目和输出正确预测的比例。</p>
</blockquote>
<p><strong>这里使用sklearn提供的cross_val_score()函数来评估SGDClassifier模型</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> cross_val_score</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cross_val_score(sgd_clf, X_train, y_train_5, cv=<span class="number">3</span>, scoring=<span class="string">"accuracy"</span>)</span><br><span class="line">array([ <span class="number">0.9502</span> , <span class="number">0.96565</span>, <span class="number">0.96495</span>]</span><br></pre></td></tr></table></figure>
<p>有大于 95% 的精度（accuracy），特别高！但要注意这是一个有数据偏差的数据集，这是因为只有 10% 的图片是数字 5，所以你总是猜测某张图片不是 5，你也会有90%的可能性是对的。处理这类问题，要回归到之前讲的准确率和召回率和ORC曲线了。</p>
<h2 id="混淆矩阵"><a href="#混淆矩阵" class="headerlink" title="混淆矩阵"></a>混淆矩阵</h2><p>对分类器来说，一个好得多的性能评估指标是混淆矩阵，<strong>为了计算混淆矩阵，首先你需要有一系列的预测值，这样才能将预测值与真实值做比较</strong>。你或许想在测试集上做预测。但是我们现在先不碰它。（记住，只有当你处于项目的尾声，当你准备上线一个分类器的时候，你才应该使用测试集）。<strong>相反，你应该使用cross_val_predict()函数</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> cross_val_predict</span><br><span class="line">y_train_pred = cross_val_predict(sgd_clf, X_train, y_train_5, cv=<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p><strong>就像 cross_val_score()，cross_val_predict()也使用 K 折交叉验证。它不是返回一个评估分数，而是返回基于每一个测试折做出的一个预测值</strong>。这意味着，对于每一个训练集的样例，你得到一个干净的预测（“干净”是说一个模型在训练过程当中没有用到测试集的数据）。</p>
<p><strong>现在使用 confusion_matrix()函数，你将会得到一个混淆矩阵</strong>。传递目标类(y_train_5)和预测类（y_train_pred）给它。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> confusion_matrix</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>confusion_matrix(y_train_5, y_train_pred)</span><br><span class="line">array([[<span class="number">53272</span>, <span class="number">1307</span>],</span><br><span class="line">        [ <span class="number">1077</span>, <span class="number">4344</span>]])</span><br></pre></td></tr></table></figure>
<p><strong>混淆矩阵中的每一行表示一个实际的类, 而每一列表示一个预测的类</strong>。该矩阵的第一行认为“非 5”（反例）中的 53272 张被正确归类为 “非 5”（他们被称为真反例，true negatives）, 而其余 1307 被错误归类为”是 5” （假正例，false positives）。第二行认为“是 5” （正例）中的 1077 被错误地归类为“非 5”（假反例，false negatives），其余 4344 正确分类为 “是 5”类（真正例，true positives）。一个完美的分类器将只有真反例和真正例，所以混淆矩阵的非零值仅在其主对角线（左上至右下）。</p>
<p><img src="/2018/07/11/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（二）：分类/12.png" alt></p>
<p>Scikit-Learn 提供了一些函数去计算分类器的指标，包括精确率和召回率（之前的文章是tensorflow，这里主要讲Scikit-Learn）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> precision_score, recall_score</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>precision_score(y_train_5, y_pred) <span class="comment"># == 4344 / (4344 + 1307)</span></span><br><span class="line"><span class="number">0.76871350203503808</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>recall_score(y_train_5, y_train_pred) <span class="comment"># == 4344 / (4344 + 1077)</span></span><br><span class="line"><span class="number">0.79136690647482011</span></span><br></pre></td></tr></table></figure>
<p>通常结合精确率和召回率会更加方便，这个指标叫做“F1 值”，特别是当你需要一个简单的方法去比较两个分类器的优劣的时候。F1 值是精确率和召回率的调和平均。普通的平均值平等地看待所有的值，而调和平均会给小的值更大的权重。<strong>所以，要想分类器得到一个高的 F1 值，需要召回率和精确率</strong>。</p>
<script type="math/tex; mode=display">F1 = \frac{2}{\frac{1}{precision} + \frac{1}{recall}} = 2 * \frac{precison * recall}{precison + recall} = \frac{TP}{TP + \frac{FN + FP}{2}}</script><p>为了计算 F1 值，简单调用f1_score()</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> f1_score</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1_score(y_train_5, y_pred)</span><br><span class="line"><span class="number">0.78468208092485547</span></span><br></pre></td></tr></table></figure>
<p>F1 支持那些有着相近精确率和召回率的分类器。这不会总是你想要的。有的场景你会绝大程度地关心精确率，而另外一些场景你会更关心召回率。不幸的是，你不能同时拥有两者。增加精确率会降低召回率，反之亦然。这叫做精确率与召回率之间的折衷<strong>.</strong>  <strong>一般来说，提高分类阈值会减少假正例，从而提高精确率。降低分类阈值会提高召回率。</strong></p>
<p><strong>Scikit-Learn 不让你直接设置阈值，但是它给你提供了设置决策分数的方法，这个决策分数可以用来产生预测。它不是调用分类器的predict()方法，而是调用decision_function()方法。这个方法返回每一个样例的分数值，然后基于这个分数值，使用你想要的任何阈值做出预测。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>y_scores = sgd_clf.decision_function([some_digit])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y_scores</span><br><span class="line">array([ <span class="number">161855.74572176</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>threshold = <span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y_some_digit_pred = (y_scores &gt; threshold)</span><br><span class="line">array([ <span class="literal">True</span>], dtype=bool)</span><br></pre></td></tr></table></figure>
<p>SGDClassifier用了一个等于 0 的阈值，所以前面的代码返回了跟predict()方法一样的结果（都返回了true）。<strong>让我们提高这个阈值：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>threshold = <span class="number">200000</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y_some_digit_pred = (y_scores &gt; threshold)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y_some_digit_pred</span><br><span class="line">array([<span class="literal">False</span>], dtype=bool)</span><br></pre></td></tr></table></figure>
<p>这证明了提高阈值会降调召回率。这个图片实际就是数字 5，当阈值等于 0 的时候，分类器可以探测到这是一个 5，当阈值提高到 20000 的时候，分类器将不能探测到这是数字 5。</p>
<p><strong>那么，你应该如何使用哪个阈值呢？首先，你需要再次使用cross_val_predict()得到每一个样例的分数值，但是这一次指定返回一个决策分数，而不是预测值。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y_scores = cross_val_predict(sgd_clf, X_train, y_train_5, cv=<span class="number">3</span>, </span><br><span class="line">                            method=<span class="string">"decision_function"</span>)</span><br></pre></td></tr></table></figure>
<p><strong>现在有了这些分数值。对于任何可能的阈值，使用precision_recall_curve(),你都可以计算精确率和召回率:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> precision_recall_curve</span><br><span class="line">precisions, recalls, thresholds = precision_recall_curve(y_train_5, y_scores)</span><br></pre></td></tr></table></figure>
<p>最后，你可以使用 Matplotlib 画出精确率和召回率，这里把精确率和召回率当作是阈值的一个函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_precision_recall_vs_threshold</span><span class="params">(precisions, recalls, thresholds)</span>:</span></span><br><span class="line">    plt.plot(thresholds, precisions[:<span class="number">-1</span>], <span class="string">"b--"</span>, label=<span class="string">"Precision"</span>)</span><br><span class="line">    plt.plot(thresholds, recalls[:<span class="number">-1</span>], <span class="string">"g-"</span>, label=<span class="string">"Recall"</span>)</span><br><span class="line">    plt.xlabel(<span class="string">"Threshold"</span>)</span><br><span class="line">    plt.legend(loc=<span class="string">"upper left"</span>)</span><br><span class="line">    plt.ylim([<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">plot_precision_recall_vs_threshold(precisions, recalls, thresholds)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2018/07/11/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（二）：分类/02.png" alt></p>
<blockquote>
<p>你也许会好奇为什么精确率曲线比召回率曲线更加起伏不平（右上部分）。原因是精确率有时候会降低，尽管当你提高阈值的时候，通常来说精确率会随之提高。另一方面，当阈值提高时候，召回率只会降低。这也就说明了为什么召回率的曲线更加平滑。</p>
</blockquote>
<p>现在你可以选择适合你任务的最佳阈值。<strong>另一个选出好的精确率/召回率折衷的方法是直接画出精确率对召回率的曲线(PR曲线)</strong>，如图所示。</p>
<p><img src="/2018/07/11/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（二）：分类/03.png" alt></p>
<p><strong>我们假设你决定达到 90% 的准确率，在 70000 附近找到一个阈值。为了作出预测（目前为止只在训练集上预测），你可以运行以下代码，而不是运行分类器的predict()方法。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y_train_pred_90 = (y_scores &gt; <span class="number">70000</span>)</span><br></pre></td></tr></table></figure>
<p>检查这些预测的准确率和召回率：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>precision_score(y_train_5, y_train_pred_90)</span><br><span class="line"><span class="number">0.8998702983138781</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>recall_score(y_train_5, y_train_pred_90)</span><br><span class="line"><span class="number">0.63991883416343853</span></span><br></pre></td></tr></table></figure>
<h2 id="ROC-曲线"><a href="#ROC-曲线" class="headerlink" title="ROC 曲线"></a>ROC 曲线</h2><p>受试者工作特征（ROC）曲线是另一个二分类器常用的工具。它非常类似与准确率/召回率曲线（PR曲线），但不是画出准确率对召回率的曲线，<strong>ROC 曲线是真正例率（true positive rate，另一个名字叫做召回率）对假正例率（false positive rate, FPR）的曲线</strong>。FPR 是反例被错误分成正例的比率。它等于 1 减去真反例率（true negative rate， TNR）。TNR是反例被正确分类的比率。TNR也叫做特异性。所以 ROC 曲线画出召回率对（1 减特异性）的曲线。</p>
<script type="math/tex; mode=display">TPR = \frac{TP}{P} = \frac{TP}{TP+FN}</script><script type="math/tex; mode=display">
FPR = \frac{FP}{N} = \frac{FP}{FP+TN} = 1-TNR</script><script type="math/tex; mode=display">
TNR = \frac{TN}{N} = \frac{TN}{TN+FP}</script><p><img src="/2018/07/11/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（二）：分类/04.png" alt></p>
<p><strong>为了画出 ROC 曲线，你首先需要计算各种不同阈值下的 TPR、FPR，使用roc_curve()函数：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> roc_curve</span><br><span class="line">fpr, tpr, thresholds = roc_curve(y_train_5, y_scores)</span><br></pre></td></tr></table></figure>
<p>然后你可以使用 matplotlib，画出 FPR 对 TPR 的曲线</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_roc_curve</span><span class="params">(fpr, tpr, label=None)</span>:</span></span><br><span class="line">    plt.plot(fpr, tpr, linewidth=<span class="number">2</span>, label=label)</span><br><span class="line">    plt.plot([<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>], <span class="string">'k--'</span>)</span><br><span class="line">    plt.axis([<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">    plt.xlabel(<span class="string">'False Positive Rate'</span>)</span><br><span class="line">    plt.ylabel(<span class="string">'True Positive Rate'</span>)</span><br><span class="line">plot_roc_curve(fpr, tpr)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2018/07/11/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（二）：分类/05.png" alt></p>
<p>一个比较分类器之间优劣的方法是：测量ROC曲线下的面积（AUC）**。一个完美的分类器的 ROC AUC 等于 1，而一个纯随机分类器的 ROC AUC 等于 0.5。Scikit-Learn 提供了一个函数来计算 ROC AUC：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> roc_auc_score</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>roc_auc_score(y_train_5, y_scores)</span><br><span class="line"><span class="number">0.97061072797174941</span></span><br></pre></td></tr></table></figure>
<p><strong>因为 ROC 曲线跟准确率/召回率曲线（或者叫 PR）很类似，你或许会好奇如何决定使用哪一个曲线呢？一个笨拙的规则是，优先使用 PR 曲线当正例很少，或者当你关注假正例多于假反例的时候。其他情况使用 ROC 曲线</strong>。举例子，回顾前面的 ROC 曲线和 ROC AUC 数值，你或许人为这个分类器很棒。但是这几乎全是因为只有少数正例（“是 5”），而大部分是反例（“非 5”）。相反，PR 曲线清楚显示出这个分类器还有很大的改善空间（PR 曲线应该尽可能地靠近右上角）。</p>
<p>我们训练一个RandomForestClassifier，然后拿它的的ROC曲线和ROC AUC数值去跟SGDClassifier的比较。<strong>首先你需要得到训练集每个样例的数值</strong>。<strong>但是由于随机森林分类器的工作方式，RandomForestClassifier不提供decision_function()方法。相反，它提供了predict_proba()方法</strong>。Skikit-Learn分类器通常二者中的一个。<strong>predict_proba()方法返回一个数组，数组的每一行代表一个样例，每一列代表一个类。数组当中的值的意思是：给定一个样例属于给定类的概率。比如，70%的概率这幅图是数字 5。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier</span><br><span class="line">forest_clf = RandomForestClassifier(random_state=<span class="number">42</span>)</span><br><span class="line">y_probas_forest = cross_val_predict(forest_clf, X_train, y_train_5, cv=<span class="number">3</span>,</span><br><span class="line">                                    method=<span class="string">"predict_proba"</span>)</span><br></pre></td></tr></table></figure>
<p><strong>但是要画 ROC 曲线，你需要的是样例的分数，而不是概率</strong>。一个简单的解决方法是使用正例的概率当作样例的分数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y_scores_forest = y_probas_forest[:, <span class="number">1</span>] <span class="comment"># score = proba of positive class 预测为正例概率</span></span><br><span class="line">fpr_forest, tpr_forest, thresholds_forest = roc_curve(y_train_5,y_scores_forest)</span><br></pre></td></tr></table></figure>
<p>现在你即将得到 ROC 曲线。<strong>将前面一个分类器的 ROC 曲线一并画出来是很有用的，可以清楚地进行比较</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.plot(fpr, tpr, <span class="string">"b:"</span>, label=<span class="string">"SGD"</span>)</span><br><span class="line">plot_roc_curve(fpr_forest, tpr_forest, <span class="string">"Random Forest"</span>)</span><br><span class="line">plt.legend(loc=<span class="string">"bottom right"</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2018/07/11/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（二）：分类/06.png" alt></p>
<p>如你所见，RandomForestClassifier的 ROC 曲线比SGDClassifier的好得多：<strong>它更靠近左上角。所以，它的 ROC AUC 也会更大。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>roc_auc_score(y_train_5, y_scores_forest)</span><br><span class="line"><span class="number">0.99312433660038291</span></span><br></pre></td></tr></table></figure>
<p>现在你知道如何训练一个二分类器，选择合适的标准，<strong>使用交叉验证去评估你的分类器，选择满足你需要的准确率/召回率折衷方案，和比较不同模型的 ROC 曲线和 ROC AUC 数值</strong>。现在让我们检测更多的数字，而不仅仅是一个数字 5。</p>
<h2 id="多类别分类"><a href="#多类别分类" class="headerlink" title="多类别分类"></a>多类别分类</h2><p><strong>一些算法（比如随机森林分类器或者朴素贝叶斯分类器）可以直接处理多类分类问题。其他一些算法（比如 SVM 分类器或者线性分类器）则是严格的二分类器。然后，有许多策略可以让你用二分类器去执行多类分类。</strong></p>
<ul>
<li>一个方法是：训练10个二分类器，每一个对应一个数字（探测器 0，探测器 1，探测器 2，以此类推）。然后当你想对某张图片进行分类的时候，让每一个分类器对这个图片进行分类，选出决策分数最高的那个分类器（One vs all 里面分数最高的One）。这叫做“一对所有”（OvA）策略</li>
<li>另一个策略是对每一对数字都训练一个二分类器：一个分类器用来处理数字 0 和数字 1，一个用来处理数字 0 和数字 2，一个用来处理数字 1 和 2，以此类推。这叫做“一对一”（OvO）策略。如果有 N 个类。你需要训练N*(N-1)/2个分类器。</li>
</ul>
<p><strong>一些算法（比如 SVM 分类器）在训练集的大小上很难扩展，所以对于这些算法，OvO 是比较好的，因为它可以在小的数据集上面可以更多地训练，较之于巨大的数据集而言。但是，对于大部分的二分类器来说，OvA 是更好的选择。Scikit-Learn 可以探测出你想使用一个二分类器去完成多分类的任务，它会自动地执行 OvA（除了 SVM 分类器，它使用 OvO）</strong>让我们试一下SGDClassifier.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sgd_clf.fit(X_train, y_train) <span class="comment"># y_train, not y_train_5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sgd_clf.predict([some_digit])</span><br><span class="line">array([ <span class="number">5.</span>])</span><br></pre></td></tr></table></figure>
<p>上面的代码在训练集上训练了一个SGDClassifier。这个分类器处理原始的目标class，从 0 到 9（y_train），而不是仅仅探测是否为 5 （y_train_5）。然后它做出一个判断（在这个案例下只有一个正确的数字）。<strong>在幕后，Scikit-Learn 实际上训练了 10 个二分类器，每个分类器都产到一张图片的决策数值，选择数值最高的那个类</strong>。</p>
<p>为了证明这是真实的，<strong>你可以调用decision_function()方法。不是返回每个样例的一个数值，而是返回 10 个数值，一个数值对应于一个类</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>some_digit_scores = sgd_clf.decision_function([some_digit])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>some_digit_scores</span><br><span class="line">array([[<span class="number">-311402.62954431</span>, <span class="number">-363517.28355739</span>, <span class="number">-446449.5306454</span> ,</span><br><span class="line">        <span class="number">-183226.61023518</span>, <span class="number">-414337.15339485</span>, <span class="number">161855.74572176</span>,</span><br><span class="line">        <span class="number">-452576.39616343</span>, <span class="number">-471957.14962573</span>, <span class="number">-518542.33997148</span>,</span><br><span class="line">        <span class="number">-536774.63961222</span>]])</span><br></pre></td></tr></table></figure>
<p>最高数值是对应于类别 5 :</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.argmax(some_digit_scores)    <span class="comment"># 找最大值的索引</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sgd_clf.classes_</span><br><span class="line">array([ <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">2.</span>, <span class="number">3.</span>, <span class="number">4.</span>, <span class="number">5.</span>, <span class="number">6.</span>, <span class="number">7.</span>, <span class="number">8.</span>, <span class="number">9.</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sgd_clf.classes[<span class="number">5</span>]    <span class="comment"># 用索引匹配类别</span></span><br><span class="line"><span class="number">5.0</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>一个分类器被训练好了之后，它会保存目标类别列表到它的属性classes<em> 中去，按照值排序。在本例子当中，在classes</em> 数组当中的每个类的索引方便地匹配了类本身，比如，索引为 5 的类恰好是类别 5 本身。但通常不会这么幸运。</p>
</blockquote>
<p><strong>如果你想强制 Scikit-Learn 使用 OvO 策略或者 OvA 策略，你可以使用OneVsOneClassifier类或者OneVsRestClassifier类。创建一个样例，传递一个二分类器给它的构造函数</strong>。举例子，下面的代码会创建一个多类分类器，使用 OvO 策略，基于SGDClassifier。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.multiclass <span class="keyword">import</span> OneVsOneClassifier</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ovo_clf = OneVsOneClassifier(SGDClassifier(random_state=<span class="number">42</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ovo_clf.fit(X_train, y_train)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ovo_clf.predict([some_digit])</span><br><span class="line">array([ <span class="number">5.</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(ovo_clf.estimators_)</span><br><span class="line"><span class="number">45</span></span><br></pre></td></tr></table></figure>
<p>训练一个RandomForestClassifier同样简单：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>forest_clf.fit(X_train, y_train)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>forest_clf.predict([some_digit])</span><br><span class="line">array([ <span class="number">5.</span>])</span><br></pre></td></tr></table></figure>
<p>这次 Scikit-Learn 没有必要去运行 OvO 或者 OvA，因为<strong>随机森林分类器能够直接将一个样例分到多个类别。你可以调用predict_proba()，得到样例对应的类别的概率值的列表</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>forest_clf.predict_proba([some_digit])</span><br><span class="line">array([[ <span class="number">0.1</span>, <span class="number">0.</span> , <span class="number">0.</span> , <span class="number">0.1</span>, <span class="number">0.</span> , <span class="number">0.8</span>, <span class="number">0.</span> , <span class="number">0.</span> , <span class="number">0.</span> , <span class="number">0.</span> ]])</span><br></pre></td></tr></table></figure>
<p>你可以看到这个分类器相当确信它的预测：在数组的索引 5 上的 0.8，意味着这个模型以 80% 的概率估算这张图片代表数字 5。它也认为这个图片可能是数字 0 或者数字 3，分别都是 10% 的几率。</p>
<p>现在当然你想评估这些分类器。<strong>像平常一样，你想使用交叉验证</strong>。让我们用cross_val_score()来评估SGDClassifier的精度。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>cross_val_score(sgd_clf, X_train, y_train, cv=<span class="number">3</span>, scoring=<span class="string">"accuracy"</span>)</span><br><span class="line">array([ <span class="number">0.84063187</span>, <span class="number">0.84899245</span>, <span class="number">0.86652998</span>])</span><br></pre></td></tr></table></figure>
<p>在所有测试折（test fold）上，它有 84% 的精度。如果你是用一个随机的分类器，你将会得到 10% 的正确率。所以这不是一个坏的分数，但是你可以做的更好。举例子，简单将输入正则化，将会提高精度到 90% 以上。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>scaler = StandardScaler()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X_train_scaled = scaler.fit_transform(X_train.astype(np.float64))    <span class="comment"># 特征正则化，没说用哪种</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cross_val_score(sgd_clf, X_train_scaled, y_train, cv=<span class="number">3</span>, scoring=<span class="string">"accuracy"</span>)</span><br><span class="line">array([ <span class="number">0.91011798</span>, <span class="number">0.90874544</span>, <span class="number">0.906636</span> ])</span><br></pre></td></tr></table></figure>
<h2 id="误差分析："><a href="#误差分析：" class="headerlink" title="误差分析："></a>误差分析：</h2><p><strong>首先，你可以检查混淆矩阵。你需要使用cross_val_predict()做出预测，然后调用confusion_matrix()函数</strong>，像你早前做的那样。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>y_train_pred = cross_val_predict(sgd_clf, X_train_scaled, y_train, cv=<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>conf_mx = confusion_matrix(y_train, y_train_pred)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>conf_mx</span><br><span class="line">array([[<span class="number">5725</span>, <span class="number">3</span>, <span class="number">24</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">49</span>, <span class="number">50</span>, <span class="number">10</span>, <span class="number">39</span>, <span class="number">4</span>],</span><br><span class="line">        [ <span class="number">2</span>, <span class="number">6493</span>, <span class="number">43</span>, <span class="number">25</span>, <span class="number">7</span>, <span class="number">40</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">109</span>, <span class="number">8</span>],</span><br><span class="line">        [ <span class="number">51</span>, <span class="number">41</span>, <span class="number">5321</span>, <span class="number">104</span>, <span class="number">89</span>, <span class="number">26</span>, <span class="number">87</span>, <span class="number">60</span>, <span class="number">166</span>, <span class="number">13</span>],</span><br><span class="line">        [ <span class="number">47</span>, <span class="number">46</span>, <span class="number">141</span>, <span class="number">5342</span>, <span class="number">1</span>, <span class="number">231</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">141</span>, <span class="number">92</span>],</span><br><span class="line">        [ <span class="number">19</span>, <span class="number">29</span>, <span class="number">41</span>, <span class="number">10</span>, <span class="number">5366</span>, <span class="number">9</span>, <span class="number">56</span>, <span class="number">37</span>, <span class="number">86</span>, <span class="number">189</span>],</span><br><span class="line">        [ <span class="number">73</span>, <span class="number">45</span>, <span class="number">36</span>, <span class="number">193</span>, <span class="number">64</span>, <span class="number">4582</span>, <span class="number">111</span>, <span class="number">30</span>, <span class="number">193</span>, <span class="number">94</span>],</span><br><span class="line">        [ <span class="number">29</span>, <span class="number">34</span>, <span class="number">44</span>, <span class="number">2</span>, <span class="number">42</span>, <span class="number">85</span>, <span class="number">5627</span>, <span class="number">10</span>, <span class="number">45</span>, <span class="number">0</span>],</span><br><span class="line">        [ <span class="number">25</span>, <span class="number">24</span>, <span class="number">74</span>, <span class="number">32</span>, <span class="number">54</span>, <span class="number">12</span>, <span class="number">6</span>, <span class="number">5787</span>, <span class="number">15</span>, <span class="number">236</span>],</span><br><span class="line">        [ <span class="number">52</span>, <span class="number">161</span>, <span class="number">73</span>, <span class="number">156</span>, <span class="number">10</span>, <span class="number">163</span>, <span class="number">61</span>, <span class="number">25</span>, <span class="number">5027</span>, <span class="number">123</span>],</span><br><span class="line">        [ <span class="number">43</span>, <span class="number">35</span>, <span class="number">26</span>, <span class="number">92</span>, <span class="number">178</span>, <span class="number">28</span>, <span class="number">2</span>, <span class="number">223</span>, <span class="number">82</span>, <span class="number">5240</span>]])</span><br></pre></td></tr></table></figure>
<p>这里是一对数字。使用 Matplotlib 的matshow()函数，将混淆矩阵以图像的方式呈现，将会更加方便</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.matshow(conf_mx, cmap=plt.cm.gray)    <span class="comment"># #灰度图,对应位置的值越大色块越亮</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2018/07/11/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（二）：分类/07.png" alt></p>
<p>这个混淆矩阵看起来相当好，因为大多数的图片在主对角线上。在主对角线上意味着被分类正确。数字 5 对应的格子看起来比其他数字要暗淡许多。这可能是数据集当中数字 5 的图片比较少，又或者是分类器对于数字 5 的表现不如其他数字那么好。你可以验证两种情况.</p>
<p>让我们关注仅包含误差数据的图像呈现。<strong>首先你需要将混淆矩阵的每一个值除以相应类别的图片的总数目。这样子，你可以比较错误率，而不是绝对的错误数（这对大的类别不公平）</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">row_sums = conf_mx.sum(axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>)</span><br><span class="line">norm_conf_mx = conf_mx / row_sums</span><br></pre></td></tr></table></figure>
<p><strong>现在让我们用 0 来填充对角线。这样子就只保留了被错误分类的数据</strong>。让我们画出这个结果。(此时数值为错误率)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.fill_diagonal(norm_conf_mx, <span class="number">0</span>)</span><br><span class="line">plt.matshow(norm_conf_mx, cmap=plt.cm.gray)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2018/07/11/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（二）：分类/08.png" alt></p>
<p>现在你可以清楚看出分类器制造出来的各类误差。记住：行代表实际类别，列代表预测的类别。第 8、9 列相当亮，这告诉你许多图片被误分成数字 8 或者数字 9。相似的，第 8、9 行也相当亮，告诉你数字 8、数字 9 经常被误以为是其他数字。相反，一些行相当黑，比如第一行：这意味着大部分的数字 1 被正确分类（一些被误分类为数字 8 ）。留意到误差图不是严格对称的。举例子，比起将数字 8 误分类为数字 5 的数量，有更多的数字 5 被误分类为数字 8。</p>
<p><strong>分析混淆矩阵通常可以给你提供深刻的见解去改善你的分类器</strong>。回顾这幅图，看样子你应该努力改善分类器在数字 8 和数字 9 上的表现，和纠正 3/5 的混淆。举例子，你可以尝试去收集更多的数据，或者你可以构造新的、有助于分类器的特征。举例子，写一个算法去数闭合的环（比如，数字 8 有两个环，数字 6 有一个， 5 没有）。又或者你可以预处理图片（比如，使用 Scikit-Learn，Pillow， OpenCV）去构造一个模式，比如闭合的环。</p>
<p>分析独特的误差，是获得关于你的分类器是如何工作及其为什么失败的洞见的一个好途径。但是这相对难和耗时。举例子，我们可以画出数字 3 和 5 的例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cl_a, cl_b = <span class="number">3</span>, <span class="number">5</span></span><br><span class="line">X_aa = X_train[(y_train == cl_a) &amp; (y_train_pred == cl_a)]</span><br><span class="line">X_ab = X_train[(y_train == cl_a) &amp; (y_train_pred == cl_b)]</span><br><span class="line">X_ba = X_train[(y_train == cl_b) &amp; (y_train_pred == cl_a)]</span><br><span class="line">X_bb = X_train[(y_train == cl_b) &amp; (y_train_pred == cl_b)]</span><br><span class="line">plt.figure(figsize=(<span class="number">8</span>,<span class="number">8</span>))</span><br><span class="line">plt.subplot(<span class="number">221</span>); plot_digits(X_aa[:<span class="number">25</span>], ../images_per_row=<span class="number">5</span>)</span><br><span class="line">plt.subplot(<span class="number">222</span>); plot_digits(X_ab[:<span class="number">25</span>], ../images_per_row=<span class="number">5</span>)</span><br><span class="line">plt.subplot(<span class="number">223</span>); plot_digits(X_ba[:<span class="number">25</span>], ../images_per_row=<span class="number">5</span>)</span><br><span class="line">plt.subplot(<span class="number">224</span>); plot_digits(X_bb[:<span class="number">25</span>], ../images_per_row=<span class="number">5</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2018/07/11/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（二）：分类/09.png" alt></p>
<p>左边两个5*5的块将数字识别为 3，右边的将数字识别为 5。一些被分类器错误分类的数字（比如左下角和右上角的块）是书写地相当差，甚至让人类分类都会觉得很困难（比如第 8 行第 1 列的数字 5，看起来非常像数字 3 ）。但是，大部分被误分类的数字，在我们看来都是显而易见的错误。很难明白为什么分类器会分错。原因是我们使用的简单的SGDClassifier，这是一个线性模型。它所做的全部工作就是分配一个类权重给每一个像素，然后当它看到一张新的图片，它就将加权的像素强度相加，每个类得到一个新的值。所以，因为 3 和 5 只有一小部分的像素有差异，这个模型很容易混淆它们。</p>
<p>3 和 5 之间的主要差异是连接顶部的线和底部的线的细线的位置。如果你画一个 3，连接处稍微向左偏移，分类器很可能将它分类成 5。反之亦然。<strong>换一个说法，这个分类器对于图片的位移和旋转相当敏感。所以，减轻 3/5 混淆的一个方法是对图片进行预处理，确保它们都很好地中心化和不过度旋转。这同样很可能帮助减轻其他类型的错误</strong>。</p>
<h2 id="多标签分类"><a href="#多标签分类" class="headerlink" title="多标签分类"></a>多标签分类</h2><p>先看一个简单点的例子，仅仅是为了阐明的目的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line">y_train_large = (y_train &gt;= <span class="number">7</span>)</span><br><span class="line">y_train_odd = (y_train % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">y_multilabel = np.c_[y_train_large, y_train_odd]</span><br><span class="line">knn_clf = KNeighborsClassifier()</span><br><span class="line">knn_clf.fit(X_train, y_multilabel)</span><br></pre></td></tr></table></figure>
<p><strong>这段代码创造了一个y_multilabel数组，里面包含两个目标标签。第一个标签指出这个数字是否为大数字（7，8 或者 9），第二个标签指出这个数字是否是奇数</strong>。<strong>接下来几行代码会创建一个KNeighborsClassifier样例（它支持多标签分类，但不是所有分类器都可以）</strong>，然后我们使用多目标数组来训练它。现在你可以生成一个预测，然后它输出两个标签：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>knn_clf.predict([some_digit])</span><br><span class="line">array([[<span class="literal">False</span>, <span class="literal">True</span>]], dtype=bool)</span><br></pre></td></tr></table></figure>
<p>它工作正确。数字 5 不是大数（False），同时是一个奇数（True）</p>
<p>有许多方法去评估一个多标签分类器，和选择正确的量度标准，这取决于你的项目。举个例子，<strong>一个方法是对每个个体标签去量度 F1 值（或者前面讨论过的其他任意的二分类器的量度标准），然后计算平均值</strong>。下面的代码计算全部标签的平均 F1 值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>y_train_knn_pred = cross_val_predict(knn_clf, X_train, y_train, cv=<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1_score(y_train, y_train_knn_pred, average=<span class="string">"macro"</span>)</span><br><span class="line"><span class="number">0.96845540180280221</span></span><br></pre></td></tr></table></figure>
<p><strong>这里假设所有标签有着同等的重要性，但可能不是这样</strong>。特别是，如果你的 Alice 的照片比 Bob 或者 Charlie 更多的时候，也许你想让分类器在 Alice 的照片上具有更大的权重。<strong>一个简单的选项是：给每一个标签的权重等于它的支持度（比如，那个标签的样例的数目）。为了做到这点，简单地在上面代码中设置average=”weighted”。</strong></p>
<h2 id="多输出分类"><a href="#多输出分类" class="headerlink" title="多输出分类"></a>多输出分类</h2><p>我们即将讨论的最后一种分类任务被叫做“多输出-多类分类”（或者简称为多输出分类）。它是多标签分类的简单泛化，在这里每一个标签可以是多类别的（比如说，它可以有多于两个可能值）。</p>
<p><strong>为了说明这点，我们建立一个系统，它可以去除图片当中的噪音。它将一张混有噪音的图片作为输入，期待它输出一张干净的数字图片，用一个像素强度的数组表示，就像 MNIST 图片那样。注意到这个分类器的输出是多标签的（一个像素一个标签）和每个标签可以有多个值（像素强度取值范围从 0 到 255）。所以它是一个多输出分类系统的例子。</strong></p>
<blockquote>
<p>分类与回归之间的界限是模糊的，比如这个例子。按理说，预测一个像素的强度更类似于一个回归任务，而不是一个分类任务。而且，多输出系统不限于分类任务。你甚至可以让你一个系统给每一个样例都输出多个标签，包括类标签和值标签。</p>
</blockquote>
<p>让我们从 MNIST 的图片创建训练集和测试集开始，然后给图片的像素强度添加噪声，这里是用 NumPy 的randint()函数。目标图像是原始图像。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">noise = rnd.randint(<span class="number">0</span>, <span class="number">100</span>, (len(X_train), <span class="number">784</span>))</span><br><span class="line">noise = rnd.randint(<span class="number">0</span>, <span class="number">100</span>, (len(X_test), <span class="number">784</span>))</span><br><span class="line">X_train_mod = X_train + noise</span><br><span class="line">X_test_mod = X_test + noise</span><br><span class="line">y_train_mod = X_train</span><br><span class="line">y_test_mod = X_test</span><br></pre></td></tr></table></figure>
<p>让我们看一下测试集当中的一张图片（是的，我们在窥探测试集，所以你应该马上邹眉）：</p>
<p><img src="/2018/07/11/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（二）：分类/10.png" alt></p>
<p>左边的加噪声的输入图片。右边是干净的目标图片。现在我们训练分类器，让它清洁这张图片：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">knn_clf.fit(X_train_mod, y_train_mod)</span><br><span class="line">clean_digit = knn_clf.predict([X_test_mod[some_index]])</span><br><span class="line">plot_digit(clean_digit)</span><br></pre></td></tr></table></figure>
<p><img src="/2018/07/11/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（二）：分类/11.png" alt></p>
<hr>
<p>到这里就讲完分类的内容了，有点混乱对不对，我们来总结梳理一下。</p>
<ul>
<li><p>要掌握自定义k折交叉验证的方法（≈cross_val_score）</p>
</li>
<li><p>cross_val_score为验证模型的一个好方法，但是只能得到准确率的评估分数</p>
</li>
<li><p>如果正反例数据偏差大，我们需要用到混淆矩阵，这个矩阵要用到预测值而不是评估分数，所以改cross_val_predict，这会返回每个测试折做出的预测值，即y_train_pred </p>
</li>
<li><p>利用预测值y_train_pred可以得到混淆矩阵，精确率，召回率，F1</p>
</li>
<li><p>有时我们需要阈值来平衡精确率，召回率，而Scikit-Learn 不让你直接设置阈值，它会调用decision_function()方法。<strong>返回样例的分数值</strong>，然后基于这个分数值，使用你想要的任何阈值做出预测。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>y_scores = sgd_clf.decision_function([some_digit])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y_scores</span><br><span class="line">array([ <span class="number">161855.74572176</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>threshold = <span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y_some_digit_pred = (y_scores &gt; threshold)</span><br><span class="line">array([ <span class="literal">True</span>], dtype=bool)</span><br></pre></td></tr></table></figure>
</li>
<li><p>每次都设定阈值不是一个完美的方法，如何才能找到合适的阈值呢？你需要再次使用cross_val_predict()得到每一个样例的分数值，<strong>但是这一次指定返回一个决策分数</strong>，<strong>而不是预测值</strong>。(阈值相关，就要进行打分)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y_scores = cross_val_predict(sgd_clf, X_train, y_train_5, cv=<span class="number">3</span>, </span><br><span class="line">                            method=<span class="string">"decision_function"</span>)</span><br></pre></td></tr></table></figure>
<p>现在有了这些分数值。对于任何可能的阈值，使用precision_recall_curve(),你都可以计算精确率和召回率；precisions, recalls, thresholds是任何阈值的范围值，可以变化曲线和PR曲线</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> precision_recall_curve</span><br><span class="line">precisions, recalls, thresholds = precision_recall_curve(y_train_5, y_scores)</span><br></pre></td></tr></table></figure>
</li>
<li><p>与PR曲线另一个相关的是ROC曲线（TPR/FPR），为了画出 ROC 曲线，你首先需要计算各种不同阈值下的 TPR、FPR，使用roc_curve()函数（还是要打分）；跳过ROC曲线(其实相当于已经做了)，想直接计算出ROC AUC也行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> roc_curve</span><br><span class="line">fpr, tpr, thresholds = roc_curve(y_train_5, y_scores)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> roc_auc_score</span><br><span class="line">roc_auc_score(y_train_5, y_scores)</span><br></pre></td></tr></table></figure>
<p>如果想得到RandomForestClassifier的ROC曲线，由于RandomForestClassifier不提供decision_function()方法，相反，它提供了predict_proba()方法（另外一种概率打分），返回概率值，此时用正例概率作为分值。例如70%的概率是垃圾邮件。</p>
<p>另外，<strong>因为 ROC 曲线跟准确率/召回率曲线（或者叫 PR）很类似，你或许会好奇如何决定使用哪一个曲线呢？一个笨拙的规则是，优先使用 PR 曲线当正例很少，或者当你关注假正例多于假反例的时候。其他情况使用 ROC 曲线</strong></p>
</li>
<li><p>多类别分类有一对一ovo, 一对多ova两种方法，一般svm由于在训练集的大小上很难扩展，因为它可以在小的数据集上面可以更多地训练，故用ovo，其他大部分用ova。如果Scikit-Learn嗅探出你想做一个多分类任务，它会自动使用ova，svm训练器除外</p>
</li>
<li><p>误差分析，将混淆矩阵归一化后用图片色块输出，查看哪些类别经常被错误分类。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Sklearn 与 TensorFlow 机器学习实用指南</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>ROC</tag>
        <tag>MNIST</tag>
      </tags>
  </entry>
  <entry>
    <title>Sklearn 与 TensorFlow 机器学习实用指南（一）：一个完整的程序</title>
    <url>/2018/07/09/Sklearn%20%E4%B8%8E%20TensorFlow%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E7%94%A8%E6%8C%87%E5%8D%97/Sklearn-%E4%B8%8E-TensorFlow-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E7%94%A8%E6%8C%87%E5%8D%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<p>写在前面：这个系列打算把「Hands-On Machine Learning with Scikit-Learn and TensorFlow 」重新梳理一遍，这本书在看完机器学习基础知识之后有一个很好的算法实践，对于算法落地有很多帮助。这次写的Sklearn 与 TensorFlow 机器学习实用指南系列，目的是让自己更清楚算法的每个流程处理，加强对一些机器学习模型理解。这本书在<a href="https://github.com/apachecn/hands_on_Ml_with_Sklearn_and_TF" target="_blank" rel="noopener">github</a>有中文的翻译版本（还在更新）.</p>
<hr>
<h1 id="拆分数据集"><a href="#拆分数据集" class="headerlink" title="拆分数据集"></a>拆分数据集</h1><h2 id="训练集-测试集"><a href="#训练集-测试集" class="headerlink" title="训练集+测试集"></a>训练集+测试集</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">split_train_test</span><span class="params">(data, test_ratio)</span>:</span></span><br><span class="line">    shuffled_indices = np.random.permutation(len(data))    <span class="comment"># 打乱序列</span></span><br><span class="line">    test_set_size = int(len(data) * test_ratio)    <span class="comment"># 拆分比例</span></span><br><span class="line">    test_indices = shuffled_indices[:test_set_size]</span><br><span class="line">    train_indices = shuffled_indices[test_set_size:]</span><br><span class="line">    <span class="keyword">return</span> data.iloc[train_indices], data.iloc[test_indices]</span><br><span class="line">    </span><br><span class="line">train_set, test_set = split_train_test(housing, <span class="number">0.2</span>)    <span class="comment"># housing数据二八拆分</span></span><br></pre></td></tr></table></figure>
<p>或者直接将整体数据打乱，然后按需取量。(california_housing_dataframe为谷歌机器学习教程提供的加州住房数据)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">california_housing_dataframe = california_housing_dataframe.reindex(	<span class="comment"># 整体打乱</span></span><br><span class="line">    np.random.permutation(california_housing_dataframe.index))</span><br><span class="line">train_set = california_housing_dataframe.head(<span class="number">12000</span>)</span><br><span class="line">test_set = california_housing_dataframe.tail(<span class="number">5000</span>)</span><br></pre></td></tr></table></figure>
<p>以上为训练集+测试集的拆分方式</p>
<h2 id="训练集-验证集-测试集"><a href="#训练集-验证集-测试集" class="headerlink" title="训练集+验证集+测试集"></a>训练集+验证集+测试集</h2><p><strong>这样的拆分方式主要有存在一些不足。1、程序多次运行后，测试集的数据有可能会加入到训练集当中，调参时用于改进模型超参数的测试集会造成过拟合。2、不便于新数据的加入</strong></p>
<p>更好的办法是将数据集拆分为训练集+验证集+测试集。</p>
<p><img src="/2018/07/09/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（一）：一个完整的程序/01.png" alt></p>
<p>那如何解决新加入数据的问题呢？<strong>一个通常的解决办法是使用每个实例的识别码</strong>，以判定是否这个实例是否应该放入测试集（假设实例有单一且不变的识别码）。<strong>例如，你可以计算出每个实例识别码的哈希值，只保留其最后一个字节，如果值小于等于 51（约为 256 的 20%），就将其放入测试集。这样可以保证在多次运行中，测试集保持不变，即使更新了数据集。新的测试集会包含新实例中的 20%，但不会有之前位于训练集的实例</strong>。可能很多数据没有稳定的特征，最简单的办法就是利用索引作为识别码。下面的代码根据识别码按0.7,0.2,0.1比例拆分训练集、验证集和测试集。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 参数identifier为单一且不变的识别码，可以为索引id</span></span><br><span class="line"><span class="comment"># hash(np.int64(identifier)).digest()[-1]返回识别码的哈希摘要值的最后一个字节</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">validate_set_check</span><span class="params">(identifier, validate_ratio, test_ratio, hash)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">256</span> * test_ratio &lt;= hash(np.int64(identifier)).digest()[<span class="number">-1</span>] &lt; <span class="number">256</span> *      (validate_ratio+test_ratio)  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_set_check</span><span class="params">(identifier, test_ratio, hash)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> hash(np.int64(identifier)).digest()[<span class="number">-1</span>] &lt; <span class="number">256</span> * test_ratio    <span class="comment"># 记录满足条件的索引</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">split_train_test_by_id</span><span class="params">(data, validate_ratio, test_ratio, id_column, hash=hashlib.md5)</span>:</span></span><br><span class="line">    ids = data[id_column]	<span class="comment"># 确定识别码</span></span><br><span class="line">    in_validate_set = ids.apply(<span class="keyword">lambda</span> id_: validate_set_check(id_, validate_ratio, test_ratio，hash))</span><br><span class="line">    in_test_set = ids.apply(<span class="keyword">lambda</span> id_: test_set_check(id_, test_ratio, hash))</span><br><span class="line">    combine_set = np.bitwise_or(in_validate_set, in_test_set)</span><br><span class="line">    <span class="keyword">return</span> data.loc[~combine_set], data.loc[in_validate_set], data.loc[in_test_set]			                       </span><br><span class="line">housing_with_id = housing.reset_index()   <span class="comment"># housing数据增加一个索引列，放在数据的第一列</span></span><br><span class="line">train_set, validate_set, test_set = split_train_test_by_id(housing_with_id, <span class="number">0.2</span>, <span class="number">0.1</span>, <span class="string">"index"</span>)</span><br></pre></td></tr></table></figure>
<h2 id="分成采样"><a href="#分成采样" class="headerlink" title="分成采样"></a>分成采样</h2><p>另外一种拆分方式：<strong>分成采样</strong></p>
<p><strong>将人群分成均匀的子分组，称为分层</strong>，从每个分层去除合适数量的实例，以保证测试集对总人数有代表性。例如，美国人口的 51.3% 是女性，48.7% 是男性。所以在美国，严谨的调查需要保证样本也是这个比例：513 名女性，487 名男性作为数据样本。数据集中的每个分层都要有足够的实例位于你的数据中，这点很重要。否则，对分层重要性的评估就会有偏差。这意味着，<strong>你不能有过多的分层</strong>，<strong>且每个分层都要足够大</strong>。后面的代码通过将收入中位数除以 1.5（以限制收入分类的数量），创建了一个收入类别属性，<strong>用ceil对值舍入（以产生离散的分类），然后将所有大于 5的分类归入到分类5 </strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 预处理，创建"income_cat"属性 </span></span><br><span class="line"><span class="comment"># 凡是会对原数组作出修改并返回一个新数组的，往往都有一个 inplace可选参数</span></span><br><span class="line"><span class="comment"># inplace=True,原数组名对应的内存值直接改变;inplace=False,原数组名对应的内存值并不改变，新的结果赋给一个新的数组.</span></span><br><span class="line">housing[<span class="string">"income_cat"</span>] = np.ceil(housing[<span class="string">"median_income"</span>] / <span class="number">1.5</span>)</span><br><span class="line">housing[<span class="string">"income_cat"</span>].where(housing[<span class="string">"income_cat"</span>] &lt; <span class="number">5</span>, <span class="number">5.0</span>, inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在，就可以根据收入分类，进行分层采样。你可以使用 Scikit-Learn 的StratifiedShuffleSplit类</span></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> StratifiedShuffleSplit</span><br><span class="line"></span><br><span class="line"><span class="comment"># random_state为随机种子生成器，可以得到相同的随机结果</span></span><br><span class="line"><span class="comment"># n_splits是将训练数据分成train/test对的组数，这里汇总成一组数据</span></span><br><span class="line">split = StratifiedShuffleSplit(n_splits=<span class="number">1</span>, test_size=<span class="number">0.2</span>, random_state=<span class="number">42</span>)    </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> train_index, test_index <span class="keyword">in</span> split.split(housing, housing[<span class="string">"income_cat"</span>]):</span><br><span class="line">    strat_train_set = housing.loc[train_index]</span><br><span class="line">    strat_test_set = housing.loc[test_index]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在，你需要删除income_cat属性，使数据回到初始状态：    </span></span><br><span class="line"><span class="keyword">for</span> set <span class="keyword">in</span> (strat_train_set, strat_test_set):</span><br><span class="line">    set.drop([<span class="string">"income_cat"</span>], axis=<span class="number">1</span>, inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<h1 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h1><h2 id="将原始数据映射到特征"><a href="#将原始数据映射到特征" class="headerlink" title="将原始数据映射到特征"></a>将原始数据映射到特征</h2><p>我们在进行机器学习的时候，采用的数据样本往往是<strong>矢量</strong>（特征矢量），而我们的<strong>原始数据</strong>并不是以矢量的形式呈现给我们的，这是便需要将数据映射到特征</p>
<h3 id="整数和浮点数映射"><a href="#整数和浮点数映射" class="headerlink" title="整数和浮点数映射"></a>整数和浮点数映射</h3><p>直接映射便ok（虽然机器学习是<strong>根据浮点值进行的训练</strong>，但是不需要将整数6转换为6.0，这个过程是默认的）</p>
<h3 id="字符串映射"><a href="#字符串映射" class="headerlink" title="字符串映射"></a>字符串映射</h3><p>好多时候，有的特征是字符串，比如此前训练的加利福尼亚房产数据集中的<strong>街区名称</strong>，机器学习是无法根据字符串来学习规律的，所以需要转换。但是存在一个问题，如果字符特征是’’一环’’ ‘’二环’’ ‘’三环’’…（代表某个城市的地理位置），那么对其进行数值转换的时候，是不可以编码为形如1，2，3，4…这样的数据的，因为其存在数据大小的问题，学习模型会把他们的大小关系作为特征而学习，所以我们需要引入<a href="https://www.cnblogs.com/king-lps/p/7846414.html" target="_blank" rel="noopener"><strong>独热编码</strong></a>,（具体解释见链接，解释的很好）.<strong>我们需要把这些文本标签转换为数字</strong>。Scikit-Learn 为这个任务提供了一个转换器LabelEncoder：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 简单来说 LabelEncoder 是对不连续的数字或者文本进行编号</span></span><br><span class="line"><span class="comment"># le.fit([1,5,67,100])</span></span><br><span class="line"><span class="comment"># le.transform([1,1,100,67,5])</span></span><br><span class="line"><span class="comment"># 输出： array([0,0,3,2,1])</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> LabelEncoder</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>encoder = LabelEncoder()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>housing_cat = housing[<span class="string">"ocean_proximity"</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>housing_cat_encoded = encoder.fit_transform(housing_cat)	<span class="comment"># 装换器</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>housing_cat_encoded</span><br><span class="line">array([<span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>, ..., <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure>
<blockquote>
<p>译注:</p>
<p>在原书中使用<code>LabelEncoder</code>转换器来转换文本特征列的方式是错误的，该转换器只能用来转换标签（正如其名）。在这里使用<code>LabelEncoder</code>没有出错的原因是该数据只有一列文本特征值，在有多个文本特征列的时候就会出错。应使用<code>factorize()</code>方法来进行操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; housing_cat_encoded, housing_categories = housing_cat.factorize()</span><br><span class="line">&gt; housing_cat_encoded[:<span class="number">10</span>]</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<p>处理离散特征这还不够，Scikit-Learn 提供了一个编码器OneHotEncoder，用于将整书分类值转变为独热向量。注意fit_transform()用于 2D 数组，而housing_cat_encoded是一个 1D 数组，所以需要将其变形：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># reshape(-1,1)里面的-1代表将数据自动计算有多少行，但是列数明确设置为1</span></span><br><span class="line"><span class="comment"># reshape(-1)则是变形为1行和自动计算有多少列</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> OneHotEncoder</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>encoder = OneHotEncoder()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>housing_cat_1hot = encoder.fit_transform(housing_cat_encoded.reshape(<span class="number">-1</span>,<span class="number">1</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>housing_cat_1hot</span><br><span class="line">&lt;<span class="number">16513</span>x5 sparse matrix of type <span class="string">'&lt;class '</span>numpy.float64<span class="string">'&gt;'</span></span><br><span class="line">    <span class="keyword">with</span> <span class="number">16513</span> stored elements <span class="keyword">in</span> Compressed Sparse Row format&gt;</span><br></pre></td></tr></table></figure>
<p>注意输出结果是一个 SciPy 稀疏矩阵，而不是 NumPy 数组。当类别属性有数千个分类时，这样非常有用。经过独热编码，我们得到了一个有数千列的矩阵，这个矩阵每行只有一个 1，其余都是 0。使用大量内存来存储这些 0 非常浪费，所以稀疏矩阵只存储非零元素的位置。你可以像一个 2D 数据那样进行使用，但是如果你真的想将其转变成一个（密集的）NumPy 数组，只需调用toarray()方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>housing_cat_1hot.toarray()</span><br><span class="line">array([[ <span class="number">0.</span>,  <span class="number">1.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">       [ <span class="number">0.</span>,  <span class="number">1.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">       [ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">1.</span>],</span><br><span class="line">       ...,</span><br><span class="line">       [ <span class="number">0.</span>,  <span class="number">1.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">       [ <span class="number">1.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">       [ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">1.</span>,  <span class="number">0.</span>]])</span><br></pre></td></tr></table></figure>
<p>使用类LabelBinarizer，我们可以用一步执行这两个转换（从文本分类到整数分类，再从整数分类到独热向量）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> LabelBinarizer</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>encoder = LabelBinarizer()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>housing_cat_1hot = encoder.fit_transform(housing_cat)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>housing_cat_1hot</span><br><span class="line">array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">       ...,</span><br><span class="line">       [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]])</span><br></pre></td></tr></table></figure>
<p>注意默认返回的结果是一个密集 NumPy 数组。向构造器LabelBinarizer传递sparse_output=True，就可以得到一个稀疏矩阵。</p>
<blockquote>
<p>译注:</p>
<p>在原书中使用<code>LabelBinarizer</code>的方式也是错误的，该类也应用于标签列的转换。正确做法是使用sklearn即将提供的<code>CategoricalEncoder</code>类。如果在你阅读此文时sklearn中尚未提供此类，用如下方式代替：（来自<a href="https://github.com/scikit-learn/scikit-learn/pull/9151" target="_blank" rel="noopener">Pull Request #9151）</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; <span class="comment">#from sklearn.preprocessing import CategoricalEncoder # in future versions of Scikit-Learn</span></span><br><span class="line">&gt;</span><br><span class="line">&gt; cat_encoder = CategoricalEncoder()</span><br><span class="line">&gt; housing_cat_reshaped = housing_cat.values.reshape(<span class="number">-1</span>, <span class="number">1</span>)</span><br><span class="line">&gt; housing_cat_1hot = cat_encoder.fit_transform(housing_cat_reshaped)</span><br><span class="line">&gt; housing_cat_1hot</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
</blockquote>
<h2 id="寻找良好特征（的特点）"><a href="#寻找良好特征（的特点）" class="headerlink" title="寻找良好特征（的特点）"></a>寻找良好特征（的特点）</h2><p>当得到特征之后，还是要进行筛选的，因为有的特征没有参考价值，就像我们的在做合成特征的时候，正常的特征数据是人均几间房间，而有的人是几十间，这明显没有参考价值<br>良好特征的几点原则</p>
<ul>
<li><p>避免很少使用的离散特征值：如果只是出现了一两次的特征几乎是没有意义的</p>
</li>
<li><p>最好具有清晰明确的含义：特征的含义不仅仅是让机器学习的模型学习的，人也要知道其具体的含义，不然不利于分析数据（最好将数值很大的秒转换为天数，或者年，让人看起来直观一些）</p>
</li>
<li><p>将“神奇”的值与实际数据混为一谈：有些特征中会出现一些”神奇的数据”，当然这些数据并不是很少的特征，而是超出范围的异常值，比如特征应该是介于0——1之间的，但是因为这个数据是空缺的，而采用的默认数值-1，那么这样的数值就是”神奇”，解决办法是，将该特征转换为两个特征：</p>
<ul>
<li>一个特征只存储质正常范围的值，不含神奇值。</li>
<li>一个特征存储布尔值，表示的信息为是否为空</li>
</ul>
</li>
<li><p>考虑上游不稳定性：由经验可知，特征的定义不应随时间发生变化，代表城市名称的话，那么特征值始终都该是城市的名称，但是有的时候，上游模型将特征值处理完毕后，返还给下游模型的却变成了数值，这样是不好的，因为这种表示在未来运行其他模型时可能轻易发生变化，那么特征就乱套了</p>
<p>​</p>
</li>
</ul>
<h3 id="可视化数据寻找规律："><a href="#可视化数据寻找规律：" class="headerlink" title="可视化数据寻找规律："></a>可视化数据寻找规律：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">housing.plot(kind=<span class="string">"scatter"</span>, x=<span class="string">"longitude"</span>, y=<span class="string">"latitude"</span>, alpha=<span class="number">0.4</span>,</span><br><span class="line">    s=housing[<span class="string">"population"</span>]/<span class="number">100</span>, label=<span class="string">"population"</span>,</span><br><span class="line">    c=<span class="string">"median_house_value"</span>, cmap=plt.get_cmap(<span class="string">"jet"</span>), colorbar=<span class="literal">True</span>,</span><br><span class="line">)</span><br><span class="line">plt.legend()</span><br></pre></td></tr></table></figure>
<p>每个圈的半径表示街区的人口（选项s），颜色代表价格（选项c）。我们用预先定义的名为jet的颜色图（选项cmap），它的范围是从蓝色（低价）到红色（高价）：</p>
<p><img src="/2018/07/09/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（一）：一个完整的程序/02.png" alt></p>
<h3 id="皮尔逊相关系数"><a href="#皮尔逊相关系数" class="headerlink" title="皮尔逊相关系数"></a>皮尔逊相关系数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">corr_matrix = housing.corr()</span><br></pre></td></tr></table></figure>
<h3 id="Pandas-的scatter-matrix函数"><a href="#Pandas-的scatter-matrix函数" class="headerlink" title="Pandas 的scatter_matrix函数"></a>Pandas 的scatter_matrix函数</h3><p>另一种检测属性间相关系数的方法是使用 Pandas 的scatter_matrix函数,它能画出每个数值属性对每个其它数值属性的图。因为现在共有 11 个数值属性，你可以得到11 ** 2 = 121张图。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pandas.tools.plotting <span class="keyword">import</span> scatter_matrix</span><br><span class="line"></span><br><span class="line">attributes = [<span class="string">"median_house_value"</span>, <span class="string">"median_income"</span>, <span class="string">"total_rooms"</span>,</span><br><span class="line">              <span class="string">"housing_median_age"</span>]</span><br><span class="line">scatter_matrix(housing[attributes], figsize=(<span class="number">12</span>, <span class="number">8</span>))</span><br></pre></td></tr></table></figure>
<p>得到两个属性的散点图</p>
<p><img src="/2018/07/09/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（一）：一个完整的程序/03.png" alt></p>
<h2 id="清查数据"><a href="#清查数据" class="headerlink" title="清查数据"></a>清查数据</h2><p>截至目前，我们假定用于训练和测试的所有数据都是值得信赖的。在现实生活中，数据集中的很多样本是不可靠的，原因有以下一种或多种：</p>
<ul>
<li><strong>遗漏值。</strong> 例如，有人忘记为某个房屋的年龄输入值。(值会为-1，所以要分为两个特征，忘了的看上面)</li>
<li><strong>重复样本。</strong> 例如，服务器错误地将同一条记录上传了两次。</li>
<li><strong>不良标签。</strong> 例如，有人错误地将一颗橡树的图片标记为枫树。</li>
<li><strong>不良特征值。</strong> 例如，有人输入了多余的位数，或者温度计被遗落在太阳底下。</li>
</ul>
<p>一旦检测到存在这些问题，通常需要将相应样本从数据集中移除，从而“修正”不良样本。要检测遗漏值或重复样本，可以编写一个简单的程序。检测不良特征值或标签可能会比较棘手，可采用可视化数据的方法。</p>
<p><strong>对于处理特征丢失的问题</strong>。前面，你应该注意到了属性total_bedrooms有一些缺失值。有三个解决选项：</p>
<ul>
<li>去掉对应的街区；（数据大可用）</li>
<li>去掉整个属性；</li>
<li>进行赋值（0、平均值、中位数等等）。</li>
</ul>
<p>用DataFrame的dropna()，drop()，和fillna()方法，可以方便地实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">housing.dropna(subset=[<span class="string">"total_bedrooms"</span>])    <span class="comment"># 选项1</span></span><br><span class="line">housing.drop(<span class="string">"total_bedrooms"</span>, axis=<span class="number">1</span>)       <span class="comment"># 选项2    axis=0对行操作，axis=1对列操作</span></span><br><span class="line">median = housing[<span class="string">"total_bedrooms"</span>].median()</span><br><span class="line">housing[<span class="string">"total_bedrooms"</span>].fillna(median)     <span class="comment"># 选项3</span></span><br></pre></td></tr></table></figure>
<p>如果选择选项 3，你需要计算训练集的中位数，用中位数填充训练集的缺失值，<strong>不要忘记保存该中位数</strong>。后面用<strong>测试集</strong>评估系统时，<strong>需要替换测试集中的缺失值</strong>，也可以用来实时替换新数据中的缺失值。</p>
<p>Scikit-Learn 提供了一个方便的类来处理缺失值：Imputer。下面是其使用方法：首先，需要创建一个Imputer实例，指定用该属性的中位数替换它的每个缺失值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> Imputer</span><br><span class="line"></span><br><span class="line">imputer = Imputer(strategy=<span class="string">"median"</span>)    <span class="comment"># 进行中位数赋值</span></span><br></pre></td></tr></table></figure>
<p><strong>因为只有数值属性才能算出中位数，我们需要创建一份不包括文本属性ocean_proximity的数据副本：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">housing_num = housing.drop(<span class="string">"ocean_proximity"</span>, axis=<span class="number">1</span>) <span class="comment"># 去除ocean_proximity不为数值属性的特征</span></span><br></pre></td></tr></table></figure>
<p>现在，就可以用fit()方法将imputer实例拟合到训练数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">imputer.fit(housing_num)</span><br></pre></td></tr></table></figure>
<p>imputer计算出了每个属性的中位数，并将结果保存在了实例变量statistics_中。只有属性total_bedrooms有缺失值，但是我们<strong>确保一旦系统运行起来，新的数据中没有缺失值</strong>，所以<strong>安全的做法是将imputer应用到每个数值</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>imputer.statistics_    <span class="comment"># 实例变量statistics_和housing_num数值数据得到的中位数是一样的</span></span><br><span class="line">array([ <span class="number">-118.51</span> , <span class="number">34.26</span> , <span class="number">29.</span> , <span class="number">2119.</span> , <span class="number">433.</span> , <span class="number">1164.</span> , <span class="number">408.</span> , <span class="number">3.5414</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>housing_num.median().values</span><br><span class="line">array([ <span class="number">-118.51</span> , <span class="number">34.26</span> , <span class="number">29.</span> , <span class="number">2119.</span> , <span class="number">433.</span> , <span class="number">1164.</span> , <span class="number">408.</span> , <span class="number">3.5414</span>])</span><br></pre></td></tr></table></figure>
<p>现在，你就可以使用这个“训练过的”imputer来对训练集进行转换，通过将缺失值替换为中位数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = imputer.transform(housing_num)</span><br></pre></td></tr></table></figure>
<p>结果是一个普通的 Numpy 数组，包含有转换后的特征。如果你想将其放回到 PandasDataFrame中，也很简单：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">housing_tr = pd.DataFrame(X, columns=housing_num.columns) <span class="comment"># 得到处理缺失值后的DF数据</span></span><br></pre></td></tr></table></figure>
<h2 id="整理数据："><a href="#整理数据：" class="headerlink" title="整理数据："></a>整理数据：</h2><h3 id="数据缩放"><a href="#数据缩放" class="headerlink" title="数据缩放"></a>数据缩放</h3><p>有两种常见的方法可以让所有的属性有相同的量度：<strong>线性函数归一化（Min-Max scaling）和标准化（standardization</strong>）。Scikit-Learn 提供了一个转换器MinMaxScaler来实现这个功能。它有一个超参数feature_range，可以让你改变范围，如果不希望范围是 0 到 1；Scikit-Learn 提供了一个转换器StandardScaler来进行标准化</p>
<p>min-max方式,对应的方法为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MinMaxScaler(self, feature_range=(<span class="number">0</span>, <span class="number">1</span>), copy=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>standardization 标准化数据,对应的方法为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">StandardScaler(self, copy=<span class="literal">True</span>, with_mean=<span class="literal">True</span>, with_std=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>警告：与所有的转换一样，缩放器只能向训练集拟合，而不是向完整的数据集（包括测试集）。只有这样，你才能用缩放器转换训练集和测试集（和新数据）。</p>
</blockquote>
<h3 id="处理极端离群值"><a href="#处理极端离群值" class="headerlink" title="处理极端离群值"></a>处理极端离群值</h3><p>还是举加利福尼亚州住房数据集中的人均住房数的例子，有的极端值达到了50<br>对于这些极端值其实很好处理，无非几个办法</p>
<ul>
<li><strong>对数缩放</strong>  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">roomsPerPerson = log((totalRooms / population) + 1)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>特征值限制到 某个上限或者下限</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">roomsPerPerson = min(totalRooms / population, <span class="number">4</span>)	<span class="comment"># 大于4.0的取4.0</span></span><br></pre></td></tr></table></figure>
<h3 id="分箱"><a href="#分箱" class="headerlink" title="分箱"></a>分箱</h3><p><strong>分箱</strong>其实是一个形象化的说法，就是把数据分开来，装在一个个箱子里，这样一个箱子里的数据就是一家人了。<br>那有什么用呢？下面就举个栗子！</p>
<p><img src="/2018/07/09/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（一）：一个完整的程序/04.png" alt></p>
<p>在数据集中，<code>latitude</code> 是一个浮点值。不过，在我们的模型中将 <code>latitude</code> 表示为浮点特征没有意义。这是因为纬度和房屋价值之间不存在线性关系。例如，纬度 35 处的房屋并不比纬度 34 处的房屋贵 35/34（或更便宜）。但是，纬度或许能很好地预测房屋价值。</p>
<p>我们现在拥有 11 个不同的布尔值特征（<code>LatitudeBin1</code>、<code>LatitudeBin2</code>、…、<code>LatitudeBin11</code>），而不是一个浮点特征。拥有 11 个不同的特征有点不方便，因此我们将它们统一成一个 11 元素矢量。这样做之后，我们可以将纬度 37.4 表示为：</p>
<p>[0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]</p>
<p>分箱之后，我们的模型现在可以为每个纬度学习完全不同的权重。（是不是觉得有点像独热编码，没错，就是的）</p>
<blockquote>
<p>为了简单起见，我们在纬度样本中使用整数作为分箱边界。如果我们需要更精细的解决方案，我们可以每隔 1/10 个纬度拆分一次分箱边界。添加更多箱可让模型从纬度 37.4 处学习和维度 37.5 处不一样的行为，但前提是每 1/10 个纬度均有充足的样本可供学习。</p>
<p>另一种方法是按<a href="https://wikipedia.org/wiki/Quantile" target="_blank" rel="noopener">分位数</a>分箱，这种方法可以确保每个桶内的样本数量是相等的。按分位数分箱完全无需担心离群值。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">分桶也称为分箱。</span></span><br><span class="line"><span class="string">例如，我们可以将 population 分为以下 3 个分桶：</span></span><br><span class="line"><span class="string">bucket_0 (&lt; 5000)：对应于人口分布较少的街区</span></span><br><span class="line"><span class="string">bucket_1 (5000 - 25000)：对应于人口分布适中的街区</span></span><br><span class="line"><span class="string">bucket_2 (&gt; 25000)：对应于人口分布较多的街区</span></span><br><span class="line"><span class="string">根据前面的分桶定义，以下 population 矢量：</span></span><br><span class="line"><span class="string">[[10001], [42004], [2500], [18000]]</span></span><br><span class="line"><span class="string">将变成以下经过分桶的特征矢量：</span></span><br><span class="line"><span class="string">[[1], [2], [0], [1]]</span></span><br><span class="line"><span class="string">这些特征值现在是分桶索引。请注意，这些索引被视为离散特征。通常情况下，这些特征将被进一步转换为上述独热表示法，但这是以透明方式实现的。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">要为分桶特征定义特征列，我们可以使用 bucketized_column（而不是使用 numeric_column），该列将数字列作为输入，并使用 boundardies 参数中指定的分桶边界将其转换为分桶特征。以下代码为 households 和 longitude 定义了分桶特征列；get_quantile_based_boundaries 函数会根据分位数计算边界，以便每个分桶包含相同数量的元素</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_quantile_based_boundaries</span><span class="params">(feature_values, num_buckets)</span>:</span></span><br><span class="line">    boundaries = np.arange(<span class="number">1.0</span>, num_buckets) / num_buckets</span><br><span class="line">    quantiles = feature_values.quantile(boundaries)</span><br><span class="line">    <span class="keyword">return</span> [quantiles[q] <span class="keyword">for</span> q <span class="keyword">in</span> quantiles.keys()]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Divide households into 7 buckets.</span></span><br><span class="line">households = tf.feature_column.numeric_column(<span class="string">"households"</span>)		<span class="comment"># 定义数值特征</span></span><br><span class="line"><span class="comment"># 分桶特征bucketized_column第一个参数用数字列 numeric_column得到的households，第二个参数用上面get_quantile_based_boundaries方法得到的分桶数据，返回的bucketized_households为可使用的分桶特征</span></span><br><span class="line">bucketized_households = tf.feature_column.bucketized_column(       </span><br><span class="line">    households,boundaries=get_quantile_based_boundaries(california_housing_dataframe[<span class="string">"households"</span>], <span class="number">7</span>))</span><br></pre></td></tr></table></figure>
<h2 id="自定义转换器"><a href="#自定义转换器" class="headerlink" title="自定义转换器"></a>自定义转换器</h2><p>尽管 Scikit-Learn 提供了许多有用的转换器，你还是需要自己动手写转换器执行任务，比如自定义的清理操作，或属性组合。<strong>你需要让自制的转换器与 Scikit-Learn 组件（比如流水线）无缝衔接工作，因为 Scikit-Learn 是依赖鸭子类型的（而不是继承，忽略对象，只要行为像就行），你所需要做的是创建一个类并执行三个方法：fit()（返回self），transform()，和fit_transform()</strong>。<strong>通过添加TransformerMixin作为基类，可以很容易地得到最后一个。另外，如果你添加BaseEstimator作为基类（且构造器中避免使用args和kargs</strong>），<strong>你就能得到两个额外的方法（get_params()和set_params()），二者可以方便地进行超参数自动微调</strong>。例如，一个小转换器类添加了上面讨论的属性：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加一个特征组合的装换器</span></span><br><span class="line"><span class="keyword">from</span> sklearn.base <span class="keyword">import</span> BaseEstimator, TransformerMixin</span><br><span class="line">rooms_ix, bedrooms_ix, population_ix, household_ix = <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里的示例没有定义fit_transform()，可能是因为fit()没有做任何动作（我猜的</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CombinedAttributesAdder</span><span class="params">(BaseEstimator, TransformerMixin)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, add_bedrooms_per_room = True)</span>:</span> <span class="comment"># no *args or **kargs</span></span><br><span class="line">        self.add_bedrooms_per_room = add_bedrooms_per_room</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit</span><span class="params">(self, X, y=None)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self  <span class="comment"># nothing else to do</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">transform</span><span class="params">(self, X, y=None)</span>:</span></span><br><span class="line">        rooms_per_household = X[:, rooms_ix] / X[:, household_ix]  <span class="comment"># X[:,3]表示的是第4列所有数据</span></span><br><span class="line">        population_per_household = X[:, population_ix] / X[:, household_ix]</span><br><span class="line">        <span class="keyword">if</span> self.add_bedrooms_per_room:</span><br><span class="line">            bedrooms_per_room = X[:, bedrooms_ix] / X[:, rooms_ix]</span><br><span class="line">            <span class="keyword">return</span> np.c_[X, rooms_per_household, population_per_household, <span class="comment"># np.c_表示的是拼接数组。</span></span><br><span class="line">                         bedrooms_per_room]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> np.c_[X, rooms_per_household, population_per_household]</span><br><span class="line"></span><br><span class="line">attr_adder = CombinedAttributesAdder(add_bedrooms_per_room=<span class="literal">False</span>)</span><br><span class="line">housing_extra_attribs = attr_adder.transform(housing.values)    <span class="comment"># 返回一个加入新特征的数据</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，转换器有一个超参数add_bedrooms_per_room，默认设为True（提供一个合理的默认值很有帮助）。这个超参数可以让你方便地发现添加了这个属性是否对机器学习算法有帮助。更一般地，你可以为每个不能完全确保的数据准备步骤添加一个超参数。数据准备步骤越自动化，可以自动化的操作组合就越多，越容易发现更好用的组合（并能节省大量时间）。</p>
<p><strong>另外sklearn是不能直接处理DataFrames的，那么我们需要自定义一个处理的方法将之转化为numpy类型</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataFrameSelector</span><span class="params">(BaseEstimator,TransformerMixin)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,attribute_names)</span>:</span> <span class="comment">#可以为列表</span></span><br><span class="line">        self.attribute_names = attribute_names</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit</span><span class="params">(self,X,y=None)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">transform</span><span class="params">(self,X)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> X[self.attribute_names].values <span class="comment">#返回的为numpy array</span></span><br></pre></td></tr></table></figure>
<h2 id="转换流水线"><a href="#转换流水线" class="headerlink" title="转换流水线"></a>转换流水线</h2><p>目前在数据预处理阶段，<strong>我们需要对缺失值进行处理、特征组合和特征缩放。每一步的执行都有着先后顺序，存在许多数据转换步骤，需要按一定的顺序执行。</strong>sklearn提供了Pipeline帮助顺序完成转换幸运的是，Scikit-Learn 提供了类Pipeline，来进行这一系列的转换。下面是一个数值属性的小流水线：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> Pipeline</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"></span><br><span class="line">num_pipeline = Pipeline([</span><br><span class="line">        (<span class="string">'imputer'</span>, Imputer(strategy=<span class="string">"median"</span>)),    <span class="comment"># 处理缺失值</span></span><br><span class="line">        (<span class="string">'attribs_adder'</span>, CombinedAttributesAdder()),    <span class="comment"># 特征组合</span></span><br><span class="line">        (<span class="string">'std_scaler'</span>, StandardScaler()),    <span class="comment"># 特征缩放</span></span><br><span class="line">        ])</span><br><span class="line"></span><br><span class="line">housing_num_tr = num_pipeline.fit_transform(housing_num)</span><br></pre></td></tr></table></figure>
<p><strong>Pipeline构造器需要一个定义步骤顺序的名字/估计器对的列表。除了最后一个估计器，其余都要是转换器（即，它们都要有fit_transform()方法）</strong>。名字可以随意起。</p>
<p><strong>当你调用流水线的fit()方法，就会对所有转换器顺序调用fit_transform()方法，将每次调用的输出作为参数传递给下一个调用，一直到最后一个估计器，它只执行fit()方法。</strong></p>
<p>估计器（Estimator）：很多时候可以直接理解成分类器，主要包含两个函数：fit()和predict()<br>转换器（Transformer）：转换器用于数据预处理和数据转换，主要是三个方法：fit（）,transform()和fit_transform()</p>
<p>最后的估计器是一个StandardScaler，它是一个转换器，因此这个流水线有一个transform()方法，可以顺序对数据做所有转换（它还有一个fit_transform方法可以使用，就不必先调用fit()再进行transform()）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num_attribs = list(housing_num) <span class="comment"># 返回的为列名[col1,col2,....]</span></span><br><span class="line">cat_attribs = [<span class="string">"ocean_proximity"</span>]</span><br><span class="line"></span><br><span class="line">num_pipeline = Pipeline([ <span class="comment"># 数值类型</span></span><br><span class="line">        (<span class="string">'selector'</span>, DataFrameSelector(num_attribs)),	<span class="comment"># DataFrames转为numpy array</span></span><br><span class="line">        (<span class="string">'imputer'</span>, Imputer(strategy=<span class="string">"median"</span>)),	<span class="comment"># 缺失值处理</span></span><br><span class="line">        (<span class="string">'attribs_adder'</span>, CombinedAttributesAdder()),	<span class="comment"># 特征组合</span></span><br><span class="line">        (<span class="string">'std_scaler'</span>, StandardScaler()),	<span class="comment"># 缩放</span></span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line">cat_pipeline = Pipeline([ <span class="comment"># 标签类型</span></span><br><span class="line">        (<span class="string">'selector'</span>, DataFrameSelector(cat_attribs)), 	<span class="comment"># DataFrames转为numpy array</span></span><br><span class="line">        (<span class="string">'cat_encoder'</span>, CategoricalEncoder(encoding=<span class="string">"onehot-dense"</span>)),	</span><br><span class="line">    ])</span><br></pre></td></tr></table></figure>
<p>上面定义的为分别处理数值类型和标签类型的转换流程，housing_num为DataFrame类型，list(DataFrame)的结果返回的为列名字。上面着两个流程还可以再整合一起。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> FeatureUnion</span><br><span class="line">full_pipeline = FeatureUnion(transformer_list=[</span><br><span class="line">        (<span class="string">"num_pipeline"</span>, num_pipeline),</span><br><span class="line">        (<span class="string">"cat_pipeline"</span>, cat_pipeline),</span><br><span class="line">    ])</span><br><span class="line">housing_prepared = full_pipeline.fit_transform(housing) <span class="comment"># 最终的结果</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>housing_prepared</span><br><span class="line">array([[ <span class="number">0.73225807</span>, <span class="number">-0.67331551</span>,  <span class="number">0.58426443</span>, ...,  <span class="number">0.</span>        ,</span><br><span class="line">         <span class="number">0.</span>        ,  <span class="number">0.</span>        ],</span><br><span class="line">       [<span class="number">-0.99102923</span>,  <span class="number">1.63234656</span>, <span class="number">-0.92655887</span>, ...,  <span class="number">0.</span>        ,</span><br><span class="line">         <span class="number">0.</span>        ,  <span class="number">0.</span>        ],</span><br><span class="line">       [...]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>housing_prepared.shape</span><br><span class="line">(<span class="number">16513</span>, <span class="number">17</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>译注:</p>
<p>如果你在上面代码中的<code>cat_pipeline</code>流水线使用<code>LabelBinarizer</code>转换器会导致执行错误，解决方案是用上文提到的<code>CategoricalEncoder</code>转换器来代替：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; cat_pipeline = Pipeline([</span><br><span class="line">&gt;         (<span class="string">'selector'</span>, DataFrameSelector(cat_attribs)),</span><br><span class="line">&gt;         (<span class="string">'cat_encoder'</span>, CategoricalEncoder(encoding=<span class="string">"onehot-dense"</span>)),</span><br><span class="line">&gt;     ])</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
</blockquote>
<p><strong>每个子流水线都以一个选择转换器开始：通过选择对应的属性（数值或分类）、丢弃其它的，来转换数据，并将输出DataFrame转变成一个 NumPy 数组。Scikit-Learn 没有工具来处理 PandasDataFrame，因此我们需要写一个简单的自定义转换器来做这项工作：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.base <span class="keyword">import</span> BaseEstimator, TransformerMixin</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataFrameSelector</span><span class="params">(BaseEstimator, TransformerMixin)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, attribute_names)</span>:</span></span><br><span class="line">        self.attribute_names = attribute_names</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit</span><span class="params">(self, X, y=None)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">transform</span><span class="params">(self, X)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> X[self.attribute_names].values</span><br></pre></td></tr></table></figure>
<h1 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h1><p>我们先来训练一个线性回归模型：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line"></span><br><span class="line">lin_reg = LinearRegression()</span><br><span class="line">lin_reg.fit(housing_prepared, housing_labels)    <span class="comment"># 利用预处理好的数据进行训练模型</span></span><br></pre></td></tr></table></figure>
<p>完毕！你现在就有了一个可用的线性回归模型。用一些训练集中的实例做下验证：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>some_data = housing.iloc[:<span class="number">5</span>]    <span class="comment"># 前五个作为预测数据</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>some_labels = housing_labels.iloc[:<span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>some_data_prepared = full_pipeline.transform(some_data)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">"Predictions:\t"</span>, lin_reg.predict(some_data_prepared))    <span class="comment"># 预测结果</span></span><br><span class="line">Predictions:     [ <span class="number">303104.</span>   <span class="number">44800.</span>  <span class="number">308928.</span>  <span class="number">294208.</span>  <span class="number">368704.</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">"Labels:\t\t"</span>, list(some_labels))</span><br><span class="line">Labels:         [<span class="number">359400.0</span>, <span class="number">69700.0</span>, <span class="number">302100.0</span>, <span class="number">301300.0</span>, <span class="number">351900.0</span>]    <span class="comment"># 实际结果</span></span><br></pre></td></tr></table></figure>
<p>行的通，尽管预测并不怎么准确（比如，第二个预测偏离了 50%！）。让我们使用 Scikit-Learn 的mean_squared_error函数，用全部训练集来计算下这个回归模型的 RMSE：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> mean_squared_error</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>housing_predictions = lin_reg.predict(housing_prepared)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lin_mse = mean_squared_error(housing_labels, housing_predictions)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lin_rmse = np.sqrt(lin_mse)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lin_rmse</span><br><span class="line"><span class="number">68628.413493824875</span></span><br></pre></td></tr></table></figure>
<p>OK，有总比没有强，但显然结果并不好，这是一个模型欠拟合训练数据的例子。当这种情况发生时，意味着特征没有提供足够多的信息来做出一个好的预测，或者模型并不强大，修复欠拟合的主要方法是选择一个更强大的模型，给训练算法提供更好的特征，或去掉模型上的限制，你可以尝试添加更多特征（比如，人口的对数值），但是首先让我们尝试一个更为复杂的模型，看看效果。训练一个决策树模型DecisionTreeRegressor。这是一个强大的模型，可以发现数据中复杂的非线性关系。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeRegressor</span><br><span class="line"></span><br><span class="line">tree_reg = DecisionTreeRegressor()</span><br><span class="line">tree_reg.fit(housing_prepared, housing_labels)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>housing_predictions = tree_reg.predict(housing_prepared)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tree_mse = mean_squared_error(housing_labels, housing_predictions)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tree_rmse = np.sqrt(tree_mse)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tree_rmse</span><br><span class="line"><span class="number">0.0</span></span><br></pre></td></tr></table></figure>
<p>等一下，发生了什么？没有误差？这个模型可能是绝对完美的吗？当然，更大可能性是这个模型严重过拟合数据。如何确定呢？如前所述，直到你准备运行一个具备足够信心的模型，都不要碰测试集，因此你需要使用训练集的部分数据来做训练，用一部分来做模型验证。</p>
<h2 id="用交叉验证做更佳的评估"><a href="#用交叉验证做更佳的评估" class="headerlink" title="用交叉验证做更佳的评估"></a>用交叉验证做更佳的评估</h2><p>使用 Scikit-Learn 的交叉验证功能。下面的代码采用了 <strong>K 折交叉验证（K-fold cross-validation）：它随机地将训练集分成十个不同的子集，成为“折”，然后训练评估决策树模型 10 次，每次选一个不用的折来做评估，用其它 9 个来做训练。结果是一个包含 10 个评分的数组：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> cross_val_score</span><br><span class="line">scores = cross_val_score(tree_reg, housing_prepared, housing_labels,</span><br><span class="line">                         scoring=<span class="string">"neg_mean_squared_error"</span>, cv=<span class="number">10</span>)</span><br><span class="line">rmse_scores = np.sqrt(-scores)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>警告：Scikit-Learn 交叉验证功能期望的是效用函数（越大越好）而不是损失函数（越低越好），因此得分函数实际上与 MSE 相反（即负值），这就是为什么前面的代码在计算平方根之前先计算-scores。</p>
</blockquote>
<p>来看下结果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">display_scores</span><span class="params">(scores)</span>:</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">"Scores:"</span>, scores)</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">"Mean:"</span>, scores.mean())</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">"Standard deviation:"</span>, scores.std())</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>display_scores(tree_rmse_scores)</span><br><span class="line">Scores: [ <span class="number">74678.4916885</span>   <span class="number">64766.2398337</span>   <span class="number">69632.86942005</span>  <span class="number">69166.67693232</span></span><br><span class="line">          <span class="number">71486.76507766</span>  <span class="number">73321.65695983</span>  <span class="number">71860.04741226</span>  <span class="number">71086.32691692</span></span><br><span class="line">          <span class="number">76934.2726093</span>   <span class="number">69060.93319262</span>]</span><br><span class="line">Mean: <span class="number">71199.4280043</span></span><br><span class="line">Standard deviation: <span class="number">3202.70522793</span></span><br></pre></td></tr></table></figure>
<p>现在决策树就不像前面看起来那么好了。实际上，它看起来比线性回归模型还糟！注意到交叉验证不仅可以让你得到模型性能的评估，还能测量评估的准确性（即，它的标准差）。决策树的评分大约是 71200，通常波动有 ±3200。如果只有一个验证集，就得不到这些信息。但是交叉验证的代价是训练了模型多次，不可能总是这样。</p>
<p>让我们计算下线性回归模型的的相同分数，以做确保：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>lin_scores = cross_val_score(lin_reg, housing_prepared, housing_labels,</span><br><span class="line"><span class="meta">... </span>                             scoring=<span class="string">"neg_mean_squared_error"</span>, cv=<span class="number">10</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lin_rmse_scores = np.sqrt(-lin_scores)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>display_scores(lin_rmse_scores)</span><br><span class="line">Scores: [ <span class="number">70423.5893262</span>   <span class="number">65804.84913139</span>  <span class="number">66620.84314068</span>  <span class="number">72510.11362141</span></span><br><span class="line">          <span class="number">66414.74423281</span>  <span class="number">71958.89083606</span>  <span class="number">67624.90198297</span>  <span class="number">67825.36117664</span></span><br><span class="line">          <span class="number">72512.36533141</span>  <span class="number">68028.11688067</span>]</span><br><span class="line">Mean: <span class="number">68972.377566</span></span><br><span class="line">Standard deviation: <span class="number">2493.98819069</span></span><br></pre></td></tr></table></figure>
<p>判断没错：决策树模型过拟合很严重，它的性能比线性回归模型还差</p>
<p>现在再尝试最后一个模型：RandomForestRegressor（随机森林），随机森林是通过用特征的随机子集训练许多决策树。在其它多个模型之上建立模型成为集成学习（Ensemble Learning），它是推进 ML 算法的一种好方法。我们会跳过大部分的代码，因为代码本质上和其它模型一样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestRegressor</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>forest_reg = RandomForestRegressor()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>forest_reg.fit(housing_prepared, housing_labels)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[...]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>forest_rmse</span><br><span class="line"><span class="number">22542.396440343684</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>display_scores(forest_rmse_scores)</span><br><span class="line">Scores: [ <span class="number">53789.2879722</span>   <span class="number">50256.19806622</span>  <span class="number">52521.55342602</span>  <span class="number">53237.44937943</span></span><br><span class="line">          <span class="number">52428.82176158</span>  <span class="number">55854.61222549</span>  <span class="number">52158.02291609</span>  <span class="number">50093.66125649</span></span><br><span class="line">          <span class="number">53240.80406125</span>  <span class="number">52761.50852822</span>]</span><br><span class="line">Mean: <span class="number">52634.1919593</span></span><br><span class="line">Standard deviation: <span class="number">1576.20472269</span></span><br></pre></td></tr></table></figure>
<p>现在好多了：随机森林看起来很有希望。但是，训练集的评分仍然比验证集的评分低很多。解决过拟合可以通过简化模型，给模型加限制（即，正则化），或用更多的训练数据。在深入随机森林之前，你应该尝试下机器学习算法的其它类型模型（不同核心的支持向量机，神经网络，等等），不要在调节超参数上花费太多时间。目标是列出一个可能模型的列表（两到五个）。</p>
<blockquote>
<p>提示：你要保存每个试验过的模型，以便后续可以再用。要确保有超参数和训练参数，以及交叉验证评分，和实际的预测值。这可以让你比较不同类型模型的评分，还可以比较误差种类。你可以用 Python 的模块pickle，非常方便地保存 Scikit-Learn 模型，或使用sklearn.externals.joblib，后者序列化大 NumPy 数组更有效率：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.externals <span class="keyword">import</span> joblib</span><br><span class="line"></span><br><span class="line">joblib.dump(my_model, <span class="string">"my_model.pkl"</span>)</span><br><span class="line"><span class="comment"># 然后</span></span><br><span class="line">my_model_loaded = joblib.load(<span class="string">"my_model.pkl"</span>)</span><br></pre></td></tr></table></figure>
<h2 id="模型微调"><a href="#模型微调" class="headerlink" title="模型微调"></a>模型微调</h2><p><strong>网格搜索</strong>：使用 Scikit-Learn 的GridSearchCV来做这项搜索工作。<strong>你所需要做的是告诉GridSearchCV要试验有哪些超参数，要试验什么值，GridSearchCV就能用交叉验证试验所有可能超参数值的组合</strong>。例如，下面的代码搜索了RandomForestRegressor超参数值的最佳组合（很费时间）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> GridSearchCV</span><br><span class="line"></span><br><span class="line">param_grid = [</span><br><span class="line">    &#123;<span class="string">'n_estimators'</span>: [<span class="number">3</span>, <span class="number">10</span>, <span class="number">30</span>], <span class="string">'max_features'</span>: [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]&#125;,</span><br><span class="line">    &#123;<span class="string">'bootstrap'</span>: [<span class="literal">False</span>], <span class="string">'n_estimators'</span>: [<span class="number">3</span>, <span class="number">10</span>], <span class="string">'max_features'</span>: [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]&#125;,</span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line">forest_reg = RandomForestRegressor()</span><br><span class="line"></span><br><span class="line">grid_search = GridSearchCV(forest_reg, param_grid, cv=<span class="number">5</span>,</span><br><span class="line">                           scoring=<span class="string">'neg_mean_squared_error'</span>)</span><br><span class="line"></span><br><span class="line">grid_search.fit(housing_prepared, housing_labels)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当你不能确定超参数该有什么值，一个简单的方法是尝试连续的 10 的幂（如果想要一个粒度更小的搜寻，可以用更小的数，就像在这个例子中对超参数n_estimators做的）。</p>
</blockquote>
<p>param_grid告诉 Scikit-Learn 首先评估所有的列在第一个dict中的n_estimators和max_features的3 × 4 = 12种组合（不用担心这些超参数的含义，会在第 7 章中解释）。然后尝试第二个dict中超参数的2 × 3 = 6种组合，这次会将超参数bootstrap设为False而不是True（后者是该超参数的默认值）。完成后，你就能获得参数的最佳组合，如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>grid_search.best_params_</span><br><span class="line">&#123;<span class="string">'max_features'</span>: <span class="number">6</span>, <span class="string">'n_estimators'</span>: <span class="number">30</span>&#125;</span><br></pre></td></tr></table></figure>
<p>你还能直接得到最佳的估计器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>grid_search.best_estimator_</span><br><span class="line">RandomForestRegressor(bootstrap=<span class="literal">True</span>, criterion=<span class="string">'mse'</span>, max_depth=<span class="literal">None</span>,</span><br><span class="line">           max_features=<span class="number">6</span>, max_leaf_nodes=<span class="literal">None</span>, min_samples_leaf=<span class="number">1</span>,</span><br><span class="line">           min_samples_split=<span class="number">2</span>, min_weight_fraction_leaf=<span class="number">0.0</span>,</span><br><span class="line">           n_estimators=<span class="number">30</span>, n_jobs=<span class="number">1</span>, oob_score=<span class="literal">False</span>, random_state=<span class="literal">None</span>,</span><br><span class="line">           verbose=<span class="number">0</span>, warm_start=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<p>当然，也可以得到评估得分：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>cvres = grid_search.cv_results_</span><br><span class="line"><span class="meta">... </span><span class="keyword">for</span> mean_score, params <span class="keyword">in</span> zip(cvres[<span class="string">"mean_test_score"</span>], cvres[<span class="string">"params"</span>]):</span><br><span class="line"><span class="meta">... </span>    print(np.sqrt(-mean_score), params)</span><br><span class="line">...</span><br><span class="line"><span class="number">64912.0351358</span> &#123;<span class="string">'max_features'</span>: <span class="number">2</span>, <span class="string">'n_estimators'</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="number">55535.2786524</span> &#123;<span class="string">'max_features'</span>: <span class="number">2</span>, <span class="string">'n_estimators'</span>: <span class="number">10</span>&#125;</span><br><span class="line"><span class="number">52940.2696165</span> &#123;<span class="string">'max_features'</span>: <span class="number">2</span>, <span class="string">'n_estimators'</span>: <span class="number">30</span>&#125;</span><br><span class="line"><span class="number">60384.0908354</span> &#123;<span class="string">'max_features'</span>: <span class="number">4</span>, <span class="string">'n_estimators'</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="number">52709.9199934</span> &#123;<span class="string">'max_features'</span>: <span class="number">4</span>, <span class="string">'n_estimators'</span>: <span class="number">10</span>&#125;</span><br><span class="line"><span class="number">50503.5985321</span> &#123;<span class="string">'max_features'</span>: <span class="number">4</span>, <span class="string">'n_estimators'</span>: <span class="number">30</span>&#125;</span><br><span class="line"><span class="number">59058.1153485</span> &#123;<span class="string">'max_features'</span>: <span class="number">6</span>, <span class="string">'n_estimators'</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="number">52172.0292957</span> &#123;<span class="string">'max_features'</span>: <span class="number">6</span>, <span class="string">'n_estimators'</span>: <span class="number">10</span>&#125;</span><br><span class="line"><span class="number">49958.9555932</span> &#123;<span class="string">'max_features'</span>: <span class="number">6</span>, <span class="string">'n_estimators'</span>: <span class="number">30</span>&#125;</span><br><span class="line"><span class="number">59122.260006</span> &#123;<span class="string">'max_features'</span>: <span class="number">8</span>, <span class="string">'n_estimators'</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="number">52441.5896087</span> &#123;<span class="string">'max_features'</span>: <span class="number">8</span>, <span class="string">'n_estimators'</span>: <span class="number">10</span>&#125;</span><br><span class="line"><span class="number">50041.4899416</span> &#123;<span class="string">'max_features'</span>: <span class="number">8</span>, <span class="string">'n_estimators'</span>: <span class="number">30</span>&#125;</span><br><span class="line"><span class="number">62371.1221202</span> &#123;<span class="string">'bootstrap'</span>: <span class="literal">False</span>, <span class="string">'max_features'</span>: <span class="number">2</span>, <span class="string">'n_estimators'</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="number">54572.2557534</span> &#123;<span class="string">'bootstrap'</span>: <span class="literal">False</span>, <span class="string">'max_features'</span>: <span class="number">2</span>, <span class="string">'n_estimators'</span>: <span class="number">10</span>&#125;</span><br><span class="line"><span class="number">59634.0533132</span> &#123;<span class="string">'bootstrap'</span>: <span class="literal">False</span>, <span class="string">'max_features'</span>: <span class="number">3</span>, <span class="string">'n_estimators'</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="number">52456.0883904</span> &#123;<span class="string">'bootstrap'</span>: <span class="literal">False</span>, <span class="string">'max_features'</span>: <span class="number">3</span>, <span class="string">'n_estimators'</span>: <span class="number">10</span>&#125;</span><br><span class="line"><span class="number">58825.665239</span> &#123;<span class="string">'bootstrap'</span>: <span class="literal">False</span>, <span class="string">'max_features'</span>: <span class="number">4</span>, <span class="string">'n_estimators'</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="number">52012.9945396</span> &#123;<span class="string">'bootstrap'</span>: <span class="literal">False</span>, <span class="string">'max_features'</span>: <span class="number">4</span>, <span class="string">'n_estimators'</span>: <span class="number">10</span>&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们通过设定超参数max_features为 6，n_estimators为 30，得到了最佳方案。对这个组合，RMSE 的值是 49959，这比之前使用默认的超参数的值（52634）要稍微好一些。祝贺你，你成功地微调了最佳模型！</p>
<p><strong>随机搜索：</strong>当探索相对较少的组合时，就像前面的例子，网格搜索还可以。但是当超参数的搜索空间很大时，最好使用RandomizedSearchCV。这个类的使用方法和类GridSearchCV很相似，但它不是尝试所有可能的组合，而是通过选择每个超参数的一个随机值的特定数量的随机组合。这个方法有两个优点：</p>
<ul>
<li>如果你让随机搜索运行，比如 1000 次，它会探索每个超参数的 1000 个不同的值（而不是像网格搜索那样，只搜索每个超参数的几个值）</li>
<li>你可以方便地通过设定搜索次数，控制超参数搜索的计算量。</li>
</ul>
<h2 id="分析最佳模型和它们的误差"><a href="#分析最佳模型和它们的误差" class="headerlink" title="分析最佳模型和它们的误差"></a>分析最佳模型和它们的误差</h2><p>通过<strong>分析最佳模型</strong>，常常可以获得对问题更深的了解。比如，RandomForestRegressor可以指出<strong>每个属性对于做出准确预测的相对重要性</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; feature_importances = grid_search.best_estimator_.feature_importances_</span><br><span class="line">&gt;&gt;&gt; feature_importances</span><br><span class="line">array([  7.14156423e-02,   6.76139189e-02,   4.44260894e-02,</span><br><span class="line">         1.66308583e-02,   1.66076861e-02,   1.82402545e-02,</span><br><span class="line">         1.63458761e-02,   3.26497987e-01,   6.04365775e-02,</span><br><span class="line">         1.13055290e-01,   7.79324766e-02,   1.12166442e-02,</span><br><span class="line">         1.53344918e-01,   8.41308969e-05,   2.68483884e-03,</span><br><span class="line">         3.46681181e-03])</span><br></pre></td></tr></table></figure>
<p>将重要性分数和属性名放到一起：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>extra_attribs = [<span class="string">"rooms_per_hhold"</span>, <span class="string">"pop_per_hhold"</span>, <span class="string">"bedrooms_per_room"</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cat_one_hot_attribs = list(encoder.classes_)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>attributes = num_attribs + extra_attribs + cat_one_hot_attribs</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(zip(feature_importances,attributes), reverse=<span class="literal">True</span>)</span><br><span class="line">[(<span class="number">0.32649798665134971</span>, <span class="string">'median_income'</span>),</span><br><span class="line"> (<span class="number">0.15334491760305854</span>, <span class="string">'INLAND'</span>),</span><br><span class="line"> (<span class="number">0.11305529021187399</span>, <span class="string">'pop_per_hhold'</span>),</span><br><span class="line"> (<span class="number">0.07793247662544775</span>, <span class="string">'bedrooms_per_room'</span>),</span><br><span class="line"> (<span class="number">0.071415642259275158</span>, <span class="string">'longitude'</span>),</span><br><span class="line"> (<span class="number">0.067613918945568688</span>, <span class="string">'latitude'</span>),</span><br><span class="line"> (<span class="number">0.060436577499703222</span>, <span class="string">'rooms_per_hhold'</span>),</span><br><span class="line"> (<span class="number">0.04442608939578685</span>, <span class="string">'housing_median_age'</span>),</span><br><span class="line"> (<span class="number">0.018240254462909437</span>, <span class="string">'population'</span>),</span><br><span class="line"> (<span class="number">0.01663085833886218</span>, <span class="string">'total_rooms'</span>),</span><br><span class="line"> (<span class="number">0.016607686091288865</span>, <span class="string">'total_bedrooms'</span>),</span><br><span class="line"> (<span class="number">0.016345876147580776</span>, <span class="string">'households'</span>),</span><br><span class="line"> (<span class="number">0.011216644219017424</span>, <span class="string">'&lt;1H OCEAN'</span>),</span><br><span class="line"> (<span class="number">0.0034668118081117387</span>, <span class="string">'NEAR OCEAN'</span>),</span><br><span class="line"> (<span class="number">0.0026848388432755429</span>, <span class="string">'NEAR BAY'</span>),</span><br><span class="line"> (<span class="number">8.4130896890070617e-05</span>, <span class="string">'ISLAND'</span>)]</span><br></pre></td></tr></table></figure>
<p>有了这个信息，你就可以丢弃一些不那么重要的特征（比如，显然只要一个分类ocean_proximity就够了，所以可以丢弃掉其它的）。你还应该看一下系统犯的误差，搞清为什么会有些误差，以及如何改正问题（添加更多的特征，或相反，去掉没有什么信息的特征，清洗异常值等等）。</p>
<h1 id="模型评估"><a href="#模型评估" class="headerlink" title="模型评估"></a>模型评估</h1><p>调节完系统之后，你终于有了一个性能足够好的系统。现在就可以用测试集评估最后的模型了。这个过程没有什么特殊的：从测试集得到预测值和标签，运行full_pipeline转换数据（调用transform()，而不是fit_transform()！），再用测试集评估最终模型：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">final_model = grid_search.best_estimator_</span><br><span class="line"></span><br><span class="line">X_test = strat_test_set.drop(<span class="string">"median_house_value"</span>, axis=<span class="number">1</span>)</span><br><span class="line">y_test = strat_test_set[<span class="string">"median_house_value"</span>].copy()</span><br><span class="line"></span><br><span class="line">X_test_prepared = full_pipeline.transform(X_test)</span><br><span class="line"></span><br><span class="line">final_predictions = final_model.predict(X_test_prepared)</span><br><span class="line"></span><br><span class="line">final_mse = mean_squared_error(y_test, final_predictions)</span><br><span class="line">final_rmse = np.sqrt(final_mse)   <span class="comment"># =&gt; evaluates to 48,209.6</span></span><br></pre></td></tr></table></figure>
<p>评估结果通常要比交叉验证的效果差一点，如果你之前做过很多超参数微调（因为你的系统在验证集上微调，得到了不错的性能，通常不会在未知的数据集上有同样好的效果）。这个例子不属于这种情况，但是当发生这种情况时，你一定要忍住不要调节超参数，使测试集的效果变好；这样的提升不能推广到新数据上。</p>
]]></content>
      <categories>
        <category>Sklearn 与 TensorFlow 机器学习实用指南</category>
      </categories>
      <tags>
        <tag>拆分数据</tag>
        <tag>机器学习</tag>
        <tag>数据预处理</tag>
        <tag>K折交叉验证</tag>
        <tag>格子搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>python编程进阶（13）：兼容、缓存、上下文</title>
    <url>/2018/07/04/python%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6/python%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6%EF%BC%8813%EF%BC%89%EF%BC%9A%E5%85%BC%E5%AE%B9%E3%80%81%E7%BC%93%E5%AD%98%E3%80%81%E4%B8%8A%E4%B8%8B%E6%96%87/</url>
    <content><![CDATA[<h1 id="兼容Python2-和Python3"><a href="#兼容Python2-和Python3" class="headerlink" title="兼容Python2+和Python3+"></a>兼容Python2+和Python3+</h1><p>很多时候你可能希望你开发的程序能够同时兼容Python2+和Python3+。</p>
<p>试想你有一个非常出名的Python模块被很多开发者使用着，但并不是所有人都只使用Python2或者Python3。这时候你有两个办法。第一个办法是开发两个模块，针对Python2一个，针对Python3一个。还有一个办法就是调整你现在的代码使其同时兼容Python2和Python3。</p>
<p>本节中，我将介绍一些技巧，让你的脚本同时兼容Python2和Python3。</p>
<h2 id="Future模块导入"><a href="#Future模块导入" class="headerlink" title="Future模块导入"></a>Future模块导入</h2><p><strong>第一种也是最重要的方法，就是导入<code>__future__</code>模块。它可以帮你在Python2中导入Python3的功能</strong>。这有一组例子：</p>
<p>上下文管理器是Python2.6+引入的新特性，如果你想在Python2.5中使用它可以这样做：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> with_statement</span><br></pre></td></tr></table></figure>
<p>在Python3中<code>print</code>已经变为一个函数。如果你想在Python2中使用它可以通过<code>__future__</code>导入：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line">print(<span class="keyword">print</span>)</span><br><span class="line"><span class="comment"># Output: &lt;built-in function print&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="模块重命名"><a href="#模块重命名" class="headerlink" title="模块重命名"></a>模块重命名</h2><p>首先，告诉我你是如何在你的脚本中导入模块的。大多时候我们会这样做：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> foo </span><br><span class="line"><span class="comment"># or</span></span><br><span class="line"><span class="keyword">from</span> foo <span class="keyword">import</span> bar</span><br></pre></td></tr></table></figure>
<p>你知道么，其实你也可以这样做：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> foo <span class="keyword">as</span> foo</span><br></pre></td></tr></table></figure>
<p>这样做可以起到和上面代码同样的功能，但最重要的是它能让你的脚本同时兼容Python2和Python3。现在我们来看下面的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">import</span> urllib.request <span class="keyword">as</span> urllib_request  <span class="comment"># for Python 3</span></span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="keyword">import</span> urllib2 <span class="keyword">as</span> urllib_request  <span class="comment"># for Python 2</span></span><br></pre></td></tr></table></figure>
<h2 id="过期的Python2内置功能"><a href="#过期的Python2内置功能" class="headerlink" title="过期的Python2内置功能"></a>过期的Python2内置功能</h2><p>另一个需要了解的事情就是Python2中有12个内置功能在Python3中已经被移除了。要确保在Python2代码中不要出现这些功能来保证对Python3的兼容。这有一个强制让你放弃12内置功能的方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> future.builtins.disabled <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure>
<p>现在，只要你尝试在Python3中使用这些被遗弃的模块时，就会抛出一个<code>NameError</code>异常如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> future.builtins.disabled <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">apply()</span><br><span class="line"><span class="comment"># Output: NameError: obsolete Python 2 builtin apply is disabled</span></span><br></pre></td></tr></table></figure>
<p><strong>标准库向下兼容的外部支持</strong></p>
<p>有一些包在非官方的支持下为Python2提供了Python3的功能。例如，我们有：</p>
<ul>
<li>enum <code>pip install enum34</code></li>
<li>singledispatch <code>pip install singledispatch</code></li>
<li>pathlib <code>pip install pathlib</code></li>
</ul>
<p>想更多了解，在Python文档中有一个<a href="https://docs.python.org/3/howto/pyporting.html" target="_blank" rel="noopener">全面的指南</a>可以帮助你让你的代码同时兼容Python2和Python3。</p>
<h1 id="函数缓存-Function-caching"><a href="#函数缓存-Function-caching" class="headerlink" title="函数缓存 (Function caching)"></a>函数缓存 (Function caching)</h1><p><strong>函数缓存允许我们将一个函数对于给定参数的返回值缓存起来</strong>。当一个I/O密集的函数被频繁<strong>使用相同的参数调用的时候，函数缓存可以节约时间</strong>。在Python 3.2版本以前我们只有写一个自定义的实现。<strong>在Python 3.2以后版本，有个<code>lru_cache</code>的装饰器，允许我们将一个函数的返回值快速地缓存或取消缓存</strong>。</p>
<h2 id="Python-3-2及以后版本"><a href="#Python-3-2及以后版本" class="headerlink" title="Python 3.2及以后版本"></a>Python 3.2及以后版本</h2><p>我们来实现一个斐波那契计算器，并使用<code>lru_cache</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> lru_cache</span><br><span class="line"></span><br><span class="line"><span class="meta">@lru_cache(maxsize=32)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">return</span> fib(n<span class="number">-1</span>) + fib(n<span class="number">-2</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print([fib(n) <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">10</span>)])</span><br><span class="line"><span class="comment"># Output: [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]</span></span><br></pre></td></tr></table></figure>
<p>那个<code>maxsize</code>参数是告诉<code>lru_cache</code>，最多缓存最近多少个返回值。</p>
<p>我们也可以轻松地对返回值清空缓存，通过这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fib.cache_clear()</span><br></pre></td></tr></table></figure>
<h1 id="上下文管理器-Context-managers"><a href="#上下文管理器-Context-managers" class="headerlink" title="上下文管理器(Context managers)"></a>上下文管理器(Context managers)</h1><p>上下文管理器允许你在有需要的时候，精确地分配和释放资源。<strong>上下文管理器的常用于一些资源的操作，需要在资源的正确获取与释放相关的操作</strong> ，先看一个例子,我们经常会用到 try … catch … finally 语句确保一些系统资源得以正确释放。如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f = open(<span class="string">'somefile'</span>)</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        print(line)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    f.close()</span><br></pre></td></tr></table></figure>
<p>我们经常用到上面的代码模式，用复用代码的模式来讲，并不够好。于是 with 语句出现了，通过定义一个上下文管理器来封装这个代码块:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'somefile'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        print(line)</span><br></pre></td></tr></table></figure>
<p><strong>使用上下文管理器最广泛的案例就是<code>with</code>语句了</strong>。想象下你有两个需要结对执行的相关操作，然后还要在它们中间放置一段代码。 <strong>上下文管理器就是专门让你做这种事情的。上面这段代码打开了一个文件，往里面写入了一些数据，然后关闭该文件。如果在往文件写数据时发生异常，它也会尝试去关闭文件</strong>。这就是<code>with</code>语句的主要优势，它确保我们的文件会被关闭，而不用关注嵌套代码如何退出。</p>
<p>上下文管理器的一个常见用例，是资源的加锁和解锁，以及关闭已打开的文件（就像我已经展示给你看的）。</p>
<p>实际上，我们可以同时处理多个上下文管理器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> A() <span class="keyword">as</span> a, B() <span class="keyword">as</span> b:</span><br><span class="line">    suite</span><br></pre></td></tr></table></figure>
<h2 id="上下文管理协议"><a href="#上下文管理协议" class="headerlink" title="上下文管理协议"></a>上下文管理协议</h2><p>与迭代器类似，实现了迭代协议的函数/对象即为迭代器。实现了上下文协议的函数/对象即为上下文管理器。迭代器协议是实现了<code>__iter__</code>方法。上下文管理协议则是一个类实现<code>__enter__</code> (self)和<code>__exit__</code>(self, exc_type, exc_valye, traceback)方法就可以了。实行如下结构：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Contextor</span>:</span></span><br><span class="line">    <span class="comment"># __enter__返回一个对象，通常是当前类的实例，也可以是其他对象。</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, exc_type, exc_val, exc_tb)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">contextor = Contextor()</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> contextor [<span class="keyword">as</span> var]:</span><br><span class="line">    with_body</span><br></pre></td></tr></table></figure>
<p><strong><code>Contextor</code> 实现了<code>__enter__</code>和<code>__exit__</code>这两个上下文管理器协议，当Contextor调用/实例化的时候，则创建了上下文管理器<code>contextor</code></strong></p>
<p>通过定义<code>__enter__</code>和<code>__exit__</code>方法的类（包括自己定义的类，只要加上特定的两个方法即可），我们<strong>可以在<code>with</code>语句里使用它</strong>。我们来看看在底层都发生了什么。</p>
<p><strong>执行步骤：</strong></p>
<ol>
<li>执行 contextor (实例化具有上下文协议的对象，这里也称为上下文表达式)以获取上下文管理器，上下文表达式就是 with 和 as 之间的代码。</li>
<li>加载上下文管理器对象的 <strong>exit</strong>()方法，备用。</li>
<li>调用上下文管理器的 <strong>enter</strong>() 方法</li>
<li>如果有 as var 从句，则将 <strong>enter</strong>() 方法的返回值赋给 var</li>
<li>执行子代码块 with_body</li>
<li>with语句调用上下文管理器之前暂存的 <strong>exit</strong>() 方法，如果 with<em>body 的退出是由异常引发的，那么该异常的 type、value 和 traceback 会作为参数传给 <strong>exit</strong>()，否则传三个 None。然后，<em>_exit</em></em>()需要明确地返回 True 或 False。当返回 True 时，异常不会被向上抛出，当返回 False 时曾会向上抛出。</li>
<li>如果 with_body 的退出由异常引发，它让<strong>exit()</strong>方法来处理异常，并且 <strong>exit</strong>() 的返回值等于 False，那么这个异常将被with语句重新引发抛出一次；如果 <strong>exit</strong>() 的返回值等于 True，那么这个异常就被无视掉，继续执行后面的代码。</li>
</ol>
<h2 id="上下文管理器工具"><a href="#上下文管理器工具" class="headerlink" title="上下文管理器工具"></a>上下文管理器工具</h2><p>通过实现上下文协议定义创建上下文管理器很方便，Python为了更优雅，还专门提供了一个模块用于实现更函数式的上下文管理器用法。Python的<code>contextlib</code>模块专门用于这个目的。</p>
<p><strong>AbstractContextManager</strong> ： 此类在 Python3.6中新增，提供了默认的<strong>enter</strong>()和<strong>exit</strong>()实现。<strong>enter</strong>()返回自身，<strong>exit</strong>()返回 None。</p>
<p><strong>contextmanager： </strong>我们要实现上下文管理器，总是要写一个类。此函数则容许我们<strong>通过一个装饰一个生成器函数</strong>得到一个上下文管理器。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> contextlib</span><br><span class="line"></span><br><span class="line"><span class="meta">@contextlib.contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">database</span><span class="params">()</span>:</span></span><br><span class="line">    db = Database()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> db.connected:</span><br><span class="line">            db.connect()</span><br><span class="line">        <span class="keyword">yield</span> db	<span class="comment"># 生成器</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        db.close()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_query</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">with</span> database() <span class="keyword">as</span> db:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'handle ---'</span>, db.query()</span><br></pre></td></tr></table></figure>
<p>使用contextlib 定义一个上下文管理器函数，通过with语句，database调用生成一个上下文管理器，然后调用函数隐式的<code>__enter__</code>方法，并将结果通yield返回。最后退出上下文环境的时候，在exception代码块中执行了<code>__exit__</code>方法。当然我们可以手动模拟上述代码的执行的细节。注意：yield 只能返回一次，返回的对象 被绑定到 as 后的变量，不需要返回时可以直接 yield，不带返回值。退出时则从 yield 之后执行。由于contextmanager继承自ContextDecorator，所以被contextmanager装饰过的生成器也可以用作装饰器。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">1</span>]: context = database()    <span class="comment"># 创建上下文管理器</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: context</span><br><span class="line">&lt;contextlib.GeneratorContextManager object at <span class="number">0x107188f10</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: db = context.__enter__() <span class="comment"># 进入with语句</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: db                          <span class="comment"># as语句，返回 Database实例</span></span><br><span class="line">Out[<span class="number">4</span>]: &lt;__main__.Database at <span class="number">0x107188a10</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: db.query()       </span><br><span class="line">Out[<span class="number">5</span>]: <span class="string">'query data'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: db.connected</span><br><span class="line">Out[<span class="number">6</span>]: <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">7</span>]: db.__exit__(<span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>)    <span class="comment"># 退出with语句</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">8</span>]: db</span><br><span class="line">Out[<span class="number">8</span>]: &lt;__main__.Database at <span class="number">0x107188a10</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">9</span>]: db.connected</span><br><span class="line">Out[<span class="number">9</span>]: <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p><strong>ContextDecorator</strong>：  我们可以实现一个上下文管理器，同时可以用作装饰器。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AContext</span><span class="params">(ContextDecorator)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Starting'</span>)</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, exc_type, exc_value, traceback)</span>:</span></span><br><span class="line">        print(<span class="string">'Finishing'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 with 中使用</span></span><br><span class="line"><span class="keyword">with</span> AContext():</span><br><span class="line">    print(<span class="string">'祖国伟大'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用作装饰器</span></span><br><span class="line"><span class="meta">@AContext()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_sth</span><span class="params">(sth)</span>:</span></span><br><span class="line">    print(sth)</span><br><span class="line"></span><br><span class="line">print_sth(<span class="string">'祖国伟大'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#在这两种写法中，有没有发现，第二种写法更好，因为我们减少了一次代码缩进，可读性更强</span></span><br></pre></td></tr></table></figure>
<p><strong>还有一种好处：当我们已经实现了某个上下文管理器时，只要增加一个继承类，该上下文管理器立刻编程装饰器。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> ContextDecorator</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mycontext</span><span class="params">(ContextBaseClass, ContextDecorator)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, *exc)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python编程进阶</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python编程进阶（12）：协程与异步IO</title>
    <url>/2018/07/03/python%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6/python%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6%EF%BC%8812%EF%BC%89%EF%BC%9A%E5%8D%8F%E7%A8%8B%E4%B8%8E%E5%BC%82%E6%AD%A5IO/</url>
    <content><![CDATA[<h1 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h1><p>子程序，或者称为函数，在所有语言中都是层级调用，比如A调用B，B在执行过程中又调用了C，C执行完毕返回，B执行完毕返回，最后是A执行完毕。所以子程序调用是通过栈实现的，一个线程就是执行一个子程序。</p>
<p>子程序调用总是一个入口，一次返回，调用顺序是明确的。<strong>而协程的调用和子程序不同。协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行</strong>。</p>
<p><strong>注意，在一个子程序中中断，去执行其他子程序，不是函数调用，有点类似CPU的中断</strong>。比如子程序A、B：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">A</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'1'</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'2'</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'3'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">B</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'x'</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'y'</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'z'</span></span><br></pre></td></tr></table></figure>
<p>假设由协程执行，在执行A的过程中，可以随时中断，去执行B，B也可能在执行过程中中断再去执行A，结果可能是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">x</span><br><span class="line">y</span><br><span class="line"><span class="number">3</span></span><br><span class="line">z</span><br></pre></td></tr></table></figure>
<h2 id="多线程比，协程有何优势？"><a href="#多线程比，协程有何优势？" class="headerlink" title="多线程比，协程有何优势？"></a>多线程比，协程有何优势？</h2><p><strong>最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销</strong>，和多线程比，线程数量越多，协程的性能优势就越明显。</p>
<p><strong>第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突</strong>，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</p>
<p><strong>因为协程是一个线程执行，那怎么利用多核CPU呢？最简单的方法是多进程+协程</strong>，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。Python对协程的支持是通过generator实现的。</p>
<h2 id="一个例子：生产者－消费者的协程"><a href="#一个例子：生产者－消费者的协程" class="headerlink" title="一个例子：生产者－消费者的协程"></a>一个例子：生产者－消费者的协程</h2><p><strong>现在我们要让生产者发送1,2,3,4,5给消费者，消费者接受数字，返回状态给生产者，而我们的消费者只需要3,4,5就行了，当数字等于3时，会返回一个错误的状态。最终我们需要由主程序来监控生产者－消费者的过程状态，调度结束程序。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#-*- coding:utf-8</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">()</span>:</span></span><br><span class="line">    status = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        n = <span class="keyword">yield</span> status</span><br><span class="line">        print(<span class="string">"我拿到了&#123;&#125;!"</span>.format(n))</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">3</span>:</span><br><span class="line">            status = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">(consumer)</span>:</span></span><br><span class="line">    n = <span class="number">5</span></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># yield给主程序返回消费者的状态</span></span><br><span class="line">        <span class="comment"># consumer.send(n)把n传值给c生成器，同时返回c生成器yield的结果（相当于fetch取一个放一个东西）</span></span><br><span class="line">        <span class="keyword">yield</span> consumer.send(n)	</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    c = consumer()	<span class="comment"># c产生一个生成器(带yield语句)</span></span><br><span class="line">    c.send(<span class="literal">None</span>)	<span class="comment"># consumer()程序推进到yield，但yield还未被执行.send()是传值给生成器的语句</span></span><br><span class="line">    p = producer(c)	<span class="comment"># p也产生一个生成器，但传入c生成器，与p进行通信</span></span><br><span class="line">    <span class="keyword">for</span> status <span class="keyword">in</span> p:<span class="comment"># 循环获取p生成器yield回来的状态</span></span><br><span class="line">        <span class="keyword">if</span> status == <span class="literal">False</span>:</span><br><span class="line">            print(<span class="string">"我只要3,4,5就行啦"</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    print(<span class="string">"程序结束"</span>)</span><br></pre></td></tr></table></figure>
<p>上面这个例子是典型的生产者－消费者问题，我们用协程的方式来实现它。</p>
<p>第一句<code>c = consumer()</code>，因为consumer函数中存在yield语句，python会把它当成一个generator，因此在运行这条语句后，python并不会像执行函数一样，而是返回了一个generator object。</p>
<p>第二条语句<code>c.send(None)</code>，这条语句的作用是将consumer（即变量c，它是一个generator）中的语句推进到第一个yield语句出现的位置，那么在例子中，consumer中的<code>status = True</code>和<code>while True:</code>都已经被执行了，程序停留在<code>n = yield status</code>的位置（注意：此时这条语句还没有被执行），上面说的send(None)语句十分重要，如果漏写这一句，那么程序直接报错</p>
<p>第三句<code>p = producer(c)</code>，这里则像上面一样定义了producer的生成器，注意的是这里我们传入了消费者的生成器，来让producer跟consumer通信。</p>
<p>第四句<code>for status in p:</code>，这条语句会循环地运行producer和获取它yield回来的状态。</p>
<p>现在程序流进入了producer里面，我们直接看<code>yield consumer.send(n)</code>，生产者调用了消费者的<strong>send()方法，把n发送给consumer</strong>（即c），在consumer中的<code>n = yield status</code>，n拿到的是消费者发送的数字，同时，consumer用yield的方式把状态（status）返回给消费者，注意：这时producer（即消费者）的<code>consumer.send()</code>调用返回的就是consumer中yield的status！消费者马上将status返回给调度它的主程序，主程序获取状态，判断是否错误，若错误，则终止循环，结束程序。上面看起来有点绕，<strong>其实这里面<code>generator.send(n)</code>的作用是：把n发送generator(生成器)中yield的赋值语句中，同时返回generator中yield的变量（结果）。</strong></p>
<p>于是程序便一直运作，直至consumer中获取的n的值变为3！此时consumer把status变为False，最后返回到主程序，主程序中断循环，程序结束。</p>
<h2 id="Coroutine与Generator"><a href="#Coroutine与Generator" class="headerlink" title="Coroutine与Generator"></a>Coroutine与Generator</h2><p>有些人会把生成器（generator）和协程（coroutine）的概念混淆，我以前也会这样，不过其实发现，两者的区别还是很大的。</p>
<p>直接上最重要的区别：</p>
<ul>
<li>generator总是生成值，一般是迭代的序列</li>
<li>coroutine关注的是消耗值，是数据(data)的消费者</li>
<li>coroutine不会与迭代操作关联，而generator会</li>
<li>coroutine强调协同控制程序流，generator强调保存状态和产生数据</li>
</ul>
<p>相似的是，它们都是不用return来实现重复调用的函数/对象，都用到了yield(中断/恢复)的方式来实现</p>
<h1 id="asyncio"><a href="#asyncio" class="headerlink" title="asyncio"></a>asyncio</h1><p><code>asyncio</code>是Python 3.4版本引入的标准库，直接内置了对异步IO的支持。</p>
<p><code>asyncio</code>的编程模型就是一个消息循环。<strong>我们从<code>asyncio</code>模块中直接获取一个<code>EventLoop</code>的引用，然后把需要执行的协程扔到<code>EventLoop</code>中执行，就实现了异步IO</strong>。用<code>asyncio</code>实现<code>Hello world</code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="comment">#@asyncio.coroutine把一个generator标记为coroutine类型，然后，我们就把这个coroutine扔到EventLoop中执行。</span></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"Hello world!"</span>)</span><br><span class="line">    <span class="comment"># 异步调用asyncio.sleep(1):</span></span><br><span class="line">    r = <span class="keyword">yield</span> <span class="keyword">from</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">"Hello again!"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取EventLoop:</span></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line"><span class="comment"># 执行coroutine</span></span><br><span class="line">loop.run_until_complete(hello())	<span class="comment"># 循环执行EventLoop里要完成的事件</span></span><br><span class="line">loop.close()</span><br></pre></td></tr></table></figure>
<p><code>hello()</code>会首先打印出<code>Hello world!</code>，然后，<strong><code>yield from</code>语法可以让我们方便地调用另一个<code>generator</code></strong>。由于<strong><code>asyncio.sleep()</code>也是一个<code>coroutine</code></strong>，<strong>所以线程不会等待<code>asyncio.sleep()</code>，而是直接中断并执行下一个消息循环</strong>。当<code>asyncio.sleep()</code>返回时，线程就可以从<code>yield from</code>拿到返回值（此处是<code>None</code>），然后接着执行下一行语句。<strong>把<code>asyncio.sleep(1)</code>看成是一个耗时1秒的IO操作，在此期间，主线程并未等待，而是去执行<code>EventLoop</code>中其他可以执行的<code>coroutine</code>了，因此可以实现并发执行</strong>。</p>
<p>我们用Task封装两个<code>coroutine</code>试试：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'Hello world! (%s)'</span> % threading.currentThread())</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'Hello again! (%s)'</span> % threading.currentThread())</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">tasks = [hello(), hello()]</span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">loop.close()</span><br></pre></td></tr></table></figure>
<p>观察执行过程：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Hello world! (&lt;_MainThread(MainThread, started <span class="number">140735195337472</span>)&gt;)</span><br><span class="line">Hello world! (&lt;_MainThread(MainThread, started <span class="number">140735195337472</span>)&gt;)	<span class="comment"># asyncio.sleep(1)会挂起并去执行下一个hello()协程</span></span><br><span class="line">(暂停约<span class="number">1</span>秒)</span><br><span class="line">Hello again! (&lt;_MainThread(MainThread, started <span class="number">140735195337472</span>)&gt;)</span><br><span class="line">Hello again! (&lt;_MainThread(MainThread, started <span class="number">140735195337472</span>)&gt;)</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>asyncio<code>提供了完善的异步IO支持；</code></li>
<li><code>异步操作需要在</code>coroutine<code>中通过</code>yield from`完成；</li>
<li>多个<code>coroutine</code>可以封装成一组Task然后并发执行</li>
</ul>
<h1 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h1><p>用<code>asyncio</code>提供的<code>@asyncio.coroutine</code>可以把一个generator标记为coroutine类型，然后在coroutine内部用<code>yield from</code>调用另一个coroutine实现异步操作。</p>
<p>为了简化并更好地标识异步IO，从Python 3.5开始引入了新的语法<code>async</code>和<code>await</code>，可以让coroutine的代码更简洁易读。</p>
<p>请注意，<code>async</code>和<code>await</code>是针对coroutine的新语法，要使用新的语法，只需要做两步简单的替换：</p>
<ol>
<li>把<code>@asyncio.coroutine</code>替换为<code>async</code>；</li>
<li>把<code>yield from</code>替换为<code>await</code>。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">compute</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    print(<span class="string">"Compute %s + %s ..."</span> % (x, y))</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1.0</span>)</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">print_sum</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    result = <span class="keyword">await</span> compute(x, y)</span><br><span class="line">    print(<span class="string">"%s + %s = %s"</span> % (x, y, result))</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(print_sum(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line"><span class="comment"># tasks = [print_sum(1, 2), print_sum(3, 4)]</span></span><br><span class="line"><span class="comment"># loop.run_until_complete(asyncio.wait(tasks))</span></span><br><span class="line">loop.close()</span><br></pre></td></tr></table></figure>
<p>当事件循环开始运行时，它会在Task中寻找coroutine来执行调度，因为事件循环注册了<code>print_sum()</code>，因此<code>print_sum()</code>被调用，<strong>执行<code>result = await compute(x, y)</code>这条语句（等同于<code>result = yield from compute(x, y)）</code></strong>，<strong>因为<code>compute()</code>自身就是一个coroutine</strong>，因此<code>print_sum()</code>这个协程就会暂时被挂起，<strong><code>compute()</code>被加入到事件循环中</strong>，程序流执行compute()中的print语句，打印”Compute %s + %s …”，然后执行了<code>await asyncio.sleep(1.0)</code>，因为<strong><code>asyncio.sleep()</code>也是一个coroutine，接着<code>compute()</code>就会被挂起，等待计时器读秒，在这1秒的过程中，事件循环会在队列中查询可以被调度的coroutine</strong>，而因为此前<code>print_sum()</code>与<code>compute()</code>都被挂起了，因此事件循环会停下来等待协程的调度(如果有其他协程task就会在等待时间内去执行并返回)，当计时器读秒结束后，程序流便会返回到<code>compute()</code>中执行return语句，结果会返回到<code>print_sum()</code>中的result中，最后打印result，事件队列中没有可以调度的任务了，此时<code>loop.close()</code>把事件队列关闭，程序结束。</p>
]]></content>
      <categories>
        <category>python编程进阶</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python编程进阶（11）：使用C扩展</title>
    <url>/2018/07/01/python%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6/python%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6%EF%BC%8811%EF%BC%89%EF%BC%9A%E4%BD%BF%E7%94%A8C%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<h1 id="使用C扩展"><a href="#使用C扩展" class="headerlink" title="使用C扩展"></a>使用C扩展</h1><p>CPython还为开发者实现了一个有趣的特性，使用Python可以轻松调用C代码</p>
<p>开发者有三种方法可以在自己的Python代码中来调用C编写的函数-<code>ctypes</code>，<code>SWIG</code>，<code>Python/C API</code>。每种方式也都有各自的利弊。</p>
<p>首先，我们要明确为什么要在Python中调用C？</p>
<p>常见原因如下：</p>
<ul>
<li>你要提升代码的运行速度，而且你知道C要比Python快50倍以上</li>
<li>C语言中有很多传统类库，而且有些正是你想要的，但你又不想用Python去重写它们</li>
<li>想对从内存到文件接口这样的底层资源进行访问</li>
<li>不需要理由，就是想这样做</li>
</ul>
<h2 id="CTypes"><a href="#CTypes" class="headerlink" title="CTypes"></a>CTypes</h2><p>Python中的<a href="https://docs.python.org/2/library/ctypes.html" target="_blank" rel="noopener">ctypes模块</a>可能是Python调用C方法中最简单的一种。ctypes模块提供了和C语言兼容的数据类型和函数来加载dll文件，因此在调用时不需对源文件做任何的修改。也正是如此奠定了这种方法的简单性。</p>
<p>示例如下</p>
<p>实现两数求和的C代码，保存为<code>add.c</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//sample C file to add 2 numbers - int and floats</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_int</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">add_float</span><span class="params">(<span class="keyword">float</span>, <span class="keyword">float</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_int</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">add_float</span><span class="params">(<span class="keyword">float</span> num1, <span class="keyword">float</span> num2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来将C文件编译为<code>.so</code>文件(windows下为DLL)。下面操作会生成adder.so文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#For Linux</span></span><br><span class="line">$  gcc -shared -Wl,-soname,adder -o adder.so -fPIC add.c</span><br><span class="line"></span><br><span class="line"><span class="comment">#For Mac</span></span><br><span class="line">$ gcc -shared -Wl,-install_name,adder.so -o adder.so -fPIC add.c</span><br></pre></td></tr></table></figure>
<p>现在在你的Python代码中来调用它</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#load the shared object file</span></span><br><span class="line">adder = CDLL(<span class="string">'./adder.so'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Find sum of integers</span></span><br><span class="line">res_int = adder.add_int(<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"Sum of 4 and 5 = "</span> + str(res_int)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Find sum of floats</span></span><br><span class="line">a = c_float(<span class="number">5.5</span>)</span><br><span class="line">b = c_float(<span class="number">4.1</span>)</span><br><span class="line"></span><br><span class="line">add_float = adder.add_float</span><br><span class="line">add_float.restype = c_float</span><br><span class="line"><span class="keyword">print</span> <span class="string">"Sum of 5.5 and 4.1 = "</span>, str(add_float(a, b))</span><br></pre></td></tr></table></figure>
<p>输出如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Sum of <span class="number">4</span> <span class="keyword">and</span> <span class="number">5</span> = <span class="number">9</span></span><br><span class="line">Sum of <span class="number">5.5</span> <span class="keyword">and</span> <span class="number">4.1</span> =  <span class="number">9.60000038147</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，C文件是自解释的，它包含两个函数，分别实现了整形求和和浮点型求和。</p>
<p>在Python文件中，一开始先导入ctypes模块，然后使用CDLL函数来加载我们创建的库文件。这样我们就可以通过变量<code>adder</code>来使用C类库中的函数了。当<code>adder.add_int()</code>被调用时，内部将发起一个对C函数<code>add_int</code>的调用。ctypes接口允许我们在调用C函数时使用原生Python中默认的字符串型和整型。</p>
<p>而对于其他类似布尔型和浮点型这样的类型，必须要使用正确的ctype类型才可以。如向<code>adder.add_float()</code>函数传参时, 我们要先将Python中的十进制值转化为c_float类型，然后才能传送给C函数。这种方法虽然简单，清晰，但是却很受限。例如，并不能在C中对对象进行操作。</p>
<h2 id="SWIG"><a href="#SWIG" class="headerlink" title="SWIG"></a>SWIG</h2><p>SWIG是Simplified Wrapper and Interface Generator的缩写。是Python中调用C代码的另一种方法。在这个方法中，开发人员必须编写一个额外的接口文件来作为SWIG(终端工具)的入口。</p>
<p>Python开发者一般不会采用这种方法，因为大多数情况它会带来不必要的复杂。而当你有一个C/C++代码库需要被多种语言调用时，这将是个非常不错的选择。</p>
<p>示例如下(来自<a href="http://www.swig.org/tutorial.html" target="_blank" rel="noopener">SWIG官网</a>)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">​```C</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="keyword">double</span> My_variable = <span class="number">3.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fact</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> n*fact(n<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_mod</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x%y);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">get_time</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">time_t</span> ltime;</span><br><span class="line">    time(&amp;ltime);</span><br><span class="line">    <span class="keyword">return</span> ctime(&amp;ltime);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译它</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">unix % swig -python example.i</span><br><span class="line">unix % gcc -c example.c example_wrap.c \</span><br><span class="line">    -I/usr/local/include/python2<span class="number">.1</span></span><br><span class="line">unix % ld -shared example.o example_wrap.o -o _example.so</span><br></pre></td></tr></table></figure>
<p>最后，Python的输出</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> example</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>example.fact(<span class="number">5</span>)</span><br><span class="line"><span class="number">120</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>example.my_mod(<span class="number">7</span>,<span class="number">3</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>example.get_time()</span><br><span class="line"><span class="string">'Sun Feb 11 23:01:07 1996'</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，使用SWIG确实达到了同样的效果，虽然下了更多的工夫，但如果你的目标是多语言还是很值得的。</p>
<h2 id="Python-C-API"><a href="#Python-C-API" class="headerlink" title="Python/C API"></a>Python/C API</h2><p><a href="https://docs.python.org/2/c-api/" target="_blank" rel="noopener">Python/C API</a>可能是被最广泛使用的方法。它不仅简单，而且可以在C代码中操作你的Python对象。</p>
<p>这种方法需要以特定的方式来编写C代码以供Python去调用它。所有的Python对象都被表示为一种叫做PyObject的结构体，并且<code>Python.h</code>头文件中提供了各种操作它的函数。例如，如果PyObject表示为PyListType(列表类型)时，那么我们便可以使用<code>PyList_Size()</code>函数来获取该结构的长度，类似Python中的<code>len(list)</code>函数。大部分对Python原生对象的基础函数和操作在<code>Python.h</code>头文件中都能找到。</p>
<p>示例</p>
<p>编写一个C扩展，添加所有元素到一个Python列表(所有元素都是数字)</p>
<p>来看一下我们要实现的效果，这里演示了用Python调用C扩展的代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Though it looks like an ordinary python import, the addList module is implemented in C</span></span><br><span class="line"><span class="keyword">import</span> addList</span><br><span class="line"></span><br><span class="line">l = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">"Sum of List - "</span> + str(l) + <span class="string">" = "</span> +  str(addList.add(l))</span><br></pre></td></tr></table></figure>
<p>上面的代码和普通的Python文件并没有什么分别，导入并使用了另一个叫做<code>addList</code>的Python模块。唯一差别就是这个模块(addList)并不是用Python编写的，而是C。</p>
<p>接下来我们看看如何用C编写<code>addList</code>模块，这可能看起来有点让人难以接受，但是一旦你了解了这之中的各种组成，你就可以一往无前了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Python.h has all the required function definitions to manipulate the Python objects</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Python.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//This is the function that is called from your python code</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> PyObject* <span class="title">addList_add</span><span class="params">(PyObject* self, PyObject* args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    PyObject * listObj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//The input arguments come as a tuple, we parse the args to get the various variables</span></span><br><span class="line">    <span class="comment">//In this case it's only one list variable, which will now be referenced by listObj</span></span><br><span class="line">    <span class="keyword">if</span> (! PyArg_ParseTuple( args, <span class="string">"O"</span>, &amp;listObj ))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//length of the list</span></span><br><span class="line">    <span class="keyword">long</span> length = PyList_Size(listObj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//iterate over all the elements</span></span><br><span class="line">    <span class="keyword">int</span> i, sum =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="comment">//get an element out of the list - the element is also a python objects</span></span><br><span class="line">        PyObject* temp = PyList_GetItem(listObj, i);</span><br><span class="line">        <span class="comment">//we know that object represents an integer - so convert it into C long</span></span><br><span class="line">        <span class="keyword">long</span> elem = PyInt_AsLong(temp);</span><br><span class="line">        sum += elem;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//value returned back to python code - another python object</span></span><br><span class="line">    <span class="comment">//build value here converts the C long to a python integer</span></span><br><span class="line">    <span class="keyword">return</span> Py_BuildValue(<span class="string">"i"</span>, sum);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//This is the docstring that corresponds to our 'add' function.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> addList_docs[] =</span><br><span class="line"><span class="string">"add(  ): add all elements of the list\n"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This table contains the relavent info mapping -</span></span><br><span class="line"><span class="comment">   &lt;function-name in python module&gt;, &lt;actual-function&gt;,</span></span><br><span class="line"><span class="comment">   &lt;type-of-args the function expects&gt;, &lt;docstring associated with the function&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> PyMethodDef addList_funcs[] = &#123;</span><br><span class="line">    &#123;<span class="string">"add"</span>, (PyCFunction)addList_add, METH_VARARGS, addList_docs&#125;,</span><br><span class="line">    &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   addList is the module name, and this is the initialization block of the module.</span></span><br><span class="line"><span class="comment">   &lt;desired module name&gt;, &lt;the-info-table&gt;, &lt;module's-docstring&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">PyMODINIT_FUNC <span class="title">initaddList</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    Py_InitModule3(<span class="string">"addList"</span>, addList_funcs,</span><br><span class="line">            <span class="string">"Add all ze lists"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>逐步解释</p>
<ul>
<li><code>Python.h</code>头文件中包含了所有需要的类型(Python对象类型的表示)和函数定义(对Python对象的操作)</li>
<li>接下来我们编写将要在Python调用的函数, 函数传统的命名方式由{模块名}_{函数名}组成，所以我们将其命名为<code>addList_add</code></li>
<li>然后填写想在模块内实现函数的相关信息表，每行一个函数，以空行作为结束</li>
<li>最后的模块初始化块签名为<code>PyMODINIT_FUNC init{模块名}</code>。</li>
</ul>
<p>函数<code>addList_add</code>接受的参数类型为PyObject类型结构(同时也表示为元组类型，因为Python中万物皆为对象，所以我们先用PyObject来定义)。传入的参数则通过<code>PyArg_ParseTuple()</code>来解析。第一个参数是被解析的参数变量。第二个参数是一个字符串，告诉我们如何去解析元组中每一个元素。字符串的第n个字母正是代表着元组中第n个参数的类型。例如，”i”代表整形，”s”代表字符串类型, “O”则代表一个Python对象。接下来的参数都是你想要通过<code>PyArg_ParseTuple()</code>函数解析并保存的元素。这样参数的数量和模块中函数期待得到的参数数量就可以保持一致，并保证了位置的完整性。例如，我们想传入一个字符串，一个整数和一个Python列表，可以这样去写</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">int n;</span><br><span class="line">char *s;</span><br><span class="line">PyObject* list;</span><br><span class="line">PyArg_ParseTuple(args, <span class="string">"siO"</span>, &amp;n, &amp;s, &amp;list);</span><br></pre></td></tr></table></figure>
<p>在这种情况下，我们只需要提取一个列表对象，并将它存储在<code>listObj</code>变量中。然后用列表对象中的<code>PyList_Size()</code>函数来获取它的长度。就像Python中调用<code>len(list)</code>。</p>
<p>现在我们通过循环列表，使用<code>PyList_GetItem(list, index)</code>函数来获取每个元素。这将返回一个<code>PyObject*</code>对象。既然Python对象也能表示<code>PyIntType</code>，我们只要使用<code>PyInt_AsLong(PyObj *)</code>函数便可获得我们所需要的值。我们对每个元素都这样处理，最后再得到它们的总和。</p>
<p>总和将被转化为一个Python对象并通过<code>Py_BuildValue()</code>返回给Python代码，这里的i表示我们要返回一个Python整形对象。</p>
<p>现在我们已经编写完C模块了。将下列代码保存为<code>setup.py</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#build the modules</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> distutils.core <span class="keyword">import</span> setup, Extension</span><br><span class="line"></span><br><span class="line">setup(name=<span class="string">'addList'</span>, version=<span class="string">'1.0'</span>,  \</span><br><span class="line">      ext_modules=[Extension(<span class="string">'addList'</span>, [<span class="string">'adder.c'</span>])])</span><br></pre></td></tr></table></figure>
<p>并且运行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python setup.py install</span><br></pre></td></tr></table></figure>
<p>现在应该已经将我们的C文件编译安装到我们的Python模块中了。</p>
<p>在一番辛苦后，让我们来验证下我们的模块是否有效</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#module that talks to the C code</span></span><br><span class="line"><span class="keyword">import</span> addList</span><br><span class="line"></span><br><span class="line">l = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">"Sum of List - "</span> + str(l) + <span class="string">" = "</span> +  str(addList.add(l))</span><br></pre></td></tr></table></figure>
<p>输出结果如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Sum of List - [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>] = <span class="number">15</span></span><br></pre></td></tr></table></figure>
<p>如你所见，我们已经使用Python.h API成功开发出了我们第一个Python C扩展。这种方法看似复杂，但你一旦习惯，它将变的非常有效。</p>
<p>Python调用C代码的另一种方式便是使用<a href="http://cython.org/" target="_blank" rel="noopener">Cython</a>让Python编译的更快。但是Cython和传统的Python比起来可以将它理解为另一种语言，所以我们就不在这里过多描述了。</p>
<h1 id="补充两个知识点"><a href="#补充两个知识点" class="headerlink" title="补充两个知识点"></a>补充两个知识点</h1><h2 id="列表辗平"><a href="#列表辗平" class="headerlink" title="列表辗平"></a>列表辗平</h2><p>可以通过使用<code>itertools</code>包中的<code>itertools.chain.from_iterable</code>轻松快速的辗平一个列表。下面是一个简单的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a_list = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]]</span><br><span class="line">print(list(itertools.chain.from_iterable(a_list)))</span><br><span class="line"><span class="comment"># Output: [1, 2, 3, 4, 5, 6]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">print(list(itertools.chain(*a_list)))</span><br><span class="line"><span class="comment"># Output: [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure>
<h2 id="for-else从句"><a href="#for-else从句" class="headerlink" title="for-else从句"></a>for-else从句</h2><p><code>for</code>循环还有一个<code>else</code>从句，我们大多数人并不熟悉。<strong>这个<code>else</code>从句会在循环正常结束时执行。这意味着，循环没有遇到任何break。若循环被某些因素打破，则不会执行else语句</strong>. 一旦你掌握了何时何地使用它，它真的会非常有用。我自己对它真是相见恨晚。</p>
<p>有个常见的构造是跑一个循环，并查找一个元素。如果这个元素被找到了，我们使用<code>break</code>来中断这个循环。有两个场景会让循环停下来。</p>
<ul>
<li>第一个是当一个元素被找到，<code>break</code>被触发。</li>
<li>第二个场景是循环结束。</li>
</ul>
<p>现在我们也许想知道其中哪一个，才是导致循环完成的原因。一个方法是先设置一个标记，然后在循环结束时打上标记。另一个是使用<code>else</code>从句。</p>
<p>这就是<code>for/else</code>循环的基本结构：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> container:</span><br><span class="line">    <span class="keyword">if</span> search_something(item):</span><br><span class="line">        <span class="comment"># Found it!</span></span><br><span class="line">        process(item)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># Didn't find anything..</span></span><br><span class="line">    not_found_in_container()</span><br></pre></td></tr></table></figure>
<p>考虑下这个简单的案例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">10</span>):</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">2</span>, n):</span><br><span class="line">        <span class="keyword">if</span> n % x == <span class="number">0</span>:</span><br><span class="line">            print(n, <span class="string">'equals'</span>, x, <span class="string">'*'</span>, n / x)</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<p>它会找出2到10之间的数字的因子。现在是趣味环节了。我们可以加上一个附加的else语句块，来抓住质数，并且告诉我们：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">10</span>):</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">2</span>, n):</span><br><span class="line">        <span class="keyword">if</span> n % x == <span class="number">0</span>:</span><br><span class="line">            print(n, <span class="string">'equals'</span>, x, <span class="string">'*'</span>, n / x)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:	<span class="comment"># 输出没有循环结束仍未找到因子的质数</span></span><br><span class="line">        <span class="comment"># loop fell through without finding a factor</span></span><br><span class="line">        print(n, <span class="string">'is a prime number'</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python编程进阶</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python编程进阶（10）：sort、lambda</title>
    <url>/2018/06/30/python%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6/python%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6%EF%BC%8810%EF%BC%89%EF%BC%9Asort%E3%80%81lambda/</url>
    <content><![CDATA[<h1 id="sort与sorted区别"><a href="#sort与sorted区别" class="headerlink" title="sort与sorted区别"></a>sort与sorted区别</h1><p>我们需要对List进行排序，Python提供了两个方法对给定的List L进行排序，</p>
<ul>
<li>方法1.用List的成员函数sort进行排序</li>
<li>方法2.用built-in函数sorted进行排序</li>
</ul>
<p>list.sort()与sorted()的不同在于，list.sort是在原位重新排列列表，而sorted()是产生一个新的列表。python中列表的内置函数list.sort（）只可以对列表中的元素进行排序，而全局性的sorted（）函数则对所有可迭代的对象都是适用的；并且list.sort（）函数是内置函数，会改变当前对象，而sorted（）函数只会返回一个排序后的当前对象的副本，而不会改变当前对象。</p>
<blockquote>
<p>原型：sort（fun，key，reverse=False）</p>
<p>sorted(itrearble, cmp=None, key=None,reverse=False)</p>
</blockquote>
<h2 id="内置函数sort（）"><a href="#内置函数sort（）" class="headerlink" title="内置函数sort（）"></a>内置函数sort（）</h2><p>参数fun是表明此sort函数是基于何种算法进行排序的，一般默认情况下python中用的是归并排序，并且一般情况下我们是不会重写此参数的，所以基本可以忽略；</p>
<p>参数key用来指定一个函数，此函数在每次元素比较时被调用，此函数代表排序的规则，也就是你按照什么规则对你的序列进行排序；</p>
<p>参数reverse是用来表明是否逆序，默认的False情况下是按照升序的规则进行排序的，当reverse=True时，便会按照降序进行排序。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> attrgetter,itemgetter</span><br><span class="line"> </span><br><span class="line">list1 = [(<span class="number">2</span>,<span class="string">'huan'</span>,<span class="number">23</span>),(<span class="number">12</span>,<span class="string">'the'</span>,<span class="number">14</span>),(<span class="number">23</span>,<span class="string">'liu'</span>,<span class="number">90</span>)]</span><br><span class="line"> </span><br><span class="line"><span class="comment">#使用默认参数进行排序，即按照元组中第一个元素进行排序</span></span><br><span class="line">list1.sort()</span><br><span class="line"><span class="keyword">print</span> list1</span><br><span class="line"><span class="comment">#输出结果为[(2, 'huan', 23), (12, 'the', 14), (23, 'liu', 90)]</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#使用匿名表达式重写key所代表的函数,按照元组的第二个元素（下标为1）进行排序</span></span><br><span class="line">list1.sort(key=<span class="keyword">lambda</span> x:(x[<span class="number">1</span>]))</span><br><span class="line"><span class="keyword">print</span> list1</span><br><span class="line"><span class="comment">#[(2, 'huan', 23), (23, 'liu', 90), (12, 'the', 14)]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#使用匿名函数重写key所代表的函数，先按照元组中下标为2的进行排序，</span></span><br><span class="line"><span class="comment"># 对于下标2处元素相同的，则按下标为0处的元素进行排序</span></span><br><span class="line">list1.sort(key=<span class="keyword">lambda</span> x:(x[<span class="number">2</span>],x[<span class="number">0</span>]))</span><br><span class="line"><span class="keyword">print</span> list1</span><br><span class="line"><span class="comment">#[(12, 'the', 14), (2, 'huan', 23), (23, 'liu', 90)]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#使用operator模块中的itemgetter函数进行重写key所代表的函数，按照下标为1处的元素(第二个)进行排序</span></span><br><span class="line">list1.sort(key=itemgetter(<span class="number">1</span>))</span><br><span class="line"><span class="keyword">print</span> list1</span><br><span class="line"><span class="comment">#[(2, 'huan', 23), (23, 'liu', 90), (12, 'the', 14)]</span></span><br></pre></td></tr></table></figure>
<h2 id="全局函数sorted（）"><a href="#全局函数sorted（）" class="headerlink" title="全局函数sorted（）"></a>全局函数sorted（）</h2><p>对于sorted（）函数中key的重写，和sort（）函数中是一样的，所以刚刚对于sort（）中讲解的方法，都是适用于sorted（）函数中。sorted（）最后会将排序的结果放到一个新的列表中，而不是对iterable本身进行修改。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sorted(<span class="string">'123456'</span>)  <span class="comment"># 字符串</span></span><br><span class="line">[<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>, <span class="string">'6'</span>]</span><br><span class="line"></span><br><span class="line">sorted([<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>])  <span class="comment"># 列表</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">sorted(&#123;<span class="number">1</span>:<span class="string">'q'</span>,<span class="number">3</span>:<span class="string">'c'</span>,<span class="number">2</span>:<span class="string">'g'</span>&#125;) <span class="comment"># 字典， 默认对字典的键进行排序</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">sorted(&#123;<span class="number">1</span>:<span class="string">'q'</span>,<span class="number">3</span>:<span class="string">'c'</span>,<span class="number">2</span>:<span class="string">'g'</span>&#125;.keys())  <span class="comment"># 对字典的键</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">sorted(&#123;<span class="number">1</span>:<span class="string">'q'</span>,<span class="number">3</span>:<span class="string">'c'</span>,<span class="number">2</span>:<span class="string">'g'</span>&#125;.values())  <span class="comment"># 对字典的值</span></span><br><span class="line">[<span class="string">'c'</span>, <span class="string">'g'</span>, <span class="string">'q'</span>]</span><br><span class="line"></span><br><span class="line">sorted(&#123;<span class="number">1</span>:<span class="string">'q'</span>,<span class="number">3</span>:<span class="string">'c'</span>,<span class="number">2</span>:<span class="string">'g'</span>&#125;.items())  <span class="comment"># 对键值对组成的元组的列表</span></span><br><span class="line">[(<span class="number">1</span>, <span class="string">'q'</span>), (<span class="number">2</span>, <span class="string">'g'</span>), (<span class="number">3</span>, <span class="string">'c'</span>)]</span><br></pre></td></tr></table></figure>
<p>对元素指定的某一部分进行排序,关键字排序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 想要按照-后的数字的大小升序排序。要用到key</span></span><br><span class="line">s =[<span class="string">'Chr1-10.txt'</span>,<span class="string">'Chr1-1.txt'</span>,<span class="string">'Chr1-2.txt'</span>,<span class="string">'Chr1-14.txt'</span>,<span class="string">'Chr1-3.txt'</span>,<span class="string">'Chr1-20.txt'</span>,<span class="string">'Chr1-5.txt'</span>]</span><br><span class="line"></span><br><span class="line">sorted(s, key=<span class="keyword">lambda</span> d :int(d.split(<span class="string">'-'</span>)[<span class="number">-1</span>].split(<span class="string">'.'</span>)[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出 ['Chr1-1.txt', 'Chr1-2.txt', 'Chr1-3.txt','Chr1-5.txt', 'Chr1-10.txt', 'Chr1-14.txt', 'Chr1-20.txt']</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这就是key的功能，制定排序的关键字，通常都是一个lambda函数，当然你也可以事先定义好这个函数。如果不讲这个关键字转化为整型，结果是这样的：</span></span><br><span class="line">sorted(s, key=<span class="keyword">lambda</span> d : d.split(<span class="string">'-'</span>)[<span class="number">-1</span>].split(<span class="string">'.'</span>)[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出 ['Chr1-1.txt', 'Chr1-10.txt','Chr1-14.txt', 'Chr1-2.txt', 'Chr1-20.txt', 'Chr1-3.txt', 'Chr1-5.txt']</span></span><br></pre></td></tr></table></figure>
<p>这相当于把这个关键字当做字符串了，很显然，在python中，’2’ &gt; ‘10’。cmp不怎么用，因为key和reverse比单独一个cmp效率要高。</p>
<h1 id="lambda的各种用法"><a href="#lambda的各种用法" class="headerlink" title="lambda的各种用法"></a>lambda的各种用法</h1><p>1， 用在过滤函数中，指定过滤列表元素的条件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">filter(<span class="keyword">lambda</span> x: x % <span class="number">3</span> == <span class="number">0</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line"> &gt; [<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure>
<p>2， 用在排序函数中，指定对列表中所有元素进行排序的准则：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sorted([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], key=<span class="keyword">lambda</span> x: abs(<span class="number">5</span>-x))</span><br><span class="line">&gt; [<span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure>
<p>3， 用在reduce函数中，指定列表中两两相邻元素的结合条件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">reduce(<span class="keyword">lambda</span> a, b: <span class="string">'&#123;&#125;, &#123;&#125;'</span>.format(a, b), [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line">&gt; <span class="string">'1, 2, 3, 4, 5, 6, 7, 8, 9'</span></span><br></pre></td></tr></table></figure>
<p>4， 用在map函数中，指定对列表中每一个元素的共同操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">map(<span class="keyword">lambda</span> x: x+<span class="number">1</span>, [<span class="number">1</span>, <span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">&gt; [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<p>5， 从另一函数中返回一个函数，常用来实现函数装饰器(Wrapper)，例如python的function decorators</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">transform</span><span class="params">(n)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">lambda</span> x: x + n</span><br><span class="line">f = transform(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">print</span> f(<span class="number">3</span>)</span><br><span class="line">&gt; <span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>6，列表排序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">4</span>, <span class="number">1</span>), (<span class="number">9</span>, <span class="number">10</span>), (<span class="number">13</span>, <span class="number">-3</span>)]</span><br><span class="line">a.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">print(a)</span><br><span class="line"><span class="comment"># Output: [(13, -3), (4, 1), (1, 2), (9, 10)]</span></span><br></pre></td></tr></table></figure>
<p>7，列表并行排序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = zip(list1, list2)</span><br><span class="line">data = sorted(data)</span><br><span class="line">list1, list2 = map(<span class="keyword">lambda</span> t: list(t), zip(*data))</span><br><span class="line"><span class="comment"># zip() 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同，利用 * 号操作符，可以将元组解压为列表。</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python编程进阶</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python编程进阶（9）：枚举、自省、推导式</title>
    <url>/2018/06/30/python%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6/python%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6%EF%BC%889%EF%BC%89%EF%BC%9A%E6%9E%9A%E4%B8%BE%E3%80%81%E8%87%AA%E7%9C%81%E3%80%81%E6%8E%A8%E5%AF%BC%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><p>枚举(<code>enumerate</code>)是Python内置函数。它的用处很难在简单的一行中说明，但是大多数的新人，甚至一些高级程序员都没有意识到它。</p>
<p>它允许我们遍历数据并自动计数，</p>
<p>下面是一个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> counter, value <span class="keyword">in</span> enumerate(some_list):</span><br><span class="line">    print(counter, value)</span><br></pre></td></tr></table></figure>
<p>不只如此，<code>enumerate</code>也接受一些可选参数，这使它更有用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_list = [<span class="string">'apple'</span>, <span class="string">'banana'</span>, <span class="string">'grapes'</span>, <span class="string">'pear'</span>]</span><br><span class="line"><span class="keyword">for</span> c, value <span class="keyword">in</span> enumerate(my_list, <span class="number">1</span>):</span><br><span class="line">    print(c, value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出:</span></span><br><span class="line">(<span class="number">1</span>, <span class="string">'apple'</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="string">'banana'</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="string">'grapes'</span>)</span><br><span class="line">(<span class="number">4</span>, <span class="string">'pear'</span>)</span><br></pre></td></tr></table></figure>
<p>上面这个可选参数允许我们定制从哪个数字开始枚举。<br>你还可以用来创建包含索引的元组列表， 例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_list = [<span class="string">'apple'</span>, <span class="string">'banana'</span>, <span class="string">'grapes'</span>, <span class="string">'pear'</span>]</span><br><span class="line">counter_list = list(enumerate(my_list, <span class="number">1</span>))</span><br><span class="line">print(counter_list)</span><br><span class="line"><span class="comment"># 输出: [(1, 'apple'), (2, 'banana'), (3, 'grapes'), (4, 'pear')]</span></span><br></pre></td></tr></table></figure>
<h1 id="对象自省"><a href="#对象自省" class="headerlink" title="对象自省"></a>对象自省</h1><p>自省(introspection)，在计算机编程领域里，是指在运行时来判断一个对象的类型的能力。它是Python的强项之一。Python中所有一切都是一个对象，而且我们可以仔细勘察那些对象。Python还包含了许多内置函数和模块来帮助我们。</p>
<h2 id="dir"><a href="#dir" class="headerlink" title="dir"></a>dir</h2><p>在这个小节里我们会学习到<code>dir</code>以及它在自省方面如何给我们提供便利。</p>
<p>它是用于自省的最重要的函数之一。<strong>它返回一个列表，列出了一个对象所拥有的属性和方法</strong>。这里是一个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">dir(my_list)</span><br><span class="line"><span class="comment"># Output: ['__add__', '__class__', '__contains__', '__delattr__', '__delitem__',</span></span><br><span class="line"><span class="comment"># '__delslice__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__',</span></span><br><span class="line"><span class="comment"># '__getitem__', '__getslice__', '__gt__', '__hash__', '__iadd__', '__imul__',</span></span><br><span class="line"><span class="comment"># '__init__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__',</span></span><br><span class="line"><span class="comment"># '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__',</span></span><br><span class="line"><span class="comment"># '__setattr__', '__setitem__', '__setslice__', '__sizeof__', '__str__',</span></span><br><span class="line"><span class="comment"># '__subclasshook__', 'append', 'count', 'extend', 'index', 'insert', 'pop',</span></span><br><span class="line"><span class="comment"># 'remove', 'reverse', 'sort']</span></span><br></pre></td></tr></table></figure>
<p>上面的自省给了我们一个列表对象的所有方法的名字。当你没法回忆起一个方法的名字，这会非常有帮助。如果我们运行<code>dir()</code>而不传入参数，那么它会返回当前作用域的所有名字。</p>
<h2 id="type和id"><a href="#type和id" class="headerlink" title="type和id"></a>type和id</h2><p><code>type</code>函数返回一个对象的类型。举个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(type(<span class="string">''</span>))</span><br><span class="line"><span class="comment"># Output: &lt;type 'str'&gt;</span></span><br><span class="line"></span><br><span class="line">print(type([]))</span><br><span class="line"><span class="comment"># Output: &lt;type 'list'&gt;</span></span><br><span class="line"></span><br><span class="line">print(type(&#123;&#125;))</span><br><span class="line"><span class="comment"># Output: &lt;type 'dict'&gt;</span></span><br><span class="line"></span><br><span class="line">print(type(dict))</span><br><span class="line"><span class="comment"># Output: &lt;type 'type'&gt;</span></span><br><span class="line"></span><br><span class="line">print(type(<span class="number">3</span>))</span><br><span class="line"><span class="comment"># Output: &lt;type 'int'&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>id()</code>函数返回任意不同种类对象的唯一ID内存地址，举个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">"Yasoob"</span></span><br><span class="line">print(id(name))</span><br><span class="line"><span class="comment"># Output: 139972439030304</span></span><br></pre></td></tr></table></figure>
<h2 id="inspect模块"><a href="#inspect模块" class="headerlink" title="inspect模块"></a>inspect模块</h2><p><code>inspect</code>模块也提供了许多有用的函数，来获取活跃对象的信息。比方说，你可以查看一个对象的成员，只需运行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> inspect</span><br><span class="line">print(inspect.getmembers(str))</span><br><span class="line"><span class="comment"># Output: [('__add__', &lt;slot wrapper '__add__' of ... ...</span></span><br></pre></td></tr></table></figure>
<p>还有好多个其他方法也能有助于自省。如果你愿意，你可以去探索它们。</p>
<p>inspect.ismodule(object)： 是否为模块<br>inspect.isclass(object)：是否为类<br>inspect.ismethod(object)：是否为方法（bound method written in python）<br>inspect.isfunction(object)：是否为函数(python function, including lambda expression)<br>inspect.isgeneratorfunction(object)：是否为python生成器函数<br>inspect.isgenerator(object):是否为生成器<br>inspect.istraceback(object)： 是否为traceback<br>inspect.isframe(object)：是否为frame<br>inspect.iscode(object)：是否为code<br>inspect.isbuiltin(object)：是否为built-in函数或built-in方法<br>inspect.isroutine(object)：是否为用户自定义或者built-in函数或方法<br>inspect.isabstract(object)：是否为抽象基类<br>inspect.ismethoddescriptor(object)：是否为方法标识符<br>inspect.isdatadescriptor(object)：是否为数字标识符，数字标识符有<code>__get__</code> 和<code>__set__属性； 通常也有__name__和__doc__属性</code><br>inspect.isgetsetdescriptor(object)：是否为getset descriptor<br>inspect.ismemberdescriptor(object)：是否为member descriptor</p>
<h1 id="各种推导式-comprehensions"><a href="#各种推导式-comprehensions" class="headerlink" title="各种推导式(comprehensions)"></a>各种推导式(comprehensions)</h1><p>推导式（又称解析式）是Python的一种独有特性，如果我被迫离开了它，我会非常想念。推导式是可以从一个数据序列构建另一个新的数据序列的结构体。 共有三种推导，在Python2和3中都有支持：</p>
<ul>
<li>列表(<code>list</code>)推导式</li>
<li>字典(<code>dict</code>)推导式</li>
<li>集合(<code>set</code>)推导式</li>
</ul>
<p>我们将一一进行讨论。一旦你知道了使用列表推导式的诀窍，你就能轻易使用任意一种推导式了。</p>
<h2 id="列表推导式（list-comprehensions）"><a href="#列表推导式（list-comprehensions）" class="headerlink" title="列表推导式（list comprehensions）"></a>列表推导式（list comprehensions）</h2><p>列表推导式（又称列表解析式）提供了一种简明扼要的方法来创建列表。<br>它的结构是在一个中括号里包含一个表达式，然后是一个<code>for</code>语句，然后是0个或多个<code>for</code>或者<code>if</code>语句。那个表达式可以是任意的，意思是你可以在列表中放入任意类型的对象。返回结果将是一个新的列表，在这个以<code>if</code>和<code>for</code>语句为上下文的表达式运行完成之后产生。</p>
<h3 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">variable = [out_exp <span class="keyword">for</span> out_exp <span class="keyword">in</span> input_list <span class="keyword">if</span> out_exp == <span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<h2 id="字典推导式（dict-comprehensions）"><a href="#字典推导式（dict-comprehensions）" class="headerlink" title="字典推导式（dict comprehensions）"></a>字典推导式（dict comprehensions）</h2><p><strong>字典推导和列表推导的使用方法是类似的,只不中括号该改成大括号，毕竟字典本身用的就是大括号。</strong>这里有个我最近发现的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mcase = &#123;<span class="string">'a'</span>: <span class="number">10</span>, <span class="string">'b'</span>: <span class="number">34</span>, <span class="string">'A'</span>: <span class="number">7</span>, <span class="string">'Z'</span>: <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">mcase_frequency = &#123;</span><br><span class="line">    k.lower(): mcase.get(k.lower(), <span class="number">0</span>) + mcase.get(k.upper(), <span class="number">0</span>)	<span class="comment"># 执行函数，k为每个字典的关键字</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> mcase.keys()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># mcase_frequency == &#123;'a': 17, 'z': 3, 'b': 34&#125;</span></span><br></pre></td></tr></table></figure>
<p>在上面的例子中我们把同一个字母但不同大小写的值合并起来了。</p>
<p>就我个人来说没有大量使用字典推导式。</p>
<p>你还可以快速对换一个字典的键和值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;v: k <span class="keyword">for</span> k, v <span class="keyword">in</span> some_dict.items()&#125;</span><br></pre></td></tr></table></figure>
<h2 id="集合推导式（set-comprehensions）"><a href="#集合推导式（set-comprehensions）" class="headerlink" title="集合推导式（set comprehensions）"></a>集合推导式（set comprehensions）</h2><p><strong>集合推导式跟列表推导式差不多，都是对一个列表的元素全部执行相同的操作，但集合是一种无重复无序的序列</strong><br><strong>区别：跟列表推到式的区别在于：1.不使用中括号，使用大括号；2.结果中无重复；3.结果是一个set()集合，集合里面是一个序列：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">squared = &#123;x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>]&#125;</span><br><span class="line">print(squared)</span><br><span class="line"><span class="comment"># Output: &#123;1, 4&#125;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python编程进阶</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python编程进阶（8）：容器Collections</title>
    <url>/2018/06/30/python%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6/python%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6%EF%BC%888%EF%BC%89%EF%BC%9A%E5%AE%B9%E5%99%A8Collections/</url>
    <content><![CDATA[<h1 id="容器-Collections"><a href="#容器-Collections" class="headerlink" title="容器(Collections)"></a>容器(Collections)</h1><p>Python附带一个模块，它包含许多容器数据类型，名字叫作<code>collections</code>。我们将讨论它的作用和用法。</p>
<p>我们将讨论的是：</p>
<ul>
<li>defaultdict</li>
<li>counter</li>
<li>deque</li>
<li>namedtuple</li>
<li>enum.Enum (包含在Python 3.4以上)</li>
</ul>
<h2 id="defaultdict"><a href="#defaultdict" class="headerlink" title="defaultdict"></a>defaultdict</h2><p>众所周知，在Python中如果访问字典中不存在的键，会引发KeyError异常（JavaScript中如果对象中不存在某个属性，则返回undefined）。<strong>但是有时候，字典中的每个键都存在默认值是非常方便的</strong>。例如下面的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">strings = (<span class="string">'puppy'</span>, <span class="string">'kitten'</span>, <span class="string">'puppy'</span>, <span class="string">'puppy'</span>,</span><br><span class="line">           <span class="string">'weasel'</span>, <span class="string">'puppy'</span>, <span class="string">'kitten'</span>, <span class="string">'puppy'</span>)</span><br><span class="line">counts = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> kw <span class="keyword">in</span> strings:</span><br><span class="line">    counts[kw] += <span class="number">1</span>	<span class="comment"># 第一次统计时没有键对应的默认值</span></span><br></pre></td></tr></table></figure>
<p>该例子统计strings中某个单词出现的次数，并在counts字典中作记录。单词每出现一次，在counts相对应的键所存的值数字加1。<strong>但是事实上，运行这段代码会抛出KeyError异常，出现的时机是每个单词第一次统计的时候，因为Python的dict中不存在默认值的说法</strong>，可以在Python命令行中验证：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>counts = dict()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>counts</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>counts[<span class="string">'puppy'</span>] += <span class="number">1</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">KeyError: <span class="string">'puppy'</span></span><br></pre></td></tr></table></figure>
<h3 id="使用判断语句检查"><a href="#使用判断语句检查" class="headerlink" title="使用判断语句检查"></a>使用判断语句检查</h3><p>既然如此，首先可能想到的方法是在单词第一次统计的时候，<strong>在counts中相应的键存下默认值1</strong>。这需要在处理的时候添加一个判断语句：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">strings = (<span class="string">'puppy'</span>, <span class="string">'kitten'</span>, <span class="string">'puppy'</span>, <span class="string">'puppy'</span>,</span><br><span class="line">           <span class="string">'weasel'</span>, <span class="string">'puppy'</span>, <span class="string">'kitten'</span>, <span class="string">'puppy'</span>)</span><br><span class="line">counts = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> kw <span class="keyword">in</span> strings:</span><br><span class="line">    <span class="keyword">if</span> kw <span class="keyword">not</span> <span class="keyword">in</span> counts:</span><br><span class="line">        counts[kw] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        counts[kw] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># counts:</span></span><br><span class="line"><span class="comment"># &#123;'puppy': 5, 'weasel': 1, 'kitten': 2&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="使用dict-setdefault-方法"><a href="#使用dict-setdefault-方法" class="headerlink" title="使用dict.setdefault()方法"></a>使用<code>dict.setdefault()</code>方法</h3><p>也可以通过<code>dict.setdefault()</code>方法来设置默认值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">strings = (<span class="string">'puppy'</span>, <span class="string">'kitten'</span>, <span class="string">'puppy'</span>, <span class="string">'puppy'</span>,</span><br><span class="line">           <span class="string">'weasel'</span>, <span class="string">'puppy'</span>, <span class="string">'kitten'</span>, <span class="string">'puppy'</span>)</span><br><span class="line">counts = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> kw <span class="keyword">in</span> strings:</span><br><span class="line">    counts.setdefault(kw, <span class="number">0</span>)</span><br><span class="line">    counts[kw] += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong><code>dict.setdefault()</code>方法接收两个参数，第一个参数是健的名称，第二个参数是默认值。假如字典中不存在给定的键，则返回参数中提供的默认值；反之，则返回字典中保存的值</strong>。利用<code>dict.setdefault()</code>方法的返回值可以重写for循环中的代码，使其更加简洁：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">strings = (<span class="string">'puppy'</span>, <span class="string">'kitten'</span>, <span class="string">'puppy'</span>, <span class="string">'puppy'</span>,</span><br><span class="line">           <span class="string">'weasel'</span>, <span class="string">'puppy'</span>, <span class="string">'kitten'</span>, <span class="string">'puppy'</span>)</span><br><span class="line">counts = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> kw <span class="keyword">in</span> strings:</span><br><span class="line">    counts[kw] = counts.setdefault(kw, <span class="number">0</span>) + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="使用collections-defaultdict类"><a href="#使用collections-defaultdict类" class="headerlink" title="使用collections.defaultdict类"></a>使用<code>collections.defaultdict</code>类</h3><p>以上的方法虽然在一定程度上解决了dict中不存在默认值的问题，但是这时候我们会想，有没有一种字典它本身提供了默认值的功能呢？答案是肯定的，那就是<code>collections.defaultdict</code>。</p>
<p><strong>defaultdict类就好像是一个dict，但是它是使用一个类型来初始化的</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd = defaultdict(list)	<span class="comment"># 接受一个list类型作为初始化参数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd</span><br><span class="line">defaultdict(&lt;type <span class="string">'list'</span>&gt;, &#123;&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>defaultdict类的初始化函数接受一个类型作为参数，当所访问的键不存在的时候，可以实例化一个值作为默认值：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd[<span class="string">'foo'</span>]</span><br><span class="line">[]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd</span><br><span class="line">defaultdict(&lt;type <span class="string">'list'</span>&gt;, &#123;<span class="string">'foo'</span>: []&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd[<span class="string">'bar'</span>].append(<span class="string">'quux'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd</span><br><span class="line">defaultdict(&lt;type <span class="string">'list'</span>&gt;, &#123;<span class="string">'foo'</span>: [], <span class="string">'bar'</span>: [<span class="string">'quux'</span>]&#125;)</span><br></pre></td></tr></table></figure>
<p>需<strong>要注意的是，这种形式的默认值只有在通过<code>dict[key]</code>或者<code>dict.__getitem__(key)</code>访问的时候才有效</strong>，这其中的原因在下文会介绍。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd = defaultdict(list)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'something'</span> <span class="keyword">in</span> dd</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd.pop(<span class="string">'something'</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">KeyError: <span class="string">'pop(): dictionary is empty'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd.get(<span class="string">'something'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd[<span class="string">'something'</span>]</span><br><span class="line">[]</span><br></pre></td></tr></table></figure>
<p><strong>该类除了接受类型名称作为初始化函数的参数之外，还可以使用任何不带参数的可调用函数，到时该函数的返回结果作为默认值</strong>，这样使得默认值的取值更加灵活。下面用一个例子来说明，如何用自定义的不带参数的函数zero()作为初始化函数的参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">zero</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd = defaultdict(zero)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd</span><br><span class="line">defaultdict(&lt;function zero at <span class="number">0xb7ed2684</span>&gt;, &#123;&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd[<span class="string">'foo'</span>]</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd</span><br><span class="line">defaultdict(&lt;function zero at <span class="number">0xb7ed2684</span>&gt;, &#123;<span class="string">'foo'</span>: <span class="number">0</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>利用<code>collections.defaultdict</code>来解决最初的单词统计问题，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line">strings = (<span class="string">'puppy'</span>, <span class="string">'kitten'</span>, <span class="string">'puppy'</span>, <span class="string">'puppy'</span>,</span><br><span class="line">           <span class="string">'weasel'</span>, <span class="string">'puppy'</span>, <span class="string">'kitten'</span>, <span class="string">'puppy'</span>)</span><br><span class="line">counts = defaultdict(<span class="keyword">lambda</span>: <span class="number">0</span>)  <span class="comment"># 使用lambda来定义简单的函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> strings:</span><br><span class="line">    counts[s] += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="defaultdict-类是如何实现的"><a href="#defaultdict-类是如何实现的" class="headerlink" title="defaultdict 类是如何实现的"></a>defaultdict 类是如何实现的</h3><p>通过上面的内容，想必大家已经了解了defaultdict类的用法，那么在defaultdict类中又是如何来实现默认值的功能呢？<strong>这其中的关键是使用了看<code>__missing__()</code>这个方法</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> defaultdict.__missing__.__doc__</span><br><span class="line">__missing__(key) <span class="comment"># Called by __getitem__ for missing key; pseudo-code:</span></span><br><span class="line">  <span class="keyword">if</span> self.default_factory <span class="keyword">is</span> <span class="literal">None</span>: <span class="keyword">raise</span> KeyError(key)</span><br><span class="line">  self[key] = value = self.default_factory()</span><br><span class="line">  <span class="keyword">return</span> value</span><br></pre></td></tr></table></figure>
<p><strong>通过查看<code>__missing__()</code>方法的docstring，可以看出当使用<code>__getitem__()</code>方法访问一个不存在的键时(dict[key]这种形式实际上是<code>__getitem__()</code>方法的简化形式)，会调用<code>__missing__()</code>方法获取默认值，并将该键添加到字典中去</strong>。</p>
<h2 id="counter"><a href="#counter" class="headerlink" title="counter"></a>counter</h2><p>Counter是一个计数器，它可以帮助我们针对某项数据进行计数。比如它可以用来计算每个人喜欢多少种颜色：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line">colours = (</span><br><span class="line">    (<span class="string">'Yasoob'</span>, <span class="string">'Yellow'</span>),</span><br><span class="line">    (<span class="string">'Ali'</span>, <span class="string">'Blue'</span>),</span><br><span class="line">    (<span class="string">'Arham'</span>, <span class="string">'Green'</span>),</span><br><span class="line">    (<span class="string">'Ali'</span>, <span class="string">'Black'</span>),</span><br><span class="line">    (<span class="string">'Yasoob'</span>, <span class="string">'Red'</span>),</span><br><span class="line">    (<span class="string">'Ahmed'</span>, <span class="string">'Silver'</span>),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">favs = Counter(name <span class="keyword">for</span> name, colour <span class="keyword">in</span> colours)</span><br><span class="line">print(favs)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 输出:</span></span><br><span class="line"><span class="comment">## Counter(&#123;</span></span><br><span class="line"><span class="comment">##     'Yasoob': 2,</span></span><br><span class="line"><span class="comment">##     'Ali': 2,</span></span><br><span class="line"><span class="comment">##     'Arham': 1,</span></span><br><span class="line"><span class="comment">##     'Ahmed': 1</span></span><br><span class="line"><span class="comment">##  &#125;)</span></span><br></pre></td></tr></table></figure>
<p>我们也可以在利用它统计一个文件，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'filename'</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    line_count = Counter(f)</span><br><span class="line">print(line_count)</span><br></pre></td></tr></table></figure>
<p>还有</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = Counter()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> ch <span class="keyword">in</span> <span class="string">'programming'</span>:</span><br><span class="line"><span class="meta">... </span>    c[ch] = c[ch] + <span class="number">1</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line">Counter(&#123;<span class="string">'g'</span>: <span class="number">2</span>, <span class="string">'m'</span>: <span class="number">2</span>, <span class="string">'r'</span>: <span class="number">2</span>, <span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'i'</span>: <span class="number">1</span>, <span class="string">'o'</span>: <span class="number">1</span>, <span class="string">'n'</span>: <span class="number">1</span>, <span class="string">'p'</span>: <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h2><p>deque提供了一个双端队列，你可以从头/尾两端添加或删除元素。要想使用它，首先我们要从<code>collections</code>中导入<code>deque</code>模块：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br></pre></td></tr></table></figure>
<p>现在，你可以创建一个<code>deque</code>对象。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = deque()</span><br></pre></td></tr></table></figure>
<p>它的用法就像python的<code>list</code>，并且提供了类似的方法，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = deque()</span><br><span class="line">d.append(<span class="string">'1'</span>)</span><br><span class="line">d.append(<span class="string">'2'</span>)</span><br><span class="line">d.append(<span class="string">'3'</span>)</span><br><span class="line"></span><br><span class="line">print(len(d))</span><br><span class="line"></span><br><span class="line"><span class="comment">## 输出: 3</span></span><br><span class="line"></span><br><span class="line">print(d[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">## 输出: '1'</span></span><br><span class="line"></span><br><span class="line">print(d[<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">## 输出: '3'</span></span><br></pre></td></tr></table></figure>
<p>你可以从两端取出(pop)数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = deque(range(<span class="number">5</span>))</span><br><span class="line">print(len(d))</span><br><span class="line"></span><br><span class="line"><span class="comment">## 输出: 5</span></span><br><span class="line"></span><br><span class="line">d.popleft()</span><br><span class="line"></span><br><span class="line"><span class="comment">## 输出: 0</span></span><br><span class="line"></span><br><span class="line">d.pop()</span><br><span class="line"></span><br><span class="line"><span class="comment">## 输出: 4</span></span><br><span class="line"></span><br><span class="line">print(d)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 输出: deque([1, 2, 3])</span></span><br></pre></td></tr></table></figure>
<p>我们也可以限制这个列表的大小，当超出你设定的限制时，数据会从对队列另一端被挤出去(pop)。<br>最好的解释是给出一个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = deque(maxlen=<span class="number">30</span>)</span><br></pre></td></tr></table></figure>
<p>现在当你插入30条数据时，最左边一端的数据将从队列中删除。</p>
<p>你还可以从任一端扩展这个队列中的数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = deque([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line">d.extendleft([<span class="number">0</span>])</span><br><span class="line">d.extend([<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>])</span><br><span class="line">print(d)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 输出: deque([0, 1, 2, 3, 4, 5, 6, 7, 8])</span></span><br></pre></td></tr></table></figure>
<h2 id="namedtuple"><a href="#namedtuple" class="headerlink" title="namedtuple"></a>namedtuple</h2><p>您可能已经熟悉元组。<br>一个元组是一个不可变的列表，你可以存储一个数据的序列，它和命名元组(<code>namedtuples</code>)非常像，但有几个关键的不同。<br><strong>主要相似点是都不像列表，你不能修改元组中的数据。为了获取元组中的数据，你需要使用整数作为索引</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">man = (<span class="string">'Ali'</span>, <span class="number">30</span>)</span><br><span class="line">print(man[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">## 输出: Ali</span></span><br></pre></td></tr></table></figure>
<p><strong>嗯，那<code>namedtuples</code>是什么呢？它把元组变成一个针对简单任务的容器。你不必使用整数索引来访问一个<code>namedtuples</code>的数据。你可以像字典(<code>dict</code>)一样访问<code>namedtuples</code>，但<code>namedtuples</code>是不可变的</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line">Animal = namedtuple(<span class="string">'Animal'</span>, <span class="string">'name age type'</span>)</span><br><span class="line">perry = Animal(name=<span class="string">"perry"</span>, age=<span class="number">31</span>, type=<span class="string">"cat"</span>)</span><br><span class="line"></span><br><span class="line">print(perry)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 输出: Animal(name='perry', age=31, type='cat')</span></span><br><span class="line"></span><br><span class="line">print(perry.name)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 输出: 'perry'</span></span><br></pre></td></tr></table></figure>
<p>现在你可以看到，我们可以用名字来访问<code>namedtuple</code>中的数据。我们再继续分析它。<strong>一个命名元组(<code>namedtuple</code>)有两个必需的参数。它们是元组名称和字段名称。</strong></p>
<p><strong>在上面的例子中，我们的元组名称是<code>Animal</code>，字段名称是’name’，’age’和’type’。</strong><br><code>namedtuple</code>让你的元组变得<strong>自文档</strong>了。你只要看一眼就很容易理解代码是做什么的。<br><strong>你也不必使用整数索引来访问一个命名元组，这让你的代码更易于维护</strong>。<br>而且，<strong>namedtuple的每个实例没有对象字典</strong>，<strong>所以它们很轻量</strong>，与普通的元组比，并不需要更多的内存。这使得它们比字典更快。</p>
<p><strong>然而，要记住它是一个元组，属性值在<code>namedtuple</code>中是不可变的，所以下面的代码不能工作</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line">Animal = namedtuple(<span class="string">'Animal'</span>, <span class="string">'name age type'</span>)</span><br><span class="line">perry = Animal(name=<span class="string">"perry"</span>, age=<span class="number">31</span>, type=<span class="string">"cat"</span>)</span><br><span class="line">perry.age = <span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 输出:</span></span><br><span class="line"><span class="comment">## Traceback (most recent call last):</span></span><br><span class="line"><span class="comment">##     File "", line 1, in</span></span><br><span class="line"><span class="comment">## AttributeError: can't set attribute</span></span><br></pre></td></tr></table></figure>
<p>你应该使用命名元组来让代码<strong>自文档</strong>，<strong>它们向后兼容于普通的元组</strong>，<strong>这意味着你可以既使用整数索引，也可以使用名称来访问<code>namedtuple</code>：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line">Animal = namedtuple(<span class="string">'Animal'</span>, <span class="string">'name age type'</span>)</span><br><span class="line">perry = Animal(name=<span class="string">"perry"</span>, age=<span class="number">31</span>, type=<span class="string">"cat"</span>)</span><br><span class="line">print(perry[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">## 输出: perry</span></span><br></pre></td></tr></table></figure>
<p>最后，你可以将一个命名元组转换为字典，方法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line">Animal = namedtuple(<span class="string">'Animal'</span>, <span class="string">'name age type'</span>)</span><br><span class="line">perry = Animal(name=<span class="string">"Perry"</span>, age=<span class="number">31</span>, type=<span class="string">"cat"</span>)</span><br><span class="line">print(perry._asdict())</span><br><span class="line"></span><br><span class="line"><span class="comment">## 输出: OrderedDict([('name', 'Perry'), ('age', 31), ...</span></span><br></pre></td></tr></table></figure>
<h2 id="enum-Enum-Python-3-4"><a href="#enum-Enum-Python-3-4" class="headerlink" title="enum.Enum (Python 3.4+)"></a>enum.Enum (Python 3.4+)</h2><p>另一个有用的容器是枚举对象，它属于<code>enum</code>模块，存在于Python 3.4以上版本中（同时作为一个独立的PyPI包<code>enum34</code>供老版本使用）。Enums(枚举类型)基本上是一种组织各种东西的方式。</p>
<p>让我们回顾一下上一个’Animal’命名元组的例子。它有一个type字段，问题是，type是一个字符串。那么问题来了，万一程序员输入了<code>Cat</code>，因为他按到了Shift键，或者输入了’CAT’，甚至’kitten’？解决的方法是为这样的枚举类型定义一个class类型，然后，<strong>每个常量都是class的一个唯一实例</strong>。Python提供了<code>Enum</code>类来实现这个功能：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</span><br><span class="line"></span><br><span class="line">Month = Enum(<span class="string">'Month'</span>, (<span class="string">'Jan'</span>, <span class="string">'Feb'</span>, <span class="string">'Mar'</span>, <span class="string">'Apr'</span>, <span class="string">'May'</span>, <span class="string">'Jun'</span>, <span class="string">'Jul'</span>, <span class="string">'Aug'</span>, <span class="string">'Sep'</span>, <span class="string">'Oct'</span>, <span class="string">'Nov'</span>, <span class="string">'Dec'</span>))</span><br></pre></td></tr></table></figure>
<p>这样我们就获得了<code>Month</code>类型的枚举类，可以直接使用<code>Month.Jan</code>来引用一个常量，或者枚举它的所有成员：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> name, member <span class="keyword">in</span> Month.__members__.items():</span><br><span class="line">    print(name, <span class="string">'=&gt;'</span>, member, <span class="string">','</span>, member.value)</span><br></pre></td></tr></table></figure>
<p><code>value</code>属性则是自动赋给成员的<code>int</code>常量，默认从<code>1</code>开始计数。</p>
<p>如果需要更精确地控制枚举类型，可以从<code>Enum</code>派生出自定义类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</span><br><span class="line"></span><br><span class="line"><span class="meta">@unique		# @unique装饰器可以帮助我们检查保证没有重复值。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Species</span><span class="params">(Enum)</span>:</span></span><br><span class="line">    cat = <span class="number">1</span></span><br><span class="line">    dog = <span class="number">2</span></span><br><span class="line">    horse = <span class="number">3</span></span><br><span class="line">    aardvark = <span class="number">4</span></span><br><span class="line">    butterfly = <span class="number">5</span></span><br><span class="line">    owl = <span class="number">6</span></span><br><span class="line">    platypus = <span class="number">7</span></span><br><span class="line">    dragon = <span class="number">8</span></span><br><span class="line">    unicorn = <span class="number">9</span></span><br><span class="line">    <span class="comment"># 依次类推</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 但我们并不想关心同一物种的年龄，所以我们可以使用一个别名</span></span><br><span class="line">    kitten = <span class="number">1</span>  <span class="comment"># (译者注：幼小的猫咪)</span></span><br><span class="line">    puppy = <span class="number">2</span>   <span class="comment"># (译者注：幼小的狗狗)</span></span><br><span class="line"></span><br><span class="line">Animal = namedtuple(<span class="string">'Animal'</span>, <span class="string">'name age type'</span>)</span><br><span class="line">perry = Animal(name=<span class="string">"Perry"</span>, age=<span class="number">31</span>, type=Species.cat)</span><br><span class="line">drogon = Animal(name=<span class="string">"Drogon"</span>, age=<span class="number">4</span>, type=Species.dragon)</span><br><span class="line">tom = Animal(name=<span class="string">"Tom"</span>, age=<span class="number">75</span>, type=Species.cat)</span><br><span class="line">charlie = Animal(name=<span class="string">"Charlie"</span>, age=<span class="number">2</span>, type=Species.kitten)</span><br></pre></td></tr></table></figure>
<p>现在，我们进行一些测试：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>charlie.type == tom.type</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>charlie.type</span><br><span class="line">&lt;Species.cat: <span class="number">1</span>&gt;</span><br></pre></td></tr></table></figure>
<p><strong>这样就没那么容易错误，我们必须更明确，而且我们应该只使用定义后的枚举类型</strong>。</p>
<p>有三种方法访问枚举数据，例如以下方法都可以获取到’cat’的值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Species(<span class="number">1</span>)</span><br><span class="line">Species[<span class="string">'cat'</span>]</span><br><span class="line">Species.cat</span><br></pre></td></tr></table></figure>
<p>参考资料</p>
<p>【1】：<a href="http://kodango.com/understand-defaultdict-in-python" target="_blank" rel="noopener">http://kodango.com/understand-defaultdict-in-python</a></p>
]]></content>
      <categories>
        <category>python编程进阶</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python编程进阶（7）：可变对象和slots</title>
    <url>/2018/06/30/python%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6/python%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6%EF%BC%887%EF%BC%89%EF%BC%9A%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1%E5%92%8Cslots/</url>
    <content><![CDATA[<h1 id="对象变动-Mutation"><a href="#对象变动-Mutation" class="headerlink" title="对象变动(Mutation)"></a>对象变动(Mutation)</h1><p>当你将一个变量赋值为另一个可变类型的变量时，<strong>对这个数据的任意改动会同时反映到这两个变量上去。新变量只不过是老变量的一个别名而已。对象可变与不可变性，是对内存地址而言的</strong>。现在讲述的这个情况只是针对可变数据类型。</p>
<h2 id="不可变对象（需要复制到新内存）"><a href="#不可变对象（需要复制到新内存）" class="headerlink" title="不可变对象（需要复制到新内存）"></a>不可变对象（需要复制到新内存）</h2><blockquote>
<p>常见不可变对象类型：int，string，float，tuple，bool ，frozenset，bytes</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">int_test</span><span class="params">()</span>:</span> </span><br><span class="line">    i = <span class="number">77</span></span><br><span class="line">    j = <span class="number">77</span></span><br><span class="line">    print(id(<span class="number">77</span>))                  <span class="comment">#140396579590760</span></span><br><span class="line">    print(<span class="string">'i id:'</span> + str(id(i)))      <span class="comment">#i id:140396579590760</span></span><br><span class="line">    print(<span class="string">'j id:'</span> + str(id(j)))      <span class="comment">#j id:140396579590760</span></span><br><span class="line">    <span class="keyword">print</span> i <span class="keyword">is</span> j                    <span class="comment">#True</span></span><br><span class="line">    j = j + <span class="number">1</span></span><br><span class="line">    print(<span class="string">'new i id:'</span> + str(id(i)))  <span class="comment">#new i id:140396579590760</span></span><br><span class="line">    print(<span class="string">'new j id:'</span> + str(id(j)))  <span class="comment">#new j id:140396579590736</span></span><br><span class="line">    <span class="keyword">print</span> i <span class="keyword">is</span> j                    <span class="comment">#False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    int_test()</span><br></pre></td></tr></table></figure>
<p>首先i和j都指向77这个内存块。然后我们修改j的值，按道理j修改之后应该i的值也发生改变的，因为它们都是指向的同一块内存，但结果是并没有。<strong>因为int类型是不可变类型，所有其实是j复制了一份到新的内存地址然后+1，然后j又指向了新的地址。所以j的内存id发生了变化。</strong></p>
<p>内存变化如下：</p>
<p><img src="/2018/06/30/python编程进阶/python编程进阶（7）：可变对象和slots/02.png" alt></p>
<h2 id="可变对象（在原内存上修改）"><a href="#可变对象（在原内存上修改）" class="headerlink" title="可变对象（在原内存上修改）"></a>可变对象（在原内存上修改）</h2><blockquote>
<p>常见可变对象类型：list，dict，set，user-defined classes(unless specifically made immutable)</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dict_test</span><span class="params">()</span>:</span></span><br><span class="line">    a = &#123;&#125;	</span><br><span class="line">    b = a</span><br><span class="line">    print(id(a))	<span class="comment"># 140367329543360</span></span><br><span class="line">    a[<span class="string">'a'</span>] = <span class="string">'hhhh'</span></span><br><span class="line">    print(<span class="string">'id a:'</span> + str(id(a)))	<span class="comment"># id a:140367329543360</span></span><br><span class="line">    print(<span class="string">'a:'</span> + str(a))	<span class="comment"># a:&#123;'a': 'hhhh'&#125;</span></span><br><span class="line">    print(<span class="string">'id b:'</span> + str(id(b)))	<span class="comment"># id b:140367329543360</span></span><br><span class="line">    print(<span class="string">'b:'</span> + str(b))	<span class="comment"># b:&#123;'a': 'hhhh'&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    dict_test()</span><br></pre></td></tr></table></figure>
<p>可以看到a最早的内存地址id是<code>140367329543360</code> 然后把a赋值给b其实就是让变量b的也指向a所指向的内存空间。然后我们发现当a发生变化后，b也跟着发生变化了。<strong>因为list是可变类型，所以并不会复制一份再改变，而是直接在a所指向的内存空间修改数据，而b也是指向该内存空间的，自然b也就跟着改变了。</strong></p>
<p><img src="/2018/06/30/python编程进阶/python编程进阶（7）：可变对象和slots/03.png" alt></p>
<p>对于列表，首地址是不可变的，而对于列表内的所有元素进行修改，会改变单个元素的地址（指向不同的引用）。所以说对于列表中的单个元素而言是不可变的，对于整体列表而言是可变的，如下图所示</p>
<p><img src="/2018/06/30/python编程进阶/python编程进阶（7）：可变对象和slots/04.jpg" alt></p>
<h2 id="python函数的参数传递"><a href="#python函数的参数传递" class="headerlink" title="python函数的参数传递"></a>python函数的参数传递</h2><p>由于<strong>python规定参数传递都是传递引用，也就是传递给函数的是原变量实际所指向的内存空间，修改的时候就会根据该引用的指向去修改该内存中的内容</strong>，所以按道理说我们在函数内改变了传递过来的参数的值的话，原来外部的变量也应该受到影响。但是上面我们说到了python中有可变类型和不可变类型，这样的话，<strong>当传过来的是可变类型(list,dict)时，我们在函数内部修改就会影响函数外部的变量。而传入的是不可变类型时在函数内部修改改变量并不会影响函数外部的变量，因为修改的时候会先复制一份再修改</strong>。下面通过代码证明一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(a_int, b_list)</span>:</span></span><br><span class="line">    a_int = a_int + <span class="number">1</span></span><br><span class="line">    b_list.append(<span class="string">'13'</span>)</span><br><span class="line">    print(<span class="string">'inner a_int:'</span> + str(a_int))</span><br><span class="line">    print(<span class="string">'inner b_list:'</span> + str(b_list))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a_int = <span class="number">5</span></span><br><span class="line">    b_list = [<span class="number">10</span>, <span class="number">11</span>]</span><br><span class="line"></span><br><span class="line">    test(a_int, b_list)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'outer a_int:'</span> + str(a_int))</span><br><span class="line">    print(<span class="string">'outer b_list:'</span> + str(b_list))</span><br></pre></td></tr></table></figure>
<p>运行结果如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">inner a_int:<span class="number">6</span></span><br><span class="line"></span><br><span class="line">inner b_list:[<span class="number">10</span>, <span class="number">11</span>, <span class="string">'13'</span>]</span><br><span class="line"></span><br><span class="line">outer a_int:<span class="number">5</span></span><br><span class="line"></span><br><span class="line">outer b_list:[<span class="number">10</span>, <span class="number">11</span>, <span class="string">'13'</span>]</span><br></pre></td></tr></table></figure>
<p>好啦！答案显而易见啦，经过<code>test()</code>方法修改后，传递过来的int类型外部变量没有发生改变，而list这种可变类型则因为<code>test()</code>方法的影响导致内容发生了改变。</p>
<p>在很多的其他语言中在传递参数的时候允许程序员选择值传递还是引用传递(比如c语言加上<em>号传递指针就是引用传递，而直接传递变量名就是值传递)，<em>*而python只允许使用引用传递，但是它加上了可变类型和不可变类型，听说python只允许引用传递是为方便内存管理，因为python使用的内存回收机制是计数器回收，就是每块内存上有一个计数器，表示当前有多少个对象指向该内存。每当一个变量不再使用时，就让该计数器-1，有新对象指向该内存时就让计数器+1，当计时器为0时，就可以收回这块内存了。</em></em></p>
<h1 id="slots-魔法"><a href="#slots-魔法" class="headerlink" title="_slots_魔法"></a>_<em>slots_</em>魔法</h1><p><strong>在Python中，每个类都有实例属性。默认情况下Python用一个字典来保存一个对象的实例属性。这非常有用，因为它允许我们在运行时去设置任意的新属性。</strong></p>
<p>然而，对于有着已知属性的小类来说，它可能是个瓶颈。这个字典浪费了很多内存。<strong>Python不能在对象创建时直接分配一个固定量的内存来保存所有的属性。因此如果你创建许多对象（我指的是成千上万个），它会消耗掉很多内存</strong>。<br>不过还是有一个方法来规避这个问题。<strong>这个方法需要使用<code>__slots__</code>来告诉Python不要使用字典，而且只给一个固定集合的属性分配空间。</strong></p>
<p>这里是一个使用与不使用<code>__slots__</code>的例子：</p>
<ul>
<li><p>不使用 <code>__slots__</code>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(object)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, identifier)</span>:</span></span><br><span class="line">      self.name = name</span><br><span class="line">      self.identifier = identifier</span><br><span class="line">      self.set_up()</span><br><span class="line">  <span class="comment"># ...</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>__slots__</code>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(object)</span>:</span></span><br><span class="line">  __slots__ = [<span class="string">'name'</span>, <span class="string">'identifier'</span>]</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, identifier)</span>:</span></span><br><span class="line">      self.name = name</span><br><span class="line">      self.identifier = identifier</span><br><span class="line">      self.set_up()</span><br><span class="line">  <span class="comment"># ...</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>第二段代码会为你的内存减轻负担。通过这个技巧，有些人已经看到内存占用率几乎40%~50%的减少。</p>
<p>稍微备注一下，你也许需要试一下PyPy。它已经默认地做了所有这些优化。</p>
<p>参考资料：</p>
<p>【1】python可变和不可变对象：<a href="https://www.jianshu.com/p/c5582e23b26c" target="_blank" rel="noopener">https://www.jianshu.com/p/c5582e23b26c</a></p>
]]></content>
      <categories>
        <category>python编程进阶</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python编程进阶（6）：装饰器</title>
    <url>/2018/06/29/python%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6/python%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6%EF%BC%886%EF%BC%89%EF%BC%9A%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
    <content><![CDATA[<h1 id="一切皆对象"><a href="#一切皆对象" class="headerlink" title="一切皆对象"></a>一切皆对象</h1><p>首先我们来理解下Python中的函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hi</span><span class="params">(name=<span class="string">"yasoob"</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hi "</span> + name</span><br><span class="line"></span><br><span class="line">print(hi())</span><br><span class="line"><span class="comment"># output: 'hi yasoob'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们甚至可以将一个函数赋值给一个变量，比如</span></span><br><span class="line">greet = hi</span><br><span class="line"><span class="comment"># 我们这里没有在使用小括号，因为我们并不是在调用hi函数</span></span><br><span class="line"><span class="comment"># 而是在将它放在greet变量里头。我们尝试运行下这个</span></span><br><span class="line"></span><br><span class="line">print(greet())</span><br><span class="line"><span class="comment"># output: 'hi yasoob'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果我们删掉旧的hi函数，看看会发生什么！</span></span><br><span class="line"><span class="keyword">del</span> hi</span><br><span class="line">print(hi())</span><br><span class="line"><span class="comment">#outputs: NameError</span></span><br><span class="line"></span><br><span class="line">print(greet())	<span class="comment"># 这里可不像数组那样具有对象可变性噢</span></span><br><span class="line"><span class="comment">#outputs: 'hi yasoob'</span></span><br></pre></td></tr></table></figure>
<h1 id="在函数中定义函数"><a href="#在函数中定义函数" class="headerlink" title="在函数中定义函数"></a>在函数中定义函数</h1><p>刚才那些就是函数的基本知识了。我们来让你的知识更进一步。在Python中我们可以在一个函数中定义另一个函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hi</span><span class="params">(name=<span class="string">"yasoob"</span>)</span>:</span></span><br><span class="line">    print(<span class="string">"now you are inside the hi() function"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">greet</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"now you are in the greet() function"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">welcome</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"now you are in the welcome() function"</span></span><br><span class="line"></span><br><span class="line">    print(greet())</span><br><span class="line">    print(welcome())</span><br><span class="line">    print(<span class="string">"now you are back in the hi() function"</span>)</span><br><span class="line"></span><br><span class="line">hi()</span><br><span class="line"><span class="comment">#output:now you are inside the hi() function</span></span><br><span class="line"><span class="comment">#       now you are in the greet() function</span></span><br><span class="line"><span class="comment">#       now you are in the welcome() function</span></span><br><span class="line"><span class="comment">#       now you are back in the hi() function</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面展示了无论何时你调用hi(), greet()和welcome()将会同时被调用。</span></span><br><span class="line"><span class="comment"># 然后greet()和welcome()函数在hi()函数之外是不能访问的，比如：</span></span><br><span class="line"></span><br><span class="line">greet()</span><br><span class="line"><span class="comment">#outputs: NameError: name 'greet' is not defined</span></span><br></pre></td></tr></table></figure>
<p>那现在我们知道了可以在函数中定义另外的函数。也就是说：我们可以创建嵌套的函数。现在你需要再多学一点，就是函数也能返回函数。</p>
<h1 id="从函数中返回函数"><a href="#从函数中返回函数" class="headerlink" title="从函数中返回函数"></a>从函数中返回函数</h1><p>其实并不需要在一个函数里去执行另一个函数，我们也可以将其作为输出返回出来：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hi</span><span class="params">(name=<span class="string">"yasoob"</span>)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">greet</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"now you are in the greet() function"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">welcome</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"now you are in the welcome() function"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> name == <span class="string">"yasoob"</span>:</span><br><span class="line">        <span class="keyword">return</span> greet</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> welcome</span><br><span class="line"></span><br><span class="line">a = hi() <span class="comment"># 执行hi()函数，得到return greet(注意没有括号)，将函数赋给a</span></span><br><span class="line">print(a)</span><br><span class="line"><span class="comment">#outputs: &lt;function greet at 0x7f2143c01500&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#上面清晰地展示了`a`现在指向到hi()函数中的greet()函数</span></span><br><span class="line"><span class="comment">#现在试试这个</span></span><br><span class="line"></span><br><span class="line">print(a())</span><br><span class="line"><span class="comment">#outputs: now you are in the greet() function</span></span><br></pre></td></tr></table></figure>
<p>再次看看这个代码。在<code>if/else</code>语句中我们返回<code>greet</code>和<code>welcome</code>，而不是<code>greet()</code>和<code>welcome()</code>。为什么那样？<strong>这是因为当你把一对小括号放在后面，这个函数就会执行；然而如果你不放括号在它后面，那它可以被到处传递，并且可以赋值给别的变量而不去执行它。</strong></p>
<p>你明白了吗？让我再稍微多解释点细节。</p>
<p>当我们写下<code>a = hi()</code>，<code>hi()</code>会被执行，而由于<code>name</code>参数默认是<em>yasoob</em>，所以函数<code>greet</code>被返回了。如果我们把语句改为<code>a = hi(name = &quot;ali&quot;)</code>，那么<code>welcome</code>函数将被返回。我们还可以打印出<code>hi()()</code>，这会输出<em>now you are in the greet() function</em>。连续两个括号的函数执行也可以，只要第一个hi()返回一个函数即可.</p>
<h1 id="将函数作为参数传给另一个函数"><a href="#将函数作为参数传给另一个函数" class="headerlink" title="将函数作为参数传给另一个函数"></a>将函数作为参数传给另一个函数</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hi</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hi yasoob!"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">doSomethingBeforeHi</span><span class="params">(func)</span>:</span></span><br><span class="line">    print(<span class="string">"I am doing some boring work before executing hi()"</span>)</span><br><span class="line">    print(func())</span><br><span class="line"></span><br><span class="line">doSomethingBeforeHi(hi)</span><br><span class="line"><span class="comment">#outputs:I am doing some boring work before executing hi()</span></span><br><span class="line"><span class="comment">#        hi yasoob!</span></span><br></pre></td></tr></table></figure>
<p>现在你已经具备所有必需知识，来进一步学习装饰器真正是什么了。装饰器让你在一个函数的前后去执行代码。</p>
<h1 id="你的第一个装饰器"><a href="#你的第一个装饰器" class="headerlink" title="你的第一个装饰器"></a>你的第一个装饰器</h1><p>在上一个例子里，其实我们已经创建了一个装饰器！现在我们修改下上一个装饰器，并编写一个稍微更有用点的程序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_new_decorator</span><span class="params">(a_func)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapTheFunction</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"I am doing some boring work before executing a_func()"</span>)</span><br><span class="line"></span><br><span class="line">        a_func()</span><br><span class="line"></span><br><span class="line">        print(<span class="string">"I am doing some boring work after executing a_func()"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapTheFunction</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_function_requiring_decoration</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"I am the function which needs some decoration to remove my foul smell"</span>)</span><br><span class="line"></span><br><span class="line">a_function_requiring_decoration()</span><br><span class="line"><span class="comment">#outputs: "I am the function which needs some decoration to remove my foul smell"</span></span><br><span class="line"></span><br><span class="line">a_function_requiring_decoration = a_new_decorator(a_function_requiring_decoration)</span><br><span class="line"><span class="comment"># 将带参数a_new_decorator函数传递给a_function_requiring_decoration</span></span><br><span class="line"><span class="comment">#now a_function_requiring_decoration is wrapped by wrapTheFunction()</span></span><br><span class="line"></span><br><span class="line">a_function_requiring_decoration()</span><br><span class="line"><span class="comment"># 执行a_function_requiring_decoration，也就是执行带参数的a_new_decorator函数</span></span><br><span class="line"><span class="comment">#outputs:I am doing some boring work before executing a_func()</span></span><br><span class="line"><span class="comment">#        I am the function which needs some decoration to remove my foul smell</span></span><br><span class="line"><span class="comment">#        I am doing some boring work after executing a_func()</span></span><br></pre></td></tr></table></figure>
<p>你看明白了吗？我们刚刚应用了之前学习到的原理。这正是python中装饰器做的事情！它们封装一个函数，并且用这样或者那样的方式来修改它的行为。现在你也许疑惑，我们在代码里并没有使用@符号？那只是一个简短的方式来生成一个被装饰的函数。这里是我们如何使用@来运行之前的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@a_new_decorator #将@下面的函数作为参数传入a_new_decorator函数，并合成@下面的同名函数。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_function_requiring_decoration</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""Hey you! Decorate me!"""</span></span><br><span class="line">    print(<span class="string">"I am the function which needs some decoration to "</span></span><br><span class="line">          <span class="string">"remove my foul smell"</span>)</span><br><span class="line"></span><br><span class="line">a_function_requiring_decoration() <span class="comment"># 执行同名函数，也即执行带参的修饰器函数</span></span><br><span class="line"><span class="comment">#outputs: I am doing some boring work before executing a_func()</span></span><br><span class="line"><span class="comment">#         I am the function which needs some decoration to remove my foul smell</span></span><br><span class="line"><span class="comment">#         I am doing some boring work after executing a_func()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#the @a_new_decorator is just a short way of saying:</span></span><br><span class="line">a_function_requiring_decoration = a_new_decorator(a_function_requiring_decoration)</span><br></pre></td></tr></table></figure>
<p>希望你现在对Python装饰器的工作原理有一个基本的理解。如果我们运行如下代码会存在一个问题：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(a_function_requiring_decoration.__name__)</span><br><span class="line"><span class="comment"># Output: wrapTheFunction</span></span><br></pre></td></tr></table></figure>
<p>这并不是我们想要的！Ouput输出应该是“a_function_requiring_decoration”。<strong>这里的函数被warpTheFunction替代了。它重写了我们函数的名字和注释文档(docstring)。幸运的是Python提供给我们一个简单的函数来解决这个问题，那就是functools.wraps。</strong>我们修改上一个例子来使用functools.wraps：<strong>在装饰器函数内加入@wraps(a_func)</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_new_decorator</span><span class="params">(a_func)</span>:</span></span><br><span class="line"><span class="meta">    @wraps(a_func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapTheFunction</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"I am doing some boring work before executing a_func()"</span>)</span><br><span class="line">        a_func()</span><br><span class="line">        print(<span class="string">"I am doing some boring work after executing a_func()"</span>)</span><br><span class="line">    <span class="keyword">return</span> wrapTheFunction</span><br><span class="line"></span><br><span class="line"><span class="meta">@a_new_decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_function_requiring_decoration</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""Hey yo! Decorate me!"""</span></span><br><span class="line">    print(<span class="string">"I am the function which needs some decoration to "</span></span><br><span class="line">          <span class="string">"remove my foul smell"</span>)</span><br><span class="line"></span><br><span class="line">print(a_function_requiring_decoration.__name__)</span><br><span class="line"><span class="comment"># Output: a_function_requiring_decoration</span></span><br></pre></td></tr></table></figure>
<p>现在好多了。我们接下来学习装饰器的一些常用场景。</p>
<p>蓝本规范:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator_name</span><span class="params">(f)</span>:</span></span><br><span class="line"><span class="meta">    @wraps(f)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorated</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> can_run:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Function will not run"</span></span><br><span class="line">        <span class="keyword">return</span> f(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> decorated</span><br><span class="line"></span><br><span class="line"><span class="meta">@decorator_name</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span>(<span class="string">"Function is running"</span>)</span><br><span class="line"></span><br><span class="line">can_run = <span class="literal">True</span>	<span class="comment"># 全局变量</span></span><br><span class="line">print(func()) <span class="comment"># 由于func函数有装饰器，执行func即执行func为参的修饰器函数</span></span><br><span class="line"><span class="comment"># Output: Function is running</span></span><br><span class="line"></span><br><span class="line">can_run = <span class="literal">False</span></span><br><span class="line">print(func())</span><br><span class="line"><span class="comment"># Output: Function will not run</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：@wraps接受一个函数来进行装饰，并加入了复制函数名称、注释文档、参数列表等等的功能。这可以让我们在装饰器里面访问在装饰之前的函数的属性。</strong></p>
<h2 id="使用场景：授权-Authorization"><a href="#使用场景：授权-Authorization" class="headerlink" title="使用场景：授权(Authorization)"></a>使用场景：授权(Authorization)</h2><p>装饰器能有助于检查某个人是否被授权去使用一个web应用的端点(endpoint)。它们被大量使用于Flask和Django web框架中。这里是一个例子来使用基于装饰器的授权：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">requires_auth</span><span class="params">(f)</span>:</span></span><br><span class="line"><span class="meta">    @wraps(f)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorated</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        auth = request.authorization</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> auth <span class="keyword">or</span> <span class="keyword">not</span> check_auth(auth.username, auth.password):</span><br><span class="line">            authenticate()</span><br><span class="line">        <span class="keyword">return</span> f(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> decorated</span><br></pre></td></tr></table></figure>
<h2 id="使用场景：日志-Logging"><a href="#使用场景：日志-Logging" class="headerlink" title="使用场景：日志(Logging)"></a>使用场景：日志(Logging)</h2><p>日志是装饰器运用的另一个亮点。这是个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logit</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">with_logging</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        print(func.__name__ + <span class="string">" was called"</span>)	<span class="comment"># 打印调用函数信息并执行相关函数</span></span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> with_logging</span><br><span class="line"></span><br><span class="line"><span class="meta">@logit</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addition_func</span><span class="params">(x)</span>:</span></span><br><span class="line">   <span class="string">"""Do some math."""</span></span><br><span class="line">   <span class="keyword">return</span> x + x</span><br><span class="line"></span><br><span class="line">result = addition_func(<span class="number">4</span>)</span><br><span class="line"><span class="comment"># Output: addition_func was called</span></span><br></pre></td></tr></table></figure>
<p>我敢肯定你已经在思考装饰器的一个其他聪明用法了。</p>
<h1 id="带参数的装饰器"><a href="#带参数的装饰器" class="headerlink" title="带参数的装饰器"></a>带参数的装饰器</h1><p>来想想这个问题，难道<code>@wraps</code>不也是个装饰器吗？但是，它接收一个参数，就像任何普通的函数能做的那样。那么，为什么我们不也那样做呢？</p>
<p>这是因为，当你使用<code>@my_decorator</code>语法时，你是在应用一个<strong>以单个函数作为参数的一个包裹函数</strong>。<strong>记住，Python里每个东西都是一个对象，而且这包括函数</strong>！记住了这些，我们可以编写一下能返回一个包裹函数的函数。</p>
<h2 id="在函数中嵌入装饰器"><a href="#在函数中嵌入装饰器" class="headerlink" title="在函数中嵌入装饰器"></a>在函数中嵌入装饰器</h2><p>我们回到日志的例子，并创建一个包裹函数，能让我们指定一个用于输出的日志文件。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logit</span><span class="params">(logfile=<span class="string">'out.log'</span>)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">logging_decorator</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">        @wraps(func)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapped_function</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            log_string = func.__name__ + <span class="string">" was called"</span></span><br><span class="line">            print(log_string)</span><br><span class="line">            <span class="comment"># 打开logfile，并写入内容</span></span><br><span class="line">            <span class="keyword">with</span> open(logfile, <span class="string">'a'</span>) <span class="keyword">as</span> opened_file:</span><br><span class="line">                <span class="comment"># 现在将日志打到指定的logfile</span></span><br><span class="line">                opened_file.write(log_string + <span class="string">'\n'</span>)</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> wrapped_function</span><br><span class="line">    <span class="keyword">return</span> logging_decorator <span class="comment"># return函数就是执行函数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@logit()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfunc1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">myfunc1()</span><br><span class="line"><span class="comment"># Output: myfunc1 was called</span></span><br><span class="line"><span class="comment"># 现在一个叫做 out.log 的文件出现了，里面的内容就是上面的字符串</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@logit(logfile='func2.log')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfunc2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">myfunc2()</span><br><span class="line"><span class="comment"># Output: myfunc2 was called</span></span><br><span class="line"><span class="comment"># 现在一个叫做 func2.log 的文件出现了，里面的内容就是上面的字符串</span></span><br></pre></td></tr></table></figure>
<h2 id="装饰器类"><a href="#装饰器类" class="headerlink" title="装饰器类"></a>装饰器类</h2><p>现在我们有了能用于正式环境的<code>logit</code>装饰器，但当我们的应用的某些部分还比较脆弱时，异常也许是需要更紧急关注的事情。<strong>比方说有时你只想打日志到一个文件。而有时你想把引起你注意的问题发送到一个email，同时也保留日志，留个记录</strong>。<strong>这是一个使用继承的场景</strong>，但目前为止我们只看到过用来构建装饰器的函数。</p>
<p><strong>幸运的是，类也可以用来构建装饰器。那我们现在以一个类而不是一个函数的方式，来重新构建<code>logit</code>。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">logit</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, logfile=<span class="string">'out.log'</span>)</span>:</span></span><br><span class="line">        self.logfile = logfile</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, func)</span>:</span></span><br><span class="line"><span class="meta">        @wraps(func)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapped_function</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            log_string = func.__name__ + <span class="string">" was called"</span></span><br><span class="line">            print(log_string)</span><br><span class="line">            <span class="comment"># 打开logfile并写入</span></span><br><span class="line">            <span class="keyword">with</span> open(self.logfile, <span class="string">'a'</span>) <span class="keyword">as</span> opened_file:</span><br><span class="line">                <span class="comment"># 现在将日志打到指定的文件</span></span><br><span class="line">                opened_file.write(log_string + <span class="string">'\n'</span>)</span><br><span class="line">            <span class="comment"># 现在，发送一个通知</span></span><br><span class="line">            self.notify()</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs) <span class="comment"># logit装饰器顺序：写入日志，发送通知，调用相关函数 </span></span><br><span class="line">        <span class="keyword">return</span> wrapped_function</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">notify</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># logit只打日志，不做别的</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>这个实现有一个附加优势，在于比嵌套函数的方式更加整洁，而且包裹一个函数还是使用跟以前一样的语法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@logit()	# 类作为装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfunc1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>现在，我们给<code>logit</code>创建子类，来添加email的功能(虽然email这个话题不会在这里展开)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">email_logit</span><span class="params">(logit)</span>:</span>	</span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    一个logit的实现版本，可以在函数调用时发送email给管理员</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, email=<span class="string">'admin@myproject.com'</span>, *args, **kwargs)</span>:</span></span><br><span class="line">        self.email = email</span><br><span class="line">        super(email_logit, self).__init__(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">notify</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 发送一封email到self.email</span></span><br><span class="line">        <span class="comment"># 这里就不做实现了</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p><strong>从现在起，<code>@email_logit</code>将会和<code>@logit</code>产生同样的效果，但是在打日志的基础上，还会多发送一封邮件给管理员</strong>。</p>
]]></content>
      <categories>
        <category>python编程进阶</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python编程进阶（5）：set&amp;三元运算符</title>
    <url>/2018/06/28/python%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6/python%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6%EF%BC%885%EF%BC%89%EF%BC%9Aset&amp;%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<h1 id="set-集合-数据结构"><a href="#set-集合-数据结构" class="headerlink" title="set(集合)数据结构"></a>set(集合)数据结构</h1><p><code>set</code>(集合)是一个非常有用的数据结构。它与列表(<code>list</code>)的行为类似，<strong>区别在于<code>set</code>不能包含重复的值</strong>。<br>这在很多情况下非常有用。例如你可能想检查列表中是否包含重复的元素，你有两个选择，第一个需要使用<code>for</code>循环，就像这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">some_list = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'b'</span>, <span class="string">'d'</span>, <span class="string">'m'</span>, <span class="string">'n'</span>, <span class="string">'n'</span>]</span><br><span class="line"></span><br><span class="line">duplicates = []</span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> some_list:</span><br><span class="line">    <span class="keyword">if</span> some_list.count(value) &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">if</span> value <span class="keyword">not</span> <span class="keyword">in</span> duplicates:</span><br><span class="line">            duplicates.append(value)</span><br><span class="line"></span><br><span class="line">print(duplicates)</span><br><span class="line"><span class="comment">### 输出: ['b', 'n']</span></span><br></pre></td></tr></table></figure>
<p>但还有一种更简单更优雅的解决方案，那就是使用<code>集合(sets)</code>，你直接这样做：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">some_list = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'b'</span>, <span class="string">'d'</span>, <span class="string">'m'</span>, <span class="string">'n'</span>, <span class="string">'n'</span>]</span><br><span class="line">duplicates = set([x <span class="keyword">for</span> x <span class="keyword">in</span> some_list <span class="keyword">if</span> some_list.count(x) &gt; <span class="number">1</span>])</span><br><span class="line">print(duplicates)</span><br><span class="line"><span class="comment">### 输出: set(['b', 'n'])</span></span><br></pre></td></tr></table></figure>
<p>集合还有一些其它方法，下面我们介绍其中一部分。</p>
<h2 id="交集"><a href="#交集" class="headerlink" title="交集"></a>交集</h2><p><strong>你可以对比两个集合的交集（两个集合中都有的数据）</strong>，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">valid = set([<span class="string">'yellow'</span>, <span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>, <span class="string">'black'</span>])</span><br><span class="line">input_set = set([<span class="string">'red'</span>, <span class="string">'brown'</span>])</span><br><span class="line">print(input_set.intersection(valid))</span><br><span class="line"><span class="comment">### 输出: set(['red'])</span></span><br></pre></td></tr></table></figure>
<h2 id="差集"><a href="#差集" class="headerlink" title="差集"></a>差集</h2><p><strong>你可以用差集(difference)找出无效的数据，相当于用一个集合减去另一个集合的数据</strong>，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">valid = set([<span class="string">'yellow'</span>, <span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>, <span class="string">'black'</span>])</span><br><span class="line">input_set = set([<span class="string">'red'</span>, <span class="string">'brown'</span>])</span><br><span class="line">print(input_set.difference(valid))</span><br><span class="line"><span class="comment">### 输出: set(['brown'])</span></span><br></pre></td></tr></table></figure>
<p><strong>你也可以用<code>{}</code>符号来创建集合</strong>，如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a_set = &#123;<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>&#125;</span><br><span class="line">print(type(a_set))</span><br><span class="line"><span class="comment">### 输出: &lt;type 'set'&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h1><p>三元运算符通常在Python里被称为条件表达式，这些表达式基于真(true)/假(false)的条件判断，在Python 2.4以上才有了三元操作。</p>
<p>下面是一个伪代码和例子：</p>
<p><strong>伪代码:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#如果条件为真，返回真 否则返回假</span></span><br><span class="line">condition_is_true <span class="keyword">if</span> condition <span class="keyword">else</span> condition_is_false</span><br></pre></td></tr></table></figure>
<p><strong>例子:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">is_fat = <span class="literal">True</span></span><br><span class="line">state = <span class="string">"fat"</span> <span class="keyword">if</span> is_fat <span class="keyword">else</span> <span class="string">"not fat"</span></span><br></pre></td></tr></table></figure>
<p>它允许用简单的一行快速判断，而不是使用复杂的多行<code>if</code>语句。 这在大多数时候非常有用，而且可以使代码简单可维护。</p>
]]></content>
      <categories>
        <category>python编程进阶</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python编程进阶（4）：函数式编程</title>
    <url>/2018/06/28/python%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6/python%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6%EF%BC%884%EF%BC%89%EF%BC%9A%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>Map，Filter 和 Reduce 三个函数能为函数式编程提供便利。我们会通过实例一个一个讨论并理解它们。</p>
<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p><strong><code>Map</code>会将一个函数映射到一个输入列表的所有元素上</strong>。这是它的规范：</p>
<p><strong>规范</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">map(function_to_apply, list_of_inputs)</span><br></pre></td></tr></table></figure>
<p>大多数时候，我们要把列表中所有元素一个个地传递给一个函数，并收集输出。比方说：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">items = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">squared = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> items:</span><br><span class="line">    squared.append(i**<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p><code>Map</code>可以让我们用一种简单而漂亮得多的方式来实现。就是这样(<strong>x为逗号右边的输入元素items</strong>)：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">items = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">squared = list(map(<span class="keyword">lambda</span> x: x**<span class="number">2</span>, items))</span><br></pre></td></tr></table></figure>
<p>大多数时候，我们使用匿名函数(lambdas)来配合<code>map</code>, 所以我在上面也是这么做的。 不仅用于一列表的输入， 我们甚至可以用于一列表的函数！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multiply</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (x*x)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (x+x)</span><br><span class="line"></span><br><span class="line">funcs = [multiply, add]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    value = map(<span class="keyword">lambda</span> x: x(i), funcs) <span class="comment"># 每次执行i时，map将funcs内元素都执行lambda函数，即执行multiply(i)和add(i)</span></span><br><span class="line">    print(list(value))</span><br><span class="line">    <span class="comment"># 译者注：上面print时，加了list转换，是为了python2/3的兼容性</span></span><br><span class="line">    <span class="comment">#        在python2中map直接返回列表，但在python3中返回迭代器</span></span><br><span class="line">    <span class="comment">#        因此为了兼容python3, 需要list转换一下</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># [0, 0]</span></span><br><span class="line"><span class="comment"># [1, 2]</span></span><br><span class="line"><span class="comment"># [4, 4]</span></span><br><span class="line"><span class="comment"># [9, 6]</span></span><br><span class="line"><span class="comment"># [16, 8]</span></span><br></pre></td></tr></table></figure>
<h1 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h1><p>顾<strong>名思义，<code>filter</code>过滤列表中的元素，并且返回一个由所有符合要求的元素所构成的列表</strong>，<code>符合要求</code>即函数映射到该元素时返回值为True. 这里是一个简短的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">number_list = range(<span class="number">-5</span>, <span class="number">5</span>)</span><br><span class="line">less_than_zero = filter(<span class="keyword">lambda</span> x: x &lt; <span class="number">0</span>, number_list)</span><br><span class="line">print(list(less_than_zero))  </span><br><span class="line"><span class="comment"># 译者注：上面print时，加了list转换，是为了python2/3的兼容性</span></span><br><span class="line"><span class="comment">#        在python2中filter直接返回列表，但在python3中返回迭代器</span></span><br><span class="line"><span class="comment">#        因此为了兼容python3, 需要list转换一下</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Output: [-5, -4, -3, -2, -1]</span></span><br></pre></td></tr></table></figure>
<p>这个<code>filter</code>类似于一个<code>for</code>循环，但它是一个内置函数，并且更快。</p>
<p>注意：如果<code>map</code>和<code>filter</code>对你来说看起来并不优雅的话，那么你可以看看另外一章：列表/字典/元组推导式。</p>
<blockquote>
<p>译者注：大部分情况下推导式的可读性更好</p>
</blockquote>
<h1 id="Reduce"><a href="#Reduce" class="headerlink" title="Reduce"></a>Reduce</h1><p>当需要对一个列表进行一些计算并返回结果时，<code>Reduce</code> 是个非常有用的函数。举个例子，当你需要计算一个整数列表的乘积时。Reduce() 函数会对参数序列中元素进行累积，函数将一个数据集合（链表，元组等）中的所有数据进行下列操作：<strong>用传给 reduce 中的函数 function（有两个参数）先对集合中的第 1、2 个元素进行操作，得到的结果再与第三个数据用 function 函数运算，最后得到一个结果</strong>。</p>
<p>语法：reduce(function, iterable[, initializer])</p>
<p>参数：</p>
<ul>
<li>function — 函数，有两个参数</li>
<li>iterable — 可迭代对象</li>
<li>initializer — 可选，初始参数</li>
</ul>
<p>现在我们来试试 reduce：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line">product = reduce( (<span class="keyword">lambda</span> x, y: x * y), [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>] )</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output: 24</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在 Python3 中，reduce() 函数已经被从全局名字空间里移除了，它现在被放置在 fucntools 模块里，如果想要使用它，则需要通过引入 functools 模块来调用 reduce() 函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; from functools import reduce</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote>
]]></content>
      <categories>
        <category>python编程进阶</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python编程进阶（3）：生成器</title>
    <url>/2018/06/28/python%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6/python%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6%EF%BC%883%EF%BC%89%EF%BC%9A%E7%94%9F%E6%88%90%E5%99%A8/</url>
    <content><![CDATA[<p>首先我们要理解迭代器(iterators)。根据维基百科，迭代器是一个让程序员可以遍历一个容器（特别是列表）的对象。然而，一个迭代器在遍历并读取一个容器的数据元素时，并不会执行一个迭代。这里有三个部分：</p>
<ul>
<li>可迭代对象(Iterable)</li>
<li>迭代器(Iterator)</li>
<li>迭代(Iteration)</li>
</ul>
<p>上面这些部分互相联系。我们会先各个击破来讨论他们，然后再讨论生成器(generators).</p>
<h1 id="可迭代对象（Iterable）"><a href="#可迭代对象（Iterable）" class="headerlink" title="可迭代对象（Iterable）"></a>可迭代对象（Iterable）</h1><p>Python中任意的对象，只要它定义了<strong>可以返回一个迭代器的<code>__iter__</code>方法，或者定义了可以支持下标索引的<code>__getitem__</code>方法</strong>(这些双下划线方法会在其他章节中全面解释)，那么它就是一个可迭代对象。<strong>简单说，可迭代对象就是能提供迭代器的任意对象</strong>。那迭代器又是什么呢？</p>
<h1 id="迭代器-Iterator"><a href="#迭代器-Iterator" class="headerlink" title="迭代器(Iterator)"></a>迭代器(Iterator)</h1><p><strong>任意对象，只要定义了<code>next</code>(Python2) 或者<code>__next__</code>方法，它就是一个迭代器</strong>。就这么简单。现在我们来理解迭代(iteration)</p>
<h1 id="迭代-Iteration"><a href="#迭代-Iteration" class="headerlink" title="迭代(Iteration)"></a>迭代(Iteration)</h1><p>用简单的话讲，它就是从某个地方（比如一个列表）取出一个元素的过程。当我们使用一个循环来遍历某个东西时，这个过程本身就叫迭代。现在既然我们有了这些术语的基本理解，那我们开始理解生成器吧。</p>
<p><img src="/2018/06/28/python编程进阶/python编程进阶（3）：生成器/01.png" alt="关系图"></p>
<p>关系结论：</p>
<ul>
<li>可迭代对象包含迭代器</li>
<li>如果一个对象拥有_<em>iter_</em>方法，其是可迭代对象；如果一个对象拥有next方法，其是迭代器。</li>
<li>定义可迭代对象，必须实现_iter<strong>  方法；定义迭代器，必须实现 _iter</strong>和next方法。</li>
</ul>
<h1 id="生成器-Generators"><a href="#生成器-Generators" class="headerlink" title="生成器(Generators)"></a>生成器(Generators)</h1><p><strong>生成器也是一种迭代器，但是你只能对其迭代一次</strong>。这是因为它们并没有把所有的值存在内存中，而是在运行时生成值。<strong>你通过遍历来使用它们，要么用一个“for”循环，要么将它们传递给任意可以进行迭代的函数和结构</strong>。大多数时候生成器是以函数来实现的。然而，它们并不返回一个值，而是<code>yield</code>(暂且译作“生出”)一个值。这里有个生成器函数的简单例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generator_function</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        <span class="keyword">yield</span> i</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> generator_function():</span><br><span class="line">    print(item)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output: 0</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 4</span></span><br><span class="line"><span class="comment"># 5</span></span><br><span class="line"><span class="comment"># 6</span></span><br><span class="line"><span class="comment"># 7</span></span><br><span class="line"><span class="comment"># 8</span></span><br><span class="line"><span class="comment"># 9</span></span><br></pre></td></tr></table></figure>
<p>这个案例并不是非常实用。<strong>生成器最佳应用场景是：你不想同一时间将所有计算出来的大量结果集分配到内存当中，特别是结果集里还包含循环。</strong></p>
<blockquote>
<p>译者注：这样做会消耗大量资源</p>
</blockquote>
<p>许多Python 2里的标准库函数都会返回列表，而Python 3都修改成了返回生成器，因为生成器占用更少的资源。</p>
<p>下面是一个计算斐波那契数列的生成器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># generator version</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibon</span><span class="params">(n)</span>:</span></span><br><span class="line">    a = b = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">yield</span> a</span><br><span class="line">        a, b = b, a + b</span><br></pre></td></tr></table></figure>
<p>函数使用方法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> fibon(<span class="number">1000000</span>):</span><br><span class="line">    print(x)</span><br></pre></td></tr></table></figure>
<p>用这种方式，我们可以不用担心它会使用大量资源。然而，之前如果我们这样来实现的话：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibon</span><span class="params">(n)</span>:</span></span><br><span class="line">    a = b = <span class="number">1</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        result.append(a)</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p>这也许会在计算很大的输入参数时，用尽所有的资源。我们已经讨论过生成器使用一次迭代，但我们并没有测试过。在测试前你需要再知道一个Python内置函数：<code>next()</code>。它允许我们获取一个序列的下一个元素。那我们来验证下我们的理解：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generator_function</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        <span class="keyword">yield</span> i</span><br><span class="line"></span><br><span class="line">gen = generator_function()</span><br><span class="line">print(next(gen))</span><br><span class="line"><span class="comment"># Output: 0</span></span><br><span class="line">print(next(gen))</span><br><span class="line"><span class="comment"># Output: 1</span></span><br><span class="line">print(next(gen))</span><br><span class="line"><span class="comment"># Output: 2</span></span><br><span class="line">print(next(gen))</span><br><span class="line"><span class="comment"># Output: Traceback (most recent call last):</span></span><br><span class="line"><span class="comment">#            File "&lt;stdin&gt;", line 1, in &lt;module&gt;</span></span><br><span class="line"><span class="comment">#         StopIteration</span></span><br></pre></td></tr></table></figure>
<p>我们可以看到，在<code>yield</code>掉所有的值后，<code>next()</code>触发了一个<code>StopIteration</code>的异常。基本上这个异常告诉我们，所有的值都已经被<code>yield</code>完了。你也许会奇怪，为什么我们在使用<code>for</code>循环时没有这个异常呢？啊哈，答案很简单。<code>for</code>循环会自动捕捉到这个异常并停止调用<code>next()</code>。你知不知道Python中一些内置数据类型也支持迭代哦？我们这就去看看：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_string = <span class="string">"Yasoob"</span></span><br><span class="line">next(my_string)</span><br><span class="line"><span class="comment"># Output: Traceback (most recent call last):</span></span><br><span class="line"><span class="comment">#      File "&lt;stdin&gt;", line 1, in &lt;module&gt;</span></span><br><span class="line"><span class="comment">#    TypeError: str object is not an iterator</span></span><br></pre></td></tr></table></figure>
<p>好吧，这不是我们预期的。这个异常说那个<code>str</code>对象不是一个迭代器。对，就是这样！<strong>它是一个可迭代对象，而不是一个迭代器。这意味着它支持迭代，但我们不能直接对其进行迭代操作。那我们怎样才能对它实施迭代呢？是时候学习下另一个内置函数，<code>iter</code>。它将根据一个可迭代对象返回一个迭代器对象</strong>。这里是我们如何使用它：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_string = <span class="string">"Yasoob"</span></span><br><span class="line">my_iter = iter(my_string)</span><br><span class="line">next(my_iter)</span><br><span class="line"><span class="comment"># Output: 'Y'</span></span><br></pre></td></tr></table></figure>
<p>现在好多啦。我肯定你已经爱上了学习生成器。一定要记住，想要完全掌握这个概念，你只有使用它。确保你按照这个模式，并在生成器对你有意义的任何时候都使用它。你绝对不会失望的！</p>
]]></content>
      <categories>
        <category>python编程进阶</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python编程进阶（2）：调试Debugging</title>
    <url>/2018/06/27/python%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6/python%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6%EF%BC%882%EF%BC%89%EF%BC%9A%E8%B0%83%E8%AF%95Debugging/</url>
    <content><![CDATA[<h1 id="调试（Debugging）"><a href="#调试（Debugging）" class="headerlink" title="调试（Debugging）"></a>调试（Debugging）</h1><p>利用好调试，能大大提高你捕捉代码Bug的。大部分新人忽略了Python debugger(<code>pdb</code>)的重要性。 在这个章节我只会告诉你一些重要的命令，你可以从官方文档中学习到更多。</p>
<blockquote>
<p>参考：<a href="https://docs.python.org/2/library/pdb.html" target="_blank" rel="noopener">https://docs.python.org/2/library/pdb.html</a> Or <a href="https://docs.python.org/3/library/pdb.html" target="_blank" rel="noopener">https://docs.python.org/3/library/pdb.html</a></p>
</blockquote>
<h3 id="从命令行运行"><a href="#从命令行运行" class="headerlink" title="从命令行运行"></a>从命令行运行</h3><p>你可以在命令行使用Python debugger运行一个脚本， 举个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ python -m pdb my_script.py</span><br></pre></td></tr></table></figure>
<p>这会触发debugger在脚本第一行指令处停止执行。这在脚本很短时会很有帮助。你可以通过(Pdb)模式接着查看变量信息，并且逐行调试。</p>
<h3 id="从脚本内部运行"><a href="#从脚本内部运行" class="headerlink" title="从脚本内部运行"></a>从脚本内部运行</h3><p>同时，你也可以在脚本内部设置断点，这样就可以在某些特定点查看变量信息和各种执行时信息了。这里将使用<code>pdb.set_trace()</code>方法来实现。举个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pdb</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_bread</span><span class="params">()</span>:</span></span><br><span class="line">    pdb.set_trace()</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"I don't have time"</span></span><br><span class="line"></span><br><span class="line">print(make_bread())</span><br></pre></td></tr></table></figure>
<p>试下保存上面的脚本后运行之。你会在运行时马上进入debugger模式。现在是时候了解下debugger模式下的一些命令了。</p>
<h5 id="命令列表："><a href="#命令列表：" class="headerlink" title="命令列表："></a>命令列表：</h5><ul>
<li><code>c</code>: 继续执行</li>
<li><code>w</code>: 显示当前正在执行的代码行的上下文信息</li>
<li><code>a</code>: 打印当前函数的参数列表</li>
<li><code>s</code>: 执行当前代码行，并停在第一个能停的地方（相当于单步进入）</li>
<li><code>n</code>: 继续执行到当前函数的下一行，或者当前行直接返回（单步跳过）</li>
</ul>
<p>单步跳过（<code>n</code>ext）和单步进入（<code>s</code>tep）的区别在于， 单步进入会进入当前行调用的函数内部并停在里面， 而单步跳过会（几乎）全速执行完当前行调用的函数，并停在当前函数的下一行。</p>
<p>pdb真的是一个很方便的功能，上面仅列举少量用法，更多的命令强烈推荐你去看官方文档。</p>
]]></content>
      <categories>
        <category>python编程进阶</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>debug</tag>
      </tags>
  </entry>
  <entry>
    <title>python编程进阶（1）：*args和**kwargs</title>
    <url>/2018/06/27/python%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6/python%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6%EF%BC%881%EF%BC%89%EF%BC%9A-args%E5%92%8C-kwargs/</url>
    <content><![CDATA[<h1 id="args和-kwargs"><a href="#args和-kwargs" class="headerlink" title="args和*kwargs"></a><em>args和*</em>kwargs</h1><p>首先, 其实并不是必须写成<code>*args</code> 和<code>**kwargs</code>。 只有变量前面的 <code>*</code>(星号)才是必须的. 你也可以写成<code>*var</code> 和<code>**vars</code>. 而写成<code>*args</code> 和<code>**kwargs</code>只是一个通俗的命名约定。</p>
<h2 id="args的用法"><a href="#args的用法" class="headerlink" title="*args的用法"></a>*args的用法</h2><p><code>*args</code> 和 <code>**kwargs</code> 主要用于函数定义。 你可以将<strong>不定数量</strong>的参数传递给一个函数。这里的不定的意思是：<strong>预先并不知道</strong>, 函数使用者会传递多少个参数给你, 所以在这个场景下使用这两个关键字。 <code>*args</code> 是用来发送一个<strong>非键值对的可变数量的参数列表</strong>给一个函数</p>
<p>看下面这个例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_var_args</span><span class="params">(f_arg, *argv)</span>:</span></span><br><span class="line">    print(<span class="string">"first normal arg:"</span>, f_arg)</span><br><span class="line">    <span class="keyword">for</span> arg <span class="keyword">in</span> argv:</span><br><span class="line">        print(<span class="string">"another arg through *argv:"</span>, arg)</span><br><span class="line"></span><br><span class="line">test_var_args(<span class="string">'yasoob'</span>, <span class="string">'python'</span>, <span class="string">'eggs'</span>, <span class="string">'test'</span>)</span><br></pre></td></tr></table></figure>
<p>产生输出:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">first normal arg: yasoob</span><br><span class="line">another arg through *argv: python</span><br><span class="line">another arg through *argv: eggs</span><br><span class="line">another arg through *argv: test</span><br></pre></td></tr></table></figure>
<h2 id="kwargs的用法"><a href="#kwargs的用法" class="headerlink" title="**kwargs的用法"></a>**kwargs的用法</h2><p><code>**kwargs</code> 允许你将不定长度的<strong>键值对</strong>, 作为参数传递给一个函数。 如果你想要在一个函数里处理<strong>带名字的参数</strong>, 你应该使用<code>**kwargs</code></p>
<p>看下面的例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet_me</span><span class="params">(**kwargs)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> key, value <span class="keyword">in</span> kwargs.items():</span><br><span class="line">        print(<span class="string">"&#123;0&#125; == &#123;1&#125;"</span>.format(key, value))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>greet_me(name=<span class="string">"yasoob"</span>)</span><br><span class="line">name == yasoo</span><br></pre></td></tr></table></figure>
<h2 id="使用args和-kwargs来调用函数"><a href="#使用args和-kwargs来调用函数" class="headerlink" title="使用args和*kwargs来调用函数"></a>使用<em>args和*</em>kwargs来调用函数</h2><p>假设，你有这样一个小函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_args_kwargs</span><span class="params">(arg1, arg2, arg3)</span>:</span></span><br><span class="line">    print(<span class="string">"arg1:"</span>, arg1)</span><br><span class="line">    print(<span class="string">"arg2:"</span>, arg2)</span><br><span class="line">    print(<span class="string">"arg3:"</span>, arg3)</span><br></pre></td></tr></table></figure>
<p>你可以使用<code>*args</code>或<code>**kwargs</code>来给这个小函数传递参数。 下面是怎样做：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 首先使用 *args</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>args = (<span class="string">"two"</span>, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test_args_kwargs(*args)</span><br><span class="line">arg1: two</span><br><span class="line">arg2: <span class="number">3</span></span><br><span class="line">arg3: <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在使用 **kwargs:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>kwargs = &#123;<span class="string">"arg3"</span>: <span class="number">3</span>, <span class="string">"arg2"</span>: <span class="string">"two"</span>, <span class="string">"arg1"</span>: <span class="number">5</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test_args_kwargs(**kwargs)</span><br><span class="line">arg1: <span class="number">5</span></span><br><span class="line">arg2: two</span><br><span class="line">arg3: <span class="number">3</span></span><br></pre></td></tr></table></figure>
<h3 id="标准参数与args、-kwargs在使用时的顺序"><a href="#标准参数与args、-kwargs在使用时的顺序" class="headerlink" title="标准参数与args、*kwargs在使用时的顺序:"></a>标准参数与<em>args、*</em>kwargs在使用时的顺序:</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">some_func(fargs, *args, **kwargs)</span><br></pre></td></tr></table></figure>
<h2 id="什么时候使用它们？"><a href="#什么时候使用它们？" class="headerlink" title="什么时候使用它们？"></a>什么时候使用它们？</h2><p>这还真的要看你的需求而定。</p>
<p>最常见的用例是在写函数装饰器的时候（会在另一章里讨论）。</p>
<p>此外它也可以用来做猴子补丁(monkey patching)。猴子补丁的意思是在程序运行时(runtime)修改某些代码。 打个比方，你有一个类，里面有个叫<code>get_info</code>的函数会调用一个API并返回相应的数据。如果我们想测试它，可以把API调用替换成一些测试数据。例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> someclass</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_info</span><span class="params">(self, *args)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Test data"</span></span><br><span class="line"></span><br><span class="line">someclass.get_info = get_info</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python编程进阶</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>The Linux Command Line学习笔记（四）</title>
    <url>/2018/06/16/Linux/The%20Linux%20Command%20Line%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    <content><![CDATA[<h2 id="第二十一章：文本处理"><a href="#第二十一章：文本处理" class="headerlink" title="第二十一章：文本处理"></a>第二十一章：文本处理</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这一章会重新拜访一些老朋友，并且会给我们介绍一些新朋友：</span><br><span class="line">cat    –    连接文件并且打印到标准输出</span><br><span class="line">sort    –    给文本行排序</span><br><span class="line">uniq    –    报告或者省略重复行</span><br><span class="line">cut    –    从每行中删除文本区域</span><br><span class="line">paste    –    合并文件文本行</span><br><span class="line">join    –    基于某个共享字段来联合两个文件的文本行</span><br><span class="line">comm    –    逐行比较两个有序的文件</span><br><span class="line">diff    –    逐行比较文件</span><br><span class="line">tr    –    翻译或删除字符</span><br><span class="line">sed    –    用于筛选和转换文本的流编辑器</span><br><span class="line"></span><br><span class="line">cat</span><br><span class="line">这个    cat    程序具有许多有趣的选项。其中许多选项用来帮助更好的可视化文本内容。一个例子是-A    选项，    其用来在文本中显示所有非打印字符。</span><br><span class="line"></span><br><span class="line">[me@linuxbox    ~]$    cat    -A    foo.txt</span><br><span class="line">^IThe    quick    brown    fox    jumped    over    the    lazy    dog.                            $</span><br><span class="line">[me@linuxbox    ~]$</span><br><span class="line">在输出结果中我们看到，这个    tab    字符在我们的文本中由^I    字符来表示，我们也看到一个$字符出现在文本行真正的结尾处，    表明我们的文本包含末尾的空格。</span><br><span class="line"></span><br><span class="line">cat    程序也包含用来修改文本的选项。最著名的两个选项是-n，其给文本行添加行号和-s，    禁止输出多个空白行。</span><br><span class="line"></span><br><span class="line">[me@linuxbox    ~]$    cat    &gt;    foo.txt</span><br><span class="line">The    quick    brown    fox</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">jumped    over    the    lazy    dog.</span><br><span class="line">[me@linuxbox    ~]$    cat    -ns    foo.txt   #增加行号，删除多余的空白行</span><br><span class="line">1            The    quick    brown    fox</span><br><span class="line">2</span><br><span class="line">3            jumped    over    the    lazy    dog.</span><br><span class="line">[me@linuxbox    ~]$</span><br><span class="line"></span><br><span class="line">sort</span><br><span class="line">我们能够演示如何用    sort    程序来处理标准输入：</span><br><span class="line">[me@linuxbox    ~]$    sort    &gt;    foo.txt</span><br><span class="line"></span><br><span class="line">c</span><br><span class="line">b</span><br><span class="line">a</span><br><span class="line">[me@linuxbox    ~]$    cat    foo.txt</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line"></span><br><span class="line">表21-1:    常见的    sort    程序选项</span><br><span class="line">|    选项    |    长选项    |    描述    |</span><br><span class="line">|-------|-------|-------|</span><br><span class="line">|    -b    |    --ignore-leading-blanks    |    默认情况下，从每行的第一个字符开始。这个选项从第一个非空白字符开始排序。    |</span><br><span class="line">|    -f    |    --ignore-case    |    让排序不区分大小写。    |</span><br><span class="line">|    -n    |    --numeric-sort    |    基于字符串的长度来排序</span><br><span class="line">|    -r    |    --reverse    |    按相反顺序排序。结果按照降序排列，而不是升序。    |</span><br><span class="line">|    -k    |    --key=field1[,field2]    |    对从    field1到    field2之间的字符排序，而不是整个文本行</span><br><span class="line">|    -o    |    --output=file    |    把排好序的输出结果发送到文件，而不是标准输出。    |</span><br><span class="line">|    -t    |    --field-separator=char    |    定义域分隔字符。</span><br><span class="line"></span><br><span class="line">我们通过对    du    命令的输出结果排序来说明这个选项，du    命令可以    确定最大的磁盘空间用户，通常，这个du  命令列出的输出结果按照路径名来序：</span><br><span class="line"></span><br><span class="line">[me@linuxbox    ~]$    du    -s    /usr/share/\*    |    head</span><br><span class="line">252                    /usr/share/aclocal</span><br><span class="line">96                     /usr/share/acpi-support</span><br><span class="line">8                      /usr/share/adduser</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">[me@linuxbox    ~]$    du    -s    /usr/share/*    |    sort    -nr    |    head    #根据长度反序排序</span><br><span class="line">509940                                    /usr/share/locale-langpack</span><br><span class="line">242660                                    /usr/share/doc</span><br><span class="line">197560                                    /usr/share/fonts</span><br><span class="line">这种排序起作用是    因为数值出现在每行的开头。但是如果我们想要基于文件行中的某个数值排序</span><br><span class="line">忽略    ls    程序能按照文件大小对输出结果进行排序，我们也能够使用    sort    程序来完成此任务：</span><br><span class="line">[me@linuxbox    ~]$    ls    -l    /usr/bin    |    sort    -nr    -k    5    |    head   #空格和制表符作为分界符，所以是以第五个字段，文件大小来排序</span><br><span class="line">-rwxr-xr-x    1    root            root            8234216        2008-04-0717:42    inkscape</span><br><span class="line">-rwxr-xr-x    1    root            root            8222692        2008-04-07    17:42    inkview</span><br><span class="line">...</span><br><span class="line">在上面的例子中，我们指定    n    和    r    选项来执行相反的数值排序，并且指定    -k    5，让    sort    程序使用第五字段作为排序的关键值。</span><br><span class="line"></span><br><span class="line">依赖多个关键值排序，例如    文件中的每一行都有三个字段：发行版的名称，版本号，和    MM/DD/YYYY    格式的发行日期：</span><br><span class="line"></span><br><span class="line">SUSE                                10.2            12/07/2006</span><br><span class="line">Fedora                              10              11/25/2008</span><br><span class="line">SUSE                                11.04           06/19/2008</span><br><span class="line">Ubuntu                              8.04            04/24/2008</span><br><span class="line">...</span><br><span class="line">为了解决这个问题，我们必须依赖多个键值来排序。sort    程序允许多个    -k    选项的实例，所以可以指定多个排序关键值。</span><br><span class="line"></span><br><span class="line">[me@linuxbox    ~]$    sort    --key=1,1    --key=2n    distros.txt</span><br><span class="line">Fedora                                    5                    03/20/2006</span><br><span class="line">Fedora                                    6                    10/24/2006</span><br><span class="line">Fedora                                    7                    05/31/2007</span><br><span class="line">...</span><br><span class="line">在第一个    key    选项的实例中，    我们指定了一个字段区域。因为我们只想对第一个字段排序，我们指定了    1,1，    意味着“始于并且结束于第一个字段。”在第二个实例中，我们指定了    2n，意味着第二个字段是排序的键值，选项字母和sort    程序的全局选项一样：b（忽略开头的空格），n（数值序），r（逆向排序），等等。</span><br><span class="line">我们列表中第三个字段包含的日期格式不利于排序。在计算机中，日期通常设置为    YYYY-MM-DD    格式，这样使按时间顺序排序变得容易，但是我们的日期为美国格式    MM/DD/YYYY。那么我们怎样能按照    时间顺序来排列这个列表呢？幸运地是，sort    程序提供了一种方式。这个    key    选项允许在字段中指定偏移量，所以我们能在字段中    定义键值。</span><br><span class="line">[me@linuxbox    ~]$    sort    -k    3.7nbr    -k    3.1nbr    -k    3.4nbr    distros.txt</span><br><span class="line">Fedora                                    10                11/25/2008</span><br><span class="line">Ubuntu                                    8.10            10/30/2008</span><br><span class="line">SUSE                                        11.0            06/19/2008</span><br><span class="line">...</span><br><span class="line">通过指定    -k    3.7，我们指示    sort    程序使用一个排序键值，其始于第三个字段中的第七个字符，同样地，我们指定    -k    3.1和    -k    3.4来分离日期中的月和日。    我们也添加了    n    和    r    选项来实现一个逆向的数值排序。这个    b    选项用来删除日期字段中开头的空格（    行与行之间的空格数迥异，因此会影响    sort    程序的输出结果）。</span><br><span class="line"></span><br><span class="line">一些文件不会使用    tabs    和空格做为字段界定符；例如，这个    /etc/passwd    文件，这个文件的字段之间通过冒号分隔开，所以我们怎样使用一个    key    字段来排序这个文件？sort    程序提供了一个    -t    选项来自定义分隔符。</span><br><span class="line">[me@linuxbox    ~]$    sort    -t    &apos;:&apos;    -k    7    /etc/passwd    |    head     # 以 ： 为分隔符</span><br><span class="line"></span><br><span class="line">uniq</span><br><span class="line">与    sort    程序相比，这个    uniq    程序是个轻量级程序，uniq    会删除任意重复行，并且把结果发送到标准输出。    它常常和    sort    程序一</span><br><span class="line">块使用，来清理重复的输出。</span><br><span class="line">让我们创建一个文本文件，来实验一下：</span><br><span class="line"></span><br><span class="line">[me@linuxbox    ~]$    cat    &gt;    foo.txt</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">住输入    Ctrl-d    来终止标准输入。现在，如果我们对文本文件执行    uniq    命令：</span><br><span class="line"></span><br><span class="line">[me@linuxbox    ~]$    uniq    foo.txt</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">输出结果与原始文件没有差异；重复行没有被删除。实际上，uniq    程序能完成任务，其输入必须是排好序的数据，</span><br><span class="line"></span><br><span class="line">[me@linuxbox    ~]$    sort    foo.txt    |    uniq</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">这是因为    uniq    只会删除相邻的重复行。uniq    程序有几个选项。这里是一些常用选项：</span><br><span class="line">表21-2:    常用的    uniq    选项</span><br><span class="line">|    选项    |    说明    |</span><br><span class="line">|-------|-----|</span><br><span class="line">|    -c    |    输出所有的重复行，并且每行开头显示重复的次数。    |</span><br><span class="line">|    -d    |    只输出重复行，而不是特有的文本行。    |</span><br><span class="line">|    -i    |    在比较文本行的时候忽略大小写。    |</span><br><span class="line">|    -u    |    只是输出独有的文本行。这是默认的。    |</span><br><span class="line"></span><br><span class="line">[me@linuxbox    ~]$    sort    foo.txt    |    uniq    -c</span><br><span class="line">                                2    a</span><br><span class="line">                                2    b</span><br><span class="line">                                2    c</span><br><span class="line"></span><br><span class="line">切片和切块</span><br><span class="line">cut</span><br><span class="line">这个    cut    程序被用来从文本行中抽取文本，并把其输出到标准输出。从文本行中指定要抽取的文本有些麻烦，使用以下选项：</span><br><span class="line">表21-3:    cut    程序选择项</span><br><span class="line">|    选项    |    说明    |</span><br><span class="line">|-----|------|</span><br><span class="line">|    -c    char_list    |    从文本行中抽取由    char_list    定义的文本，也就是字符。</span><br><span class="line">|    -f    field_list    |    从文本行中抽取一个或多个由    field_list    定义的字段</span><br><span class="line">|    -d    delim_char    |    当指定-f    选项之后，使用    delim_char    做为字段分隔符</span><br><span class="line">|    --complement    |    抽取整个文本行，除了那些由-c    和／或-f    选项指定的文本。    |</span><br><span class="line">正如我们所看到的，cut    程序抽取文本的方式相当不灵活。cut    命令最好用来从其它程序产生的文件中    抽取文本，而不是从人们直接输入的文本中抽取。</span><br><span class="line">如果我们使用带有    -A    选项的    cat    命令，我们能查看是否这个文件符号由    tab    字符分离字段的要求。</span><br><span class="line">[me@linuxbox    ~]$    cat    -A    distros.txt</span><br><span class="line">SUSE^I10.2^I12/07/2006$         #看起来不错。字段之间仅仅是单个    tab    字符，没有嵌入空格</span><br><span class="line">Fedora^I10^I11/25/2008$</span><br><span class="line">SUSE^I11.0^I06/19/2008$</span><br><span class="line">...</span><br><span class="line">[me@linuxbox    ~]$    cut    -f    3    distros.txt   #第三个字段</span><br><span class="line">12/07/2006</span><br><span class="line">11/25/2008</span><br><span class="line">06/19/2008</span><br><span class="line">04/24/2008</span><br><span class="line">...</span><br><span class="line">因为我们的    distros    文件是由    tab    分隔开的，最好用    cut    来抽取字段而不是字符。这是因为一个由    tab    分离的文件，    每行不太可能包含相同的字符数，这就使计算每行中字符的位置变得困难或者是不可能。然而，    我们已经抽取了一个字段，幸运地是其包含地日期长度相同，所以通过从每行中抽取年份，我们能展示怎样    来抽取字符：</span><br><span class="line">[me@linuxbox    ~]$    cut    -f    3    distros.txt    |    cut    -c    7-10</span><br><span class="line">2006</span><br><span class="line">2008</span><br><span class="line">2007</span><br><span class="line">...</span><br><span class="line">通过对我们的列表再次运行    cut    命令，我们能够抽取从位置7到10的字符，其对应于日期字段的年份.</span><br><span class="line">当操作字段的时候，有可能指定不同的字段分隔符，而不是    tab    字符。这里我们将会从/etc/passwd    文件中    抽取第一个字段：</span><br><span class="line">[me@linuxbox    ~]$    cut    -d    &apos;:&apos;    -f    1    /etc/passwd    |    head   #使用-d    选项，我们能够指定冒号做为字段分隔符。</span><br><span class="line"></span><br><span class="line">paste</span><br><span class="line">这个    paste    命令的功能正好与    cut    相反。它会添加一个或多个文本列到文件中，而不是从文件中抽取文本列</span><br><span class="line">[me@linuxbox    ~]$    paste    distros-dates.txt    distros-versions.txt     #第二个文件粘贴在第一个文件后</span><br><span class="line"></span><br><span class="line">join</span><br><span class="line">一个    join操作通常与关系型数据库有关联，在关系型数据库中来自多个享有共同关键域的表格的    数据结合起来，得到一个期望的结果。这个    join    程序执行相同的操作</span><br><span class="line">[me@linuxbox    ~]$    join    distros-key-names.txt    distros-key-vernums.txt    |    head</span><br><span class="line">这两个文件的日期是共同列，可以自动连接。同样，第二个文件链接到第一个文件后面</span><br><span class="line"></span><br><span class="line">比较文本</span><br><span class="line">comm</span><br><span class="line">这个    comm    程序会比较两个文本文件，并且会显示每个文件特有的文本行和共有的文本行。通过使用    cat    命令，我们将会创建两个内容几乎相同的文本文件：</span><br><span class="line"></span><br><span class="line">[me@linuxbox    ~]$    cat    &gt;    file1.txt</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">[me@linuxbox    ~]$    cat    &gt;    file2.txt</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">下一步，我们将使用    comm    命令来比较这两个文件：</span><br><span class="line"></span><br><span class="line">[me@linuxbox    ~]$    comm    file1.txt    file2.txt</span><br><span class="line">a</span><br><span class="line">                                b</span><br><span class="line">                                c</span><br><span class="line">                                d</span><br><span class="line">                e</span><br><span class="line">正如我们所见到的，comm    命令产生了三列输出。第一列包含第一个文件独有的文本行；第二列，    文本行是第二列独有的；第三列包含两个文件共有的文本行。comm    支持    -n    形式的选项，这里    n    代表    1，2或    3。这些选项使用的时候，指定了要隐藏的列。例如，如果我们只想输出两个文件共享的文本行，    我们将隐藏第一列和第二列的输出结果：</span><br><span class="line"></span><br><span class="line">[me@linuxbox    ~]$    comm    -12    file1.txt    file2.txt</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line"></span><br><span class="line">diff</span><br><span class="line">类似于    comm    程序，diff    程序被用来监测文件之间的差异。软件开发员经常使用    diff    程序来检查不同程序源码    版本之间的更改，diff    能够递归地检查源码目录，经常称之为源码树。diff    程序的一个常见用例是    创建    diff    文件或者补丁，它会被其它程序使用，例如    patch    程序（我们一会儿讨论），来把文件    从一个版本转换为另一个版本。</span><br><span class="line">如果我们使用    diff    程序，来查看我们之前的文件实例：</span><br><span class="line"></span><br><span class="line">[me@linuxbox    ~]$    diff    file1.txt    file2.txt</span><br><span class="line">1d0</span><br><span class="line">&lt;    a</span><br><span class="line">4a4</span><br><span class="line">&gt;    e</span><br><span class="line">在默认格式中（不常用），    每组的更改之前都是一个更改命令，其形式为    range    operation    range    ，    用来描述要求更改的位置和类型，从而把第一个文件转变为第二个文件：</span><br><span class="line">表21-4:    diff    更改命令</span><br><span class="line">|    改变    |    说明    |</span><br><span class="line">|-----|--------|</span><br><span class="line">|    r1ar2    |    把第二个文件中位置    r2    处的文件行添加到第一个文件中的    r1    处。    |</span><br><span class="line">|    r1cr2    |    用第二个文件中位置    r2    处的文本行更改（替代）位置    r1    处的文本行。    |</span><br><span class="line">|    r1dr2    |    删除第一个文件中位置    r1    处的文本行，这些文本行将会出现在第二个文件中位置    r2    处。    |</span><br><span class="line"></span><br><span class="line">常用的是上下文模式和统一模式（记住这个就行了）</span><br><span class="line">当使用上下文模式（带上    -c    选项），我们将看到这些：</span><br><span class="line"></span><br><span class="line">[me@linuxbox    ~]$    diff    -c    file1.txt    file2.txt</span><br><span class="line">***    file1.txt                2008-12-23    06:40:13.000000000    -0500</span><br><span class="line">---    file2.txt            2008-12-23    06:40:34.000000000    -0500</span><br><span class="line">***************</span><br><span class="line">***    1,4    ****</span><br><span class="line">-    a</span><br><span class="line">        b</span><br><span class="line">        c</span><br><span class="line">        d</span><br><span class="line">---    1,4    ----</span><br><span class="line">        b</span><br><span class="line">        c</span><br><span class="line">        d</span><br><span class="line">        +    e</span><br><span class="line">表21-5:    diff    上下文模式更改指示符</span><br><span class="line">|    指示符    |    意思    |</span><br><span class="line">|-------|---------|</span><br><span class="line">|    blank    |    上下文显示行。它并不表示两个文件之间的差异。    |</span><br><span class="line">|    -    |    删除行。这一行将会出现在第一个文件中，而不是第二个文件内。    |</span><br><span class="line">|    +    |    添加行。这一行将会出现在第二个文件内，而不是第一个文件中。    |</span><br><span class="line">|    !    |    更改行。将会显示某个文本行的两个版本，每个版本会出现在更改组的各自部分。    |</span><br><span class="line"></span><br><span class="line">这个统一模式相似于上下文模式，但是更加简洁。通过    -u    选项来指定它：</span><br><span class="line"></span><br><span class="line">[me@linuxbox    ~]$    diff    -u    file1.txt    file2.txt</span><br><span class="line">---    file1.txt    2008-12-23    06:40:13.000000000    -0500</span><br><span class="line">+++    file2.txt    2008-12-23    06:40:34.000000000    -0500</span><br><span class="line">@@    -1,4    +1,4    @@</span><br><span class="line">-a</span><br><span class="line">    b</span><br><span class="line">    c</span><br><span class="line">    d</span><br><span class="line">+e</span><br><span class="line">上下文模式和统一模式之间最显著的差异就是重复上下文的消除</span><br><span class="line">表21-6:    diff    统一模式更改指示符</span><br><span class="line">|    字符    |    意思    |</span><br><span class="line">|-----|-------|</span><br><span class="line">|    空格    |    两个文件都包含这一行。    |</span><br><span class="line">|    -    |    在第一个文件中删除这一行。    |</span><br><span class="line">|    +    |    添加这一行到第一个文件中。    |</span><br><span class="line"></span><br><span class="line">patch</span><br><span class="line">Linux    内核是由一个    大型的，组织松散的贡献者团队开发而成，这些贡献者会提交固定的少量更改到源码包中。    这个    Linux    内核由几百万行代码组成，虽然每个贡献者每次所做的修改相当少。对于一个贡献者    来说，每做一个修改就给每个开发者发送整个的内核源码树，这是没有任何意义的。相反，    提交一个    diff    文件。一个    diff    文件包含先前的内核版本与带有贡献者修改的新版本之间的差异。    然后一个接受者使用    patch    程序，把这些更改应用到他自己的源码树中。</span><br><span class="line"></span><br><span class="line">运行时编辑</span><br><span class="line">tr</span><br><span class="line">这个    tr    程序被用来更改字符。我们可以把它看作是一种基于字符的查找和替换操作。我们可以通过    tr    命令来执行这样的转换，如下所示：</span><br><span class="line">[me@linuxbox    ~]$    echo    &quot;lowercase    letters&quot;    |    tr    a-z    A-Z</span><br><span class="line">LOWERCASE    LETTERS</span><br><span class="line">tr    命令接受两个参数：要被转换的字符集以及    相对应的转换后的字符集。</span><br><span class="line">tr    也可以完成另一个技巧。使用-s    选项，tr    命令能“挤压”（删除）重复的字符实例：</span><br><span class="line">[me@linuxbox    ~]$    echo    &quot;aaabbbccc&quot;    |    tr    -s    ab</span><br><span class="line">abccc</span><br><span class="line">这里我们有一个包含重复字符的字符串。通过给    tr    命令指定字符集“ab”，我们能够消除字符集中    字母的重复实例，然而会留下不属于字符集的字符（“c”）无更改。注意重复的字符必须是相邻的，    如果它们不相邻，那么挤压会没有效果，例如：</span><br><span class="line">[me@linuxbox    ~]$    echo    &quot;abcabcabc&quot;    |    tr    -s    ab</span><br><span class="line">abcabcabc</span><br><span class="line"></span><br><span class="line">sed</span><br><span class="line">名字    sed    是    stream    editor（流编辑器）的简称。它对文本流进行编辑，要不是一系列指定的文件，    要不就是标准输入。这里有一个非常简单的    sed    实例：</span><br><span class="line">[me@linuxbox    ~]$    echo    &quot;front&quot;    |    sed    &apos;s/front/back/&apos;</span><br><span class="line">back</span><br><span class="line">在这个例子中，我们使用    echo    命令产生了一个单词的文本流，然后把它管道给    sed    命令。sed，依次，对流文本执行指令    s/front/back/，随后输出“back”。这个替换命令由字母    s    来代表，其后跟着查找    和替代字符串，斜杠字符做为分隔符。分隔符的选择是随意的。按照惯例，经常使用斜杠字符。</span><br><span class="line"></span><br><span class="line">sed    中的大多数命令之前都会带有一个地址，其指定了输入流中要被编辑的文本行。如果省略了地址，    然后会对输入流的每一行执行编辑命令。最简单的地址形式是一个行号。我们能够添加一个地址    到我们例子中：</span><br><span class="line">[me@linuxbox    ~]$    echo    &quot;front&quot;    |    sed    &apos;1s/front/back/&apos;</span><br><span class="line">back</span><br><span class="line">给我们的命令添加地址    1，就导致只对仅有一行文本的输入流的第一行执行替换操作。如果我们指定另一个数字：</span><br><span class="line">[me@linuxbox    ~]$    echo    &quot;front&quot;    |    sed    &apos;2s/front/back/&apos;</span><br><span class="line">front</span><br><span class="line">我们看到没有执行这个编辑命令，因为我们的输入流没有第二行。地址可以用许多方式来表达。这里是    最</span><br><span class="line">常用的：</span><br><span class="line">表21-7:    sed    地址表示法</span><br><span class="line">|    地址    |    说明    |</span><br><span class="line">|-----|-------|</span><br><span class="line">|    n    |    行号，n    是一个正整数。    |</span><br><span class="line">|    $    |    最后一行。    |</span><br><span class="line">|    /regexp/    |    所有匹配一个    POSIX    基本正则表达式的文本行</span><br><span class="line">|    addr1,addr2    |    从    addr1    到    addr2    范围内的文本行，包含地址    addr2    在内。地址可能是上述任意    单独</span><br><span class="line">的地址形式。    |</span><br><span class="line">|    first~step    |    匹配由数字first代表的文本行，然后随后的每个在    step    间隔处的文本行。例如  5~5    则指第五行和之后每五行位置的文本。行。    |</span><br><span class="line">|    addr1,+n    |    匹配地址    addr1    和随后的    n    个文本行。    |</span><br><span class="line">|    addr!    |    匹配所有的文本行，除了    addr    之外</span><br><span class="line">通过使用这一章中早前的    distros.txt    文件，我们将演示不同种类的地址表示法。首先，一系列行号：</span><br><span class="line">[me@linuxbox    ~]$    sed    -n    &apos;1,5p&apos;    distros.txt</span><br><span class="line">SUSE                                       10.2                    12/07/2006</span><br><span class="line">Fedora                                    10                       11/25/2008</span><br><span class="line">SUSE                                       11.0                    06/19/2008</span><br><span class="line">Ubuntu                                   8.04                    04/24/2008</span><br><span class="line">Fedora                                    8                         11/08/2007</span><br><span class="line">在这个例子中，我们打印出一系列的文本行，开始于第一行，直到第五行。为此，我们使用    p    命令，    其就是简单地把匹配的文本行打印出来。然而为了高效，我们必须包含选项    -n（不自动打印选项），    让sed    不要默认地打印每一行。</span><br><span class="line"></span><br><span class="line">下一步，我们将试用一下正则表达式：</span><br><span class="line">[me@linuxbox    ~]$    sed    -n    &apos;/SUSE/p&apos;    distros.txt       # 斜杠界定的正则表达式</span><br><span class="line">SUSE                                    10.2                    12/07/2006</span><br><span class="line">SUSE                                    11.0                    06/19/2008</span><br><span class="line">SUSE                                    10.3                    10/04/2007</span><br><span class="line">SUSE                                    10.1                    05/11/2006</span><br><span class="line">最后，我们将试着否定上面的操作，通过给这个地址添加一个感叹号：</span><br><span class="line">[me@linuxbox    ~]$    sed    -n    &apos;/SUSE/!p&apos;    distros.txt</span><br><span class="line">Fedora                                    10                            11/25/2008</span><br><span class="line">Ubuntu                                    8.04                    04/24/2008</span><br><span class="line">Fedora                                    8                                11/08/2007</span><br><span class="line">Ubuntu                                    6.10                    10/26/2006</span><br><span class="line">这里我们看到期望的结果：输出了文件中所有的文本行，除了那些匹配这个正则表达式的文本行。</span><br><span class="line">目前为止，我们已经知道了两个    sed    的编辑命令，s    和    p。这里是一个更加全面的基本编辑命令列表：</span><br><span class="line">表21-8:    sed    基本编辑命令</span><br><span class="line">|    命令    |    说明    |</span><br><span class="line">|-----|-------|</span><br><span class="line">|    =    |    输出当前的行号。    |</span><br><span class="line">|    a    |    在当前行之后追加文本。    |</span><br><span class="line">|    d    |    删除当前行。    |</span><br><span class="line">|    i    |    在当前行之前插入文本。    |</span><br><span class="line">|    p    |    打印当前行。默认情况下，sed    程序打印每一行，并且只是编辑文件中匹配指定地址的文本行。通过指定-n    选项，这个默认的行为能够被略。    |</span><br><span class="line">|    q    |    退出    sed，不再处理更多的文本行。如果不指定-n    选项，输出当前行。    |</span><br><span class="line">|    Q    |    退出    sed，不再处理更多的文本行。    |</span><br><span class="line">|    s/regexp/replacement/    |    只要找到一个    regexp    匹配项，就替换为    replacement    的内</span><br><span class="line"></span><br><span class="line">到目前为止，这个    s    命令是最常使用的编辑命令。</span><br><span class="line">[me@linuxbox    ~]$    echo    &quot;aaabbbccc&quot;    |    sed    &apos;s/b/B/&apos;</span><br><span class="line">aaa Bbbccc</span><br><span class="line">我们看到虽然执行了替换操作，但是只针对第一个字母    “b”    实例，然而剩余的实例没有更改。通过添加g    标志，    我们能够更改所有的实例：</span><br><span class="line">[me@linuxbox    ~]$    echo    &quot;aaabbbccc&quot;    |    sed    &apos;s/b/B/g&apos;</span><br></pre></td></tr></table></figure>
<h2 id="第二十二章：格式化输出"><a href="#第二十二章：格式化输出" class="headerlink" title="第二十二章：格式化输出"></a>第二十二章：格式化输出</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在这章中，我们继续着手于文本相关的工具，关注那些用来格式化输出的程序，而不是改变文本自身。    这些工具通常让文本准备就绪打印，这是我们在下一章会提到的。</span><br><span class="line">nl    -    添加行号</span><br><span class="line">nl    程序是一个相当神秘的工具，用作一个简单的任务。它添加文件的行数。在它最简单的用途中，它相当于    cat    -n:</span><br><span class="line"></span><br><span class="line">[me@linuxbox    ~]$    nl    distros.txt    |    head</span><br><span class="line"></span><br><span class="line">1            Fedora        5                            2006-03-20</span><br><span class="line">2            Fedora        6                            2006-10-24</span><br><span class="line">3            Fedora        7                            2007-05-31</span><br><span class="line"></span><br><span class="line">fold    -    限制文件行宽</span><br><span class="line"></span><br><span class="line">[me@linuxbox    ~]$    echo    &quot;The    quick    brown    fox    jumped    over    the    lazy    dog.&quot;   |    fold    -w    12</span><br><span class="line">The    quick    br</span><br><span class="line">own    fox    jump</span><br><span class="line">ed    over    the</span><br><span class="line">lazy    dog.</span><br><span class="line">我们设定了行宽为12个字符。    如果没有字符设置，默认是80。注意到文本行不会因为单词边界而不会被分解。增加的    -s    选项将让    fold    分解到最后可用的空白    字符，即会考虑单词边界。</span><br><span class="line"></span><br><span class="line">[me@linuxbox    ~]$    echo    &quot;The    quick    brown    fox    jumped    over    the    lazy    dog.&quot;</span><br><span class="line">|    fold    -w    12    -s</span><br><span class="line">The    quick</span><br><span class="line">brown    fox</span><br><span class="line">jumped    over</span><br><span class="line">the    lazy</span><br><span class="line">dog.</span><br></pre></td></tr></table></figure>
<h2 id="第二十三章：打印"><a href="#第二十三章：打印" class="headerlink" title="第二十三章：打印"></a>第二十三章：打印</h2><p>非目前学习重点</p>
<h2 id="第二十四章：编译程序"><a href="#第二十四章：编译程序" class="headerlink" title="第二十四章：编译程序"></a>第二十四章：编译程序</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用高级语言编写的程序，经过另一个称为编译器的程序的处理，会转换成机器语言。一些编译器把    高级指令翻译成汇编语言，然后使用一个汇编器完成翻译成机器语言的最后阶段。</span><br><span class="line">Python脚本在Linux上怎么运行？</span><br><span class="line">[root@qiansw tmp]# cat test.py         #这是一个python示例程序</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">#!/usr/bin/python</span><br><span class="line">for i in range(0,5):</span><br><span class="line">    print i</span><br><span class="line">[root@qiansw tmp]# ll</span><br><span class="line">total 48</span><br><span class="line">-rw-r--r-- 1 root root     48 Oct 30 11:04 test.py</span><br><span class="line">[root@qiansw tmp]# chmod +x test.py    #为脚本增加执行权限，另外一种表达[root@qiansw tmp]# chmod 755 test.py    #为脚本增加执行权限</span><br><span class="line">[root@qiansw tmp]# ./test.py                 #这是第一种方法</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">[root@qiansw tmp]# python test.py        #这是第二种方法，不用增加执行权限</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line"></span><br><span class="line">有两种方式：</span><br><span class="line">1、直接使用python xxxx.py执行。其中python可以写成python的绝对路径。使用which python进行查询。</span><br><span class="line">2、在文件的头部（第一行）写上#!/usr/bin/python2.7，这个地方使用python的绝对路径，就是上面用which python查询来的结果。然后在外面就可以使用./xxx.py执行了。</span><br><span class="line">因为在linux中，python啊shell这些程序都是普通的文本格式，都需要一种程序去解释执行它。要么调用的时候指定，要么在文件头指定。</span><br></pre></td></tr></table></figure>
<h2 id="第二十五章：编写第一个shell脚本"><a href="#第二十五章：编写第一个shell脚本" class="headerlink" title="第二十五章：编写第一个shell脚本"></a>第二十五章：编写第一个shell脚本</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">最简单的解释，一个    shell    脚本就是一个包含一系列命令的文件。shell    读取这个文件，然后执行    文件中的所有命令，就好像这些命令已经直接被输入到了命令行中一样。</span><br><span class="line"></span><br><span class="line">我们把此脚本文件保存为    hello_world。</span><br><span class="line">下一步我们要做的事情是让我们的脚本可执行。使用    chmod    命令，这很容易做到：</span><br><span class="line">[me@linuxbox    ~]$    ls    -l    hello_world</span><br><span class="line">-rw-r--r--    1        me                me                        63        2009-03-07    10:10    hello_world</span><br><span class="line">[me@linuxbox    ~]$    chmod    755    hello_world</span><br><span class="line">[me@linuxbox    ~]$    ls    -l    hello_world</span><br><span class="line">-rwxr-xr-x    1        me                me                        63        2009-03-07    10:10    hello_world</span><br><span class="line">对于脚本文件，有两个常见的权限设置；权限为755的脚本，则每个人都能执行，和权限为700的    脚本，</span><br><span class="line">只有文件所有者能够执行。</span><br><span class="line"></span><br><span class="line">脚本文件位置</span><br><span class="line">当设置了脚本权限之后，我们就能执行我们的脚本了：</span><br><span class="line">[me@linuxbox    ~]$    ./hello_world</span><br><span class="line">Hello    World!</span><br><span class="line">为了能够运行此脚本，我们必须指定脚本文件明确的路径。如果我们没有那样做，我们会得到这样的提示：</span><br><span class="line">[me@linuxbox    ~]$    hello_world</span><br><span class="line">bash:    hello_world:    command    not    found</span><br><span class="line"></span><br><span class="line">回到第12章，我们讨论了    PATH    环境变量及其它在系统    查找可执行程序方面的作用。回顾一下，如果没有给出可执行程序的明确路径名，那么系统每次都会    搜索一系列的目录，来查找此可执行程序。这个/bin    目录就是其中一个系统会自动搜索的目录。    这个目录列表被存储在一个名为PATH    的环境变量中。</span><br><span class="line"></span><br><span class="line">大多数的    Linux    发行版会配置    PATH    变量，让其包含一个位于用户家目录下的    bin    目录，从而允许用户能够执行他们自己的程序。所以如果我们创建了    一个bin    目录，并把我们的脚本放在这个目录下，那么这个脚本就应该像其它程序一样开始工作了：</span><br><span class="line">[me@linuxbox    ~]$    mkdir    bin</span><br><span class="line">[me@linuxbox    ~]$    mv    hello_world    bin    #移动到用户家目录下的bin目录下</span><br><span class="line">[me@linuxbox    ~]$    hello_world</span><br><span class="line">Hello    World!</span><br><span class="line"></span><br><span class="line">如果这个    PATH    变量不包含这个目录（记住以下两个命令就可以了），我们能够轻松地添加它，通过在我们的.bashrc    文件中包含下面    这一行文本：</span><br><span class="line"></span><br><span class="line">export    PATH=~/bin:&quot;$PATH&quot;</span><br><span class="line">当做了这个修改之后，它会在每个新的终端会话中生效。为了把这个修改应用到当前的终端会话中，    我们必须让    shell    重新读取这个    .bashrc    文件。这可以通过    “sourcing”.bashrc    文件来完成：</span><br><span class="line"></span><br><span class="line">[me@linuxbox    ~]$    .    .bashrc</span><br><span class="line"></span><br><span class="line">脚本文件的好去处</span><br><span class="line">这个    ~/bin    目录是存放为个人所用脚本的好地方。如果我们编写了一个脚本，系统中的每个用户都可以使用它，    那么这个脚本的传统位置是    /usr/local/bin。系统管理员使用的脚本经常放到    /usr/local/sbin    目录下。    大多数情况下，本地支持的软件，不管是脚本还是编译过的程序，都应该放到    /usr/local    目录下，而不是在    /bin    或    /usr/bin    目录下。这些目录都是由    Linux    文件系统层次结构标准指定，只包含由    Linux发行商    所提供和维护的文件。</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>The Linux Command Line学习笔记（三）</title>
    <url>/2018/06/12/Linux/The%20Linux%20Command%20Line%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="第十六章：存储媒介"><a href="#第十六章：存储媒介" class="headerlink" title="第十六章：存储媒介"></a>第十六章：存储媒介</h2><p>非目前学习重点，暂略</p>
<h2 id="第十七章：网络系统"><a href="#第十七章：网络系统" class="headerlink" title="第十七章：网络系统"></a>第十七章：网络系统</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我们仅仅会关注一些最经常    使用到的命令。我们要研究的命令包括那些被用来监测网络和传输文件的命令。</span><br><span class="line">ping             -    发送    ICMP    ECHO_REQUEST    软件包到网络主机</span><br><span class="line">traceroute    -    打印到一台网络主机的路由数据包</span><br><span class="line">netstat         -    打印网络连接，路由表，接口统计数据，伪装连接，和多路广播成员</span><br><span class="line">ftp                -    因特网文件传输程序</span><br><span class="line">wget             -    非交互式网络下载器</span><br><span class="line">ssh                -    Open SSH    SSH    客户端（远程登录程序）</span><br><span class="line"></span><br><span class="line">ping，网络连接验证， 按下组合键    Ctrl-c，中断这个命令之后</span><br><span class="line">[me@linuxbox    ~]$    ping    www.baidu.com</span><br><span class="line"></span><br><span class="line">网络中传输文件</span><br><span class="line">ftp</span><br><span class="line">ftp    命令属于真正的“经典”程序之一，它的名字来源于其所使用的协议，就是文件传输协议。FTP（它的原始形式）并不是安全的，因为它会以明码形式发送帐号的姓名和密码，由于此种原因，几乎因特网中所有    FTP    服务器    都是匿名的</span><br><span class="line"></span><br><span class="line">在下面的例子中，我们将展示一个典型的会话，从匿名    FTP    服务器，其名字是    fileserver，的/pub/_images/Ubuntu-8.04的目录下，使用    ftp    程序下载一个    Ubuntu    系统映像文件。</span><br><span class="line"></span><br><span class="line">[me@linuxbox    ~]$    ftp    fileserver</span><br><span class="line">Name    (fileserver:me):    anonymous</span><br><span class="line">ftp&gt;    cd    pub/cd\_images/Ubuntu-8.04</span><br><span class="line">ftp&gt;    ls</span><br><span class="line">ftp&gt;    lcd    Desktop</span><br><span class="line">ftp&gt;    get    ubuntu-8.04-desktop-i386.iso</span><br><span class="line">ftp&gt;    bye</span><br><span class="line">|---------|------------|</span><br><span class="line">1、  唤醒    ftp    程序，让它连接到    FTP    服务器，fileserver。    |</span><br><span class="line">2、 登录名。输入登录名后，将出现一个密码提示。一些服务器将会接受空密码，    其它一些则</span><br><span class="line">会要求一个邮件地址形式的密码。如果是这种情况，试着输入    “user@example.com”。    |</span><br><span class="line">3、 跳转到远端系统中，要下载文件所在的目录下，注意在大多数匿名的    FTP    服务器中，支持公共下载的文件都能在目录    pub    下找到    |</span><br><span class="line">4、列出远端系统中的目录。    |</span><br><span class="line">5、 跳转到本地系统中的 ~/Desktop目录下。在实例中，ftp  程序在工作目录    ~    下被唤醒。这个命令把工作目录改为    ~/Desktop    |</span><br><span class="line">6、 告诉远端系统传送文件到本地。因为本地系统的工作目录    已经更改到了    ~/Desktop，所以文件会被下载到此目录。    |</span><br><span class="line"></span><br><span class="line">另外还有两个常用传输文件程序：</span><br><span class="line">lftp    -    更好的    ftp，包括    多协议支持（包括    HTTP），若下载失败会自动地重新下载</span><br><span class="line">wget  -   不只能下载单个文件，多个文件，甚至整个网站都能下载</span><br><span class="line"></span><br><span class="line">与远程主机安全通信</span><br><span class="line">明码形式来传输所有的交流信息（包括登录命令和密码）。这使它们完全不    适合使用在因特网时代。</span><br><span class="line">ssh</span><br><span class="line">为了解决这个问题，开发了一款新的协议，叫做    SSH（Secure    Shell）。    SSH 首先，它要认证远端主机是否为它    所知道的那台主机（这样就阻止了所谓的“中间人”的攻击），其次，它加密了本地与远程主机之间    所有的通讯信息。SSH    由两部分组成。SSH    服务器运行在远端主机上运行，在端口号22上监听将要到来的连接，而    SSH    客户端用在本地系统中，用来和远端服务器通信。</span><br><span class="line"></span><br><span class="line">用来与远端    SSH    服务器相连接的    SSH    客户端程序，顺理成章，叫做    ssh。连接到远端名为    remote-sys主机，我们可以这样使用    ssh    客户端程序：</span><br><span class="line"></span><br><span class="line">[me@linuxbox    ~]$    ssh    remote-sys</span><br><span class="line">The    authenticity    of    host    &apos;remote-sys    (192.168.1.4)&apos;    can&apos;t    be</span><br><span class="line">established.</span><br><span class="line">RSA    key    fingerprint    is</span><br><span class="line">41:ed:7a:df:23:19:bf:3c:a5:17:bc:61:b3:7f:d9:bb.</span><br><span class="line">Are    you    sure    you    want    to    continue    connecting    (yes/no)?</span><br><span class="line">一旦建立了连接，会提示    用户输入他或她的密码：</span><br><span class="line"></span><br><span class="line">远端    shell    会话一直存在，直到用户输入    exit    命令后，则关闭了远程连接。这时候，本地的    shell    会话    恢</span><br><span class="line">复，本地    shell    提示符重新出现。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">也有可能使用不同的用户名连接到远程系统。例如，如果本地用户“me”，在远端系统中有一个帐号名“bob”，则用户    me    能够用    bob    帐号登录到远端系统，如下所示：</span><br><span class="line"></span><br><span class="line">[me@linuxbox    ~]$    ssh    bob@remote-sys</span><br><span class="line">bob@remote-sys&apos;s    password:</span><br><span class="line">Last    login:    Sat    Aug    30    13:03:21    2008</span><br><span class="line">[bob@remote-sys    ~]$</span><br></pre></td></tr></table></figure>
<h2 id="第十八章：查找文件"><a href="#第十八章：查找文件" class="headerlink" title="第十八章：查找文件"></a>第十八章：查找文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在这一章中，我们将察看    两个用来在系统中查找文件的工具。这些工具是：</span><br><span class="line">locate    –    通过名字来查找文件</span><br><span class="line">find    –    在目录层次结构中搜索文件</span><br><span class="line">我们也将看一个经常与文件搜索命令一起使用的命令，它用来处理搜索到的文件列表：</span><br><span class="line"></span><br><span class="line">xargs    –    从标准输入生成和执行命令行</span><br><span class="line">另外，我们将介绍两个命令来协助我们探索：</span><br><span class="line"></span><br><span class="line">touch    –    更改文件时间</span><br><span class="line">stat    –    显示文件或文件系统状态</span><br><span class="line"></span><br><span class="line">locate    -    查找文件的简单方法</span><br><span class="line">这个    locate    程序快速搜索路径名数据库，并且输出每个与给定字符串相匹配的文件名，例如，我们想要找到所有名字以“zip”开头的程序，假定包含    匹配程序的目录以”bin/”结尾。</span><br><span class="line"></span><br><span class="line">[me@linuxbox    ~]$    locate    bin/zip</span><br><span class="line">locate    命令将会搜索它的路径名数据库，输出任一个包含字符串“bin/zip”的路径名：</span><br><span class="line"></span><br><span class="line">/usr/bin/zip</span><br><span class="line">/usr/bin/zipcloak</span><br><span class="line">/usr/bin/zipgrep</span><br><span class="line">/usr/bin/zipinfo</span><br><span class="line">/usr/bin/zipnote</span><br><span class="line">/usr/bin/zipsplit</span><br><span class="line">locate    可以结合其它工具，比如说    grep    命令，来设计更加    有趣的搜索：</span><br><span class="line"></span><br><span class="line">[me@linuxbox    ~]$    locate    zip    |    grep    bin</span><br><span class="line">/bin/bunzip2</span><br><span class="line">/bin/bzip2</span><br><span class="line">/bin/bzip2recover</span><br><span class="line">/usr/bin/gpg-zip</span><br><span class="line">/usr/bin/funzip</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">find    -    查找文件的复杂方式</span><br><span class="line">locate    程序只能依据文件名来查找文件，而    find    程序能基于各种各样的属性，    搜索一个给定目录（以及它的子目录），来查找文件.</span><br><span class="line"></span><br><span class="line">find    命令的最简单使用是，搜索一个或多个目录。例如，输出我们的家目录列表。</span><br><span class="line">[me@linuxbox    ~]$    find    ~</span><br><span class="line">对于最活跃的用户帐号，这将产生一张很大的列表,让我们使用    wc    程序来计算出文件的数量：</span><br><span class="line">[me@linuxbox    ~]$    find    ~    |    wc    -l</span><br><span class="line">47068</span><br><span class="line"></span><br><span class="line">比如说我们想要目录列表。我们可以添加以下测试条件：</span><br><span class="line"></span><br><span class="line">[me@linuxbox    ~]$    find    ~    -type    d    |    wc    -l</span><br><span class="line">这里添加测试条件-type    d    限制了只搜索目录</span><br><span class="line"></span><br><span class="line">表18-1:    find    文件类型</span><br><span class="line">|    文件类型    |    描述    |</span><br><span class="line">|---------|------------|</span><br><span class="line">|    b    |    块设备文件    |</span><br><span class="line">|    c    |    字符设备文件    |</span><br><span class="line">|    d    |    目录    |</span><br><span class="line">|    f    |    普通文件    |</span><br><span class="line">|    l    |    符号链接    |</span><br><span class="line">我们也可以通过加入一些额外的测试条件，根据文件大小和文件名来搜索：让我们查找所有文件名匹配    通</span><br><span class="line">配符模式“*.JPG”和文件大小大于1M    的文件：</span><br><span class="line"></span><br><span class="line">[me@linuxbox    ~]$    find    ~    -type    f    -name    &quot;\*.JPG&quot;    -size    +1M    |    wc    -l</span><br><span class="line">840</span><br><span class="line"></span><br><span class="line">在这个例子里面，我们加入了    -name    测试条件，后面跟通配符模式。注意，我们把它用双引号引起来，从而阻止    shell    展开路径名。紧接着，我们加入    -size    测试条件，后跟字符串“+1M”。开头的加号表明我们正在寻找文件大小大于指定数的文件。若字符串以减号开头，则意味着查找小于指定数的文件。    若没有符号意味着“精确匹配这个数”。结尾字母“M”表明测量单位是兆字节。</span><br><span class="line"></span><br><span class="line">find    命令支持大量不同的测试条件。下表是列出了一些常见的测试条件。请注意，在需要数值参数的    情况下，可以应用以上讨论的“+”和”-“符号表示法：</span><br><span class="line">表18-3:    find    测试条件</span><br><span class="line">|    测试条件    |    描述    |</span><br><span class="line">|---------|------------|</span><br><span class="line">|    -name    pattern    |    用指定的通配符模式匹配的文件和目录。    |</span><br><span class="line">|    -size    n    |    匹配的文件大小为    n。    |</span><br><span class="line">|    -type    c    |    匹配的文件类型是    c。    |</span><br><span class="line">|    -user    name    |    匹配的文件或目录属于某个用户。这个用户可以通过用户名或用户    ID    来表示。    |</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">操作符</span><br><span class="line">幸运地是，find    命令提供了    一种方法来结合测试条</span><br><span class="line">件，通过使用逻辑操作符来创建更复杂的逻辑关系。    为了表达上述的测试条件，我们可以这样做（括号转义，不要被自动展开）：</span><br><span class="line">[me@linuxbox    ~]$    find    ~    \(    -type    f    -not    -perm    0600    \)    -or    \(    -type    d    -not    -perm    0700    \)</span><br><span class="line">|    操作符    |    描述    |</span><br><span class="line">|---------|------------|</span><br><span class="line">|    -and    |    如果操作符两边的测试条件都是真，则匹配。可以简写为    -a。    注意若没有使用操作符，则默认使</span><br><span class="line">用    -and。    |</span><br><span class="line">|    -or    |    若操作符两边的任一个测试条件为真，则匹配。可以简写为    -o。    |</span><br><span class="line">|    -not    |    若操作符后面的测试条件是真，则匹配。可以简写为一个感叹号（!）。    |</span><br><span class="line">|    ()    |    把测试条件和操作符组合起来形成更大的表达式。这用来控制逻辑计算的优先级</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">预定义的操作</span><br><span class="line">幸运地是，find    命令允许基于搜索结果来执行操作</span><br><span class="line">表18-6:    几个预定义的    find    命令操作</span><br><span class="line">|    操作    |    描述    |</span><br><span class="line">|---------|------------|</span><br><span class="line">|    -delete    |    删除当前匹配的文件。    |</span><br><span class="line">|    -ls    |    对匹配的文件执行等同的    ls    -dils    命令。并将结果发送到标准输出。    |</span><br><span class="line">|    -print    |    把匹配文件的全路径名输送到标准输出。如果没有指定其它操作，这是    默认操作。    |</span><br><span class="line">|    -quit    |    一旦找到一个匹配，退出。    |</span><br><span class="line"></span><br><span class="line">find    ~    -type    f    -name    &apos;*.BAK&apos;    -delete</span><br><span class="line">在这个例子里面，用户家目录（和它的子目录）下搜索每个以.BAK    结尾的文件名。当找到后，就删除它们。</span><br><span class="line">警告：当使用    -delete    操作时，不用说，你应该格外小心。首先测试一下命令，    用    -print    操作代替    -delete，来确认搜索结果。</span><br><span class="line">记住，在每个测试和操作之间会默认应用    -and    逻辑运算符。    我们也可以这样表达这个命令，使逻辑关系更容易看出：</span><br><span class="line"></span><br><span class="line">find    ~    -type    f    -and    -name    &apos;*.BAK&apos;    -and    -print</span><br></pre></td></tr></table></figure>
<p><img src="/2018/06/12/Linux/The Linux Command Line学习笔记（三）/01.png" alt></p>
<p> 因为测试和行为之间的逻辑关系决定了哪一个会被执行，我们知道测试和行为的顺序很重要 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用户定义的行为</span><br><span class="line">除了预定义的行为之外，我们也可以唤醒随意的命令。传统方式是通过    -exec    行为。这个    行为像这样工作：</span><br><span class="line">-exec    command    &#123;&#125;    ;</span><br><span class="line">&#123;&#125;是当前路径名的符号表示，分号是要求的界定符    表明命令结束。这里是一个使用  -exec  行为的例子，其作用如之前讨论的    -delete    行为：</span><br><span class="line"></span><br><span class="line">-exec    rm    &apos;&#123;&#125;&apos;    &apos;;&apos;</span><br><span class="line">重述一遍，因为花括号和分号对于    shell    有特殊含义，所以它们必须被引起来或被转义。</span><br><span class="line">通过使用    -ok    行为来代替    -exec，在执行每个指定的命令之前，    起提示用户作用：</span><br><span class="line"></span><br><span class="line">touch命令通常被用来设置或更新文件的访问，更改，和修改时间。然而，如果一个文件名参数是一个不存在的文件，则会创建一个空文件。</span><br><span class="line">注意不同于    ls    命令，find    命令的输出结果是无序的。其顺序由存储设备的布局决定</span><br><span class="line">stat，是一款加大马力的    ls    命令版本</span><br></pre></td></tr></table></figure>
<h2 id="第十九章：归档和备份"><a href="#第十九章：归档和备份" class="headerlink" title="第十九章：归档和备份"></a>第十九章：归档和备份</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">它们就是文件压缩程序：</span><br><span class="line"></span><br><span class="line">gzip    –    压缩或者展开文件</span><br><span class="line">bzip2    –    块排序文件压缩器，另外一种压缩算法，基本和gzip一样</span><br><span class="line">归档程序：</span><br><span class="line"></span><br><span class="line">tar    –    磁带打包工具</span><br><span class="line">zip    –    打包和压缩文件</span><br><span class="line">还有文件同步程序：</span><br><span class="line"></span><br><span class="line">rsync    –    同步远端文件和目录</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gzip</span><br><span class="line">这个    gzip    程序被用来压缩一个或多个文件。当执行    gzip    命令时，则原始文件的压缩版会替代原始文件。</span><br><span class="line">相对应的    gunzip    程序被用来把压缩文件复原为没有被压缩的版本</span><br><span class="line"></span><br><span class="line">[me@linuxbox    ~]$    gzip    foo.txt</span><br><span class="line">[me@linuxbox    ~]$    gunzip    foo.txt.gz</span><br><span class="line">接下来，我们运行    gzip    命令，它会把原始文件替换为一个叫做    foo.txt.gz    的压缩文件。接下来，我们运行    gunzip    程序来解压缩文件。随后，我们能见到压缩文件已经被原始文件替代了，    同样地保留了相同的权限和时间戳。</span><br><span class="line">如果我们的目标只是为了浏览一下压缩文本文件的内容，我们可以这样做：</span><br><span class="line"></span><br><span class="line">[me@linuxbox    ~]$    gunzip    -c    foo.txt    |    less</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">归档文件</span><br><span class="line">归档就是收集许多文件，并把它们    捆绑成一个大文件的过程。归档经常作为系统备份的一部分来使用。</span><br><span class="line">我们经常看到扩展名为    .tar    或者    .tgz    的文件，它们各自表示“普通”    的    tar    包和被    gzip程序压缩过的    tar    包。一个    tar    包可以由一组独立的文件，一个或者多个目录，或者    两者混合体组成。命令语法如下：</span><br><span class="line"></span><br><span class="line">tar    mode[options]    pathname...     # 语法</span><br><span class="line">表19-2:    tar    模式</span><br><span class="line">|    模式    |    说明    |</span><br><span class="line">|---------|------------|</span><br><span class="line">|    c    |    为文件和／或目录列表创建归档文件。    |</span><br><span class="line">|    x    |    抽取归档文件，相当于归档后复制到另外一个位置。    | </span><br><span class="line">|    r    |    追加具体的路径到归档文件的末尾。    |</span><br><span class="line">|    t    |    列出归档文件的内容。    |</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">让我们创建整个操练场的    tar    包：</span><br><span class="line"></span><br><span class="line">[me@linuxbox    ~]$    tar    cf    playground.tar    playground    #f选项可能是force</span><br><span class="line">列出归档文件的内容</span><br><span class="line"></span><br><span class="line">[me@linuxbox    ~]$    tar    tf    playground.tar</span><br><span class="line">抽取    tar    包    playground    到一个新位置</span><br><span class="line"></span><br><span class="line">[me@linuxbox    ~]$    cd    foo     #进到目标目录</span><br><span class="line">[me@linuxbox    ~]$    tar    xf    ../playground.tar  #xf为抽取后的文件</span><br><span class="line">有一个警告，然而：除非你是超级用户，要不然从归档文件中抽取的文件和目录的所有权由执行此复原操作的用户所拥有，而不属于原始所有者。</span><br><span class="line">tar    命令另一个有趣的行为是它处理归档文件路径名的方式。默认情况下，路径名是相对的，而不是绝对路径。</span><br><span class="line"></span><br><span class="line">假定我们想要复制家目录及其内容到另一个系统中，    并且有一个大容量的    USB    硬盘，可以把它作为传输工具</span><br><span class="line">[me@linuxbox    ~]$    sudo    tar    cf    /media/Big Disk/home.tar    /home</span><br><span class="line">[me@linuxbox2    /]$    sudo    tar    xf    /media/Big Disk/home.tar</span><br><span class="line">c参数为创建归档，x参数为提取归档内容，f应该是强制。第一个路径为归档后放置的路径，第二个路径是对什么内容进行归档。</span><br><span class="line"></span><br><span class="line">GNU    版本的    tar    命令（在    Linux    发行版中最常出现）通过    --wildcards    选项来    支持通配符。这个例子使用了之前    playground.tar    文件：这个命令将只会抽取匹配特定路径名的文件，路径名中包含了通配符    dir-*</span><br><span class="line"></span><br><span class="line">[me@linuxbox    ~]$    cd    foo</span><br><span class="line">[me@linuxbox    foo]$    tar    xf    ../playground2.tar    --wildcards    &apos;home/me/playground/dir-\*/file-A&apos;</span><br><span class="line"></span><br><span class="line">tar    命令经常结合    find    命令一起来制作归档文件。在这个例子里，我们将会使用    find    命令来    产生一个文件集合，然后这些文件被包含到归档文件中。</span><br><span class="line"></span><br><span class="line">[me@linuxbox    ~]$    find    playground    -name    &apos;file-A&apos;    -exec    tar    rf    playground.tar    &apos;&#123;&#125;&apos;    &apos;+&apos;</span><br><span class="line">这里我们使用    find    命令来匹配    playground    目录中所有名为    file-A    的文件，然后使用-exec    行为，来    唤</span><br><span class="line">醒带有追加模式（r）的    tar    命令，把匹配的文件添加到归档文件    playground.tar    里面。</span><br><span class="line"></span><br><span class="line">zip</span><br><span class="line">这个    zip    程序既是压缩工具，也是一个打包工具，Windows    用户比较熟悉。然而，在    Linux    中    gzip    是主要的压缩程序，而    bzip2则位居第二。例如，制作一个    playground    的    zip    版本的文件包，这样做：</span><br><span class="line"></span><br><span class="line">[me@linuxbox    ~]$    zip    -r    playground.zip    playground</span><br><span class="line">除非我们包含-r    选项，要不然只有    playground    目录（没有任何它的内容）被存储</span><br><span class="line"></span><br><span class="line">使用    unzip    程序，来直接抽取一个    zip    文件的内容。</span><br><span class="line"></span><br><span class="line">[me@linuxbox    ~]$    cd    foo</span><br><span class="line">[me@linuxbox    foo]$    unzip    ../playground.zip</span><br><span class="line">使用-l    选项，导致    unzip    命令只是列出文件包中的内容而没有抽取文件</span><br><span class="line"></span><br><span class="line"> 对于    zip    命令（与    tar    命令相反）要注意一点，就是如果指定了一个已经存在的文件包，其被更新    而不是</span><br><span class="line">被替代。这意味着会保留此文件包。</span><br><span class="line"></span><br><span class="line">同步文件和目录</span><br><span class="line">通过使用    rsync    远端更新协议，此协议    允许    rsync    快速地检测两个目录的差异，执行最小量的复制来达到目录间的同步。</span><br><span class="line">rsync    被这样唤醒：</span><br><span class="line"></span><br><span class="line">rsync    options    source    destination</span><br><span class="line">这里    source    和    destination    是下列选项之一：</span><br><span class="line">一个本地文件或目录</span><br><span class="line">一个远端文件或目录，以[user@]host:path    的形式存在</span><br><span class="line">一个远端    rsync    服务器，由    rsync://[user@]host[:port]/path    指定</span><br><span class="line">注意    source    和    destination    两者之一必须是本地文件。rsync    不支持远端到远端的复制。</span><br><span class="line"></span><br><span class="line">下一步，我们将同步    playground    目录在    foo    目录中</span><br><span class="line"></span><br><span class="line">[me@linuxbox    ~]$    rsync    -av    playground    foo</span><br><span class="line">我们包括了-a    选项（递归和保护文件属性）和-v    选项（冗余输出）</span><br></pre></td></tr></table></figure>
<h2 id="第二十章：正则表达式"><a href="#第二十章：正则表达式" class="headerlink" title="第二十章：正则表达式"></a>第二十章：正则表达式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep    程序会在文本文件中查找一个指定的正则表达式，并把匹配行输出到标准输出。就像这样:</span><br><span class="line"></span><br><span class="line">[me@linuxbox    ~]$    ls    /usr/bin    |    grep    zip</span><br><span class="line">这个命令会列出，位于目录    /usr/bin    中，文件名中包含子字符串“zip”的所有文件。</span><br><span class="line">这个    grep    程序以这样的方式来接受选项和参数：</span><br><span class="line"></span><br><span class="line">grep    [options]    regex    [file...]    #这里的    regx    是指一个正则表达式。</span><br><span class="line"></span><br><span class="line">这是一个常用的    grep    选项列表：</span><br><span class="line">表20-1:    grep    选项</span><br><span class="line">选项  描述</span><br><span class="line">-i           忽略大小写。不会区分大小写字符。也可用--ignore-case    来指定。</span><br><span class="line">-v          不匹配。通常，grep    程序会打印包含匹配项的文本行。这个选项导致    grep    程序    只会不包含匹配项的文本行</span><br><span class="line">-c          打印匹配的数量（或者是不匹配的数目，若指定了-v    选项），而不是文本行本身。   </span><br><span class="line">-l           打印包含匹配项的文件名，而不是文本行本身</span><br><span class="line">-L          相似于-l    选项，但是只是打印不包含匹配项的文件名</span><br><span class="line">-h          应用于多文件搜索，只输出匹配项，不输出文件名（因为默认两个都会输出）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[me@linuxbox    ~]$    grep    bzip    dirlist*.txt   #搜索字符串bzip</span><br><span class="line">dirlist-bin.txt:bzip2</span><br><span class="line">dirlist-bin.txt:bzip2recover</span><br><span class="line">[me@linuxbox    ~]$    grep    -l    bzip    dirlist*.txt  # 只输出包含匹配项的文件名</span><br><span class="line">dirlist-bin.txt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">元字符和文本</span><br><span class="line">表达式元字符由以下字符组成：^    $    .    [    ]    &#123;    &#125;    -    ?    *    +    (    )    |    \  然后其它所有字符都被认为是原义字符</span><br><span class="line"></span><br><span class="line">圆点字符，其被用来匹配任意字符</span><br><span class="line">[me@linuxbox    ~]$    grep    -h    &apos;.zip&apos;    dirlist*.txt</span><br><span class="line">bunzip2</span><br><span class="line">bzip2</span><br><span class="line"></span><br><span class="line">插入符号和美元符号被看作是锚点，表示以**开头和以**结尾</span><br><span class="line">[me@linuxbox    ~]$    grep    -h    &apos;^zip&apos;    dirlist*.txt</span><br><span class="line">zip</span><br><span class="line">zipcloak</span><br><span class="line">[me@linuxbox    ~]$    grep    -h    &apos;zip$&apos;    dirlist*.txt</span><br><span class="line">gunzip</span><br><span class="line">gzip</span><br><span class="line"></span><br><span class="line">通过中括号表达式，我们能够指定    一个字符集合</span><br><span class="line">[me@linuxbox    ~]$    grep    -h    &apos;[bg]zip&apos;    dirlist*.txt</span><br><span class="line">bzip2recover</span><br><span class="line">gzip</span><br><span class="line"></span><br><span class="line">否定，如果在正则表示式中的第一个字符是一个插入字符，则剩余的字符被看作是不会在给定的字符位置出现的字符集合</span><br><span class="line">[me@linuxbox    ~]$    grep    -h    &apos;[^bg]zip&apos;    dirlist*.txt   #zip之前的字符一定不是b或者g</span><br><span class="line">bunzip2</span><br><span class="line">gunzip</span><br><span class="line"></span><br><span class="line">字符区域</span><br><span class="line">[me@linuxbox    ~]$    grep    -h    &apos;^[A-Z]&apos;    dirlist*.txt</span><br><span class="line">MAKEDEV</span><br><span class="line"></span><br><span class="line">扩展的正则表达式</span><br><span class="line">正则表达式的实现分成了两类：    基本正则表达式（BRE）和扩展的正则表达式（ERE）,因为我们将要讨论的下一个特性是    ERE    的一部分,由    egrep    程序来执行这项操作，但是    GUN    版本的    grep    程序也支持扩展的正则表达式，当使用了-E    选项</span><br><span class="line">之后。</span><br><span class="line"></span><br><span class="line">Alternation</span><br><span class="line">我们将要讨论的扩展表达式的第一个特性叫做    alternation（交替），其是一款允许从一系列表达式    之间选择匹配项的实用程序。</span><br><span class="line"></span><br><span class="line">[me@linuxbox    ~]$    echo    &quot;AAA&quot;    |    grep    AAA       #左边传过来的和右边匹配</span><br><span class="line">AAA</span><br><span class="line">[me@linuxbox    ~]$    echo    &quot;BBB&quot;    |    grep    AAA</span><br><span class="line">[me@linuxbox    ~]$</span><br><span class="line">一个相当直截了当的例子，我们把    echo    的输出管道给    grep，然后看到输出结果。当出现    一个匹配项时，我们看到它会打印出来；当没有匹配项时，我们看到没有输出结果。现在我们将添加    alternation，以竖杠线元字符为标记：</span><br><span class="line"></span><br><span class="line">[me@linuxbox    ~]$    echo    &quot;AAA&quot;    |    grep    -E    &apos;AAA|BBB&apos;</span><br><span class="line">AAA</span><br><span class="line">[me@linuxbox    ~]$    echo    &quot;BBB&quot;    |    grep    -E    &apos;AAA|BBB&apos;</span><br><span class="line">BBB</span><br><span class="line">[me@linuxbox    ~]$    echo    &quot;CCC&quot;    |    grep    -E    &apos;AAA|BBB&apos;</span><br><span class="line">[me@linuxbox    ~]$</span><br><span class="line">这里我们看到正则表达式’AAA|BBB’，这意味着“匹配字符串    AAA    或者是字符串    BBB”。注意因为这是    一个扩展的特性，我们给    grep    命令（虽然我们能以    egrep    程序来代替）添加了-E    选项，并且我们    把这个正则表达式用单引号引起来，为的是阻止    shell    把竖杠线元字符解释为一个    pipe    操作符。</span><br><span class="line"></span><br><span class="line">限定符</span><br><span class="line">扩展的正则表达式支持几种方法，来指定一个元素被匹配的次数。</span><br><span class="line">?    -    匹配零个或一个元素</span><br><span class="line">*    -    匹配零个或多个元素</span><br><span class="line">+    -    匹配一个或多个元素</span><br><span class="line">&#123;    &#125;    -    匹配特定个数的元素</span><br><span class="line">表20-3:    指定匹配的数目</span><br><span class="line">|    限定符    |    意思    |</span><br><span class="line">|-------|-------|</span><br><span class="line">|    &#123;n&#125;    |    匹配前面的元素，如果它确切地出现了    n    次。    |</span><br><span class="line">|    &#123;n,m&#125;    |    匹配前面的元素，如果它至少出现了    n    次，但是不多于    m    次。    |</span><br><span class="line">|    &#123;n,&#125;    |    匹配前面的元素，如果它出现了    n    次或多于    n    次。    |</span><br><span class="line">|    &#123;,m&#125;    |    匹配前面的元素，如果它出现的次数不多于    m    次。    |</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>The Linux Command Line学习笔记（二）</title>
    <url>/2018/06/10/Linux/The%20Linux%20Command%20Line%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h2 id="第十一章：进程"><a href="#第十一章：进程" class="headerlink" title="第十一章：进程"></a>第十一章：进程</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这一章将介绍以下命令：</span><br><span class="line">这一章将介绍以下命令：</span><br><span class="line">ps    –    报告当前进程快照</span><br><span class="line">top    –    显示任务</span><br><span class="line">jobs    –    列出活跃的任务</span><br><span class="line">bg    –    把一个任务放到后台执行</span><br><span class="line">fg    –    把一个任务放到前台执行</span><br><span class="line">kill    –    给一个进程发送信号</span><br><span class="line">killall    –    杀死指定名字的进程</span><br><span class="line">shutdown    –    关机或重启系统</span><br><span class="line"></span><br><span class="line">系统分配给每个进程一个数字，这个数字叫做进程ID    或    PID。PID    号按升序分配，init    进程的    PID    总是1。</span><br><span class="line">查看进程  ps。ps    程序有许多选项，它最简单地使用形式是这样的：</span><br><span class="line"></span><br><span class="line">[me@linuxbox    ~]$    ps</span><br><span class="line">PID    TTY                   TIME     CMD</span><br><span class="line">5198    pts/1             00:00:00    bash</span><br><span class="line">10129    pts/1            00:00:00    ps</span><br><span class="line">TTY    是“Teletype”    的简写，是指进程的控制终端，TIME    字段表示    进程所消耗的</span><br><span class="line">CPU    时间数量，CMD代表运行的命令</span><br><span class="line"></span><br><span class="line">[me@linuxbox    ~]$    ps    x    # 可以得到更多关于系统运行状态的信息：</span><br><span class="line">输出结果中，新添加了一栏，标题为    STAT    。STAT    是    “state”    的简写，它揭示了进程当前状态：</span><br><span class="line">表11-1:    进程状态</span><br><span class="line">|    状态    |    意义    |</span><br><span class="line">|    ---    |    ---    |</span><br><span class="line">|    R    |    运行。这意味着，进程正在运行或准备运行。    |</span><br><span class="line">|    S    |    正在睡眠。    进程没有运行，而是，正在等待一个事件，    比如说，一个按键或者网络数据包。    |</span><br><span class="line">|    D    |    不可中断睡眠。进程正在等待    I/O，比方说，一个磁盘驱动器的    I/O。    |</span><br><span class="line">|    T    |    已停止.    已经指示进程停止运行。稍后介绍更多。    |</span><br><span class="line">|    Z    |    一个死进程或“僵尸”进程</span><br><span class="line">|    &lt;    |    一个高优先级进程</span><br><span class="line">|    N    |    低优先级进程。</span><br><span class="line"></span><br><span class="line">另一个流行的选项组合是    “aux”（不带开头的”-“字符）。这会给我们更多信息：</span><br><span class="line">[me@linuxbox    ~]$    ps    aux</span><br><span class="line"></span><br><span class="line">用    top    命令动态查看进程</span><br><span class="line">[me@linuxbox    ~]$    top</span><br><span class="line">top    显示结果由两部分组成：    最上面是系统概要，下面是进程列表，以    CPU    的使用率排序。输入q退出top程序。</span><br><span class="line"></span><br><span class="line">把一个进程放置到后台(执行)</span><br><span class="line">启动一个程序，让它立即在后台    运行，我们在程序命令之后，加上”&amp;”字符：</span><br><span class="line"></span><br><span class="line">[me@linuxbox    ~]$    xlogo    &amp;   #xlogo打开一个试验窗口</span><br><span class="line">[1]    28236                        # 工作号为1</span><br><span class="line">[me@linuxbox    ~]$</span><br><span class="line">如果我们运行    ps    命令，可以看到我们的进程：</span><br><span class="line"></span><br><span class="line">[me@linuxbox    ~]$    ps</span><br><span class="line">PID    TTY                 TIME              CMD</span><br><span class="line">10603    pts/1            00:00:00            bash</span><br><span class="line">28236    pts/1            00:00:00            xlogo</span><br><span class="line">28239    pts/1            00:00:00            ps</span><br><span class="line">执行    jobs    命令，我们可以看到这个输出列表：</span><br><span class="line">[me@linuxbox    ~]$    jobs</span><br><span class="line">[1]+    Running                                                xlogo    &amp;</span><br><span class="line"></span><br><span class="line">进程返回到前台</span><br><span class="line">一个在后台运行的进程对一切来自键盘的输入都免疫，也不能用    Ctrl-c    来中断它。使用    fg    命令，让一个</span><br><span class="line">进程返回前台执行：</span><br><span class="line"></span><br><span class="line">[me@linuxbox    ~]$    jobs</span><br><span class="line">[1]+    Running                                xlogo    &amp;</span><br><span class="line">[me@linuxbox    ~]$    fg    %1</span><br><span class="line">xlogo</span><br><span class="line">fg    命令之后，跟随着一个百分号和工作序号，输入    Ctrl-c    来终止    xlogo    程序</span><br><span class="line"></span><br><span class="line">停止一个进程，输入    Ctrl-z，可以停止一个前台进程。</span><br><span class="line">使用    fg    命令，可以恢复程序到前台运行，或者用    bg    命令把程序移到后台。</span><br><span class="line"></span><br><span class="line">Signals</span><br><span class="line">kill    命令被用来“杀死”程序。这样我们就可以终止需要杀死的程序。指定我们想要终止的进程    PID。也可以用    jobspec（例如，“％1”）来代替    PID。</span><br><span class="line"></span><br><span class="line">[me@linuxbox    ~]$    xlogo    &amp;</span><br><span class="line">[1]    28401</span><br><span class="line">[me@linuxbox    ~]$    kill    28401</span><br><span class="line">[1]+    Terminated                                                            xlogo</span><br><span class="line">这个    kill    命令不是确切地“杀死”程序，而是给程序    发送信号。当程序    接到信号之后，则做出响应。</span><br><span class="line">通过    kill    命令给进程发送信号，kill    命令被用来给程序发送信号。它最常见的语法形式看起来像这样（默认TERM终止信号）：</span><br><span class="line">kill    [-signal]    PID...</span><br><span class="line">表    11-4:    常用信号</span><br><span class="line">|    编号    |    名字    |    含义    |</span><br><span class="line">|    1    |    HUP    |    挂起，这意味着，当发送这个信号到一个守护进程后，    这个进程会重新启动，并且重新读取它的配置文件</span><br><span class="line">|    2    |    INT    |    中断。实现和    Ctrl-c    一样的功能，由终端发送。通常，它会终止一个程序。    |</span><br><span class="line">|    15    |    TERM    |    终止。这是    kill    命令发送的默认信号</span><br><span class="line">|    18    |    CONT    |    继续。在停止一段时间后，进程恢复运行。    |</span><br><span class="line">|    19    |    STOP    |    停止。这个信号导致进程停止运行，而没有终止</span><br><span class="line">例如：</span><br><span class="line">[me@linuxbox    ~]$    kill    -1    13546     #挂起 工作号为13546的进程</span><br></pre></td></tr></table></figure>
<h2 id="第十二章：shell环境"><a href="#第十二章：shell环境" class="headerlink" title="第十二章：shell环境"></a>第十二章：shell环境</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在这一章，我们将用到以下命令：</span><br><span class="line">printenv    -    打印部分或所有的环境变量</span><br><span class="line">set    -    设置    shell    选项</span><br><span class="line">export    —    导出环境变量，让随后执行的程序知道。</span><br><span class="line">alias    -    创建命令别名</span><br><span class="line"></span><br><span class="line">shell    在环境中存储了两种基本类型的数据，虽然对于    bash    来说，很大程度上这些类型是不可    辨别的。</span><br><span class="line">它们是环境变量和    shell    变量。Shell    变量是由    bash    存放的少量数据，而剩下的基本上    都是环境变量</span><br><span class="line"></span><br><span class="line">[me@linuxbox    ~]$    printenv    |    less #显示环境变量</span><br><span class="line"></span><br><span class="line">非登录    shell    会话也会继承它们父进程的环境设置，通常是一个登录    shell</span><br><span class="line"></span><br><span class="line">曾经是否感到迷惑    shell    是怎样知道到哪里找到我们在命令行中输入的命令的？例如，当我们输入    ls    后，</span><br><span class="line">shell    不会查找整个计算机系统，来找到    /bin/ls（ls    命令的绝对路径名），而是，它查找一个目录列表，</span><br><span class="line">这些目录包含在    PATH    变量中。</span><br><span class="line"></span><br><span class="line">通过添加字符串    $HOME/bin    到    PATH    变量值的末尾，则目录    $HOME/bin    就添加到了命令搜索目录列表中。这意味着当我们想要在自己的家目录下，创建一个目录来存储我们自己的私人程序时，shell    已经给我们准备好了。我们所要做的事就是    把创建的目录叫做    bin</span><br><span class="line"></span><br><span class="line">按照通常的规则，添加目录到你的    PATH    变量或者是定义额外的环境变量，要把这些更改放置到</span><br><span class="line">.bash_profile    文件中.     对于其它的更改，要放到    .bashrc    文件中。(修改通过vi编辑器)</span><br><span class="line"></span><br><span class="line">移动    鼠标到文件的最后一行，然后添加以下几行到文件    .bashrc    中：</span><br><span class="line"></span><br><span class="line">umask    0002</span><br><span class="line">export    HISTCONTROL=ignoredups</span><br><span class="line">export    HISTSIZE=1000</span><br><span class="line">alias    l.=&apos;ls    -d    .*    --color=auto&apos;</span><br><span class="line">alias    ll=&apos;ls    -l    --color=auto&apos;</span><br><span class="line"></span><br><span class="line">|    文本行    |    含义    |</span><br><span class="line">|-------|---------|</span><br><span class="line">|    umask    0002    |    设置掩码来解决共享目录的问题。    |</span><br><span class="line">|    export    HISTCONTROL=ignoredups    |    使得    shell    的历史记录功能忽略一个命令，如果相同的命令已被</span><br><span class="line">记录。    |</span><br><span class="line">|    export    HISTSIZE=1000    |    增加命令历史的大小，从默认的    500    行扩大到    1000    行。    |</span><br><span class="line">|    alias    l.=&apos;ls    -d    .*    --color=auto&apos;    |    创建一个新命令，叫做&apos;l.&apos;，这个命令会显示所有以点开头的目录项。    |</span><br><span class="line">|    alias    ll=&apos;ls    -l    --color=auto&apos;    |    创建一个叫做&apos;ll&apos;的命令，这个命令会显示长格式目录列表。    |</span><br><span class="line"></span><br><span class="line">激活我们的修改</span><br><span class="line">我们对于文件    .bashrc    的修改不会生效，直到我们关闭终端会话，再重新启动一个新的会话，    因为</span><br><span class="line">.bashrc    文件只是在刚开始启动终端会话时读取。然而，我们可以强迫    bash    重新读取修改过的    .bashrc</span><br><span class="line">文件，使用下面的命令：</span><br><span class="line">[me@linuxbox    ~]$    source    .bashrc</span><br></pre></td></tr></table></figure>
<h2 id="第十三章：VI简介"><a href="#第十三章：VI简介" class="headerlink" title="第十三章：VI简介"></a>第十三章：VI简介</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[me@linuxbox    ~]$    vi    #启动vi:q!                          #加感叹号是强制退出</span><br><span class="line">小贴示：如果你在    vi    中“迷失”了，试着按下    Esc    键两次来找到路（回到普通模式）。</span><br><span class="line"></span><br><span class="line">编辑模式</span><br><span class="line">再次启动    vi，这次传递给    vi    一个不存在的文件名。这也是用    vi    创建新文件的方法。</span><br><span class="line">[me@linuxbox    ~]$    vi    foo.txt</span><br><span class="line">当    vi    启动后，进入    的是命令模式。这种模式下，几乎每个按键都是一个命令，所以如果我们打算输入字符，vi    会发疯，弄得一团糟。</span><br><span class="line">插入模式</span><br><span class="line">为了在文件中添加文本，首先我们必须进入插入模式。按下”i”按键进入插入模式，按下    Esc    按键，返回命令模式。</span><br><span class="line"></span><br><span class="line">--    INSERT    --</span><br><span class="line"></span><br><span class="line">保存我们的工作</span><br><span class="line">在命令模式下输入一个    ex    命令（ex操作为命令模式下的操作）。    通过按下”:”键。为了写入我们修改的文件，我们在冒号之后输入”w”字符，然后按下回车键</span><br><span class="line"></span><br><span class="line">:w</span><br><span class="line"></span><br><span class="line">移动光标</span><br><span class="line">当在    vi    命令模式（不是插入模式）下时，vi    提供了大量的移动命令</span><br><span class="line">|    0    (零按键)    |    移动到当前行的行首。    |</span><br><span class="line">|    $    |    移动到当前行的末尾。    |</span><br><span class="line">|    Ctrl-f    or    Page    Down    |    向下翻一页    |</span><br><span class="line">|    Ctrl-b    or    Page    Up    |    向上翻一页    |</span><br><span class="line">|    G    |    移动到文件末尾。    |</span><br><span class="line"></span><br><span class="line">基本编辑</span><br><span class="line">如果我们按下“u”    按键，当在命令模式下，vi    将会撤销你所做的最后一次修改</span><br><span class="line">如果我们想要在这个句子的末尾添加一些文本，输入”a”，在光标处，vi    进入插入模式。”A”命令，在行尾进入插入模式。另外还有：</span><br><span class="line">|    o    |    当前行的下方打开一行。    |，进入插入模式</span><br><span class="line">|    O    |    当前行的上方打开一行。    | ，进入插入模式</span><br><span class="line">记住按下    Esc    按键来退出插入模式。</span><br><span class="line"></span><br><span class="line">删除文本</span><br><span class="line">表13-3:    文本删除命令</span><br><span class="line">|    命令    |    删除的文本    |</span><br><span class="line">|-------|---------|</span><br><span class="line">|    x    |    当前字符    |</span><br><span class="line">|    3x    |    当前字符及其后的两个字符。    |</span><br><span class="line">|    dd    |    当前行。    |</span><br><span class="line">|    5dd    |    当前行及随后的四行文本。    |</span><br><span class="line">|    d$    |    从光标位置开始到当前行的行尾。    |</span><br><span class="line">|    d0    |    从光标位置开始到当前行的行首。    |</span><br><span class="line"></span><br><span class="line">剪切，复制和粘贴文本</span><br><span class="line">这个    d    命令不仅删除文本，它还“剪切”文本。每次我们使用    d    命令，删除的部分被复制到一个    粘贴缓</span><br><span class="line">冲区中（看作剪切板）。过后我们执行小    p    命令把剪切板中的文本粘贴到光标位置之后，    或者是大    P    命</span><br><span class="line">令把文本粘贴到光标之前。</span><br><span class="line"></span><br><span class="line">y    命令用来“拉”（复制）文本。p命令粘贴。</span><br><span class="line">表13-4:    复制命令</span><br><span class="line">|    命令    |    复制的内容    |</span><br><span class="line">|-------|---------|</span><br><span class="line">|    yy    |    当前行。    |</span><br><span class="line">|    5yy    |    当前行及随后的四行文本。    |</span><br><span class="line">|    y$    |    从当前光标位置到当前行的末尾。    |</span><br><span class="line">|    y0    |    从当前光标位置到行首。    |</span><br><span class="line"></span><br><span class="line">查找和替换</span><br><span class="line">查找一行：   f    命令查找一行，移动光标到下一个所指定的字符上。例如，命令    fa    会把光标定位到同一行中    下一个出现的”a”字符上。在一行中执行了字符的查找命令之后，通过输入分号来重复这个查找。</span><br><span class="line"></span><br><span class="line">查找整个文件：移动光标到下一个出现的单词或短语上，使用    /    命令。下一步，输入要查找的单词或短语后，  按下回车。光标就会移动到下一个包含所查找字符串的位置。通过    n    命令来重复先前的查找</span><br></pre></td></tr></table></figure>
<p> 全局查找和替代vi 使用 ex 命令来执行查找和替代操作（vi 中叫做“替换”）。把整个文件中的单词“Line”更改为“line”， 我们输入以下命令： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:%s/Line/line/g</span><br></pre></td></tr></table></figure>
<p><img src="/2018/06/10/Linux/The Linux Command Line学习笔记（二）/01.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">需要用户确认的替换命令。通过添加一个”c”字符到这个命令的末尾，来完成    这个替换命令。例如：</span><br><span class="line"></span><br><span class="line">:%s/line/Line/gc</span><br><span class="line">这个命令会把我们的文件恢复先前的模样；然而，在执行每个替换命令之前，vi    会停下来，    通过下面的信</span><br><span class="line">息，来要求我们确认这个替换：</span><br><span class="line"></span><br><span class="line">replace    with    Line    (y/n/a/q/l/^E/^Y)?</span><br><span class="line">表13-5:    替换确认按键</span><br><span class="line">|    按键    |    行为    |</span><br><span class="line">|-------|---------|</span><br><span class="line">|    y    |    执行替换操作    |</span><br><span class="line">|    n    |    跳过这个匹配的实例    |</span><br><span class="line">|    a    |    对这个及随后所有匹配的字符串执行替换操作。    |</span><br><span class="line">|    q    or    esc    |    退出替换操作。    |</span><br><span class="line">|    l    |    执行这次替换并退出。l    是    “last”    的简写。    |</span><br><span class="line">|    Ctrl-e,    Ctrl-y    |    分别是向下滚动和向上滚动。用于查看建议替换的上下文。    |</span><br><span class="line"></span><br><span class="line">文件之间转换</span><br><span class="line">从这个文件转到下一个文件，使用这个    ex    命令：</span><br><span class="line"></span><br><span class="line">:n</span><br><span class="line">回到先前的文件使用：</span><br><span class="line"></span><br><span class="line">:N</span><br><span class="line">当我们从一个文件移到另一个文件时，如果当前文件没有保存修改，vi    会阻止我们转换文件，    这是    vi    强制执行的政策。在命令之后添加感叹号，可以强迫    vi    放弃修改而转换文件。</span><br><span class="line">我们可以查看正在编辑的文件列表，使用:buffers    命令</span><br><span class="line">:buffers</span><br><span class="line"></span><br><span class="line">1    #       &quot;foo.txt&quot;                             line    1</span><br><span class="line">2    %a      &quot;ls-output.txt&quot;                       line    0</span><br><span class="line">Press    ENTER    or    type    command    to    continue</span><br><span class="line">注意：你不同通过:n    或:N    命令在由:e    命令加载的文件之间进行切换。这时要使用:buffer    命令，    其后加上缓冲区号码，来转换文件。</span><br><span class="line"></span><br><span class="line">从一个文件复制内容到另一个文件</span><br><span class="line">以打开的两个文件为例，首先转换到缓冲区1（foo.txt）    ，输入：</span><br><span class="line"></span><br><span class="line">:buffer    1</span><br><span class="line"></span><br><span class="line">我们应该得到以下输出：</span><br><span class="line"></span><br><span class="line">The    quick    brown    fox    jumped    over    the    lazy    dog.    It    was    cool.</span><br><span class="line">Line    2</span><br><span class="line">Line    3</span><br><span class="line">Line    4</span><br><span class="line">Line    5</span><br><span class="line">下一步，把光标移到第一行，并且输入    yy    来复制这一行。转换到第二个缓冲区，输入：</span><br><span class="line"></span><br><span class="line">:buffer    2</span><br><span class="line">现在屏幕会包含一些文件列表（这里只列出了一部分）：</span><br><span class="line"></span><br><span class="line">total    343700</span><br><span class="line">-rwxr-xr-x    1    root    root                31316        2007-12-05        08:58    [</span><br><span class="line">....</span><br><span class="line">移动光标到第一行，输入    p    命令把我们从前面文件中复制的一行粘贴到这个文件中：</span><br><span class="line"></span><br><span class="line">total    343700</span><br><span class="line">The    quick    brown    fox    jumped    over    the    lazy    dog.    It    was    cool.</span><br><span class="line">-rwxr-xr-x    1    root    root                31316        2007-12-05        08:58    [</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">保存工作</span><br><span class="line">像    vi    中的其它操作一样，有几种不同的方法来保存我们所修改的文件。我们已经研究了:w    这个    ex    命令，但还有几种方法，可能我们也觉得有帮助。</span><br><span class="line">在命令模式下，输入    ZZ    就会保存并退出当前文件</span><br></pre></td></tr></table></figure>
<h2 id="第十四章：自定制shell提示符"><a href="#第十四章：自定制shell提示符" class="headerlink" title="第十四章：自定制shell提示符"></a>第十四章：自定制shell提示符</h2><p>并不是每个人都会花心思来更改提示符，因为通常默认的提示符就很让人满意</p>
<h2 id="第十五章：软件包管理"><a href="#第十五章：软件包管理" class="headerlink" title="第十五章：软件包管理"></a>第十五章：软件包管理</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">软件包管理是指系统中一种安装和维护软件的方法，inux    系统中几乎所有的软件都可以在互联网上找到。其中大多数软件由发行商以    包文件的形式提供，剩下的则以源码形式存在，可以手动安装。在后面章节里，我们将会谈谈怎样    通过编译源码来安装软件。</span><br><span class="line"></span><br><span class="line">查找资源库中的软件包</span><br><span class="line">|    Red    Hat    |    yum    search    search_string    |</span><br><span class="line">例如：yum    search    emacs</span><br><span class="line"></span><br><span class="line">从资源库中安装一个软件包</span><br><span class="line">|    Red    Hat    |    yum    install    package_name    |</span><br><span class="line"></span><br><span class="line">通过软件包文件来安装软件</span><br><span class="line">如果从某处而不是从资源库中下载了一个软件包文件，可以使用底层工具来直接（没有经过依赖解析）安装它。</span><br><span class="line">|    Red    Hat    |    rpm    -i    package_file    |</span><br><span class="line"></span><br><span class="line">卸载软件</span><br><span class="line">|    Red    Hat    |    yum    erase    package_name    |</span><br><span class="line"></span><br><span class="line">经过资源库来更新软件包</span><br><span class="line">|    Red    Hat    |    yum    update    |</span><br><span class="line"></span><br><span class="line">经过软件包文件来升级软件</span><br><span class="line">如果已经从一个非资源库网站下载了一个软件包的最新版本，可以安装这个版本，用它来    替代先前的版本：</span><br><span class="line">|    Red    Hat    |    rpm    -U    package_file    |</span><br><span class="line"></span><br><span class="line">列出所安装的软件包</span><br><span class="line">|    Red    Hat    |    rpm    -qa    |</span><br><span class="line"></span><br><span class="line">确定是否安装了一个软件包</span><br><span class="line">|    Red    Hat    |    rpm    -q    package_name    |</span><br><span class="line"></span><br><span class="line">查找安装了某个文件的软件包</span><br><span class="line">|    Red    Hat    |    rpm    -qf    file_name    |</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>The Linux Command Line学习笔记（一）</title>
    <url>/2018/06/07/Linux/The%20Linux%20Command%20Line%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>记录读《The Linux Command Line》的学习笔记，因为之前是记在印象笔记里面的，格式有点对不上，这里内容就全部粘贴到代码框里面。</p>
<p><a href="https://sevencai.github.io/2018/08/10/The-Linux-Command-Line-读书笔记（一）/" target="_blank" rel="noopener">另外一篇此书的学习笔记博客</a></p>
<hr>
<h2 id="文件查看"><a href="#文件查看" class="headerlink" title="文件查看"></a>文件查看</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`pwd  —  打印出当前工作目录名`</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`ls    —    列出目录内容ls -l  # 长模式ls -l  # 修改时间排序ls -a # 显示所用文件，默认不显示隐藏文件ls -S  # 按大小排序me@linuxbox    ~]$    ls    /usr   # 除了当前工作目录以外，也可以指定要列出内容的目录[me@linuxbox    ~]$    ls    ~    /usr #列出多个指定目录的内容 ,家目录（用字符“~”代表）`</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd    —    更改目录</span><br><span class="line">符号    “.”    指的是工作目录（找下一层使用，一般可省略使用），”..”    指的是工作目录的父目录（找上一层使用）</span><br><span class="line">|    cd    |    更改工作目录到你的家目录。    |</span><br><span class="line">|    cd    -    |    更改工作目录到先前的工作目录。    |</span><br><span class="line">|    cd    ~user_name    |    更改工作目录到用户家目录。例如,    cd    ~bob    会更改工作目录到用户“bob”的家目</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">linux一切皆文件，不依赖后缀名判断</span><br><span class="line">使用 file 打印文件描述</span><br><span class="line">me@linuxbox    ~]$    file    picture.jpg</span><br><span class="line">picture.jpg:    JPEG    image    data,    JFIF    standard    1.01</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">less浏览文本文件内容，以下是常用命令</span><br><span class="line">|    G    |    移动到最后一行    |</span><br><span class="line">|    1G    or    g    |    移动到开头一行    |</span><br><span class="line">|    /charaters    |    向前查找指定的字符串    |</span><br><span class="line">|    q    |    退出    less    程序    |</span><br><span class="line">|    h    |    显示帮助屏幕    |</span><br></pre></td></tr></table></figure>
<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">接受文件名作为参数的任何命令，都可以使用通配符，要记得一些简单的规则（类似正则）</span><br><span class="line">cp   item1 item2 —    复制文件和目录</span><br><span class="line">mv  item1 item2—    移动/重命名文件和目录</span><br><span class="line">mkdir  dir1  —    创建目录</span><br><span class="line">rm   item1 —    删除文件和目录（一旦删除不可恢复，慎重使用）</span><br><span class="line">ln    —    创建硬链接和符号链接</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这里列举了    cp    命令一些有用的选项（短选项和等效的长选项）：其他操作也类同</span><br><span class="line">|    -a,    --archive    |    复制文件和目录，以及它们的属性，包括所有权和权限。</span><br><span class="line">|    -i,    --interactive    |    在重写已存在文件之前，提示用户确认</span><br><span class="line">|    -r,    --recursive    |    递归地复制目录及目录中的内容。当复制目录时，    需要这个选项（或者-a    选项）。    |</span><br><span class="line">|    -u,    --update    |    当把文件从一个目录复制到另一个目录时，仅复制    目标目录中不存在的文件，或者是文</span><br><span class="line">件内容新于目标目录中已经存在的文件。    |</span><br><span class="line">|    -v,    --verbose    |    显示翔实的命令操作信息    |</span><br><span class="line"></span><br><span class="line">rm命令参数选项：</span><br><span class="line">|    -f,    --force    |    忽视不存在的文件，不显示提示信息。这选项颠覆了“--interactive”选项。    |</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`ln    命令即可创建硬链接，也可以创建符号链接。`</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`重命名：[me@linuxbox    playground]$    mv    oldname  newname`</span><br></pre></td></tr></table></figure>
<h2 id="使用命令"><a href="#使用命令" class="headerlink" title="使用命令"></a>使用命令</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type    –    说明怎样解释一个命令名</span><br><span class="line">which    –    显示会执行哪个可执行程序</span><br><span class="line">man    –    显示命令手册页 ，完整正式又复杂</span><br><span class="line">apropos    –    显示一系列适合的命令，基于某个关键字的匹配项搜索</span><br><span class="line">info    –    显示命令    info</span><br><span class="line">whatis    –    显示一个命令的简洁描述</span><br><span class="line">alias    –    创建命令别名</span><br><span class="line"></span><br><span class="line">到底什么是命令？命令可以是下面四种形式之一：</span><br><span class="line">1.     是一个可执行程序，比如说shell，perl，python，ruby，等等。</span><br><span class="line">2.     是一个内建于    shell    自身的命令。cd    命令，就是一个    shell    内部命令。</span><br><span class="line">3.     是一个    shell    函数。</span><br><span class="line">4.     是一个命令别名。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[me@linuxbox    ~]$    type    ls</span><br><span class="line">ls    is    aliased    to    `ls    --color=tty`</span><br><span class="line">[me@linuxbox    ~]$    which    ls</span><br><span class="line">/bin/ls</span><br><span class="line">[me@linuxbox    ~]$    help    cd</span><br><span class="line">cd:    cd    [-L|-P]    [dir]      # 方括号，表示可选的项目。一个竖杠字符    表示互斥选项</span><br><span class="line">[me@linuxbox    ~]$    mkdir    --help   # 显示命令所支持的语法和选项说明</span><br><span class="line">Usage:    mkdir    [OPTION]    DIRECTORY...</span><br><span class="line">[me@linuxbox    ~]$    man    ls   # 手册页的组织形式|    章节    |    内容    |，可以指定章号</span><br><span class="line">[me@linuxbox    ~]$    apropos    floppy   #以”floppy”为关键词来搜索参考手册的</span><br><span class="line">create_floppy_devices    (8)            -    udev    callout    to    create    all    possible #输出结果每行的第一个字段是手册页的名字，第二个字段展示章节。注意，man    命令加上”-k”选项，和    apropos    完成一样的功能。</span><br><span class="line">许多手册页都很难阅读，whatis    程序显示匹配特定关键字的手册页的名字和一行命令说明。</span><br><span class="line">info    － GNU    项目提供了一个命令程序手册页的替代物，称为”info”，输入”info”，接着输入程序名称，启动    info。下表中的命令，当显示一个    info    页面时，    用来控制阅读器。</span><br><span class="line">表    6-2:    info    命令</span><br><span class="line">|    命令    |    行为    |</span><br><span class="line">|    ---    |    ---    |</span><br><span class="line">|    ?    |    显示命令帮助    |</span><br><span class="line">|    Pg Up    or    Backspace    |    显示上一页    |</span><br><span class="line">|    Pg Dn    or    Space    |    显示下一页    |</span><br><span class="line">|    n    |    下一个    -    显示下一个结点    |</span><br><span class="line">|    p    |    上一个    -    显示上一个结点    |</span><br><span class="line">|    u    |    Up    -    显示当前所显示结点的父结点，通常是个菜单    |</span><br><span class="line">|    Enter    |    激活光标位置下的超级链接    |</span><br><span class="line">|    q    |    退出    |</span><br><span class="line"></span><br><span class="line">[me@linuxbox    ~]$    type    test  # 检测新命名是否与系统重名</span><br><span class="line">test    is    a    shell    builtin #重名，需要换一个</span><br><span class="line">[me@linuxbox    ~]$    type    foo  # 检测</span><br><span class="line">bash:    type:    foo:    not    found # 不重名，可以使用这个新命名</span><br><span class="line">[me@linuxbox    ~]$    alias    foo=&apos;cd    /usr;    ls;    cd    -&apos; #通过    alia    命令    把这一串命令转变为一个命令</span><br><span class="line">注意命令结构：alias    name=&apos;string&apos;。在命令”alias”之后，输入“name”，紧接着（没有空格）是一个等号，等号之后是    一串用引号引起的字符串，字符串的内容要赋值给    name</span><br><span class="line">删除别名，使用    unalias    命令，像这样：</span><br><span class="line">[me@linuxbox    ~]$    unalias    foo</span><br><span class="line">[me@linuxbox    ~]$    type    foo</span><br><span class="line">bash:    type:    foo:    not    found</span><br></pre></td></tr></table></figure>
<h2 id="IO重定向"><a href="#IO重定向" class="headerlink" title="IO重定向"></a>IO重定向</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`重定向命令的输入输出，命令的输入来自文件，而输出也存到文件。    也可以把多个命令连接起来组成一个强大的命令管道。为了炫耀这个工具，我们将叙述    以下命令：`</span><br></pre></td></tr></table></figure>
<h2 id="第八章：从shell眼中看世界"><a href="#第八章：从shell眼中看世界" class="headerlink" title="第八章：从shell眼中看世界"></a>第八章：从shell眼中看世界</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo    是一个    shell    内部命令，来完成非常简单的任务。    它在标准输出中打印出它的文本参数。</span><br><span class="line"></span><br><span class="line">[me@linuxbox    ~]$    echo    this    is    a    test</span><br><span class="line">this    is    a    test</span><br><span class="line">[me@linuxbox    ~]$    echo    *</span><br><span class="line">Desktop    Documents    ls-output.txt    Music    Pictures    Public    Templates    Videos</span><br><span class="line"></span><br><span class="line">为什么    echo    不打印“*”呢，最简单的答案就是在    echo    命令被执行前，    shell    把“*”展开成了    另外的东西（在这种情况下，就是在当前工作目录下的文件名字）</span><br><span class="line">类似还有</span><br><span class="line"></span><br><span class="line">[me@linuxbox    ~]$    echo    this    is    a                test</span><br><span class="line">this    is    a    test</span><br><span class="line">[me@linuxbox    ~]$    echo    The    total    is    $100.00</span><br><span class="line">The    total    is    00.00  # $1的值替换为一个空字符串，因为 1 是没有定义的变量</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">路径名展开</span><br><span class="line">这种通配符（即*）工作机制叫做路径名展开（当前工作目录下的文件名字）</span><br><span class="line"></span><br><span class="line">[me@linuxbox    ~]$    echo    D*</span><br><span class="line">Desktop        Documents  #列出当前工作目录下的D开头的文件名字</span><br><span class="line"></span><br><span class="line">波浪线展开</span><br><span class="line">波浪线字符(“~”)有特殊的意思。当它用在    一个单词的开头时，它会展开成指定用户的家目录名，如果没有指定用户名，则是当前用户的家目录：</span><br><span class="line"></span><br><span class="line">[me@linuxbox    ~]$    echo    ~</span><br><span class="line">/home/me</span><br><span class="line"></span><br><span class="line">算术表达式展开</span><br><span class="line">shell    允许算术表达式通过展开来执行。这允许我们把    shell    提示当作计算器来使用：</span><br><span class="line"></span><br><span class="line">[me@linuxbox    ~]$    echo    $((2    +    2))</span><br><span class="line">4</span><br><span class="line">|    /    |    除（取整数除法，所以结果是整数。）    |</span><br><span class="line">|    %    |    取余，只是简单的意味着，“余数”    |</span><br><span class="line">|    **    |    取幂    |</span><br><span class="line"></span><br><span class="line">[me@linuxbox    ~]$    echo    Five    divided    by    two    equals    $((5/2))</span><br><span class="line">Five    divided    by    two    equals    2</span><br><span class="line">[me@linuxbox    ~]$    echo    with    $((5%2))    left    over.</span><br><span class="line">with    1    left    over.</span><br><span class="line"></span><br><span class="line">花括号展开</span><br><span class="line">可能最奇怪的展开是花括号展开。通过它，你可以从一个包含花括号的模式中    创建多个文本字符串。例子：</span><br><span class="line"></span><br><span class="line">[me@linuxbox    ~]$    echo    Front-&#123;A,B,C&#125;-Back</span><br><span class="line">Front-A-Back    Front-B-Back    Front-C-Back</span><br><span class="line">[me@linuxbox    ~]$    echo    &#123;Z..A&#125; #可以一系列整数和字符</span><br><span class="line">Z    Y    X    W    V    U    T    S    R    Q    P    O    N    M    L    K    J    I    H    G    F    E    D    C    B    A</span><br><span class="line">[me@linuxbox    ~]$    echo    a&#123;A&#123;1,2&#125;,B&#123;3,4&#125;&#125;b  #嵌套</span><br><span class="line">a A1b    a A2b    a B3b    a B4b</span><br><span class="line"></span><br><span class="line">命令替换</span><br><span class="line">命令替换允许我们把一个命令的输出作为一个展开模式来使用：</span><br><span class="line"></span><br><span class="line">me@linuxbox    ~]$    echo    $(ls)</span><br><span class="line">Desktop    Documents    ls-output.txt    Music    Pictures    Public    Templates      Videos</span><br><span class="line">[me@linuxbox    ~]$    ls    -l    $(which    cp) #把 which cp的执行结果作为一个参传递给ls命令</span><br><span class="line">-rwxr-xr-x    1    root    root    71516    2007-12-05    08:58    /bin/cp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">双引号、单引号</span><br><span class="line">双意味着单词分割，路径名展开，    波浪线展开，和花括号展开都被禁止，然而参数展开，算术展开，和命令替换    仍然执行。</span><br><span class="line">单引号所有都被禁止。</span><br><span class="line">[me@linuxbox    ~]$    echo    text    ~/*.txt    &#123;a,b&#125;    $(echo    foo)    $((2+2))    $USER</span><br><span class="line">text    /home/me/ls-output.txt    a    b    foo    4    me</span><br><span class="line">[me@linuxbox    ~]$    echo    &quot;text    ~/*.txt    &#123;a,b&#125;    $(echo    foo)    $((2+2))    $USER&quot;</span><br><span class="line">text    ~/*.txt            &#123;a,b&#125;    foo    4    me</span><br><span class="line">[me@linuxbox    ~]$    echo    &apos;text    ~/*.txt    &#123;a,b&#125;    $(echo    foo)    $((2+2))    $USER&apos;</span><br><span class="line">text    ~/*.txt        &#123;a,b&#125;    $(echo    foo)    $((2+2))    $USER</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">转义字符&apos;\&apos;</span><br><span class="line">|    \a    |    响铃（”警告”－导致计算机嘟嘟响）    |</span><br><span class="line">|    \b    |    退格符    |</span><br><span class="line">|    \n    |    新的一行。在类    Unix    系统中，产生换行。    |</span><br><span class="line">|    \r    |    回车符    |</span><br><span class="line">|    \t    |    制表符    |</span><br></pre></td></tr></table></figure>
<h2 id="第九章：键盘高级操作技巧"><a href="#第九章：键盘高级操作技巧" class="headerlink" title="第九章：键盘高级操作技巧"></a>第九章：键盘高级操作技巧</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`clear    －    清空屏幕`</span><br></pre></td></tr></table></figure>
<h2 id="第十章：权限"><a href="#第十章：权限" class="headerlink" title="第十章：权限"></a>第十章：权限</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`在这一章中，我们将看看这一系统安全的本质部分，会介绍以下命令：`</span><br></pre></td></tr></table></figure>
<p>chmod － 更改文件模式chmod</p>
<p>命令支持两种不同的方法来改变文件模式：1、八进制数字表示法，或 2、 符号表示法。这两种方法都有人用。首先我们讨论一下八进制数字表示法。</p>
<p><img src="/2018/06/07/Linux/The Linux Command Line学习笔记（一）/01.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">通过使用3个八进制数字，我们能够设置文件所有者，用户组，和其他人的权限：</span><br><span class="line">[me@linuxbox    ~]$    chmod    600    foo.txt</span><br><span class="line">通过传递参数    “600”，我们能够设置文件所有者的权限为读写权限，而删除用户组和其他人的所有    权限</span><br><span class="line"></span><br><span class="line">chmod    命令还支持另一种符号表示法，通过字符    “u”，“g”，“o”，和    “a”    的组合来指定    要影响的对象。如果没有指定字符，则假定使用”all”</span><br><span class="line">表10-4:    chmod    命令符号表示法</span><br><span class="line">|||</span><br><span class="line">|-----|-----------|</span><br><span class="line">|    u    |    &quot;user&quot;的简写，意思是文件或目录的所有者。    |</span><br><span class="line">|    g    |    用户组。    |</span><br><span class="line">|    o    |    &quot;others&quot;的简写，意思是其他所有的人。    |</span><br><span class="line">|    a    |    &quot;all&quot;的简写，是&quot;u&quot;,    &quot;g&quot;和“o”三者的联合。    |</span><br><span class="line">执行的操作可能是一个“＋”字符，表示加上一个权限，    一个“－”，表示删掉一个权限，或者是一个“＝”，表示只有指定的权限可用，其它所有的权限被删除。</span><br><span class="line">表10-5:    chmod    符号表示法实例</span><br><span class="line">|||</span><br><span class="line">|-----|-----------|</span><br><span class="line">|    u+x    |    为文件所有者添加可执行权限。    |</span><br><span class="line">|    u-x    |    删除文件所有者的可执行权限。    |</span><br><span class="line">|    +x    |    为文件所有者，用户组，和其他所有人添加可执行权限。    等价于    a+x。    |</span><br><span class="line">|    o-rw    |    除了文件所有者和用户组，删除其他人的读权限和写权限。    |</span><br><span class="line">|    go=rw    |    给群组的主人和任意文件拥有者的人读写权限。如果群组的主人或全局之前已经有了执行的权限，他们将被移除。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">umask    －    设置默认权限</span><br><span class="line"></span><br><span class="line">[me@linuxbox    ~]$    rm    -f    foo.txt</span><br><span class="line">[me@linuxbox    ~]$    umask</span><br><span class="line">0002</span><br><span class="line">运行不带参数的    umask    命令，    看一下当前的掩码值。响应的数值是0002（0022是另一个常用值），这个数值是掩码的八进制表示形式，</span><br><span class="line">以下是掩码0002的八进制表达形式</span><br></pre></td></tr></table></figure>
<p><img src="/2018/06/07/Linux/The Linux Command Line学习笔记（一）/02.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这次自己设置掩码</span><br><span class="line"></span><br><span class="line">[me@linuxbox    ~]$    rm    foo.txt</span><br><span class="line">[me@linuxbox    ~]$    umask    0000</span><br><span class="line">大多数情况下，你不必修改掩码值，系统提供的默认掩码值就很好了</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`更改身份`</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>R导论学习笔记（十）：统计模型</title>
    <url>/2018/05/26/R%E8%AF%AD%E8%A8%80/R%E5%AF%BC%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%EF%BC%89%EF%BC%9A%E7%BB%9F%E8%AE%A1%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/qq_35542779/article/details/78794365" target="_blank" rel="noopener">R语言基本统计分析方法（包及函数）</a></p>
<p><a href="https://www.kaggle.com/erikbruin/house-prices-lasso-xgboost-and-a-detailed-eda" target="_blank" rel="noopener">kaggle R语言实战 —House Prices</a></p>
<p><a href="https://uteric.github.io/R语言学习笔记1/" target="_blank" rel="noopener">其他博主的学习笔记</a></p>
]]></content>
      <categories>
        <category>R语言</category>
      </categories>
      <tags>
        <tag>R语言</tag>
      </tags>
  </entry>
  <entry>
    <title>R导论学习笔记（九）：编写函数</title>
    <url>/2018/05/26/R%E8%AF%AD%E8%A8%80/R%E5%AF%BC%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89%EF%BC%9A%E7%BC%96%E5%86%99%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`一个函数是通过下面的语句形式定义的，`</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`%anything %将以二元操作符（binary operator）的形式在表达式中使用，而不是函数的形式。例如我们用! 作为中间的字符。函数可以如下定义`</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`注意任何在函数内部的普通赋值都是局部的暂时的，当退出函数时都会丢失。如果想在一个函数里面全局赋值或者永久赋值，可以采用“强赋值”（superassignment）操作符&lt;&lt;- 或者采用函数assign()`</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`在众多泛型函数中，plot() 用于图形化显示对象，summary()用于各种类型的概述分析，以及anova() 用于比较统计模型。可以用函数methods() 得到当前对某个类对象可用的泛型函数列表.`</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>R语言</category>
      </categories>
      <tags>
        <tag>R语言</tag>
      </tags>
  </entry>
  <entry>
    <title>R导论学习笔记（八）：概率分布和条件语句</title>
    <url>/2018/05/24/R%E8%AF%AD%E8%A8%80/R%E5%AF%BC%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%92%8C%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<p> R 的统计表 </p>
<p><img src="/2018/05/24/R语言/R导论学习笔记（八）：概率分布和条件语句/01.png" alt></p>
<p> 不同的名字前缀表示不同的含义，d表示概率密度函数，p 表示累积分布函数（cumulative distribution function，CDF），q 表示分位函数以及r 表示随机模拟(random deviates)或者随机数发生器 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我们可以用很多方法分析一个单变量数据集的分布。最简单的办法就是直接看数字。利用函数summary 和fivenum 会得到两个稍稍有点差异的汇总信息。 此外，stem(“茎叶”图)也会反映整个数据集的数字信息。用函数hist 绘制柱状图。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; hist(eruptions)</span><br><span class="line">&gt; ## 让箱距缩小，绘制密度图</span><br><span class="line">&gt; hist(eruptions, seq(1.6, 5.2, 0.2), prob=TRUE)    # seq为范围和箱距，prob为T时显示频率，F时为频数</span><br><span class="line">&gt; lines(density(eruptions, bw=0.1))</span><br><span class="line">&gt; rug(eruptions) # 显示实际的数据点</span><br><span class="line">更为精致的密度图是用函数density 绘制的。在这个例子中，我们加了一条由density 产生的曲线。你可以用试错法（trial-and-error）选择带宽bw（bandwidth）因为默认的带宽值让密度曲线过于平滑</span><br></pre></td></tr></table></figure>
<p><img src="/2018/05/24/R语言/R导论学习笔记（八）：概率分布和条件语句/02.png" alt></p>
<p>函数ecdf 绘制一个数据集的经验累积分布（empirical cumulativedistribution）函数。</p>
<p>分位比较图（Quantile-quantile (Q-Q) plot），又称QQ图，通常用于检验是否满足正态分布</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#    检验是否符合正态分布</span><br><span class="line">norm.test&lt;- function(input.data,alpha=0.05,pic=TRUE)&#123;</span><br><span class="line">    if(pic==TRUE)&#123;#画图形</span><br><span class="line">           dev.new()    # 打开一个新的图形窗口</span><br><span class="line">           par(mfrow=c(2,1))    # 一个图版显示2行,3列</span><br><span class="line">           qqnorm(input.data,main=&quot;qq图&quot;)    </span><br><span class="line">           qqline(input.data)    # 画出QQ图</span><br><span class="line">           hist(input.data,frep=F,main=&quot;直方图和密度估计曲线&quot;)</span><br><span class="line">           lines(density(input.data),col=&quot;blue&quot;) #密度估计曲线</span><br><span class="line">           x&lt;- c(round(min(input.data)):round(max(input.data)))</span><br><span class="line">           lines(x,dnorm(x,mean(input.data),sd(input.data)),col=&quot;red&quot;) #正态分布曲线</span><br><span class="line">    &#125;</span><br><span class="line">    sol&lt;- shapiro.test(input.data)</span><br><span class="line">    if(sol$p.value&gt;alpha)&#123;</span><br><span class="line">        print(paste(&quot;success:服从正态分布,p.value=&quot;,sol$p.value,&quot;&gt;&quot;,alpha))    </span><br><span class="line">    &#125;else&#123;</span><br><span class="line">         print(paste(&quot;error:不服从正态分布,p.value=&quot;,sol$p.value,&quot;&lt;=&quot;,alpha))</span><br><span class="line">    &#125;</span><br><span class="line">    sol</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">利用Shapiro-Wilk方法进行正态检验</span><br><span class="line">&gt; shapiro.test(long)</span><br><span class="line">Shapiro-Wilk normality test</span><br><span class="line">data: long</span><br><span class="line">W = 0.9793, p-value = 0.01052</span><br><span class="line">检验结果，因为W接近1，p值大于0.05，所以数据为正态分布</span><br><span class="line"></span><br><span class="line">利用R自带的Kolmogorov-Smirnov 检验，Kolmogorov-Smirnov检验需要三个输入变量，及数据本身、均值及标准差</span><br><span class="line">&gt; ks.test(long, &quot;pnorm&quot;, mean = mean(long), sd = sqrt(var(long)))</span><br><span class="line">One-sample Kolmogorov-Smirnov test</span><br><span class="line">data: long</span><br><span class="line">D = 0.0661, p-value = 0.4284</span><br><span class="line">alternative hypothesis: two.sided</span><br><span class="line">检验结果，因为p值大于0.05，所以数据为正态分布</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">到现在为止，我们已经学会了单样本的正态性检验。而更常见的操作是比较两个样本的特征。在R 里面，所有“传统”的检验都放在包stats 里面。这个包常常会自动载入。</span><br><span class="line">盒状图（boxplot）为这两组数据提供了简单的图形比较。</span><br><span class="line"></span><br><span class="line">A &lt;- scan()</span><br><span class="line">79.98 80.04 80.02 80.04 80.03 80.03 80.04 79.97</span><br><span class="line">80.05 80.03 80.02 80.00 80.02</span><br><span class="line">B &lt;- scan()</span><br><span class="line">80.02 79.94 79.98 79.97 79.97 80.03 79.95 79.97</span><br><span class="line">boxplot(A, B)</span><br></pre></td></tr></table></figure>
<p><img src="/2018/05/24/R语言/R导论学习笔记（八）：概率分布和条件语句/03.png" alt></p>
<p><img src="/2018/05/24/R语言/R导论学习笔记（八）：概率分布和条件语句/04.png" alt></p>
<p><a href="https://www.sohu.com/a/220236877_434937" target="_blank" rel="noopener">箱型图解释</a></p>
<p><a href="https://www.cnblogs.com/minks/p/4753009.html" target="_blank" rel="noopener">通俗理解T检验和F检验</a></p>
<p>简单来说，通过把所得到的统计检定值与统计学家建立了一些随机变量的概率分布进行比较，证明样本的统计结果不是随机得到的，是有意义的。专业上，P值或sig值为结果可信程度的一个递减指标，如p=0.05提示样本中变量关联有5%的可能是由于偶然性造成的。即假设总体中任意变量间均无关联。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">R 语言的条件语句形式为</span><br><span class="line"></span><br><span class="line">&gt; if (expr1) expr2else expr3</span><br><span class="line">R 语言有下面形式的for 循环架构</span><br><span class="line"></span><br><span class="line">&gt; for (name in expr 1 ) expr 2</span><br><span class="line">其他循环语句包括</span><br><span class="line"></span><br><span class="line">&gt; repeat expr</span><br><span class="line">和语句</span><br><span class="line"></span><br><span class="line">&gt; while (condition) expr</span><br><span class="line">关键字break可以用于结束任何循环，甚至是非常规的。它是结束repeat 循环的唯一办法。</span><br><span class="line">关键字next 可以用来结束一次特定的循环，然后直接跳入“下一次”循环</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>R语言</category>
      </categories>
      <tags>
        <tag>R语言</tag>
      </tags>
  </entry>
  <entry>
    <title>R导论学习笔记（七）：从文件中读取数据</title>
    <url>/2018/05/22/R%E8%AF%AD%E8%A8%80/R%E5%AF%BC%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E4%BB%8E%E6%96%87%E4%BB%B6%E4%B8%AD%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">read.table()函数</span><br><span class="line">为了可以直接读取整个数据框，外部文件常常要求有特定的格式。</span><br><span class="line">• 第一行可以有该数据框各个变量的名字。</span><br><span class="line">• 随后的行中第一个条目是行标签，其他条目是各个变量的值。</span><br><span class="line">有列名字和行标签的输入文件格式：</span><br><span class="line"></span><br><span class="line">Price Floor Area Rooms Age Cent.heat</span><br><span class="line">01 52.00 111.0 830 5 6.2 no</span><br><span class="line">02 54.75 128.0 710 5 7.5 no</span><br><span class="line">03 57.50 101.0 1000 5 4.2 no</span><br><span class="line">04 57.50 131.0 690 6 8.8 no</span><br><span class="line">05 59.75 93.0 900 5 1.9 yes</span><br><span class="line">...</span><br><span class="line">忽略行索引/行标签，可用如下的命令</span><br><span class="line"></span><br><span class="line">&gt; House Price &lt;- read.table(&quot;houses.data&quot;, header=TRUE)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`假定有三个数据向量`</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data() 访问内部标准数据集为了</span><br><span class="line">访问某个特定R包的数据，可以使用参数package，例如data(package=&quot;rpart&quot;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`用edit 调用数据框和矩阵时，R 会产生一个电子表形式的编辑环境。这对在数据集上进行小的修改时非常有用的。它的命令是&gt; xnew &lt;- edit(xold)`</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>R语言</category>
      </categories>
      <tags>
        <tag>R语言</tag>
      </tags>
  </entry>
  <entry>
    <title>R导论学习笔记（六）：列表和数据框</title>
    <url>/2018/05/22/R%E8%AF%AD%E8%A8%80/R%E5%AF%BC%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E5%88%97%E8%A1%A8%E5%92%8C%E6%95%B0%E6%8D%AE%E6%A1%86/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">下面的例子演示怎么创建一个列表：</span><br><span class="line"></span><br><span class="line">&gt; Lst &lt;- list(name=&quot;Fred&quot;, wife=&quot;Mary&quot;, no.children=3,child.ages=c(4,7,9))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`分量常常会被编号的（numbered），并且可以利用这种编号来访问分量。如果列表 Lst 有四个分量，这些分量则可以用Lst[[1]], Lst[[2]], Lst[[3]] 和Lst[[4]]独立访问。如果Lst[[4]] 是一个有下标的数组，那么Lst[[4]][1] 就是该数组的第一个元素。`</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">列表的分量可以被命名，这种情况下可以通过名字访问。此时，可以把字符串形式的分量名字放在列表名后面的双中括号中，或者干脆采用下面的形式</span><br><span class="line"></span><br><span class="line">&gt; name$component name</span><br><span class="line">此在上面给定的例子中，</span><br><span class="line">Lst$name 和Lst[[1]] 返回结果都是&quot;Fred&quot;,</span><br><span class="line">Lst$wife 和Lst[[2]] 返回的则是&quot;Mary&quot;,</span><br><span class="line">而Lst$child.ages[1] 和Lst[[4]][1] 返回一样的数字4。</span><br><span class="line">另外你同样可以在双中括号中使用列表分量的名字，即和Lst$name 等价的Lst[[&quot;name&quot;]]</span><br><span class="line"></span><br><span class="line">这里特别要注意一下Lst[[1]] 和Lst[1] 的差别。[[. . . ]] 是用来选择单个元素的操作符，而[. . . ] 是一个更为一般的下标操作符。因此前者得到的是列表Lst 中的</span><br><span class="line">第一个对象, 并且含有分量名字的命名列表（named list）中的分量名字会被排除在外的。后者得到的则是列表Lst 中仅仅由第一个元素构成的子列表。如果是命名列表，分量名字会传给子列表的。即</span><br><span class="line">Lst[[1]] 得到 Fred</span><br><span class="line">Lst[1] 得到name=&quot;Fred&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">可以通过函数list() 将已有的对象构建成列表。下面的命令</span><br><span class="line"></span><br><span class="line">&gt; Lst &lt;- list(name 1 =object 1 , . . . , name m=object m)将创建一个含有m 个分量的列表Lst。它的分量分别是object 1, . . . , object m，分量名则是由参数得到（命名没有特定要求）。如果这些名字被忽略了，那么分量只有被编号了。当连接函数c() 的参数中有列表对象时，结果就是一个列表模式的对象</span><br><span class="line"></span><br><span class="line">&gt; list.ABC &lt;- c(list.A, list.B, list.C)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`数据框常常会被看作是一个由不同模式和属性的列构成的矩阵。它能以矩阵形式出现，行列可以通过矩阵的索引习惯访问。可以通过函数data.frame 创建符合上面对列(分量)限制的数据框对象：&gt; accountants &lt;- data.frame(home=statef, loot=incomes, shot=incomef)`</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`从外部文件读取一个数据框最简单的方法是使用函数read.table()`</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用$ 符号访问对象不是非常的方便，如accountants$statef。一个非常有用的工具将会使列表或者数据框的分量可以通过它们的名字直接调用。而且这种调用是暂时性的，没有必要每次都显式的引用列表名字。函数attach() 除了可以用目录路径作为参数，也可以使用数据框。假定数据框lentils 有三个变量lentils$u, lentils$v, lentils$w，那么</span><br><span class="line"></span><br><span class="line">&gt; attach(lentils)将把数据框绑定在搜索路径的位置2（position 2）上（注释：R 的搜索路径是一种层状结构，当前搜索位置是1，可以通过函数attach()设置搜索路径的位置2。）。如果位置1没有变量u, v 或w，那么u, v 和w 直接在数据框中访问。因此，下面的命令</span><br><span class="line"></span><br><span class="line">&gt; u &lt;- v+w际上没有替换数据框中的变量u，而是被处于搜索路径位置1工作空间中的变量u 所屏蔽。为了真正改变数据框中的数据，最简单的办法还是使用$ 符号：</span><br><span class="line"></span><br><span class="line">&gt; lentils$u &lt;- v+w去除一个数据框的绑定，可以使用</span><br><span class="line"></span><br><span class="line">&gt; detach()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`如何使用数据框• 处理问题时，将相应的数据框绑定在位置2上，在第1 层的工作目录中存放操作值和临时变量；• 问题结束时，用$ 形式的赋值命令把任何你想保留的变量加入数据框中，然后利用函数detach() 将绑定去除；• 最后去掉工作目录中所有你不想要的变量，尽可能清空临时变量。`</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>R语言</category>
      </categories>
      <tags>
        <tag>R语言</tag>
      </tags>
  </entry>
  <entry>
    <title>R导论学习笔记（五）：数组和矩阵</title>
    <url>/2018/05/21/R%E8%AF%AD%E8%A8%80/R%E5%AF%BC%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E6%95%B0%E7%BB%84%E5%92%8C%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`数组和矩阵的联系：一个矩阵只是一个二维的数组`</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`向量只有在定义了 dim 属性后才能作为数组在R 中使用。假定，z是一个含1500个元素的向量。那么&gt; dim(z) &lt;- c(3,5,100)对dim 属性的赋值使得该向量成一个3 ×5 ×100 的数组。`</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`数据向量（data vector）的值在数组中的排列顺序采用 FORTRAN 方式的数组元素次序，即“按列次序”，也就是说第一下标变化最快，最后下标变化最慢。假定数组a的维数向量是c(3,4,2)，则a 中有3×4×2 = 24 元素，依次为a[1,1,1],a[2,1,1], ..., a[2,4,2], a[3,4,2]。`</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">延续前面的例子，a[2,,] 是一个4 × 2 的数组。它的维度向量为c(4,2)，数据向量依次包括下面的值</span><br><span class="line"></span><br><span class="line">c(a[2,1,1], a[2,2,1], a[2,3,1], a[2,4,1],a[2,1,2], a[2,2,2], a[2,3,2], a[2,4,2])</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a[,,]表示整个数组。这和忽略下标直接使用a 效果是一样的</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">假定我们有一个4 ×5 的数组X，我们可以做如下的事情：</span><br><span class="line">• 以向量的格式取出元素X[1,3], X[2,2] 和X[3,1]，</span><br><span class="line">• 在数组X 中用0替换这些元素。在这个例子中，我们需要一个3 ×2 的下标数组，见下面的代码。</span><br><span class="line"></span><br><span class="line">#  注意顺序是按列加上去的</span><br><span class="line">&gt; x &lt;- array(1:20, dim=c(4,5)) # 产生一个 4 × 5 的数组。</span><br><span class="line">&gt; x</span><br><span class="line">[,1] [,2] [,3] [,4] [,5]</span><br><span class="line">[1,] 1 5 9 13 17</span><br><span class="line">[2,] 2 6 10 14 18</span><br><span class="line">[3,] 3 7 11 15 19</span><br><span class="line">[4,] 4 8 12 16 20</span><br><span class="line"></span><br><span class="line">&gt; i &lt;- array(c(1:3,3:1), dim=c(3,2))</span><br><span class="line">&gt; i # i 是一个 3 × 2 的索引矩阵。</span><br><span class="line">[,1] [,2]</span><br><span class="line">[1,] 1 3</span><br><span class="line">[2,] 2 2</span><br><span class="line">[3,] 3 1</span><br><span class="line">&gt; x[i] # 提取这些元素。</span><br><span class="line">[1] 9 6 3</span><br><span class="line">&gt; x[i] &lt;- 0 # 用0替换这些元素。</span><br><span class="line">&gt; x</span><br><span class="line">[,1] [,2] [,3] [,4] [,5]</span><br><span class="line">[1,] 1 5 0 13 17</span><br><span class="line">[2,] 2 0 10 14 18</span><br><span class="line">[3,] 0 7 11 15 19</span><br><span class="line">[4,] 4 8 12 16 20</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`cbind和rbind分别是根据列和行合并，例如ib &lt;- cbind(1:5, 2)&gt; ib     [,1] [,2][1,]    1    2[2,]    2    2[3,]    3    2[4,]    4    2[5,]    5    2`</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在R中求单变量的频次，直接使用table函数就可以了，比如：</span><br><span class="line"></span><br><span class="line">&gt; table(rpois(100,5))</span><br><span class="line">0  1  2  3  4  5  6  7  8  9 10</span><br><span class="line">1  4  9 22 22 11 11 13  3  2  2    </span><br><span class="line"></span><br><span class="line">同样的，可以使用table函数来求两个或多个变量之间的列联表，比如：</span><br><span class="line">&gt;  table(rpois(100,2),rpois(100,1))       </span><br><span class="line">   0  1  2  3  4  5  </span><br><span class="line">0  7  4  3  0  0  0  </span><br><span class="line">1  8  7  6  1  1  0  </span><br><span class="line">2 14 14  2  2  0  1  </span><br><span class="line">3  6  7  1  1  0  0  </span><br><span class="line">4  2  3  4  2  0  0  </span><br><span class="line">5  1  0  0  0  1  0  </span><br><span class="line">6  0  2  0  0  0  0</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`除了用设定一个向量dim 属性的方法来构建数组，它还可直接通过函数array 将向量转换得到，具体格式为&gt; Z &lt;- array(data vector , dim vector )&gt; Z &lt;- array(0, c(3,4,2))这样就会使得Z 是一个所有值都是0的3 ×4 ×2 数组`</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`数组可用于算术表达式中，并且结果就是一个基于数据向量的对应元素运算而得到的数组。所有操作数的属性dim 必须一致`</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">所谓数组(或向量)a和b的外积,指的是a的每一个元素和b的每一个元素搭配在一起相乘得到的新元素.当然运算规则也可自定义.外积运算符为 %o%(注意:百分号中间的字母是小写的字母o)，也可以用&gt; ab &lt;- outer(a, b, &quot;*&quot;)</span><br><span class="line">例如:</span><br><span class="line"></span><br><span class="line">&gt; a &lt;- 1:2</span><br><span class="line">&gt; b &lt;- 3:5</span><br><span class="line">&gt; d &lt;- a %o% b</span><br><span class="line">&gt; d   </span><br><span class="line">	[,1] [,2] [,3]    # a的每一个元素和b的每一个元素搭配在一起相乘</span><br><span class="line">[1,] 3    4    5</span><br><span class="line">[2,] 6    8    10</span><br><span class="line">注意维数公式为:</span><br><span class="line">dim(d) = c( dim(a) , dim(b) )</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">广义转置：我们可以用命令B &lt;- t(A)表示矩阵A转置，函数nrow(A) 和ncol(A) 将会分别返回矩阵A 的行数和列数。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A*B表示矩阵元素对应相乘（要求行列相同），A%*%B表示矩阵乘法，行列式用法（要求满足m,k × k,n）。</span><br><span class="line"></span><br><span class="line">a &lt;- array(1:9,c(3,3))</span><br><span class="line">b &lt;- array(2,c(3,3))a*ba%*%b     </span><br><span class="line">	[,1] [,2] [,3]</span><br><span class="line">[1,]    2    8   14</span><br><span class="line">[2,]    4   10   16</span><br><span class="line">[3,]    6   12   18     </span><br><span class="line">	[,1] [,2] [,3]</span><br><span class="line">[1,]   24   24   24</span><br><span class="line">[2,]   30   30   30</span><br><span class="line">[3,]   36   36   36</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`函数crossprod() 可以完成“矢积”（crossproduct）运算，也就是说crossprod(X,y) 和t(X) %*% y 等价，但是在运算上更为高效.如果crossprod() 第二个参数忽略了，它将默认和第一个参数一样，即第一个参数和自己进行运算`</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`函数diag() 的含义依赖于它的参数。当v 是一个向量时，diag(v)返回以该向量元素为对角元素的对角矩阵。当M 是一个矩阵时，diag(M) 返回M的对角元素。这和Matlab 中diag() 的用法完全一致。不过有点混乱的是，如果k 是单个值，那么diag(k) 的结果就是k ×k 的方阵！`</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`求解线性方程组是矩阵乘法的逆运算。当下面的命令运行后，&gt; b &lt;- A %*% x（想象多元方程组形式，A的行数为样本数）。如果仅仅给出A 和b，那么x 就是该线性方程组的根。在R 里面，用命令&gt; solve(A,b)求解线性方程组，并且返回x (可能会有一些精度丢失)。注意，在线性代数里面该值表示为x = A−1b ，其中A−1表示A的逆（inverse）。矩阵的逆可以用下面的命令计算，solve(A)不过一般很少用到。在数学上，用直接求逆的办法解x &lt;- solve(A) %*% b相比solve(A,b)不仅低效而且还有一种潜在的不稳定性。用于多元计算的二次型xA−1x可以通过像x %*% solve(A,x)的方式计算得到，而不是直接计算A 的逆。`</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">函数eigen(Sm) 用来计算矩阵Sm 的特征值和特征向量。这个函数的返回值是一个含有values 和vectors 两个分量的列表。ev$val 表示Sm 的特征值向量ev$vec 则是相应特征向量构成的一个矩阵。假定我们仅仅需要特征值，我们可以采用如下的命令：</span><br><span class="line"></span><br><span class="line">&gt; evals &lt;- eigen(Sm)$values</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`函数svd(M) 可以把任意一个矩阵M作为一个参数, 且对M 进行奇异值分解。这包括一个和M 列空间一致的正交列U 的矩阵，一个和M 行空间一致的正交列V 的矩阵，以及一个正元素D 的对角矩阵，如M = U %*% D %*% t(V)`</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">函数lsfit() 返回最小二乘法拟合（Least squares ﬁtting）的结果列表。赋值可以采用入下命令</span><br><span class="line"></span><br><span class="line">&gt; ans &lt;- lsfit(X, y)但实际上，你在回归分析中可能已经习惯使用lm(.) (见线性模型&lt;页码：70&gt;部分) 而不是lsfit()。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">单个因子会把各部分数据分成不同的组。类似的是，一对因子可以实现交叉分组等。 函数table() 可以从等长的不同因子中计算出频率表。如果有k 个因子参数，那么结果将是一个k-维的频率分布数组。假定statef 是一个设定数据向量元素个体所在州的因子，那么下面的赋值</span><br><span class="line"></span><br><span class="line">&gt; statefr &lt;- table(statef)</span><br><span class="line">将会把一个样本中各种状态的频率分布表赋给statefr。这些频率会被排序且以因子的水平特性标记。等价但有点烦琐实现方式如下</span><br><span class="line"></span><br><span class="line">&gt; statefr &lt;- tapply(statef, statef, length)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>R语言</category>
      </categories>
      <tags>
        <tag>R语言</tag>
      </tags>
  </entry>
  <entry>
    <title>R导论学习笔记（四）：有序因子和无序因子</title>
    <url>/2018/05/21/R%E8%AF%AD%E8%A8%80/R%E5%AF%BC%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E6%9C%89%E5%BA%8F%E5%9B%A0%E5%AD%90%E5%92%8C%E6%97%A0%E5%BA%8F%E5%9B%A0%E5%AD%90/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`因子（factor）是一个对等长的其他向量元素进行分类（分组）的向量对象。 R同时提供有序（ordered）和无序（unordered）因子。`</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">注意在字符向量中，“有序”意味着以字母排序的。因子可以简单地用函数factor() 创建：</span><br><span class="line"></span><br><span class="line">&gt; statef &lt;- factor(state)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">函数levels() 可以用来得到因子的水平（levels），相当于分类依据因子</span><br><span class="line"></span><br><span class="line">&gt; levels(statef)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用因子来计算样本中每个州的平均收入的一个例子：</span><br><span class="line"></span><br><span class="line">&gt; state &lt;- c(&quot;tas&quot;, &quot;sa&quot;, &quot;qld&quot;, &quot;nsw&quot;, &quot;nsw&quot;, &quot;nt&quot;, &quot;wa&quot;, &quot;wa&quot;,</span><br><span class="line">&quot;qld&quot;, &quot;vic&quot;, &quot;nsw&quot;, &quot;vic&quot;, &quot;qld&quot;, &quot;qld&quot;, &quot;sa&quot;, &quot;tas&quot;,</span><br><span class="line">&quot;sa&quot;, &quot;nt&quot;, &quot;wa&quot;, &quot;vic&quot;, &quot;qld&quot;, &quot;nsw&quot;, &quot;nsw&quot;, &quot;wa&quot;,</span><br><span class="line">&quot;sa&quot;, &quot;act&quot;, &quot;nsw&quot;, &quot;vic&quot;, &quot;vic&quot;, &quot;act&quot;)&gt; </span><br><span class="line">statef &lt;- factor(state)</span><br><span class="line"></span><br><span class="line"># 查看&gt; statef</span><br><span class="line">[1] tas sa qld nsw nsw nt wa wa qld vic nsw vic qld qld sa</span><br><span class="line">[16] tas sa nt wa vic qld nsw nsw wa sa act nsw vic vic act</span><br><span class="line">Levels: act nsw nt qld sa tas vic wa</span><br><span class="line">&gt; levels(statef)</span><br><span class="line">[1] &quot;act&quot; &quot;nsw&quot; &quot;nt&quot; &quot;qld&quot; &quot;sa&quot; &quot;tas&quot; &quot;vic&quot; &quot;wa&quot;</span><br><span class="line"></span><br><span class="line">&gt; incomes &lt;- c(60, 49, 40, 61, 64, 60, 59, 54, 62, 69, 70, 42, 56,</span><br><span class="line">61, 61, 61, 58, 51, 48, 65, 49, 49, 41, 48, 52, 46,</span><br><span class="line">59, 46, 58, 43)</span><br><span class="line"></span><br><span class="line">我们可以用函数tapply()：</span><br><span class="line">&gt; incmeans &lt;- tapply(incomes, statef, mean)</span><br><span class="line">这将给出一个均值向量。各个元素都用对应的水平名字标记。</span><br><span class="line"></span><br><span class="line">act nsw nt qld sa tas vic wa44.500 57.333 55.500 53.600 55.000 60.500 56.000 52.250</span><br><span class="line">解释：indomes数据在statef的分类/分组情况下，进行mean操作</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`有时候因子的水平有自己的自然顺序并且这种顺序是有意义的。我们需要记录下来可能在进一步的统计分析中用到。函数ordered() 就是用来创建这种有序因子。在其他方面，函数ordered() 和factor 基本完全一样。大多数情况下，有序和无序因子的唯一差别在于前者显示的时候反应了各水平的顺序。另外, 在线性模型拟合的时候，两种因子对应的对照矩阵的意义是完全不同的。`</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>R语言</category>
      </categories>
      <tags>
        <tag>R语言</tag>
      </tags>
  </entry>
  <entry>
    <title>R导论学习笔记（三）：对象</title>
    <url>/2018/05/21/R%E8%AF%AD%E8%A8%80/R%E5%AF%BC%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`R 的对象类型包括数值型（numeric），复数型（complex），逻辑型（logical），字符型（character）和原味型（raw）。向量必须保证它的所有元素是一样的模式。因此任何给定的向量必须明确属于逻辑性，数值型，复数型，字符型或者原味型。注意空向量也有自己的模式。例如，空的字符串向量将会被显示character(0) 和空的数值向量显示为numeric(0)。`</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`一个对象的模式（mode）是该对象基本要素的类型，另外一个所有对象都有的特征是长度（length），模式和长度又叫做一个对象的“内在属性”。`</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`例如，如果z 是一个长为100 的复数向量，那么命令mode(z) 就会得到字符串&quot;complex&quot; 而length(z) 对应的是100。`</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">有一系列类似as.something() 的函数，这些函数主要用于对象模式数据的强制转换，例如&gt; digits &lt;- as.character(z)   # 转为字符形式</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">改变对象长度这一点上，一个“空”的对象仍然有其模式的。例如&gt; e &lt;- numeric()创建了一个数值模式的空向量结构e。类似的是，character()是一个空的字符向量，等等。一旦一个任意长度的对象被创建，新元素可以通过给定一个在先前索引范围外的索引值而加入。因此&gt; e[3] &lt;- 17将创建一个长度为3的向量e(此时，前两个元素都是NA)。相反，删减一个对象的大小只需要用赋值操作。因此，如果alpha 是一个长度为10的对象，那么&gt; alpha &lt;- alpha[2 * 1:5]将创建一个由偶数索引位值上的元素构成的长度为5的对象(此时，老的索引将会被抛弃)。我们可以用下面命令仅仅保留起始的三个值&gt; length(alpha) &lt;- 3一个向量也可以用同样的办法扩充（扩充部分用缺损值）。</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>R语言</category>
      </categories>
      <tags>
        <tag>R语言</tag>
      </tags>
  </entry>
  <entry>
    <title>R导论学习笔记（二）：算术操作和向量运算</title>
    <url>/2018/05/20/R%E8%AF%AD%E8%A8%80/R%E5%AF%BC%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E7%AE%97%E6%9C%AF%E6%93%8D%E4%BD%9C%E5%92%8C%E5%90%91%E9%87%8F%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">假如我们要创建一个含有五个数值的向量x，且这五个值分别为10.4，5.6，3.1，6.4 和21.7，则 R 中的命令为</span><br><span class="line"></span><br><span class="line">&gt; x &lt;- c(10.4, 5.6, 3.1, 6.4, 21.7)</span><br><span class="line">赋值也可以用函数assign() 实现。下面的命令和前面的赋值命令等价：</span><br><span class="line"></span><br><span class="line">&gt; assign(&quot;x&quot;, c(10.4, 5.6, 3.1, 6.4, 21.7))进一步的赋值，会创建一个含有11个元素的向量y，其中包括两份x 拷贝和位于中间的一个0。</span><br><span class="line"></span><br><span class="line">&gt; y &lt;- c(x, 0, x)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在算术表达式中使用向量将会对该向量的每一个元素都进行同样算术运算。出现在同一个表达式中的向量最好是长度一致。如果他们的长度不一样，该表达式的值将是一个和其中最长向量等长的向量。表达式中短的向量会被循环使用（recycled）(可能是部分的元素)以达到最长向量的长度。利用前面例子中的变量，命令</span><br><span class="line"></span><br><span class="line">&gt; v &lt;- 2*x + y + 1</span><br><span class="line">将产生一个新的长度为11的向量v。它由2*x 重复2.2次，y 重复一次，1 重复11次得到的向量相加而成。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`sum(x)给出x 中元素的累加和， 而prod(x) 则得到它们的乘积。var(x)则计算样本方差`</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果var() 的参数是一个n×p 的矩阵，则将该矩阵行与行之间看作是相互独立的p-变量的样本向量，从而得到一个p×p 的样本协方差矩阵。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">函数seq() 是数列生成中最为常用的工具。它有五个参数，起始的两个参数，表示一个数列的首尾。如果只是给定这两个值，则和冒号运算符的效果完全一样了。前两个参数就可以用from=value 和to=value 方式设定；</span><br><span class="line"></span><br><span class="line">因此seq(1,30)，seq(from=1, to=30)，seq(to=30, from=1) 同1:30 完全一样。seq() 随后的两个参数是by=value 和length=value；它们分别表示这个数列的步长和长度。如果二者没有设定，默认值就是by=1（步长为1）。</span><br><span class="line"></span><br><span class="line">&gt; seq(-5, 5, by=.2) -&gt; s3</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">还有一个相关的函数是rep()。 它可以用各种复杂的方式重复一个对象。最简单的方式是</span><br><span class="line"></span><br><span class="line">&gt; s5 &lt;- rep(x, times=5)这种方式先把x 的完整拷贝五次，保持x 的数列顺序，逐一放在s5 中。另一种有用的方式是</span><br><span class="line"></span><br><span class="line">&gt; s6 &lt;- rep(x, each=5)这种方式把x 中的每个元素都重复五次，然后将重复五次的元素逐一放入</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">逻辑向量元素可以被赋予的值有TRUE，FALSE 和NA (“不可得到”)逻辑向量可以由条件式（conditions）产生。例如</span><br><span class="line"></span><br><span class="line">&gt; temp &lt;- x &gt; 13        # 得到TRUE or FALSE</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`函数is.na(x) 返回一个和x 同等长度的向量。它的某个元素值为TRUE 当且仅当x中对应元素是NA。`</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`特别要注意的是逻辑表达式x == NA 和is.na(x) 完全不同。因为NA 不是一个真实的值而是一个符号以表示某个量是不可得到的, 因此x == NA 得到的是一个长度和x一致的向量。它的所有 元素的值都是NA.`</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`总之，对于NA 和Na N(数学上无法计算得到) 用is.na(xx) 检验都是 TRUE。为了区分它们，is.nan(xx)就只对是Na N 元素显示TRUE。`</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`通过函数c() 可以把几个字符向量连接成一个字符向量；函数paste() 可以有任意多的参数，并且把它们一个接一个连成字符串。这些参数中的任何数字都将被显式地强制转换成字符串，而且以同样的方式在终端显示。默认的分隔符是单个的空格符，不过这可以被指定的参数修改。参数sep=string 就是将分隔符换成string，这个参数可以设为空。例如，&gt; labs &lt;- paste(c(&quot;X&quot;,&quot;Y&quot;), 1:10, sep=&quot;&quot;)使得labs 变成一个字符向量。c(&quot;X1&quot;, &quot;Y2&quot;, &quot;X3&quot;, &quot;Y4&quot;, &quot;X5&quot;, &quot;Y6&quot;, &quot;X7&quot;, &quot;Y8&quot;, &quot;X9&quot;, &quot;Y10&quot;)`</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`负整数向量索引。这种索引向量指定被排除的元素而不是包括进来。&gt; y &lt;- x[-(1:5)]            #将x 除开始五个元素外的其他元素都赋给y。`</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">字符串向量索引，这可能仅仅用于一个对象可以用names 属性来识别它的元素。</span><br><span class="line"></span><br><span class="line">&gt; fruit &lt;- c(5, 10, 1, 20)</span><br><span class="line">&gt; names(fruit) &lt;- c(&quot;orange&quot;, &quot;banana&quot;, &quot;apple&quot;, &quot;peach&quot;)</span><br><span class="line">&gt; lunch &lt;- fruit[c(&quot;apple&quot;,&quot;orange&quot;)]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>R语言</category>
      </categories>
      <tags>
        <tag>R语言</tag>
      </tags>
  </entry>
  <entry>
    <title>R导论学习笔记（一）：基础</title>
    <url>/2018/05/17/R%E8%AF%AD%E8%A8%80/R%E5%AF%BC%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>记录读《R导论》和《153分钟学会R》 的学习笔记</p>
<hr>
<p>如果你是第一次在UNIX 系统使用 R，我们推荐的操作步骤如下：</p>
<ol>
<li>创建一个独立的子目录work 来保存你要在这个系统上用 R 分析的数据文件。当你用 R 处理这些数据时，这将是你的工作目录。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mkdir work</span><br><span class="line">$ cd work</span><br></pre></td></tr></table></figure>
<ol>
<li><p>用命令启动 R 程序。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ R</span><br></pre></td></tr></table></figure>
</li>
<li><p>此时，可以键入 R 的命令(见后面的内容)。</p>
</li>
<li><p>退出 R 程序的命令是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;q()</span><br></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">为了得到任何特定名字的函数的帮助，如solve，可以使用如下命令 &gt; help(solve)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在大多数 R 平台中，你可以通过运行下面的命令得到HTML 格式的帮助。 &gt; help.start()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">命令可以被(;)隔开，或者另起一行。基本命令可以通过大括弧(&#123;和&#125;) 放在一起构成一个复合表达式（compound expression）。注释几乎可以放在任何地方。一行中，从井号(#)开始到句子收尾之间的语句就是注释。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果一批命令保存在工作目录work 下一个叫commands.R 的文件中，可以用下面的命令在 R 会话中执行这个文件。 &gt; source(&quot;commands.R&quot;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如何清除变量？清除单个变量使用 rm() 函数，清除内存中所有的变量： </span><br><span class="line">rm( l i s t = l s ( a l l = TRUE))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如何得到函数的代码？通常情况你只需要在 R 平台下写出你需要查看的函数名，回车即可。比如：</span><br><span class="line">d i s t</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">但有时候这个函数可能是一个泛型函数（Generic Function），上面的方法就需要稍稍改进一下：先使用 methods() 函数来查看这个类函数的列表，找到具体需要的函数，写出来，回车 ，问题解决。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">summary # It i s a generic funciton</span><br><span class="line">methods (summary) # l i s t of the S3 methods</span><br><span class="line">summary . lm # maybe you want to know the l i n e a r models ’ s summary</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">想查看一个矩阵的前（后）几行， 么办？可以使用 head() 或 tail() 函数。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在 R 中公式的符号都是什么意义？</span><br><span class="line">拿常见的 lm，glm 模型来说，y ˜model 是一种特定的格式，表示以 y 为响应变量，模型为model。其中 model 中的变量由+来连接，或者由: 来表示变量间的 “交互作用”。除了+和 : ，我们使用 ∗来表示′a + b + a : b′。(a + b + c)∧2表示(a + b + c)∗(a + b + c)，即主因素 a、b、c 和各个因素的交互作用。−表示去掉之意。(a + b + c)∧2−a : b表示′a + b + c + b : c + a : c′。在公式表达中除了变量和因子名外，运算符号也是可以存在的。如′log(y) a+log(x)′是合法的。符号. 在 update 函数中有特殊的意义，它表示 “已经存在” 之意。</span><br><span class="line"></span><br><span class="line">1fm &lt;− aov ( Speed ~ Run + Expt)</span><br><span class="line">fm0 &lt;− update (fm , . ~ . − Run)        # .表示之前的旧模型</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">可以将 R 中显示的结果输出到文件么？可以。使用 sink()函数。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">怎样将因子 (factor) 转换为数字</span><br><span class="line"></span><br><span class="line">as . numeric ( as . character ( f ))    #这个点一定要小心，因为对于顺序型 factor 数据，如果强制转化为数值型，会返回的是 factor的顺序信息，而非你看到的 character 信息。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">为什么当我使用 source() 时，不能显示输出结果？</span><br><span class="line"></span><br><span class="line">对需要显示输出的对象使用 print() ，或者使用 source(ﬁle, echo = TRUE)。如果 R 代码里面包含 sink() 之类的函数，必须使用 source(ﬁle, echo = TRUE) 才能得到正确的输出结果，否则 sink 的对象将为空</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在 R 里面使用必须使用双反斜杠或单斜杠表示文件路径，比如：</span><br><span class="line"></span><br><span class="line">d :\\R−2.4.1\\ l i b r a r y \\ xgobi \\ s c r i p t s \\ xgobi . bat</span><br><span class="line">d : /R−2.4.1 / l i b r a r y / xgobi / s c r i p t s / xgobi . bat</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如何删掉缺失值？</span><br><span class="line"></span><br><span class="line">在 R 中使用 NA（not available）表示缺失值，要注意 R（S）语言中 NA 同样是一个逻辑值。使用函数 is.na()来判断是否为缺失值，删除缺失值。</span><br><span class="line">x [ ! i s . na (x ) ]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如何将字符串转变为命令行？</span><br><span class="line"></span><br><span class="line">这里用到 eval() 和 parse() 函数。首先使用 parse() 函数将字符串转化为表达式（expression），而后使用 eval() 函数对表达式求解`</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如何向一个向量 加元素？参考 append()函数。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我的数据框有相同的行，如何去掉这些行？</span><br><span class="line">参考 unique 函数。 duplicated 函数返回了元素是否重复的逻辑值。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如何对数列（array）进行维度变换？</span><br><span class="line">使用函数 apermx &lt;− array (1:24 , 2:4)</span><br><span class="line">xt &lt;− aperm (x , c (2 ,1 ,3))</span><br><span class="line">dim(x) ; dim( xt )</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如何删除 list 中的元素？</span><br><span class="line"></span><br><span class="line">R 中使用 NULL 表示无效的对象。</span><br><span class="line">l s t &lt;− l i s t ( ”a”=l i s t ( ”b”=1,”c”=2) ,”b”=l i s t ( ”d”=3,”e”=4))l s t [ [ ”a” ] ] [ ”b” ] &lt;− NULL # or l s t $a$b &lt;− NULL</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如何对矩阵 行 (列) 作计算？使用函数 apply()</span><br><span class="line"></span><br><span class="line">vec =1:20</span><br><span class="line">mat=matrix ( vec , ncol =4)</span><br><span class="line">vec</span><br><span class="line">cumsum( vec )</span><br><span class="line">mat</span><br><span class="line">apply (mat ,2 ,cumsum)</span><br><span class="line">apply (mat ,1 ,cumsum)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如何注掉大段的 R  程序</span><br><span class="line"></span><br><span class="line">i f (FALSE)&#123;something passby&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一组数中随机抽取数据？参考函数 sample()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如何根据共有的列将两个数据框合并？</span><br><span class="line"></span><br><span class="line">我们经常会遇到两个数据框拥有相同的时间或观测值，但这些列却不尽相同。处理的办法就是使用 merge(x, y ,by.x = ,by.y = ,all = ) 函数。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如何求矩阵各行 (列) 的均值？</span><br><span class="line"></span><br><span class="line">如果运算量不是很大，当然可以使用 apply() 函数。row Means() 和 col Means() 函数可以更快地得到你要的结果。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如何计算组合数或得到所有排列组合？</span><br><span class="line"></span><br><span class="line">choose() 用于计算排列组合数</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如何在 R 里面求（偏）导数？</span><br><span class="line"></span><br><span class="line">使用函数 D()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如何模拟高斯（正态）分布数据？</span><br><span class="line"></span><br><span class="line">使用 rnorm(n , mean , sd) 来产生 n 个来自于均值为 mean，标准差为 sd 的高斯（正态）分布的数据。在 R 里面通过分布前增加字母 ‘d’ 表示概率密度函数，‘p’ 表示累积分布函数，‘q’表示分位数函数，‘r’ 表示产生该分布的随机数</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如何在字符串中选取特定位置的字符？</span><br><span class="line"></span><br><span class="line">参考 substr()函数。substr ( ” abcdef ” ,2 ,4)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这里要区别一下 length，length 函数是返回向量里元素的个数。比如 “你好吗” 是长度为一的向量，但这个元素的字符长度为三，这里就需要使用 nchar 函数：</span><br><span class="line"></span><br><span class="line">nchar ( ’你好吗 ’ )[ 1 ] </span><br><span class="line">3length ( ’你好吗 ’ )[ 1 ] 1</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如何在同一面出多张图？</span><br><span class="line"></span><br><span class="line">修改绘图参数，如 par(mfrow = c(2,2)) 或 par(mfcol = c(2,2))；</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如何在条形图上显示每个 bar 的数值？</span><br><span class="line"></span><br><span class="line">如果明白 barplot() 函数其实是由低级绘图命令 rect() 函数构造的，那下面的例子也就不难理解了：</span><br><span class="line"></span><br><span class="line">x &lt;− 1:10 ; names (x) &lt;− l e t t e r s [ 1 : 1 0 ]</span><br><span class="line">b &lt;− barplot (x , col = rev ( heat . c o l o r s (10)) )</span><br><span class="line">text (b , x , l a b e l s = x , pos = 3)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">没有直接计算峰度和偏度的函数？当然自己写一个也费不了太多时间。FBasics 包中提供了可以直接计算偏度和峰度的函数。</span><br><span class="line"></span><br><span class="line">skewness ()</span><br><span class="line">kurtosis ()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如何得到一个正态总体均值µ的区间估计？很简单，t.test() 函数</span><br><span class="line"></span><br><span class="line">x &lt;− rnorm (100)</span><br><span class="line">t . t e s t (x)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如何做聚类分析？</span><br><span class="line"></span><br><span class="line">K 均值聚类 (kmeans() )：层次聚类 (hclust() )：</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如何做主成分分析？</span><br><span class="line">stats 包中的 princomp 函数（特征根求解），以及 prcomp 函数（奇异值分解）</span><br><span class="line"></span><br><span class="line">( pc . cr &lt;− princomp ( USArrests , cor = TRUE))</span><br><span class="line">plot ( pc . cr , type = ” l i n e s ” # or ” barplot ”) # or s c r e e p l o </span><br><span class="line">tloadings ( pc . cr )</span><br><span class="line">princomp() 中的参数 cor = TRUE 表示使用样本相关矩阵作主成分分析，反之使用样本协方差矩阵。loadings() 返回因子荷载。screeplot() 绘制碎石图。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如何对样本数据进行正态检验？比较常见的方法：</span><br><span class="line"></span><br><span class="line">shapiro.test() ，ks.test()(Kolmogorov-Smirnov 检验) ，jarque.bera.test()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如何做配对 t 检验？参考 t.test() 中的 paired 参数</span><br><span class="line"></span><br><span class="line">require ( s t a t s )</span><br><span class="line">## Student ’ s paired t−t e s t</span><br><span class="line">t . t e s t ( extra ~ group , data = sleep , paired = TRUE)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">多项式回归应该使用什么函数？使用 I() ，例如：</span><br><span class="line"></span><br><span class="line">lm(y ~ x + I (x^2) + I (x^3))</span><br></pre></td></tr></table></figure>
<p> 如何使用方差分析（ANOVA）？<br>方差分析同线性回归模型很类似，毕竟它们都是线性模型。最简单实现方差分析的函数为aov()，通过规定函数内公式形式来指定方差分析类型： </p>
<p><img src="/2018/05/17/R语言/R导论学习笔记（一）：基础/01.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如何求解没有常数项的线性回归模型？只需在公式中引入 0 即可 ：</span><br><span class="line"></span><br><span class="line">r e s u l t &lt;− lm( smokes ~ 0 + male + female , data = smokerdata )</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">回归的命令是？参考 MASS 包中的 lm.ridge() 函数。</span><br><span class="line"></span><br><span class="line">data ( longley ) # not the same as the S−PLUS dataset</span><br><span class="line">names ( longley ) [ 1 ] &lt;− ”y”</span><br><span class="line">lm . ridge (y ~ . , longley )</span><br><span class="line">plot (lm . ridge (y ~ . , longley ,lambda = seq ( 0 , 0 . 1 , 0 . 0 0 1 ) ) )</span><br><span class="line">s e l e c t (lm . ridge (y ~ . , longley ,lambda = seq ( 0 , 0 . 1 , 0 . 0 0 0 1 ) ) )</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`如何使用正交多项式回归？在 R 中，使用 poly() 函数：( z &lt;− poly (1:10 , 3))`</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如何求 Spearman 等级（或 kendall）相关系数？</span><br><span class="line"></span><br><span class="line">cor() 函数默认为求出 Person 相关系数，修改其 method 参数即可求得 Kendallτ和Spearman 秩相关系数。</span><br><span class="line">cor ( longley , method = ”spearman” )</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`如何做 Decision Tree？基于树型方法的模型（Tree-based model）并不被统计学背景的研究者所熟悉，但它在其他领域却时常被广泛应用。下面是 Modern Applied Statistics With S 中的例子，需要加载 rpart包。l i b r a r y ( rpart )set . seed (123)cpus . rp &lt;− rpart ( log10 ( perf ) ~ . , cpus [ , 2 : 8 ] , cp = 1e−3)plot ( cpus . rp , uniform = T)text ( cpus . rp , d i g i t s = 3)`</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">box-cox 变换？MASS 包中的boxcox ()函数。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">R 有类似于 SPSS 的界面么？有！安装包 Rcmdr ，加载包后，使用命令Commander()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`样来计算函数运行使用时间？使用 system.time() 。proc.time() 可以获得 R 进程存在的时间，system.time() 通过调用两次 proc.time() 来计算函数运行的时间。`</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>R语言</category>
      </categories>
      <tags>
        <tag>R语言</tag>
      </tags>
  </entry>
</search>
