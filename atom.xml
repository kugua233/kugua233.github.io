<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mosbyllc</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-01-05T01:45:05.112Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Mosbyllc</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2019年终总结：成为大海，刻不容缓</title>
    <link href="http://yoursite.com/2020/01/04/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/2019%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93%EF%BC%9A%E6%88%90%E4%B8%BA%E5%A4%A7%E6%B5%B7%EF%BC%8C%E5%88%BB%E4%B8%8D%E5%AE%B9%E7%BC%93/"/>
    <id>http://yoursite.com/2020/01/04/年终总结/2019年终总结：成为大海，刻不容缓/</id>
    <published>2020-01-04T12:20:19.000Z</published>
    <updated>2020-01-05T01:45:05.112Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2020/01/04/年终总结/2019年终总结：成为大海，刻不容缓/00.jpg" alt></p><hr><p>​        2019，被大多数温暖环绕，偶尔一些人生瞬间变得冰冷和坚硬，无法躲避。但还好，一切终将过去。总的来说，2019并不简单，生活频繁出拳（胖虎的300斤铁拳，直立对打，凭着经验和运气躲过一些，另外一些结结实实地砸在脸上。可以说每一拳都不含糊，一击重拳，甚至可以感受到在脸上凝固停滞的拳气。不过今年也算是和生活对过几招了，本想着步步清风认真生活，凭阅历自撰一本《人间攻略》，大摇大摆地走上建设社会的征途，没想到生活反手甩一本《人间骚浪贱指南》，害，2019全线崩溃，2020推倒重来，希望今年和生活再次交手能从容一些了。</p><blockquote><p> 「说真的，你将来打算怎么办呢？」「我打算喝完这一杯」</p></blockquote><h2 id="研究生毕业失与得"><a href="#研究生毕业失与得" class="headerlink" title="研究生毕业失与得"></a>研究生毕业失与得</h2><ol><li><strong>毕业</strong> </li></ol><p>研究生三年，形象地说， 从一个小池塘跳到另外一个小池塘中，激起一朵Information Sciences期刊论文小浪花，然后扑通入水无踪影，从二十几岁精壮小伙想掏空世界的功利心来看，不值当。很难想象，这朵靠着身体抽搐翻腾出来小破花有多艰难，为啥别人的象牙塔是导师领进豪华直升电梯，直通塔顶，而我们要一步一爬，唉哟连特么象牙塔都是自己垒起来的，还好最后实验室人手一篇领域(次)顶刊，纷纷告别科研学术，有着不错的工作落脚处，也算是纯粹地感受了一把学术上知其然也知其所以然过程，人生历程多了一份体验，虽然不符预期，但也感激经历。</p><p>学校这几年忙忙忙，感觉也没忙出啥东西来，没发展别的兴趣，甜甜的恋爱还是没轮到我，好像蓝色大门里说的「 夏天就要过去了，我们好像什么都没做」「 是啊，就这样跑来跑去，什么都没做 」「那总会留下些什么吧，留下了什么，我们就会成为怎么样的大人 」</p><p>真要说有哪些值得关注的改变话，觉得还是有一些：</p><ul><li>喜欢上了摇滚乐</li><li>性格从怂包变得小型社恐（到今天似乎消除了，大家都一样，五五开）</li><li>资源搜索能力加强，有需要的东西可以独立自学</li><li>处理感情还是一塌糊涂，不能成熟表达爱与索取爱</li><li>总在试探，都在权衡，消散热爱的能力</li></ul><p>毕业的话，希望自己的期刊论文每年多一次引用吧，谷歌学术搜索排名能前一点，这个新年学术愿望不过分吧。</p><ol><li><strong>就业</strong></li></ol><p>面试造火箭，上班拧螺丝的故事早有耳闻，人力小姐姐萝莉外表杀人诛心可不含糊，论实力与面试的迷一样的相关函数，求职路上太多有意思的故事了，这一路也不容易。</p><p>忙着论文错过了秋招，磕磕碰碰地走上春招这条血路，太难了呀，简直比沥青未干的蜀道还难！一场场大型面试崩溃招聘现场， 黑压压一片学生，排着队递简历，精神上首先就完了。投了简历石沉大海，回来路上，真的是天空突然一道光打在你身上，自我怀疑的高光时刻。二十五岁这场人生三分之一考试，每次到交答卷才发现真的准备的不够充分。春招凭着发表的论文和一些算法竞赛的获奖，获得较多的面试机会，磕磕碰碰，沉舟侧畔，最后也算成功上岸了，有两个比较有印象的故事：</p><p> 1）投了一些大厂算法类的岗位无果后，参加了一个猎头帮改简历的招聘会，那天去的早， 现场没啥人，改完简历后和猎头大叔聊了起来，咔咔咔一顿哭诉当代年轻人的不容易，委屈大王，心酸2019，为啥生活不如意都落我这个失意年轻人的大头上！（那段时间感情状态、生活状态各方面真的是DOWN到深海几万里）。猎头大叔当时说啥我忘记了，总之谈了很久，他让我加油坚持，不要放低要求去小企业得以慰藉，年轻人要有年轻人的样子！我心中一顿爆暖，离开的时候还喊了我回来，握了握手，说很开心和我谈话。</p><p>2）一家基金公司，总裁面，到了给offer阶段，我说还有另外一家在考虑，她说来不来她这里没关系，年轻人找工作要好好考虑，要选对行业和团队，不要盯着一个岗位就上，并给了很多中肯的年轻人意见。我是很信仰人生经验攻略的，这些年一路过来，可太缺参考物了，最后没去还是很谢谢这些不给年轻人画饼，并愿意指导年轻人意见的大佬。</p><p>给毕业求职的同学一些建议：</p><ol><li>不要错过秋春招</li><li>清楚自己的满意和愿意接受的岗位</li><li>校招不像做饭，不需要等万事俱备才开始</li><li>每次多总结复盘，打铁还需自身硬</li><li>小心人力大姐</li></ol><blockquote><p>以上其实都是废话，多面几次自己就有谱了</p></blockquote><p>不管怎样，还是顺利毕业了嘿！</p><p><img src="/2020/01/04/年终总结/2019年终总结：成为大海，刻不容缓/02.jpg" alt></p><h2 id="自我管理"><a href="#自我管理" class="headerlink" title="自我管理"></a>自我管理</h2><p>​        <strong>1.睡眠</strong></p><p><img src="/2020/01/04/年终总结/2019年终总结：成为大海，刻不容缓/03.jpg" alt></p><p>出来搬砖以来，睡眠变得规律很多，七点起床，十点半准时雇人敲晕自己。睡眠时间大概维持在七个半小时，午休半小时，持续搬砖问题不大。周末一般会把一周攒起来的抖音刷一遍，看看天地之间的沙雕，安心睡去。</p><ol><li><strong>记账</strong></li></ol><p><img src="/2020/01/04/年终总结/2019年终总结：成为大海，刻不容缓/05.jpg" alt></p><p>​        不得不说，当代年轻人独立买房还是很艰难，看着每项支出其实也还好，但是汇到一起每月支出都会比想象的多，要是活动多一些也存不了几个钱。今年出来搬砖后，把银行和朋友借的钱都还清，自己日常支出也能稳定下来，这个感觉还是很棒的！</p><p>​        定投指数基金，3000点入场，做一颗茁壮成长的韭菜！</p><ol><li><strong>健康</strong></li></ol><p><img src="/2020/01/04/年终总结/2019年终总结：成为大海，刻不容缓/07.jpg" alt></p><p>​        今年做了个手术，还确诊了过敏性鼻炎，是要提醒自己该更加注意身体健康这一方面了。另外鼻炎应该是学校宿舍那台旧空调造成的，风口对着床吹，还滴水，每次在宿舍鼻子难受的不行，去到实验室马上就好了，弄到这个不治的毛病还是很痛苦的。目前的策略是上班走路走路走路！枸杞枸杞枸杞！泡脚泡脚泡脚！ 健身是没戏了，在学校都没能坚持下来，希望明年能坚持去游个泳吧。</p><h2 id="关于书影音"><a href="#关于书影音" class="headerlink" title="关于书影音"></a>关于书影音</h2><p>​        <img src="/2020/01/04/年终总结/2019年终总结：成为大海，刻不容缓/09.jpg" alt></p><p>五星电影：</p><ul><li>极限职业（韩）</li><li>调音师（印度）</li><li>海蒂和爷爷（德）</li><li>复仇者联盟4（美）</li><li>摇摆狂潮（韩）</li></ul><p>书籍：</p><ul><li>《代码整洁之道—程序员的职业素养》</li><li>《代码整洁之道—Clean》</li><li>《黑客与画家》</li><li>《交换梦想》</li><li>《宇宙超度指南》</li><li>《如何成为一个厉害的人》</li></ul><p>音乐演出</p><ul><li>陈知游园惊梦 2019避雨屋檐巡演</li><li>Brett乐队 2019巡演</li><li>文雀乐队 2019她从来不唱我们的歌巡演</li></ul><p><img src="/2020/01/04/年终总结/2019年终总结：成为大海，刻不容缓/10.png" alt></p><p>今年观影70+，还为观影事业买了个投影仪，每个周末的夜晚，100寸电子辐射的快乐，碳水化合物乐园，灵魂像膨化食品被打开时一样开心的裂开。听歌方面依然是摇滚为主，流行和民谣听一些，没想到居然Andrew Applepie成为了年度歌手，一度认为人类必须牵着手才能听Applepie，哎呀哎呀摇滚死了呀。</p><p>今年看书希望多看些编程类的工具书，数据库、理解框架是目前搬砖进阶的目标。</p><blockquote><p>不要为今年读书太少而难过，去年你也没读多少</p></blockquote><h2 id="Flag！Flag！Flag！"><a href="#Flag！Flag！Flag！" class="headerlink" title="Flag！Flag！Flag！"></a>Flag！Flag！Flag！</h2><ul><li><p>希望今年可以更自信地表达自己</p></li><li><p>搬出来一个人住，养条狗，或养个女朋友</p></li><li><p>尝试视频内容创作</p></li><li><p>开源一个自己感兴趣的工程项目</p></li><li><p>逛一逛动物园，打卡深圳所有公园</p></li><li><p>存钱买老婆</p></li></ul><p>总的来说，2019并不值得被总结，是经历当中最难的一年，有很多至暗时刻不愿提及，没必要铭记些什么，2019过去了就过去了。用一些不太恰当又很冗长的比喻就是， 就像聊了18个月的心理医生突然告诉你，我不能再给你做咨询了，因为我已经爱上你了； 就像一个易碎的老年人正盯着你并且缓缓插队，而你只好故作无睹 ；就像班上倒数第二辅导倒数第一课后习题，并且给出详细的解题思路 。2020不敢说万事顺利，希望新一年遇到的问题都是不太复杂自己慢慢能处理好的，新年加油！</p><p>新的一年，就不祝一帆风顺了，祝大家乘风破浪吧！</p><p>以上</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/2020/01/04/年终总结/2019年终总结：成为大海，刻不容缓/00.jpg&quot; alt&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;​        2019，被大多数温暖环绕，偶尔一些人生瞬间变得冰冷和坚硬，无法躲避。但还好，一切终将过去。总的来说，2019并不
      
    
    </summary>
    
      <category term="年终总结" scheme="http://yoursite.com/categories/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="年终总结" scheme="http://yoursite.com/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>深度学习（四）：循环神经网络</title>
    <link href="http://yoursite.com/2018/12/18/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <id>http://yoursite.com/2018/12/18/深度学习/深度学习（四）：循环神经网络/</id>
    <published>2018-12-18T09:06:13.000Z</published>
    <updated>2019-12-29T01:54:17.291Z</updated>
    
    <content type="html"><![CDATA[<p>在本章中，我们将看到循环神经网络背后的基本概念，他们所面临的主要问题（换句话说，在之前中讨论的消失／爆炸的梯度），以及广泛用于反抗这些问题的方法：LSTM 和 GRU cell（单元）。 循环神经网路主要解决带有时序性质的问题。</p><h2 id="基本循环神经"><a href="#基本循环神经" class="headerlink" title="基本循环神经"></a>基本循环神经</h2><p>看下图中一个简单的循环神经网络图，它由输入层、一个隐藏层和一个输出层组成。我们可以看到，循环神经网络的隐藏层的值s不仅仅取决于当前这次的输入x，<strong>还取决于上一次隐藏层的值s</strong>（结果向前和向后传播后的上一次这个位置的值）。</p><p><img src="/2018/12/18/深度学习/深度学习（四）：循环神经网络/01.jpg" alt></p><p>如果我们把上面的图展开，循环神经网络也可以画成下面这个样子：</p><p><img src="/2018/12/18/深度学习/深度学习（四）：循环神经网络/02.jpg" alt></p><p> 现在看起来就清楚不少了，这个网络在t时刻接收到输入$X<em>t$之后，隐藏层的值是$S_t$，输出值是$o_t$。关键一点是，$s_t$的值不仅仅取决于$X_t$，还取决于$S</em>{t−1}$。我们可以使用下面的公式来表示循环神经网络的计算方法： (U,V,W都为权重) </p><script type="math/tex; mode=display">o_t=g(Vs_t)\\s_t=f(Ux_t+Ws_{t-1})</script><p>式1是输出层的计算公式，输出层是一个全连接层，也就是它的每个节点都和隐藏层的每个节点相连。V是输出层的权重矩阵，g是激活函数。式2是隐藏层的计算公式，它是循环层。U是输入x的权重矩阵，W是上一次的值st−1st−1作为这一次的输入的权重矩阵，f是激活函数。</p><p>从上面的公式可以看出，循环层和全连接层的区别就是多了一个权重矩阵W。</p><p>若反复把式2代入带式1，我们将得到：</p><script type="math/tex; mode=display">o_t=g(Vs_t)=g(Vf(Ux_t+Ws_{t-1}))</script><script type="math/tex; mode=display">=g(Vf(Ux_t+Wf(Ux_{t-1}+Ws_{t-2 })))</script><script type="math/tex; mode=display">=g(Vf(Ux_t+Wf(Ux_{t-1}+Wf(Ux_{t-2}+Ws_{t-3 }))))</script><p> 从上面可以看出，循环神经网络的输出值$o<em>t$，是受前面历次输入值$x_t$、$x</em>{t−1}$、$x_{t−2}$…的影响的，这就是为什么循环神经网络可以往前看任意多个输入值的原因。 </p><p> 再来看一个清晰一点的循环神经元层，见下图， 在每个时间步t，每个神经元都接收输入向量$x^{(t)}$和前一个时间步的输出向量$y^{(t−1)}$，如图所示。 请注意，输入和输出都是向量（当只有一个神经元时，输出是一个标量）。 </p><p><img src="/2018/12/18/深度学习/深度学习（四）：循环神经网络/03.png" alt></p><p> 每个循环神经元有两组权重：一组用于输入 $x^{(t)}$，另一组用于前一时间步长 $y^{(t−1)}$的输出。我们称这些权重向量为$w_x$和$w_y$。如下面公式所示（<code>b</code>是偏差项，<code>φ(·)</code>是激活函数，例如 ReLU），可以计算单个循环神经元的输出。 </p><p><img src="/2018/12/18/深度学习/深度学习（四）：循环神经网络/04.png" alt></p><p> 就像前馈神经网络一样，我们可以使用上一个公式的向量化形式，对整个小批量计算整个层的输出。 </p><p><img src="/2018/12/18/深度学习/深度学习（四）：循环神经网络/05.png" alt></p><ul><li>$Y^{(t)}$是$m×n<em>{neurons}$矩阵，包含在最小批次中每个实例在时间步<code>t</code>处的层输出（<code>m</code>是小批次中的实例数， $n</em>{neurons}$是神经元数</li><li>$X^{(t)}$是$m×n<em>{inputs}$矩阵，包含所有实例的输入的（$n</em>{inputs}$是输入特征的数量 ）</li><li>$W<em>x$是$ n</em>{inputs}×n_{neurons} $矩阵，包含当前时间步的输入的连接权重的。</li><li>$W<em>y$是$n</em>{neurons}×n_{neurons}$矩阵，包含上一个时间步的输出的连接权重。</li><li>权重矩阵$W<em>x$和$W_y$通常连接成单个矩阵W，形状为$(n</em>{inputs}+n<em>{neurons})×n</em>{neurons}$（见上述公式第二行）</li><li><code>b</code>是大小为 $n_{neurons}$的向量，包含每个神经元的偏置项</li></ul><blockquote><p>注意， 在第一个时间步，<code>t = 0</code>，没有以前的输出，所以它们通常被假定为全零。</p></blockquote><h2 id="TensorFlow-中的解释基本-RNN"><a href="#TensorFlow-中的解释基本-RNN" class="headerlink" title="TensorFlow 中的解释基本 RNN"></a>TensorFlow 中的解释基本 RNN</h2><p>首先，我们来实现一个非常简单的 RNN 模型，而不使用任何 TensorFlow 的 RNN 操作，以更好地理解发生了什么。 我们将<strong>使用 tanh 激活函数创建由 5 个循环神经元的循环层组成的 RNN</strong>（如下图所示的 RNN）。</p><p><img src="/2018/12/18/深度学习/深度学习（四）：循环神经网络/03.png" alt></p><p> 我们将假设 RNN <strong>只运行两个时间步</strong>，每个时间步输入大小为 3 的向量。 下面的代码构建了这个 RNN，展开了两个时间步骤： </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">n_inputs = <span class="number">3</span></span><br><span class="line">n_neurons = <span class="number">5</span></span><br><span class="line">X0 = tf.placeholder(tf.float32, [<span class="literal">None</span>, n_inputs])</span><br><span class="line"><span class="comment"># 充当经过向前向后传播后的下一时刻的输入值</span></span><br><span class="line">X1 = tf.placeholder(tf.float32, [<span class="literal">None</span>, n_inputs]) </span><br><span class="line">Wx = tf.Variable(tf.random_normal(shape=[n_inputs, n_neurons], dtype=tf.float32))</span><br><span class="line">Wy = tf.Variable(tf.random_normal(shape=[n_neurons, n_neurons], dtype=tf.float32))</span><br><span class="line">b = tf.Variable(tf.zeros([<span class="number">1</span>, n_neurons], dtype=tf.float32))</span><br><span class="line">Y0 = tf.tanh(tf.matmul(X0, Wx) + b)</span><br><span class="line">Y1 = tf.tanh(tf.matmul(Y0, Wy) + tf.matmul(X1, Wx) + b) <span class="comment"># 主要理解这句</span></span><br><span class="line">init = tf.global_variables_initializer()</span><br></pre></td></tr></table></figure><h2 id="双向循环神经网络"><a href="#双向循环神经网络" class="headerlink" title="双向循环神经网络"></a>双向循环神经网络</h2><p>对于语言模型来说，很多时候光看前面的词是不够的，比如下面这句话：</p><blockquote><p>我的手机坏了，我打算<em>__</em>一部新手机。</p></blockquote><p>可以想象，如果我们只看横线前面的词，手机坏了，那么我是打算修一修？换一部新的？还是大哭一场？这些都是无法确定的，但是如果我们也看到了后面的词是“一部新手机”，那么横线上的词填“买”的概率就大很多了。</p><p>而这个在单向循环神经网络是无法建模的，因此我们需要双向循环神经网络，如下图所示：</p><p><img src="/2018/12/18/深度学习/深度学习（四）：循环神经网络/06.jpg" alt></p><p> 我们先考虑$y_2$的计算，从上图可以看出，双向卷积神经网络的隐藏层要保存两个值，一个A参与正向计算，另一个A′参与反向计算。最终的输出值$y_2$取决于$A_2$和$A_2’$，其计算方法为： </p><script type="math/tex; mode=display">y_2=g(VA_2+V'A_2')</script><p>$A_2$和$A_2’$ 则分别计算 </p><script type="math/tex; mode=display">A_2=f(WA_1+Ux_2)</script><script type="math/tex; mode=display">A_2'=f(W'A_3'+U'x_2 )</script><p> 现在，我们已经可以看出一般的规律：正向计算时，隐藏层的值$s<em>t$与$s</em>{t−1}$有关；反向计算时，隐藏层的值$s<em>t′$与$s′</em>{t+1}$有关；最终的输出取决于正向和反向计算的加和。现在，我们仿照式1和式2，写出双向循环神经网络的计算方法： </p><script type="math/tex; mode=display">o_t=g(Vs_t+V's_t')</script><script type="math/tex; mode=display">s_t=f(Ux_t+Ws_{t-1 })</script><script type="math/tex; mode=display">s_t'=f(U'x_t+W's_{t+1}')</script><p>从上面三个公式我们可以看到，正向计算和反向计算不共享权重，也就是说U和U′、W和W′、V和V′都是不同的权重矩阵。</p><h2 id="深度循环神经网络"><a href="#深度循环神经网络" class="headerlink" title="深度循环神经网络"></a>深度循环神经网络</h2><p>前面我们介绍的循环神经网络只有一个隐藏层，我们当然也可以堆叠两个以上的隐藏层，这样就得到了深度循环神经网络。如下图所示</p><p><img src="/2018/12/18/深度学习/深度学习（四）：循环神经网络/07.jpg" alt></p><h2 id="训练-RNN"><a href="#训练-RNN" class="headerlink" title="训练 RNN"></a>训练 RNN</h2><p>为了训练一个 RNN，诀窍是在时间上展开（就像我们刚刚做的那样），然后简单地使用常规反向传播（见图 14-5）。 这个策略被称为时间上的标准反向传播（BPTT）。另外可以<strong>采用截断式沿时间反向传播算法</strong>（BPTT）可以降低循环网络中每项参数更新的复杂度。简而言之，此种算法可以让我们以同样的运算能力更快地定型神经网络 。假设用长度为12个时间步的时间序列定型一个循环网络。我们需要进行12步的正向传递，计算误差（基于预测与实际值对比），再进行12个时间步的反向传递：</p><p><img src="/2018/12/18/深度学习/深度学习（四）：循环神经网络/08.png" alt></p><p>就像在正常的反向传播中一样，展开的网络（用虚线箭头表示）有第一个正向传递。然后使用损失函数评估输出序列$C(Y<em>{t</em>{min}},Y<em>{t</em>{min+1}},…,Y<em>{t</em>{max}})$。其中$t<em>{min}$ 和$t</em>{max}$ 是第一个和最后一个输出时间步长，不计算忽略的输出），并且该损失函数的梯度通过展开的网络向后传播（实线箭头）；最后使用在 BPTT 期间计算的梯度来更新模型参数。 请注意，梯度在损失函数所使用的所有输出中反向流动，而不仅仅通过最终输出（截断式传播，例如，在图 14-5 中，损失函数使用网络的最后三个输出Y(2)，Y(3)，和Y(4)，所以梯度流经这三个输出，但不通过Y(0)和Y(1)。而且，由于在每个时间步骤使用相同的参数<code>W</code>和<code>b</code>，所以反向传播将做正确的事情并且总结所有时间步骤。</p><p>具体BPTT的解析过程可以看这篇<a href="http://www.cnblogs.com/zhbzz2007/p/6339346.html" target="_blank" rel="noopener">戳我</a></p><h3 id="训练序列分类器"><a href="#训练序列分类器" class="headerlink" title="训练序列分类器"></a>训练序列分类器</h3><p>我们训练一个 RNN 来分类 MNIST 图像。 卷积神经网络将更适合于图像分类，但这是一个你已经熟悉的简单例子。 我们将把每个图像视为 28 行 28 像素的序列（因为每个MNIST图像是<code>28×28</code>像素）。 我们将使用 150 个循环神经元的单元，再加上一个全连接层，其中包含连接到上一个时间步的输出的 10 个神经元（每个类一个），然后是一个 softmax 层（见图）。</p><p><img src="/2018/12/18/深度学习/深度学习（四）：循环神经网络/10.png" alt></p><p> 建模阶段非常简单， 它和我们在之前中建立的 MNIST 分类器几乎是一样的，只是展开的 RNN 替换了隐层。 注意，全连接层连接到状态张量，其仅包含 RNN 的最终状态（即，第 28 个输出）。 另请注意，<code>y</code>是目标类的占位符。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">n_steps = <span class="number">28</span></span><br><span class="line">n_inputs = <span class="number">28</span></span><br><span class="line">n_neurons = <span class="number">150</span></span><br><span class="line">n_outputs = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">learning_rate = <span class="number">0.001</span></span><br><span class="line"></span><br><span class="line">X = tf.placeholder(tf.float32, [<span class="literal">None</span>, n_steps, n_inputs])</span><br><span class="line">y = tf.placeholder(tf.int32, [<span class="literal">None</span>])</span><br><span class="line"></span><br><span class="line">basic_cell = tf.contrib.rnn.BasicRNNCell(num_units=n_neurons)</span><br><span class="line">outputs, states = tf.nn.dynamic_rnn(basic_cell, X, dtype=tf.float32)</span><br><span class="line"></span><br><span class="line">logits = tf.layers.dense(states, n_outputs)</span><br><span class="line">xentropy = tf.nn.sparse_softmax_cross_entropy_with_logits(labels=y,</span><br><span class="line">                                                          logits=logits)</span><br><span class="line">loss = tf.reduce_mean(xentropy)</span><br><span class="line">optimizer = tf.train.AdamOptimizer(learning_rate=learning_rate)</span><br><span class="line">training_op = optimizer.minimize(loss)</span><br><span class="line">correct = tf.nn.in_top_k(logits, y, <span class="number">1</span>)</span><br><span class="line">accuracy = tf.reduce_mean(tf.cast(correct, tf.float32))</span><br><span class="line"></span><br><span class="line">init = tf.global_variables_initializer()</span><br></pre></td></tr></table></figure><p>现在让我们加载 MNIST 数据，并按照网络的预期方式将测试数据重塑为<code>[batch_size, n_steps, n_inputs]</code>。 我们之后会关注训练数据的重塑。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.examples.tutorials.mnist <span class="keyword">import</span> input_data</span><br><span class="line">mnist = input_data.read_data_sets(<span class="string">"/tmp/data/"</span>)</span><br><span class="line">X_test = mnist.test.images.reshape((<span class="number">-1</span>, n_steps, n_inputs))</span><br><span class="line">y_test = mnist.test.labels</span><br></pre></td></tr></table></figure><p>现在我们准备训练 RNN 了。 执行阶段与第 10 章中 MNIST 分类器的执行阶段完全相同，不同之处在于我们在将每个训练的批量提供给网络之前要重新调整。</p><p>现在我们准备训练 RNN 了。 执行阶段与第 10 章中 MNIST 分类器的执行阶段完全相同，不同之处在于我们在将每个训练的批量提供给网络之前要重新调整。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">batch_size = <span class="number">150</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    init.run()</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> range(n_epochs):</span><br><span class="line">        <span class="keyword">for</span> iteration <span class="keyword">in</span> range(mnist.train.num_examples // batch_size):</span><br><span class="line">            X_batch, y_batch = mnist.train.next_batch(batch_size)</span><br><span class="line">            X_batch = X_batch.reshape((<span class="number">-1</span>, n_steps, n_inputs))</span><br><span class="line">            sess.run(training_op, feed_dict=&#123;X: X_batch, y: y_batch&#125;)</span><br><span class="line">        acc_train = accuracy.eval(feed_dict=&#123;X: X_batch, y: y_batch&#125;)</span><br><span class="line">        acc_test = accuracy.eval(feed_dict=&#123;X: X_test, y: y_test&#125;)</span><br><span class="line">        print(epoch, <span class="string">"Train accuracy:"</span>, acc_train, <span class="string">"Test accuracy:"</span>, acc_test)</span><br></pre></td></tr></table></figure><p>输出应该是这样的：</p><p><img src="/2018/12/18/深度学习/深度学习（四）：循环神经网络/11.png" alt></p><p>我们获得了超过 98% 的准确性 - 不错！ 另外，通过调整超参数，使用 He 初始化初始化 RNN 权重，更长时间训练或添加一些正则化（例如，droupout），你肯定会获得更好的结果。</p><p>你可以通过将其构造代码包装在一个变量作用域内（例如，使用<code>variable_scope(&quot;rnn&quot;, initializer = variance_scaling_initializer())</code>来使用 He 初始化）来为 RNN 指定初始化器。</p><h3 id="为预测时间序列而训练"><a href="#为预测时间序列而训练" class="headerlink" title="为预测时间序列而训练"></a>为预测时间序列而训练</h3><p>首先，我们来创建一个 RNN。 它将包含 100 个循环神经元，并且我们将在 20 个时间步骤上展开它，因为每个训练实例将是 20 个输入那么长。 每个输入将仅包含一个特征（在该时间的值）。 目标也是 20 个输入的序列，每个输入包含一个值。 代码与之前几乎相同：</p><p><img src="/2018/12/18/深度学习/深度学习（四）：循环神经网络/12.png" alt></p><p>一般来说，你将不只有一个输入功能。 例如，如果你试图预测股票价格，则你可能在每个时间步骤都会有许多其他输入功能，例如竞争股票的价格，分析师的评级或可能帮助系统进行预测的任何其他功能。</p><p>在每个时间步，我们现在有一个大小为 100 的输出向量。但是我们实际需要的是每个时间步的单个输出值。 最简单的解决方法是将单元包装在<code>OutputProjectionWrapper</code>中。 单元包装器就像一个普通的单元，代理每个方法调用一个底层单元，但是它也增加了一些功能。<code>Out putProjectionWrapper</code>在每个输出之上添加一个完全连接的线性神经元层（即没有任何激活函数）（但不影响单元状态）。 所有这些完全连接的层共享相同（可训练）的权重和偏差项。 结果 RNN 如图所示</p><p><img src="/2018/12/18/深度学习/深度学习（四）：循环神经网络/13.png" alt></p><p>装单元是相当容易的。 让我们通过将<code>BasicRNNCell</code>包装到<code>OutputProjectionWrapper</code>中来调整前面的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cell =tf.contrib.rnn.OutputProjectionWrapper(</span><br><span class="line">    tf.contrib.rnn.BasicRNNCell(num_units=n_neurons,activation=tf.nn.relu),</span><br><span class="line">    output_size=n_outputs)</span><br></pre></td></tr></table></figure><p>到现在为止还挺好。 现在我们需要定义损失函数。 我们将使用均方误差（MSE），就像我们在之前的回归任务中所做的那样。 接下来，我们将像往常一样创建一个 Adam 优化器，训练操作和变量初始化操作。（省略）</p><h3 id="生成-RNN"><a href="#生成-RNN" class="headerlink" title="生成 RNN"></a>生成 RNN</h3><p>到现在为止，我们已经训练了一个能够预测未来时刻样本值的模型，正如前文所述，可以用模型来生成新的序列。</p><p>为模型提供 长度为<code>n_steps</code>的种子序列, 比如全零序列，然后通过模型预测下一时刻的值；把该预测值添加到种子序列的末尾，用最后面 长度为<code>n_steps</code>的序列做为新的种子序列，做下一次预测，以此类推生成预测序列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sequence = [<span class="number">0.</span>] * n_steps</span><br><span class="line"><span class="keyword">for</span> iteration <span class="keyword">in</span> range(<span class="number">300</span>):</span><br><span class="line">    X_batch = np.array(sequence[-n_steps:].reshape(<span class="number">1</span>, n_steps, <span class="number">1</span>)</span><br><span class="line">    y_pred = sess.run(outputs, feed_dict=&#123;X: X_batch&#125;</span><br><span class="line">    sequence.append(y_pred[<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure><h2 id="LSTM-单元"><a href="#LSTM-单元" class="headerlink" title="LSTM 单元"></a>LSTM 单元</h2><p><strong>在训练长序列的 RNN 模型时，那么就需要把 RNN 在时间维度上展开成很深的神经网络</strong>。正如任何深度神经网络一样，其面临着梯度消失/爆炸的问题，使训练无法终止或收敛。很多之前讨论过的缓解这种问题的技巧都可以应用在深度展开的 RNN 网络：好的参数初始化方式，非饱和的激活函数（如 ReLU），批量规范化（Batch Normalization）， 梯度截断（Gradient Clipping），更快的优化器。</p><p>即便如此， RNN 在处理适中的长序列（如 100 输入序列）也在训练时表现的很慢。最简单和常见的方法解决训练时长问题就是在训练阶段仅仅展开限定时间步长的 RNN 网络，一种称为截断时间反向传播的算法。</p><p><strong>在长的时间训练过程中，第二个要面临的问题时第一个输入的记忆会在长时间运行的 RNN 网络中逐渐淡去。 那么在一定时间后，第一个输入实际上会在 RNN 的状态中消失于无形</strong>。 为了解决其中的问题，各种能够携带长时记忆的神经单元的变体被提出。<strong>这些变体是有效的，往往基本形式的神经单元就不怎么被使用了。</strong></p><p>首先了解一下最流行的一种长时记忆神经单元：长短时记忆神经单元 LSTM。 可以看下面这篇文章</p><p><a href="https://www.yunaitong.cn/understanding-lstm-networks.html" target="_blank" rel="noopener">理解LSTM网络</a></p><blockquote><p>注：LSTM和GRU单元是近年来RNN成功背后的主要原因之一，特别实在自然语言的应用</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在本章中，我们将看到循环神经网络背后的基本概念，他们所面临的主要问题（换句话说，在之前中讨论的消失／爆炸的梯度），以及广泛用于反抗这些问题的方法：LSTM 和 GRU cell（单元）。 循环神经网路主要解决带有时序性质的问题。&lt;/p&gt;
&lt;h2 id=&quot;基本循环神经&quot;&gt;&lt;a
      
    
    </summary>
    
      <category term="深度学习" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="循环神经网络" scheme="http://yoursite.com/tags/%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>深度学习（三）：卷积神经网络</title>
    <link href="http://yoursite.com/2018/12/14/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <id>http://yoursite.com/2018/12/14/深度学习/深度学习（三）：卷积神经网络/</id>
    <published>2018-12-14T09:06:13.000Z</published>
    <updated>2019-12-29T01:13:51.552Z</updated>
    
    <content type="html"><![CDATA[<h2 id="认识卷积神经网络"><a href="#认识卷积神经网络" class="headerlink" title="认识卷积神经网络"></a>认识卷积神经网络</h2><p>全连接神经网络之所以不太适合图像识别任务，主要有三个方面的问题：</p><ul><li>参数数量太多，一个输入1000×1000像素的图片有100万个神经元（一个像素点代表一个神经元）</li><li>没有利用像素之间的位置信息</li><li>网络层数限制，网络层数越多，其表达能力越强，但是通过梯度下降方法训练深度全连接神经网络很困难，因为全连接神经网络的梯度很难传递超过三层。</li></ul><h3 id="局部感受野（local-receptive-fields）"><a href="#局部感受野（local-receptive-fields）" class="headerlink" title="局部感受野（local receptive fields）"></a>局部感受野（local receptive fields）</h3><p>在之前的全连接神经网络中，一个样例的输入被转换为一个一维向量。但在一个卷积网络中，把输入看作是一个按照28×28排列的正方形，或者当有颜色通道的时候，比如28x28x3，就是宽高都是28，且有3个颜色通道。比如下图就代表了一个输入</p><p><img src="/2018/12/14/深度学习/深度学习（三）：卷积神经网络/01.jpg" alt></p><p> 然后，我们通常把输入像素连接到一个隐藏层的神经元，但和全连接神经网络那样每个输入都连接一个隐藏层神经元不同的是，这里我们只是把输入图像进行局部的连接。 </p><p><img src="/2018/12/14/深度学习/深度学习（三）：卷积神经网络/02.jpg" alt></p><p>如此不断地重复，构建起第一个隐藏层。注意如果我们有一个28×28的输入图像，5×5的局部感受野，那么隐藏层中就会有24×24个神经元。这是因为在抵达抵达最右边或最底部的输入图像之前，我们只能把局部感受野向右或向下移动23个神经元。</p><p><img src="/2018/12/14/深度学习/深度学习（三）：卷积神经网络/03.jpg" alt></p><p>如上图所示，把图中间的那个看作是可以“滑动的窗口”，他的作用是和输入相应的“感受域”下的像素做运算得到新的值。这个运算就是“卷积”运算了。图上面有详细的运算过程。实际上就是每个相应元素的值相乘，然后把得到的都加起来。这个窗口的本质是其中的数字和一个偏置构成的，通常就把<strong>这个窗口(Convolution kernel)叫做滤波器或者卷积核（相当于是全连接层里面要求的隐藏权重，它代表识别某个特征）</strong>。 这个“窗口”是可以滑动的，每次的滑动步长可以人为指定 。</p><h3 id="池化-Pooling"><a href="#池化-Pooling" class="headerlink" title="池化(Pooling)"></a>池化(Pooling)</h3><p>它的作用是逐渐<strong>降低数据体的空间尺寸，这样的话就能减少网络中参数的数量，使得计算资源耗费变少，也能有效控制过拟合</strong>。最常见的形式是汇聚层使用尺寸2x2的滤波器，以步长为2来对每个深度切片进行降采样，将其中75%的激活信息都丢掉。每个MAX操作是从4个数字中取最大值（也就是在深度切片中某个2x2的区域）。深度保持不变。</p><p>Pooling的方法很多，最常用的是Max Pooling。 此外，还有平均池化（average pooling）和L2-norm池化。</p><p><img src="/2018/12/14/深度学习/深度学习（三）：卷积神经网络/04.jpg" alt></p><h2 id="卷积神经网络的层"><a href="#卷积神经网络的层" class="headerlink" title="卷积神经网络的层"></a>卷积神经网络的层</h2><p>首先，让我们对卷积神经网络有一个感性的认识，下图就是一个卷积神经网络的示意图：</p><p><img src="/2018/12/14/深度学习/深度学习（三）：卷积神经网络/05.jpg" alt></p><p> 如上图所示，一个神经网络由若干卷积层（CONV）、Pooling层（POOL）、全连接层（FC）组成。你可以构建各种不同的卷积神经网络，它的常用架构模式为： </p><script type="math/tex; mode=display">INPUT\rightarrow\left[\left[CONV\right]\times N\rightarrow POOL\right]\times M\rightarrow\left[FC\right]\times K</script><p>也就是N个卷积层叠加，然后叠加一个Pooling层（可选），重复这个结构M次，最后叠加K个全连接层。</p><p>对于上图来说，该卷积神经网络的架构为：</p><script type="math/tex; mode=display">INPUT\rightarrow\left[\left[CONV\right]\times 1\rightarrow POOL\right]\times 2\rightarrow\left[FC\right]\times 2</script><p>也就是N=1,M=2,K=2</p><p>我们看到输入层的宽度和高度对应于输入图像的宽度和高度，而他的深度为1。接着第一个卷积层对这幅图像进行了卷积操作，得到了三个Feature Map。<strong>实际上这个卷积层包含三个Filter（卷积核，是隐藏不显示图上的），也就是三套参数，每个Filter都可以把原始输入图像卷积得到一个Feature Map，三个Filter就可以得到三个Feature Map</strong>。<strong>至于一个卷积层可以有多少个Filter，那是可以自由设定的。也就是说，卷积层的Filter个数也是一个超参数</strong>。<strong>我们可以把Feature Map可以看做是通过卷积变换提取到的图像特征，三个Filter就对原始图像提取出三组不同的特征</strong>，也就是得到了三个Feature Map，也称做三个通道(channel)。</p><p>在第一个卷积层之后，Pooling层对三个Feature Map做了下采样，得到了三个更小的Feature Map。接着，<strong>是第二个卷积层，它有5个Filter</strong>。<strong>每个Fitler都把前面下采样之后的3个Feature Map卷积在一起（每个Fitlter与输入有相同的深度，然后对应相乘后总相加）</strong>，得到一个新的Feature Map。这样，5个Filter就得到了5个Feature Map。接着，是第二个Pooling，继续对5个Feature Map进行下采样，得到了5个更小的Feature Map。</p><p><strong>最后两层是全连接层。第一个全连接层的每个神经元，和上一层5个Feature Map中的每个神经元相连</strong>，第二个全连接层(也就是输出层)的每个神经元，则和第一个全连接层的每个神经元相连，这样得到了整个网络的输出。</p><p>至此，我们对卷积神经网络有了最基本的感性认识。接下来，我们将介绍卷积神经网络中各种层的计算和训练。</p><h3 id="卷积层"><a href="#卷积层" class="headerlink" title="卷积层"></a>卷积层</h3><p>卷积层的参数是一些可学习的滤波器（卷积核，隐藏不显示，相当于全连接层的隐藏权重）构成，<strong>滤波器的宽度和高度一般不大，深度与其输入数据保持一致</strong>。见下图：</p><p><img src="/2018/12/14/深度学习/深度学习（三）：卷积神经网络/06.jpg" alt></p><p><img src="/2018/12/14/深度学习/深度学习（三）：卷积神经网络/07.jpg" alt></p><p><img src="/2018/12/14/深度学习/深度学习（三）：卷积神经网络/08.jpg" alt></p><p><img src="/2018/12/14/深度学习/深度学习（三）：卷积神经网络/09.jpg" alt></p><p><strong>要点</strong>：卷积层有一个或多个滤波器（卷积核）构成，每个卷积核宽度和高度（这里为5×5）一般不大，深度（这里为3）与其输入数据保持一致。这里有6个不同的卷积核，得到的6个不同的activation map分别表示诸如边缘特征、形状特征等特征图，将这些activation map映射在深度方向上层叠起来就生成了输出数据。所以在用了6个过滤器（卷积层）之后，我们可以得到28×28×6的激活图。</p><h3 id="卷积层输出值的计算"><a href="#卷积层输出值的计算" class="headerlink" title="卷积层输出值的计算"></a>卷积层输出值的计算</h3><p>我们使用一个简单的例子来讲述如何计算卷积，然后，抽象出卷积层的一些重要概念和计算方法。</p><p>假设有一个5×5的图像，使用一个3×3的滤波器进行卷积，想得到3×3的Feature Map，如下所示：</p><p><img src="/2018/12/14/深度学习/深度学习（三）：卷积神经网络/10.jpg" alt></p><p> 为了清楚地描述卷积的计算过程，我们首先对图像的每个像素进行编号，用$x<em>{i,j}$表示图像的第i行第j列元素，对filter的每个权重进行编号，用$w</em>{m,n}$表示第m行第n列权重，用$w<em>b$表示filter的偏置项；对Feature Map的每个元素进行编号，用$a</em>{i,j}$表示Feature Map的第i行第j列元素；用f表示激活函数（此处使用Relu函数作为激活函数）。然后使用下列公式计算卷积： </p><script type="math/tex; mode=display">a_{i,j}=f\left(\sum_{m=0}^2{\sum_{n=0}^2{w_{m,n}x_{m+i,n+j}}}+w_b\right)</script><p> 例如，对于Feature Map的左上角元素$a_{0,0}$来说，其卷积计算方法为：</p><script type="math/tex; mode=display">a_{0,0}=f\left(\sum_{m=0}^2{\sum_{n=0}^2{w_{m,n}x_{m+0,n+0}}}+w_b\right)=Relu\left(4\right)=4</script><p> 按照这个公式可以依次计算出Feature Map中所有的值，下面的动画显示了整个Feature Map的计算过程： </p><p><img src="/2018/12/14/深度学习/深度学习（三）：卷积神经网络/11.gif" alt></p><h3 id="填充和步幅"><a href="#填充和步幅" class="headerlink" title="填充和步幅"></a>填充和步幅</h3><p>假设输入形状的$n_h\times n_w$，卷积核窗口形状是$k_h\times k_w$，那么输出的形状将会是</p><script type="math/tex; mode=display">(n_h-k_h+1)\times (n_w-k_w+1)</script><p>所以卷积层的输出形状由输⼊形状和卷积核窗口形状决定。这里我们将介绍卷积层的两个超参数，填充和步幅。它们可以对给定形状的输⼊和卷积核改变输出形状。</p><p><strong>填充</strong>（padding）是指在输入和宽的两侧填充元素（通常是0元素）。下图表示在原输入高的宽的两侧分别添加了值为0的元素，使得高和宽从3变成了5，并导致输出的高和宽由2增加到4.</p><p><img src="/2018/12/14/深度学习/深度学习（三）：卷积神经网络/12.png" alt></p><p>卷积窗口从输⼊数组的最左上⽅开始，按从左往右、从上往下的顺序，依次在输⼊数组上滑动。我们将每次滑动的⾏数和列数称为<strong>步幅</strong>（stride）</p><p>上面的计算过程中，步幅（stride）为1。当然步幅可以设为大于1的数。例如，当步幅为2时，Feature Map计算如下：</p><p><img src="/2018/12/14/深度学习/深度学习（三）：卷积神经网络/13.jpg" alt></p><h3 id="多输入通道"><a href="#多输入通道" class="headerlink" title="多输入通道"></a>多输入通道</h3><p>到此我们讲了深度为1的卷积层的计算方法，如果深度大于1怎么计算呢？其实也是类似的。 下图展⽰了含2个输⼊通道的⼆维互相关计算的例⼦。在每个通道上，⼆维输⼊数组与⼆维核数组做互相关运算，再按通道相加即得到输出。图中阴影部分为第⼀个输出元及其计算所使⽤的输⼊和核数组元素：</p><script type="math/tex; mode=display">(1×1+2×2+4×3+5×4)+(0×0+1×1+3×2+4×3)=56</script><p><img src="/2018/12/14/深度学习/深度学习（三）：卷积神经网络/14.png" alt></p><p> 动画演示 </p><p><img src="/2018/12/14/深度学习/深度学习（三）：卷积神经网络/15.gif" alt></p><h2 id="内存需求"><a href="#内存需求" class="headerlink" title="内存需求"></a>内存需求</h2><p>CNN 的另一个问题是卷积层需要大量的 RAM，特别是在训练期间，因为反向传播需要在正向传递期间计算的所有中间值。</p><p><strong>如果由于内存不足错误导致训练崩溃，则可以尝试减少小批量大小。 或者，您可以尝试使用步幅降低维度，或者删除几个图层。 或者你可以尝试使用 16 位浮点数而不是 32 位浮点数。 或者你可以在多个设备上分发 CNN。</strong></p><h2 id="CNN-架构"><a href="#CNN-架构" class="headerlink" title="CNN 架构"></a>CNN 架构</h2><p>典型的 CNN 体系结构有一些卷积层（每一个通常跟着一个 ReLU 层），然后是一个池化层，然后是另外几个卷积层（+ ReLU），然后是另一个池化层，等等。 随着网络的进展，图像变得越来越小，但是由于卷积层的缘故，图像通常也会越来越深（即更多的特征映射）。 在堆栈的顶部，添加由几个全连接层（+ ReLU）组成的常规前馈神经网络，并且最终层输出预测（例如，输出估计类别概率的 softmax 层）。</p><p><strong>一个常见的错误是使用太大的卷积核。 通常可以通过将两个3×3内核堆叠在一起来获得与9×9内核相同的效果，计算量更少。</strong></p><p>多年来，这种基础架构的变体已经被开发出来，导致了该领域的惊人进步。<strong>这里就不展开讲了，大家感兴趣可以去找相关的论文和资料深入了解这些流行的CNN架构。</strong></p><h3 id="LeNet-5"><a href="#LeNet-5" class="headerlink" title="LeNet-5"></a>LeNet-5</h3><p>LeNet-5 架构也许是最广为人知的 CNN 架构。 如前所述，它是由 Yann LeCun 于 1998 年创建的，广泛用于手写数字识别（MNIST）。</p><p><img src="/2018/12/14/深度学习/深度学习（三）：卷积神经网络/16.png" alt></p><h3 id="AlexNet"><a href="#AlexNet" class="headerlink" title="AlexNet"></a>AlexNet</h3><p>AlexNet CNN 架构赢得了 2012 年的 ImageNet ILSVRC 挑战赛：它达到了 17% 的 top-5 的错误率，而第二名错误率只有 26%！ 它由 Alex Krizhevsky（因此而得名），Ilya Sutskever 和 Geoffrey Hinton 开发。 它与 LeNet-5 非常相似，只是更大更深，它是第一个将卷积层直接堆叠在一起，而不是在每个卷积层顶部堆叠一个池化层。</p><p><img src="/2018/12/14/深度学习/深度学习（三）：卷积神经网络/17.png" alt></p><h3 id="VGG"><a href="#VGG" class="headerlink" title="VGG"></a>VGG</h3><p>它名字来源于论⽂作者所在的实验室Visual Geometry Group。VGG提出了可以通过重复使⽤简单的基础块来构建深度模型的思路.</p><p>VGG块的组成规律是：连续使⽤数个相同的填充为1、窗口形状为3 × 3的卷积层后接上⼀个步幅为2、窗口形状为2 × 2的最⼤池化层。卷积层保持输⼊的⾼和宽不变，而池化层则对其减半。VGG⽹络同Alex Net和Le Net⼀样，VGG⽹络由卷积层模块后接全连接层模块构成。。全连接模块则跟Alex Net中的⼀样。</p><h3 id="GoogLeNet"><a href="#GoogLeNet" class="headerlink" title="GoogLeNet"></a>GoogLeNet</h3><p>GoogLeNet 架构是由 Christian Szegedy 等人开发的。 来自 Google Research，通过低于 7% 的 top-5 错误率，赢得了 ILSVRC 2014 的挑战赛。 这个伟大的表现很大程度上因为它比以前的 CNN 网络更深。 <strong>这是通过称为初始模块（inception modules）的子网络实现的</strong>，这使得 GoogLeNet 比以前的架构更有效地使用参数：实际上，GoogLeNet 的参数比 AlexNet 少了 10 倍（约 600 万而不是 6000 万）。</p><p><img src="/2018/12/14/深度学习/深度学习（三）：卷积神经网络/18.png" alt></p><h3 id="ResNet"><a href="#ResNet" class="headerlink" title="ResNet"></a>ResNet</h3><p>最后是，2015 年 ILSVRC 挑战赛的赢家 Kaiming He 等人开发的 Residual Network（或 ResNet），该网络的 top-5 误率低到惊人的 3.6%，它使用了一个非常深的 CNN，由 152 层组成。 能够训练如此深的网络的关键是使用跳过连接（skip connection，也称为快捷连接）：一个层的输入信号也被添加到位于下一层的输出。 让我们看看为什么这是有用的。</p><p>当训练一个神经网络时，目标是使其模拟一个目标函数<code>h(x)</code>。 如果将输入x添加到网络的输出中（即添加跳过连接），那么网络将被迫模拟<code>f(x)= h(x) - x</code>而不是<code>h(x)</code>。 这被称为残留学习</p><p><img src="/2018/12/14/深度学习/深度学习（三）：卷积神经网络/19.png" alt></p><p>当你初始化一个普通的神经网络时，它的权重接近于零，所以网络只输出接近零的值。 如果添加跳过连接，则生成的网络只输出其输入的副本; 换句话说，它最初对身份函数进行建模。 如果目标函数与身份函数非常接近（常常是这种情况），这将大大加快训练速度。 由于跳过连接，信号可以很容易地通过整个网络。 深度剩余网络可以看作是一堆剩余单位，其中每个剩余单位是一个有跳过连接的小型神经网络。</p><p>现在让我们看看 ResNet 的架构（见下图）。 这实际上是令人惊讶的简单。 它的开始和结束与GoogLeNet完全一样（除了没有 dropout 层），而在两者之间只是一堆很简单的残余单位。 每个残差单元由两个卷积层组成，使用<code>3×3</code>的内核和保存空间维度（步幅 1，<code>SAME</code>填充），批量归一化（BN）和 ReLU 激活。</p><p><img src="/2018/12/14/深度学习/深度学习（三）：卷积神经网络/20.jpg" alt></p><p>正如你所看到的，这个领域正在迅速发展，每年都会有各种各样的架构出现。 一个明显的趋势是 CNN 越来越深入。 他们也越来越轻量，需要越来越少的参数。 目<strong>前，ResNet 架构既是最强大的，也是最简单的，所以它现在应该是你应该使用的</strong> 。</p><p>Res Net中的跨层连接设计引申出了数个后续⼯作，稠密连接⽹络（Dense Net）是其中一个，Dense Net的主要构建模块是稠密块（dense block）和过渡层（transition layer）。前者定义了输⼊和输出是如何连结的，后者则⽤来控制通道数，使之不过⼤。</p><p>还有其他一些架构可供您参考，特别是 VGGNet（2014 年 ILSVRC 挑战赛的亚军）和 Inception-v4（将 GooLeNet 和 ResNet 的思想融合在一起，实现了接近 3% 的 top-5 误差 ImageNet 分类率）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;认识卷积神经网络&quot;&gt;&lt;a href=&quot;#认识卷积神经网络&quot; class=&quot;headerlink&quot; title=&quot;认识卷积神经网络&quot;&gt;&lt;/a&gt;认识卷积神经网络&lt;/h2&gt;&lt;p&gt;全连接神经网络之所以不太适合图像识别任务，主要有三个方面的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="深度学习" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="卷积神经网络" scheme="http://yoursite.com/tags/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>深度学习（二）：训练深层神经网络</title>
    <link href="http://yoursite.com/2018/12/11/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%AE%AD%E7%BB%83%E6%B7%B1%E5%B1%82%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <id>http://yoursite.com/2018/12/11/深度学习/深度学习（二）：训练深层神经网络/</id>
    <published>2018-12-11T09:06:13.000Z</published>
    <updated>2019-12-29T00:59:26.023Z</updated>
    
    <content type="html"><![CDATA[<p>前面介绍了人工神经网络，并训练了我们的第一个深度神经网络。 但它是一个非常浅的 DNN，只有两个隐藏层。 如果你需要解决非常复杂的问题，例如检测高分辨率图像中的数百种类型的对象，该怎么办？ 你可能需要训练更深的 DNN，也许有 10 层，每层包含数百个神经元，通过数十万个连接来连接。 这会相当困难</p><ul><li>首先，你将面临棘手的梯度消失问题（或相关的梯度爆炸问题），这会影响深度神经网络，并使较低层难以训练。</li><li>其次，对于如此庞大的网络，训练将非常缓慢。</li><li>第三，具有数百万参数的模型将会有严重的过拟合训练集的风险。</li></ul><p>在本章中，我们将从解释<strong>梯度消失</strong>问题开始，并探讨解决这个问题的一些最流行的解决方案。 接下来我们将看看<strong>各种优化器，它们可以加速大型模型的训练</strong>。 最后，我们将浏览一些流行的<strong>大型神经网络正则化技术</strong>。 使用这些工具，你将能够训练非常深的网络：欢迎来到深度学习的世界！</p><h2 id="梯度消失-爆炸问题"><a href="#梯度消失-爆炸问题" class="headerlink" title="梯度消失/爆炸问题"></a>梯度消失/爆炸问题</h2><p>反向传播算法的工作原理是从输出层到输入层，传播误差的梯度。 一旦该算法已经计算了网络中每个参数的损失函数的梯度，它就使用这些梯度来用梯度下降步骤来更新每个参数。</p><p>不幸的是，梯度往往变得越来越小，随着算法进展到较低层。 结果，梯度下降更新使得低层连接权重实际上保持不变，并且训练永远不会收敛到良好的解决方案。 这被称为梯度消失问题。 在某些情况下，可能会发生相反的情况：梯度可能变得越来越大，许多层得到了非常大的权重更新，算法发散。这是梯度爆炸的问题，在循环神经网络中最为常见 。</p><h3 id="Xavier初始化和-He-初始化"><a href="#Xavier初始化和-He-初始化" class="headerlink" title="Xavier初始化和 He 初始化"></a>Xavier初始化和 He 初始化</h3><p>虽然这种不幸的行为已经经过了相当长的一段时间的实验观察 但直到 2010 年左右，人们才有了明显的进步。 Xavier Glorot 和 Yoshua Bengio 发表的题为《Understanding the Difficulty of Training Deep Feedforward Neural Networks》的论文分析了一些疑问，包括流行的 sigmoid 激活函数和当时最受欢迎的<strong>默认权重参数初始化技术的组合，即随机初始化时使用平均值为 0，标准差为 1 的正态分布 。</strong></p><p>简而言之，他们表明，用这个激活函数和这个初始化方案，每层输出的方差远大于其输入的方差。网络正向，每层的方差持续增加，直到激活函数在顶层饱和。这实际上是因为logistic函数的平均值为 0.5 而不是 0（双曲正切函数的平均值为 0，表现略好于深层网络中的logistic函数） 。看一下logistic 激活函数，可以看到当输入变大（负或正）时，函数饱和在 0 或 1，导数非常接近 0。因此，当反向传播开始时， 它几乎没有梯度通过网络传播回来，而且由于反向传播通过顶层向下传递，所以存在的小梯度不断地被稀释，因此较低层确实没有任何东西可用。</p><p>Glorot 和 Bengio 在他们的论文中提出了一种显著缓解这个问题的方法。 我们需要信号在两个方向上正确地流动：在进行预测时是正向的，在反向传播梯度时是反向的。 我们不希望信号消失，也不希望它爆炸并饱和。 <strong>为了使信号正确流动，作者认为，我们需要每层输出的方差等于其输入的方差</strong>。</p><p>实际上不可能保证两者都是一样的，除非这个层具有相同数量的输入和输出连接，但是他们提出了一个很好的折衷办法，在实践中证明这个折中办法非常好<strong>：随机初始化连接权重必须如下面公式所描述的那样</strong>。其中<code>n_inputs</code>和<code>n_outputs</code>是权重正在被初始化的层（也称为扇入和扇出）的输入和输出连接的数量。 <strong>这种初始化策略通常被称为Xavier初始化（在作者的名字之后）</strong> 。很多初始化策略也都是为了保持每层的分布不变 ，这样利于传递信息 。</p><p><img src="/2018/12/11/深度学习/深度学习（二）：训练深层神经网络/01.png" alt></p><p> 使用 Xavier 初始化策略可以大大加快训练速度，这是导致深度学习目前取得成功的技巧之一。 最近的一些论文针对不同的激活函数提供了类似的策略，如下表所示。 ReLU 激活函数（及其变体，包括简称 ELU 激活）的初始化策略有时称为 He 初始化（在其作者的姓氏之后）。 </p><p><img src="/2018/12/11/深度学习/深度学习（二）：训练深层神经网络/02.png" alt></p><h3 id="非饱和激活函数"><a href="#非饱和激活函数" class="headerlink" title="非饱和激活函数"></a>非饱和激活函数</h3><p>激活函数在深度神经网络中表现得更好，特别是 ReLU 激活函数，主要是因为它对正值不会饱和（也因为它的计算速度很快）。</p><p>不幸的是，<strong>ReLU</strong>激活功能并不完美。 它有一个被称为 “ReLU 死区” 的问题：在训练过程中，一些神经元有效地死亡，意味着它们停止输出 0 以外的任何东西。在某些情况下，你可能会发现你网络的一半神经元已经死亡，特别是如果你使用大学习率。 在训练期间，如果神经元的权重得到更新，使得神经元输入的加权和为负，则它将开始输出 0 。当这种情况发生时，由于当输入为负时，ReLU函数的梯度为0，神经元不可能恢复生机。</p><p>为了解决这个问题，你可能需要使用 ReLU 函数的一个变体，比如 <strong>leaky ReLU</strong>。这个函数定义为<code>LeakyReLUα(z)= max(αz，z)</code> 。超参数<code>α</code>定义了函数“leaks”的程度：它是<code>z &lt; 0</code>时函数的斜率，通常设置为 0.01。这个小斜坡确保 leaky ReLU 永不死亡；他们可能会长期昏迷，但他们有机会最终醒来。 事实上，设定<code>α= 0.2</code>（巨大 leak）似乎导致比<code>α= 0.01</code>（小 leak）更好的性能。</p><p><img src="/2018/12/11/深度学习/深度学习（二）：训练深层神经网络/03.png" alt></p><p> 最后，Djork-Arné Clevert 等人在 2015 年的一篇论文中提出了一种称为指数线性单元（exponential linear unit，ELU）的新的激活函数，在他们的实验中表现优于所有的 ReLU 变体：训练时间减少，神经网络在测试集上表现的更好，如下所示。 </p><p><img src="/2018/12/11/深度学习/深度学习（二）：训练深层神经网络/04.png" alt></p><p>它看起来很像 ReLU 函数，但有一些区别，主要区别在于：</p><ul><li>首先它在<code>z &lt; 0</code>时取负值，这使得该单元的平均输出接近于 0。这有助于减轻梯度消失问题，如前所述。 超参数<code>α</code>定义为当<code>z</code>是一个大的负数时，ELU 函数接近的值。它通常设置为 1，但是如果你愿意，你可以像调整其他超参数一样调整它。</li><li>其次，它对<code>z &lt; 0</code>有一个非零的梯度，避免了神经元死亡的问题。</li><li>第三，函数在任何地方都是平滑的，包括<code>z = 0</code>左右，这有助于加速梯度下降，因为它不会弹回<code>z = 0</code>的左侧和右侧。</li></ul><p>ELU 激活函数的主要缺点是计算速度慢于 ReLU 及其变体（由于使用指数函数），但是在训练过程中，这是通过更快的收敛速度来补偿的。 然而，在测试时间，ELU 网络将比 ReLU 网络慢。</p><p>那么你应该使用哪个激活函数来处理深层神经网络的隐藏层？ 虽然你的里程会有所不同，一般 ELU &gt; leaky ReLU（及其变体）&gt; ReLU &gt; tanh &gt; sigmoid。 如果您关心运行时性能，那么您可能喜欢 leaky ReLU超过ELU。</p><h3 id="批量标准化"><a href="#批量标准化" class="headerlink" title="批量标准化"></a>批量标准化</h3><p>尽管使用 He初始化和 ELU（或任何 ReLU 变体）可以显著减少训练开始阶段的梯度消失/爆炸问题，但不保证在训练期间问题不会回来。</p><p>在 2015 年的一篇论文中，Sergey Ioffe 和 Christian Szegedy 提出了一种称为批量标准化（Batch Normalization，BN）的技术来解决梯度消失/爆炸问题，每层输入的分布在训练期间改变的问题，更普遍的问题是当前一层的参数改变，每层输入的分布会在训练过程中发生变化（他们称之为内部协变量偏移问题）。</p><p>该技术包括在每层的激活函数之前在模型中添加操作，简单地对输入进行zero-centering和规范化，然后每层使用两个新参数（一个用于尺度变换，另一个用于偏移）对结果进行尺度变换和偏移。 换句话说，这个操作可以让模型学习到每层输入值的最佳尺度,均值。为了对输入进行归零和归一化，算法需要估计输入的均值和标准差。 它通过评估当前小批量输入的均值和标准差（因此命名为“批量标准化”）来实现。</p><p><img src="/2018/12/11/深度学习/深度学习（二）：训练深层神经网络/05.jpg" alt></p><p>在测试时，没有小批量计算经验均值和标准差，所以您只需使用整个训练集的均值和标准差。 这些通常在训练期间使用移动平均值进行有效计算。 因此，总的来说，每个批次标准化的层次都学习了四个参数：<code>γ</code>（标度），<code>β</code>（偏移），<code>μ</code>（平均值）和<code>σ</code>（标准差）</p><p>作者证明，这项技术大大改善了他们试验的所有深度神经网络。梯度消失问题大大减少了，他们可以使用饱和激活函数，如 tanh 甚至 sigmoid 激活函数。网络对权重初始化也不那么敏感。他们能够使用更大的学习率，显著加快了学习过程。 由于每层所需的额外计算，神经网络的预测速度较慢。 所以，如果你需要预测闪电般快速，你可能想要检查普通ELU + He初始化执行之前如何执行批量标准化。您可能会发现，训练起初相当缓慢，而渐变下降正在寻找每层的最佳尺度和偏移量，但一旦找到合理的好值，它就会加速。</p><p>当然，如果你训练的时间越长，准确性就越好，但是由于这样一个浅的网络，批量范数和 ELU 不太可能产生非常积极的影响：它们大部分都是为了更深的网络而发光。</p><p>批量标准化和初始化权重参数的意义差不多，更深的理解可以看这篇 <a href="https://plushunter.github.io/2017/05/14/深度学习系列（9）：Batch Normalization/" target="_blank" rel="noopener">批量标准化</a></p><h3 id="梯度裁剪"><a href="#梯度裁剪" class="headerlink" title="梯度裁剪"></a>梯度裁剪</h3><p>减少梯度爆炸问题的一种常用技术是在反向传播过程中<strong>简单地剪切梯度，使它们不超过某个阈值</strong>（这对于递归神经网络是非常有用的）。 这就是所谓的梯度裁剪。一般来说，人们更喜欢批量标准化，但了解梯度裁剪以及如何实现它仍然是有用的。</p><h2 id="复用预训练层"><a href="#复用预训练层" class="headerlink" title="复用预训练层"></a>复用预训练层</h2><p>从零开始训练一个非常大的 DNN 通常不是一个好主意，相反，您应该总是尝试找到一个现有的神经网络来完成与您正在尝试解决的任务类似的任务，然后复用这个网络的较低层：这就是所谓的迁移学习。这不仅会大大加快训练速度，还将需要更少的训练数据。 一般包括三个步骤</p><p>1、冻结较低层：在训练过程中变量不会发生变化（通常称为冻结层）。</p><p>2、缓存冻结层：由于冻结层不会改变，因此可以为每个训练实例缓存最上面的冻结层的输出。 由于训练贯穿整个数据集很多次，这将给你一个巨大的速度提升</p><p>3、调整，删除或替换较高层：对于新任务来说最有用的高层特征可能与对原始任务最有用的高层特征明显不同。 你需要找到正确的层数来复用。 一般拥有的训练数据越多，您可以解冻的层数就越多。</p><h3 id="Model-Zoos"><a href="#Model-Zoos" class="headerlink" title="Model Zoos"></a>Model Zoos</h3><p>你在哪里可以找到一个类似于你想要解决的任务训练的神经网络？ 首先看看显然是在你自己的模型目录。 这是保存所有模型并组织它们的一个很好的理由，以便您以后可以轻松地检索它们。 另一个选择是在模型动物园中搜索。 许多人为了各种不同的任务而训练机器学习模型，并且善意地向公众发布预训练模型。</p><p>TensorFlow 在 <a href="https://github.com/tensorflow/models" target="_blank" rel="noopener">https://github.com/tensorflow/models</a> 中有自己的模型动物园。 特别是，它包含了大多数最先进的图像分类网络，如 VGG，Inception 和 ResNet（参见第 13 章，检查<code>model/slim</code>目录），包括代码，预训练模型和 工具来下载流行的图像数据集。</p><p>另一个流行的模型动物园是 Caffe 模型动物园。 它还包含许多在各种数据集（例如，ImageNet，Places 数据库，CIFAR10 等）上训练的计算机视觉模型（例如，LeNet，AlexNet，ZFNet，GoogLeNet，VGGNet，开始）。 Saumitro Dasgupta 写了一个转换器，可以在 <a href="https://github.com/ethereon/caffetensorflow。" target="_blank" rel="noopener">https://github.com/ethereon/caffetensorflow。</a></p><h2 id="更快的优化器"><a href="#更快的优化器" class="headerlink" title="更快的优化器"></a>更快的优化器</h2><p>练一个非常大的深度神经网络可能会非常缓慢。 到目前为止，我们已经看到了四种加速训练的方法（并且达到更好的解决方案）：对连接权重应用良好的初始化策略，使用良好的激活函数，使用批量规范化以及重用预训练网络的部分。 另一个巨大的速度提升来自使用比普通渐变下降优化器更快的优化器。 在本节中，我们将介绍最流行的：动量优化，Nesterov 加速梯度，AdaGrad，RMSProp，最后是 Adam 优化。</p><p>剧透：<strong>本节的结论是，您几乎总是应该使用<code>Adam_optimization</code></strong>，所以如果您不关心它是如何工作的，只需使用<code>AdamOptimizer</code>替换您的<code>GradientDescentOptimizer</code>，然后跳到下一节！ 只需要这么小的改动，训练通常会快几倍。 <strong>但是，Adam 优化确实有三个可以调整的超参数（加上学习率）。 默认值通常工作的不错，但如果您需要调整它们，知道他们怎么实现的可能会有帮助</strong>。</p><p>理解这些优化器可以看这篇 <a href="https://plushunter.github.io/2017/05/11/深度学习系列（7）：神经网络的优化方法/" target="_blank" rel="noopener">神经网络的优化方法</a></p><h3 id="训练稀疏模型"><a href="#训练稀疏模型" class="headerlink" title="训练稀疏模型"></a>训练稀疏模型</h3><p>上面所有刚刚提出的优化算法都会产生密集的模型，这意味着大多数参数都是非零的。 如果你在运行时需要一个非常快速的模型，或者如果你需要它占用较少的内存，你可能更喜欢用一个稀疏模型优化器来代替。</p><p>这时可以使用FTRL 优化器，一种由尤里·涅斯捷罗夫（Yurii Nesterov）提出的技术。 当与 l1 正则化一起使用时，这种技术通常导致非常稀疏的模型。</p><h2 id="学习率调整"><a href="#学习率调整" class="headerlink" title="学习率调整"></a>学习率调整</h2><p>自适应下降的学习速率会更好。有三种流行的方法：</p><ul><li>性能调度：每 N 步测量验证误差（就像提前停止一样），当误差下降时，将学习率降低一个因子<code>λ</code>。</li><li>指数调度：将学习率设置为<strong>迭代次数<code>t</code></strong>的函数$\eta(t)=\eta_0\cdot10^{-t/r}$： 这很好，但它需要调整初始速率<code>η0</code>和<strong>总迭代次数</strong><code>r</code>。 学习率将由每<code>r</code>步下降 10 倍。</li><li>幂调度：设学习率为$\eta(t)=\eta_0(1+t/r)^{-c}$。 超参数<code>c</code>通常被设置为 1。这与指数调度类似，但是学习率下降要慢得多。</li></ul><p>根据Andrew Senior 等2013年的论文。 比较了使用动量优化训练深度神经网络进行语音识别时一些最流行的学习率调整的性能。 作者得出结论：在这种情况下，性能调度和指数调度都表现良好，但他们更喜欢指数调度，因为它实现起来比较简单，容易调整，收敛速度略快于最佳解决方案 。</p><h2 id="通过正则化避免过拟合"><a href="#通过正则化避免过拟合" class="headerlink" title="通过正则化避免过拟合"></a>通过正则化避免过拟合</h2><p>1、早起停止法</p><p>2、L1和L2正则化：注意不需要对bias正则，只对权重</p><p>3、Dropout</p><p>深度神经网络最流行的正则化技术可以说是 dropout。 它由 GE Hinton 于 2012 年提出，并在 Nitish Srivastava 等人的论文中进一步详细描述，并且已被证明是非常成功的：即使是最先进的神经网络，仅仅通过增加丢失就可以提高1-2％的准确度。</p><p>是一个相当简单的算法：在每个训练步骤中，每个神经元（包括输入神经元，但不包括输出神经元）都有一个暂时“丢弃”的概率<code>p</code>，这意味着在这个训练步骤中它将被完全忽略， 在下一步可能会激活（见下图 ）。 超参数<code>p</code>称为丢失率，通常设为 50%。 训练后，神经元不会再下降。</p><p><img src="/2018/12/11/深度学习/深度学习（二）：训练深层神经网络/05.png" alt></p><p>如果观察到模型过拟合，则可以增加 dropout 率（即，减少<code>keep_prob</code>超参数）。 相反，如果模型欠拟合训练集，则应尝试降低 dropout 率（即增加<code>keep_prob</code>）。 它也可以帮助增加大层的 dropout 率，并减少小层的 dropout 率。</p><p>dropout 似乎减缓了收敛速度，但通常会在调整得当时使模型更好。 所以，这通常值得花费额外的时间和精力。</p><p>Dropconnect是dropout的变体，其中单个连接随机丢弃而不是整个神经元。 一般而言，dropout表现会更好。</p><h2 id="最大范数正则化"><a href="#最大范数正则化" class="headerlink" title="最大范数正则化"></a>最大范数正则化</h2><p>另一种在神经网络中非常流行的正则化技术被称为最大范数正则化：对于每个神经元，它约束输入连接的权重<code>w</code>，使得$\Vert w\Vert_2 \leq r$，其中<code>r</code>是最大范数超参数，$\Vert \cdot \Vert$是 L2 范数。</p><p>我们通常通过在每个训练步骤之后计算 $\Vert w\Vert_2$来实现这个约束，并且如果需要的话可以剪切<code>W</code> ，即$w\leftarrow w\frac{r}{\Vert w\Vert_2}$。</p><p>减少<code>r</code>增加了正则化的数量(经常剪切<code>W</code>)，并有助于减少过拟合。 最大范数正则化还可以帮助减轻梯度消失/爆炸问题（如果您不使用批量标准化）。</p><h2 id="数据增强"><a href="#数据增强" class="headerlink" title="数据增强"></a>数据增强</h2><p>最后一个正则化技术，数据增强，包括从现有的训练实例中产生新的训练实例，人为地增加了训练集的大小。 这将减少过拟合，使之成为正则化技术。 诀窍是生成逼真的训练实例;</p><p>例如，如果您的模型是为了分类蘑菇图片，您可以稍微移动，旋转和调整训练集中的每个图片的大小，并将结果图片添加到训练集。 这迫使模型更能容忍图片中蘑菇的位置，方向和大小。 如果您希望模型对光照条件更加宽容，则可以类似地生成具有各种对比度的许多图像。 假设蘑菇是对称的，你也可以水平翻转图片。 通过结合这些转换，可以大大增加训练集的大小。</p><h2 id="实践指南"><a href="#实践指南" class="headerlink" title="实践指南"></a>实践指南</h2><p>当然，如果你能找到解决类似问题的方法，你应该尝试重用预训练的神经网络的一部分。</p><p>这个默认配置可能需要调整：</p><ul><li>如果你找不到一个好的学习率（收敛速度太慢，所以你增加了训练速度，现在收敛速度很快，但是网络的准确性不是最理想的），那么你可以尝试添加一个学习率调整，如指数衰减。</li><li>如果你的训练集太小，你可以实现数据增强。</li><li>如果你需要一个稀疏的模型，你可以添加 l1 正则化混合（并可以选择在训练后将微小的权重归零）。 如果您需要更稀疏的模型，您可以尝试使用 FTRL 而不是 Adam 优化以及 l1 正则化。</li><li>如果在运行时需要快速模型，则可能需要删除批量标准化，并可能用 leakyReLU 替换 ELU 激活函数。 有一个稀疏的模型也将有所帮助。</li></ul><hr><ol><li>使用 He 初始化随机选择权重，是否可以将所有权重初始化为相同的值？</li></ol><p>答：不，所有的权值都应该独立采样;它们的初值不应该相同。如果任意一层的所有神经元都有相同的权值。这就像每层只有一个神经元，而且速度要慢得多。</p><ol><li>可以将偏置初始化为 0 吗？</li></ol><p>答：可以</p><ol><li>说出 ELU 激活功能与 ReLU 相比的三个优点。</li></ol><p>答：</p><ul><li>它可以取负值，所以任意一层神经元的<strong>平均输出</strong>通常比使用relu激活函数(从不输出负值)时<strong>更接近于0</strong>。这有助于缓解渐变消失的问题。</li><li>它总是有一个非零的导数，这避免了神经元死亡的问题。</li><li>处处平滑，而Relu的斜率在z = 0时突然从0跳到1。这样的骤减使梯度下降效果降低，因为它会在z =0附近反弹.</li></ul><ol><li>在哪些情况下，您想要使用以下每个激活函数：ELU，leaky ReLU（及其变体），ReLU，tanh，logistic 以及 softmax？</li></ol><p>答：ELU是一个不错的默认选择。如果想要训练速度更快一些可以采用 leaky ReLU（及其变体）</p><ol><li>dropout 是否会减慢训练？ 它是否会减慢推断（即预测新的实例）？</li></ol><p>答：dropout确实会减慢训练速度，总的来说大概是两倍。然而，它没有对推断（预测新的实例）的影响，因为它只在训练期间打开。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前面介绍了人工神经网络，并训练了我们的第一个深度神经网络。 但它是一个非常浅的 DNN，只有两个隐藏层。 如果你需要解决非常复杂的问题，例如检测高分辨率图像中的数百种类型的对象，该怎么办？ 你可能需要训练更深的 DNN，也许有 10 层，每层包含数百个神经元，通过数十万个连
      
    
    </summary>
    
      <category term="深度学习" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="正则化" scheme="http://yoursite.com/tags/%E6%AD%A3%E5%88%99%E5%8C%96/"/>
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="梯度消失/爆炸" scheme="http://yoursite.com/tags/%E6%A2%AF%E5%BA%A6%E6%B6%88%E5%A4%B1-%E7%88%86%E7%82%B8/"/>
    
  </entry>
  
  <entry>
    <title>深度学习（一）：神经网络与反向传播</title>
    <link href="http://yoursite.com/2018/12/09/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/"/>
    <id>http://yoursite.com/2018/12/09/深度学习/深度学习（一）：神经网络与反向传播/</id>
    <published>2018-12-09T09:06:13.000Z</published>
    <updated>2019-12-29T01:55:34.567Z</updated>
    
    <content type="html"><![CDATA[<h2 id="神经元"><a href="#神经元" class="headerlink" title="神经元"></a>神经元</h2><p>首先我们从最简单的神经网络——神经元讲起，以下即为一个神经元（Neuron）的图示：</p><p><img src="/2018/12/09/深度学习/深度学习（一）：神经网络与反向传播/01.jpg" alt></p><p>我们知道感知机的激活函数是阶跃函数；而当我们说神经元的时，激活函数往往选择sigmoid函数或tanh函数 ,<strong>还有Relu函数（效果较好）</strong>。如下图所示 </p><p><img src="/2018/12/09/深度学习/深度学习（一）：神经网络与反向传播/02.jpg" alt></p><p>可以看出，这个单一神经元的输入输出的映射关系其实就是一个逻辑回归（logistic regression）。</p><h2 id="神经网络模型"><a href="#神经网络模型" class="headerlink" title="神经网络模型"></a>神经网络模型</h2><h3 id="神经网络模型-1"><a href="#神经网络模型-1" class="headerlink" title="神经网络模型"></a>神经网络模型</h3><p>所谓神经网络就是将许多神经元联结在一起，这样，一个神经元的输出就可以是另一神经元的输入。例如，下图就是一个简单的神经网络：</p><p><img src="/2018/12/09/深度学习/深度学习（一）：神经网络与反向传播/03.jpg" alt></p><p>这样的神经网络也称之为多层感知机（MLP），MLP 由一个（通过）输入层、一个或多个称为隐藏层的 LTU （单层感知器）组成，一个最终层 LTU 称为输出层。除了输出层之外的每一层包括偏置神经元，并且全连接到下一层。当人工神经网络有两个或多个隐含层时，称为深度神经网络（DNN）。</p><h2 id="BP反向传播"><a href="#BP反向传播" class="headerlink" title="BP反向传播"></a>BP反向传播</h2><p>反向传播指的是计算神经⽹络参数梯度的⽅法。总的来说，反向传播依据微积分中的链式法则，沿着从输出层到输⼊层的顺序，依次计算并存储⽬标函数有关神经⽹络各层的中间变量以及参数的梯度。</p><p><img src="/2018/12/09/深度学习/深度学习（一）：神经网络与反向传播/04.png" alt></p><p><img src="/2018/12/09/深度学习/深度学习（一）：神经网络与反向传播/05.png" alt></p><p><img src="/2018/12/09/深度学习/深度学习（一）：神经网络与反向传播/06.png" alt></p><p><img src="/2018/12/09/深度学习/深度学习（一）：神经网络与反向传播/07.png" alt></p><p>上图依次为利用dE/dx6求出第一个dE/dw; 利用分量的点对点继续求dE/dw; 利用求和来下一个dE/dy2 ;(这里的所以x,y总输入输出都是知道的)</p><ul><li>dE/dw是有上下夹层dE/dx与上面一层的y求出的</li><li>dE/dy是由上面一层全连接的wij 与其连接的dE/dx求出的</li></ul><p><img src="/2018/12/09/深度学习/深度学习（一）：神经网络与反向传播/08.png" alt></p><p>dE/dy2 = dE/dx4, w24 和 dE/dx5, dw25的求和得到其中，y2=w24*x4,故有dx_j/dy_i = wij</p><h2 id="用-TensorFlow-高级-API-训练-MLP"><a href="#用-TensorFlow-高级-API-训练-MLP" class="headerlink" title="用 TensorFlow 高级 API 训练 MLP"></a>用 TensorFlow 高级 API 训练 MLP</h2><p>与 TensorFlow 一起训练 MLP 最简单的方法是使用高级 API TF.Learn，这与 sklearn 的 API 非常相似。<code>DNNClassifier</code>可以很容易训练具有任意数量隐层的深度神经网络，而 softmax 输出层输出估计的类概率。例如，下面的代码训练两个隐藏层的 DNN（一个具有 300 个神经元，另一个具有 100 个神经元）和一个具有 10 个神经元的 SOFTMax 输出层进行分类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">feature_columns = tf.contrib.learn.infer_real_valued_columns_from_input(X) </span><br><span class="line">dnn_clf = tf.contrib.learn.DNNClassifier(hidden_units=[<span class="number">300</span>, <span class="number">100</span>], n_classes=<span class="number">10</span>,</span><br><span class="line">                                         feature_columns=feature_columns) </span><br><span class="line">dnn_clf.fit(x=X, y=y, batch_size=<span class="number">50</span>, steps=<span class="number">40000</span>)</span><br></pre></td></tr></table></figure><p>如果你在 MNIST 数据集上运行这个代码（在缩放它之后，例如，通过使用 skLearn 的<code>StandardScaler</code>），你实际上可以得到一个在测试集上达到 98.1% 以上精度的模型！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score &gt;&gt;&gt; y_pred = list(dnn_clf.predict(X_test)) &gt;&gt;&gt; accuracy_score(y_test, y_pred) <span class="number">0.98180000000000001</span></span><br></pre></td></tr></table></figure><p>TF.Learn 学习库也为评估模型提供了一些方便的功能：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dnn_clf.evaluate(X_test, y_test) &#123;<span class="string">'accuracy'</span>: <span class="number">0.98180002</span>, <span class="string">'global_step'</span>: <span class="number">40000</span>, <span class="string">'loss'</span>: <span class="number">0.073678359</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="使用普通-TensorFlow-训练-DNN"><a href="#使用普通-TensorFlow-训练-DNN" class="headerlink" title="使用普通 TensorFlow 训练 DNN"></a>使用普通 TensorFlow 训练 DNN</h2><p>如果您想要更好地控制网络架构，您可能更喜欢使用 TensorFlow 的较低级别的 Python API。 在本节中，我们将使用与之前的 API 相同的模型，我们将实施 Minibatch 梯度下降来在 MNIST 数据集上进行训练。 第一步是建设阶段，构建 TensorFlow 图。 第二步是执行阶段，您实际运行计算图谱来训练模型。</p><h3 id="构造阶段"><a href="#构造阶段" class="headerlink" title="构造阶段"></a>构造阶段</h3><p>开始吧。 首先我们需要导入<code>tensorflow</code>库。 然后我们必须指定输入和输出的数量，并设置每个层中隐藏的神经元数量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tfn_inputs = <span class="number">28</span>*<span class="number">28</span> <span class="comment"># MNISTn_hidden1 = 300n_hidden2 = 100n_outputs = 10</span></span><br></pre></td></tr></table></figure><p>接下来，可以使用占位符节点来表示训练数据和目标。<code>X</code>的形状仅有部分被定义。 我们知道它将是一个 2D 张量（即一个矩阵），沿着第一个维度的实例和第二个维度的特征，我们知道特征的数量将是<code>28×28</code>（每像素一个特征） <strong>但是我们不知道每个训练批次将包含多少个实例。 所以<code>X</code>的形状是<code>(None, n_inputs)</code></strong>。 <strong>同样，我们知道<code>y</code>将是一个 1D 张量，每个实例有一个入口，但是我们再次不知道在这一点上训练批次的大小，所以形状<code>(None)</code></strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X = tf.placeholder(tf.float32, shape=(<span class="literal">None</span>, n_inputs), name=<span class="string">"X"</span>)y = tf.placeholder(tf.int64, shape=(<span class="literal">None</span>), name=<span class="string">"y"</span>)</span><br></pre></td></tr></table></figure><p>现在让我们创建一个实际的神经网络。 占位符<code>X</code>将作为输入层; 在执行阶段，它将一次更换一个训练批次（注意训练批中的所有实例将由神经网络同时处理）。 现在您需要创建两个隐藏层和输出层。 两个隐藏的层几乎相同：它们只是它们所连接的输入和它们包含的神经元的数量不同。 <strong>输出层也非常相似，但它使用 softmax 激活函数而不是 ReLU 激活函数</strong>。 <strong>所以让我们创建一个<code>neuron_layer()</code>函数，我们将一次创建一个图层。 它将需要参数来指定输入，神经元数量，激活函数和图层的名称：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">neuron_layer</span><span class="params">(X, n_neurons, name, activation=None)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> tf.name_scope(name):</span><br><span class="line">        n_inputs = int(X.get_shape()[<span class="number">1</span>])</span><br><span class="line">        stddev = <span class="number">2</span> / np.sqrt(n_inputs)</span><br><span class="line">        init = tf.truncated_normal((n_inputs, n_neurons), stddev=stddev)</span><br><span class="line">        W = tf.Variable(init, name=<span class="string">"weights"</span>) <span class="comment"># 使用满足分布概率来更好第初始化W权重</span></span><br><span class="line">        b = tf.Variable(tf.zeros([n_neurons]), name=<span class="string">"biases"</span>)</span><br><span class="line">        <span class="comment"># multiply这个函数实现的是元素级别的相乘，也就是两个相乘的数元素各自相乘，而不是矩阵乘法</span></span><br><span class="line">        <span class="comment"># tf.matmul才算矩阵乘法，注意区别</span></span><br><span class="line">        z = tf.matmul(X, W) + b </span><br><span class="line">        <span class="keyword">if</span> activation == <span class="string">"relu"</span>:</span><br><span class="line">            <span class="keyword">return</span> tf.nn.relu(z)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> z</span><br></pre></td></tr></table></figure><p>我们逐行浏览这个代码：</p><ol><li>首先，我们使用名称范围来创建每层的名称：它将包含该神经元层的所有计算节点。 <strong>这是可选的</strong>，但如果节点组织良好，则 TensorBoard 图形将会更加出色。</li><li>接下来，我们通过查找输入矩阵的形状并获得第二个维度的大小来获得输入数量（<strong>第一个维度用于实例数量</strong>）。</li><li>接下来的三行创建一个保存权重矩阵的<code>W</code>变量。 它将是包含每个输入和每个神经元之间的所有连接权重的2D张量；因此，<strong>它的形状将是<code>(n_inputs, n_neurons)</code></strong>。<strong>它将被随机初始化，使用具有标准差为<code>2/√n</code>的截断的正态（高斯）分布</strong>(使用截断的正态分布而不是常规正态分布确保不会有任何大的权重，这可能会减慢训练。).<strong>使用这个特定的标准差有助于算法的收敛速度更快</strong>（我们将在后面进一步讨论这一点），这是对神经网络的微小调整之一，对它们的效率产生了巨大的影响）。 重要的是为所有隐藏层随机初始化连接权重，以避免梯度下降算法无法中断的任何对称性。（例如，如果将所有权重设置为 0，则所有神经元将输出 0，并且给定隐藏层中的所有神经元的误差梯度将相同。 然后，梯度下降步骤将在每个层中以相同的方式更新所有权重，因此它们将保持相等。 换句话说，尽管每层有数百个神经元，你的模型就像每层只有一个神经元一样。）</li><li>下一行创建一个偏差的<code>b</code>变量，初始化为 0（在这种情况下无对称问题），每个神经元有一个偏置参数。</li><li>然后我们创建一个子图来计算<code>z = X·W + b</code>。 该向量化实现将有效地计算输入的加权和加上层中每个神经元的偏置，对于批次中的所有实例，仅需一次.</li><li>最后，如果激活参数设置为<code>relu</code>，则代码返回<code>relu(z)</code>（即<code>max(0,z)</code>），否则它只返回<code>z</code>。</li></ol><p>好了，现在你有一个很好的函数来创建一个神经元层。 让我们用它来创建深层神经网络！ 第一个隐藏层以<code>X</code>为输入。 第二个将第一个隐藏层的输出作为其输入。 最后，输出层将第二个隐藏层的输出作为其输入。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.name_scope(<span class="string">"dnn"</span>):</span><br><span class="line">        hidden1 = neuron_layer(X, n_hidden1, <span class="string">"hidden1"</span>, activation=<span class="string">"relu"</span>)</span><br><span class="line">    hidden2 = neuron_layer(hidden1, n_hidden2, <span class="string">"hidden2"</span>, activation=<span class="string">"relu"</span>)</span><br><span class="line">    logits = neuron_layer(hidden2, n_outputs, <span class="string">"outputs"</span>)</span><br></pre></td></tr></table></figure><p>要注意，<strong>logit 是在通过 softmax 激活函数之前神经网络的输出</strong>：为了优化，我们稍后将处理 softmax 计算。</p><p><strong>正如你所期望的，TensorFlow 有许多方便的功能来创建标准的神经网络层，所以通常不需要像我们刚才那样定义你自己的<code>neuron_layer()</code>函数</strong>。 例如，TensorFlow 的<code>tf.layers.dense()</code>函数创建一个完全连接的层，其中所有输入都连接到图层中的所有神经元。 <strong>它使用正确的初始化策略来负责创建权重和偏置变量，并且默认情况下不使用激活函数（我们可以使用<code>activate_fn</code>参数来更改它）</strong>。 它还支持正则化和归一化参数。 我们来调整上面的代码来使用<code>tf.layers.dense()</code>函数，而不是我们的<code>neuron_layer()</code>函数。 只需导入该功能，并使用以下代码替换之前所有 dnn 构建部分：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.name_scope(<span class="string">"dnn"</span>):</span><br><span class="line">    hidden1 = tf.layers.dense(X, n_hidden1, name=<span class="string">"hidden1"</span>,</span><br><span class="line">                              activation=tf.nn.relu)</span><br><span class="line">    hidden2 = tf.layers.dense(hidden1, n_hidden2, name=<span class="string">"hidden2"</span>,</span><br><span class="line">                              activation=tf.nn.relu)</span><br><span class="line">    logits = tf.layers.dense(hidden2, n_outputs, name=<span class="string">"outputs"</span>)</span><br></pre></td></tr></table></figure><h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p>现在我们已经有了神经网络模型，我们需要定义我们用来训练的损失函数。 正如我们在之前对 Softmax 回归所做的那样，我们将使用交叉熵。 我们将使用<code>sparse_softmax_cross_entropy_with_logits()</code>：它根据“logit”计算交叉熵（即，在通过 softmax 激活函数之前的网络输出），并且期望以 0 到 -1 数量的整数形式的标签（在我们的例子中，从 0 到 9）。 <strong>这将给我们一个包含每个实例的交叉熵的 1D 张量</strong>。 <strong>然后，我们可以使用 TensorFlow 的<code>reduce_mean()</code>函数来计算所有实例的平均交叉熵。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.name_scope(<span class="string">"loss"</span>):</span><br><span class="line">    xentropy = tf.nn.sparse_softmax_cross_entropy_with_logits(labels=y, logits=logits)</span><br><span class="line">    loss = tf.reduce_mean(xentropy, name=<span class="string">"loss"</span>)</span><br></pre></td></tr></table></figure><p>该<code>sparse_softmax_cross_entropy_with_logits()</code>函数等同于应用 SOFTMAX 激活函数，然后计算交叉熵，但它更高效，它妥善照顾的边界情况下，比如 logits 等于 0，这就是为什么我们没有较早的应用 SOFTMAX 激活函数。 还有称为<code>softmax_cross_entropy_with_logits()</code>的另一个函数，该函数在标签单热载体的形式（而不是整数 0 至类的数目减 1）。</p><h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><p>我们有神经网络模型，我们有损失函数，现在我们需要定义一个<code>GradientDescentOptimizer</code>来调整模型参数以最小化损失函数。没什么新鲜的; 就像我们之前中所做的那样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">learning_rate = <span class="number">0.01</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.name_scope(<span class="string">"train"</span>):</span><br><span class="line">    optimizer = tf.train.GradientDescentOptimizer(learning_rate)</span><br><span class="line">    training_op = optimizer.minimize(loss)</span><br></pre></td></tr></table></figure><h3 id="评估模型性能"><a href="#评估模型性能" class="headerlink" title="评估模型性能"></a>评估模型性能</h3><p>建模阶段的最后一个重要步骤是指定如何评估模型。 我们将简单地将精度用作我们的绩效指标。 首先，对于每个实例，通过检查最高 logit 是否对应于目标类别来确定神经网络的预测是否正确。 为此，您可以使用<code>in_top_k()</code>函数。 这返回一个充满布尔值的 1D 张量，因此我们需要将这些布尔值转换为浮点数，然后计算平均值。 这将给我们网络的整体准确性.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.name_scope(<span class="string">"eval"</span>):</span><br><span class="line">    correct = tf.nn.in_top_k(logits, y, <span class="number">1</span>)</span><br><span class="line">    accuracy = tf.reduce_mean(tf.cast(correct, tf.float32))</span><br></pre></td></tr></table></figure><p>而且，像往常一样，我们需要创建一个初始化所有变量的节点，我们还将创建一个<code>Saver</code>来将我们训练有素的模型参数保存到磁盘中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">init = tf.global_variables_initializer()</span><br><span class="line">saver = tf.train.Saver()</span><br></pre></td></tr></table></figure><p>建模阶段结束。 这是不到 40 行代码，但相当激烈：我们为输入和目标创建占位符，我们创建了一个构建神经元层的函数，我们用它来创建 DNN，我们定义了损失函数，我们 创建了一个优化器，最后定义了性能指标。 现在到执行阶段。</p><h3 id="执行阶段"><a href="#执行阶段" class="headerlink" title="执行阶段"></a>执行阶段</h3><p>首先，我们加载 MNIST。 我们可以像之前的章节那样使用 ScikitLearn，但是 TensorFlow 提供了自己的助手来获取数据，将其缩放（0 到 1 之间），将它洗牌，并提供一个简单的功能来一次加载一个小批量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.examples.tutorials.mnist <span class="keyword">import</span> input_data</span><br><span class="line">mnist = input_data.read_data_sets(<span class="string">"/tmp/data/"</span>)</span><br><span class="line">n_epochs = <span class="number">10001</span>  <span class="comment"># 迭代次数</span></span><br><span class="line">batch_size = <span class="number">50</span>   <span class="comment"># 小批量大小</span></span><br></pre></td></tr></table></figure><p>现在我们去训练模型:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    init.run()</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> range(n_epochs):</span><br><span class="line">        <span class="keyword">for</span> iteration <span class="keyword">in</span> range(mnist.train.num_examples // batch_size): <span class="comment"># 每批量一次</span></span><br><span class="line">            X_batch, y_batch = mnist.train.next_batch(batch_size)</span><br><span class="line">            sess.run(training_op, feed_dict=&#123;X: X_batch, y: y_batch&#125;) <span class="comment"># 运行计算程序</span></span><br><span class="line">        acc_train = accuracy.eval(feed_dict=&#123;X: X_batch, y: y_batch&#125;)</span><br><span class="line">        acc_test = accuracy.eval(feed_dict=&#123;X: mnist.test.images, y: mnist.test.labels&#125;)</span><br><span class="line">        print(epoch, <span class="string">"Train accuracy:"</span>, acc_train, <span class="string">"Test accuracy:"</span>, acc_test)</span><br><span class="line"></span><br><span class="line">    save_path = saver.save(sess, <span class="string">"./my_model_final.ckpt"</span>)</span><br></pre></td></tr></table></figure><p>该代码打开一个 TensorFlow 会话，并运行初始化所有变量的<code>init</code>节点。 然后它运行的主要训练循环：在每个时期，通过一些小批次的对应于训练集的大小的代码进行迭代。 <strong>每个小批量通过<code>next_batch()</code>方法获取，然后代码简单地运行训练操作</strong>，为当前的小批量输入数据和目标提供。 接下来，在每个时期结束时，代码评估最后一个小批量和完整训练集上的模型，并打印出结果。 最后，模型参数保存到磁盘。</p><h3 id="使用神经网络进行预测"><a href="#使用神经网络进行预测" class="headerlink" title="使用神经网络进行预测"></a>使用神经网络进行预测</h3><p>现在神经网络被训练了，你可以用它进行预测。 为此，您可以重复使用相同的建模阶段，但是更改执行阶段，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    saver.restore(sess, <span class="string">"./my_model_final.ckpt"</span>) <span class="comment"># or better, use save_path</span></span><br><span class="line">    X_new_scaled = mnist.test.images[:<span class="number">20</span>]</span><br><span class="line">    Z = logits.eval(feed_dict=&#123;X: X_new_scaled&#125;)</span><br><span class="line">    y_pred = np.argmax(Z, axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>首先，代码从磁盘加载模型参数。 然后加载一些您想要分类的新图像。 记住应用与训练数据相同的特征缩放（在这种情况下，将其从 0 缩放到 1）。 然后代码评估对数点节点。 如果您想知道所有估计的类概率，则需要将<code>softmax()</code>函数应用于对数，但如果您只想预测一个类，则可以简单地选择具有最高 logit 值的类（使用<code>argmax()</code>函数做的伎俩）。</p><h2 id="微调神经网络超参数"><a href="#微调神经网络超参数" class="headerlink" title="微调神经网络超参数"></a>微调神经网络超参数</h2><p>神经网络的灵活性也是其主要缺点之一：有很多超参数要进行调整。 不仅可以使用任何可想象的网络拓扑（如何神经元互连），而且即使在简单的 MLP 中，您可以更改层数，每层神经元数，每层使用的激活函数类型，权重初始化逻辑等等。 你怎么知道什么组合的超参数是最适合你的任务？</p><p>可以使用具有交叉验证的网格搜索来查找正确的超参数 ，但是由于要调整许多超参数，并且由于在大型数据集上训练神经网络需要很多时间 。像之前讨论过的，使用随机搜索要好得多 ，另一个选择是使用诸如 Oscar 之类的工具，它可以实现更复杂的算法，以帮助您快速找到一组好的超参数.</p><h3 id="隐藏层数量"><a href="#隐藏层数量" class="headerlink" title="隐藏层数量"></a>隐藏层数量</h3><p>实际上已经表明，只有一个隐藏层的 MLP 可以建模甚至最复杂的功能，只要它具有足够的神经元。 但是他们忽略了这样一个事实：深层网络具有比浅层网络更高的参数效率：他们可以使用比浅网格更少的神经元来建模复杂的函数，使得训练更快。</p><p>总而言之，对于许多问题，您可以从一个或两个隐藏层开始。(MNIST 数据集上容易达到 97% 以上的准确度使用两个具有相同总神经元数量的隐藏层 )；对于更复杂的问题，您可以逐渐增加隐藏层的数量，直到您开始覆盖训练集。 <strong>但是，我们很少从头开始训练这样的网络：重用预先训练的最先进的网络执行类似任务的部分更为常见</strong>。训练将会更快，需要更少的数据 。</p><h3 id="每层隐藏层的神经元数量"><a href="#每层隐藏层的神经元数量" class="headerlink" title="每层隐藏层的神经元数量"></a>每层隐藏层的神经元数量</h3><p>不幸的是，正如你所看到的，找到完美的神经元数量仍然是黑色的艺术.</p><p><strong>一个更简单的方法是选择一个具有比实际需要的更多层次和神经元的模型</strong>，然后使用早期停止来防止它过度拟合（以及其他正则化技术，特别是 drop out，我们将在后面）。 这被称为“拉伸裤”的方法：而不是浪费时间寻找完美匹配您的大小的裤子，只需使用大型伸缩裤，缩小到合适的尺寸。</p><h3 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h3><p>在大多数情况下，您可以在隐藏层中使用 ReLU 激活函数（或其中一个变体 ）</p><p>对于输出层，softmax 激活函数通常是分类任务的良好选择（当这些类是互斥的时）。 对于回归任务，您完全可以不使用激活函数。</p><hr><ol><li>为什么通常使用逻辑斯蒂回归分类器而不是经典感知器（即使用感知器训练算法训练单层的线性阈值单元）？你如何调整感知器使之等同于逻辑回归分类器？</li></ol><p>答：经典感知器只有在数据集是线性可分的情况下才会收敛。相比之下，逻辑回归分类器将收敛于一个很好的解决方案，即使数据集不是线性可分的，它会输出类的概率。如果你将感知器的激活函数改为逻辑激活函数(或如果有多个神经元，则为softmax激活函数)，，则等价于逻辑回归分类器。</p><ol><li>为什么激活函数是训练第一个 MLP 的关键因素？</li></ol><p>答：logistic激活函数是训练第一批MLP的关键因素，因为它是一个复杂的过程导数总是不为零的，所以梯度下降总是可以沿着斜率向下滚动。当激活函数是阶跃函数，梯度下降无法移动，因为根本没有斜率。</p><ol><li>假设有一个 MLP 有一个 10 个神经元组成的输入层，接着是一个 50 个神经元的隐藏层，最后一个 3 个神经元输出层。所有人工神经元使用 Relu 激活函数。</li></ol><ul><li>输入矩阵<code>X</code>的形状是什么？ ——   -m × 10，其中m为batch size.</li><li>隐藏层的权重向量的形状以及它的偏置向量的形状如何？ ——W_h=50 × 10，b_h = 50（一维长度）</li><li>输出层的权重向量和它的偏置向量的形状是什么？ ——W_o=50 × 3，b_o=3</li><li>网络的输出矩阵<code>Y</code>是什么形状？ ——Y=m × 3</li><li>写出计算网络输出矩阵的方程 —$-Y=(X\cdot W_h+b_h)\cdot W_o+b_o$</li></ul><ol><li>如果你想把电子邮件分类成垃圾邮件或正常邮件，你需要在输出层中有多少个神经元？在输出层中应该使用什么样的激活函数？如果你想解决 MNIST 问题，你需要多少神经元在输出层，使用什么激活函数？</li></ol><p>答：只需要神经系统在输出层中的一个神经元，通常在估计概率时，使用输出层的logistic激活函数。如果你想处理mnist，你需要输出层的10个神经元，你必须替换<br>logistic函数与softmax激活函数，它可以处理多个分裂，每个类输出一个概率。如果现在想让你的神经网络预测房屋价格，则需要一个输出神经元，不使用任何激活函数<br>输出层。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;神经元&quot;&gt;&lt;a href=&quot;#神经元&quot; class=&quot;headerlink&quot; title=&quot;神经元&quot;&gt;&lt;/a&gt;神经元&lt;/h2&gt;&lt;p&gt;首先我们从最简单的神经网络——神经元讲起，以下即为一个神经元（Neuron）的图示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2018/
      
    
    </summary>
    
      <category term="深度学习" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="反向传播" scheme="http://yoursite.com/tags/%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/"/>
    
      <category term="神经网络" scheme="http://yoursite.com/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>数据挖掘概念与技术笔记（8）：聚类（2）</title>
    <link href="http://yoursite.com/2018/11/14/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%888%EF%BC%89%EF%BC%9A%E8%81%9A%E7%B1%BB%EF%BC%882%EF%BC%89/"/>
    <id>http://yoursite.com/2018/11/14/数据挖掘概念与技术/数据挖掘概念与技术笔记（8）：聚类（2）/</id>
    <published>2018-11-14T09:06:14.000Z</published>
    <updated>2019-12-28T14:33:34.902Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基于密度的聚类"><a href="#基于密度的聚类" class="headerlink" title="基于密度的聚类"></a>基于密度的聚类</h2><p>密度聚类方法的指导思想是，只要样本点的密度大于某阈值，则将该样本添加到最近的簇中。这类算法能克服基于距离的算法只能发现“类圆”（凸）的聚类的缺点，可发现任意形状的聚类，且对噪声数据不敏感。但计算密度单元的计算复杂度大，需要建立空间索引来降低计算量。</p><h3 id="DBSCAN：一种基于高密度连通区域的密度聚类"><a href="#DBSCAN：一种基于高密度连通区域的密度聚类" class="headerlink" title="DBSCAN：一种基于高密度连通区域的密度聚类"></a>DBSCAN：一种基于高密度连通区域的密度聚类</h3><p>DBCSAN（Density-Based Spatial Clustering of Applications with Noise）是一个比较有代表性的基于密度的聚类算法。与划分和层次聚类方法不同，它将簇定义为密度相连的点的最大集合，能够把具有足够高密度的区域划分为簇，并可在有“噪声”的数据中发现任意形状的聚类。</p><p>基础概念</p><ul><li>对象的ϵ−领域：给定对象在半径ϵϵ内的区域</li><li>核心对象：对于给定的数目m，如果一个对象的ϵ−领域至少包含m个对象，则称该对象为核心对象。</li><li>直接密度可达：给定一个对象集合D，如果p是在q的ϵ−领域内，而q是一个核心对象，我们说对象p从对象q出发时直接密度可达的。</li></ul><p>如图ϵ=1 ，m=5， q是一个核心对象，从对象q出发到对象p是直接密度可达的。</p><p><img src="/2018/11/14/数据挖掘概念与技术/数据挖掘概念与技术笔记（8）：聚类（2）/01.jpg" alt></p><ul><li>密度可达：如果存在一个对象链$p<em>1,p_2,⋅⋅⋅,p_n$，使得$p_1=q$，$p_n=p$，并且对$p_i (1≤i≤n)∈D$，有$p</em>{i+1}$是从$p_i$关于ϵ和m直接密度可达的，则p是从q密度可达的(也就是中间连接了多个直接密度可达)。注意密度可达不是等价关系，因为它不是对称的。如果$o_1$和$o_2$都是核心对象，则都是密度可达；如果$o_2$是核心对象$o_1$不是，则$o_1$可能是从$o_2$密度可达，反过来就不可以。（需要从核心出发到不核心）</li></ul><p><img src="/2018/11/14/数据挖掘概念与技术/数据挖掘概念与技术笔记（8）：聚类（2）/02.jpg" alt></p><p> 密度相连：如果对象集合D中存在一个对象o，使得对p和q是从o关于ϵ和m密度可达的，那么对象p和q是关于ϵ和m密度相连的。 (存在中间点o，分别到q和p两条路线都是密度可达，则q和p密度相连)。不像密度可达，密度相连是等价的。 </p><p><img src="/2018/11/14/数据挖掘概念与技术/数据挖掘概念与技术笔记（8）：聚类（2）/03.jpg" alt></p><p>算法步骤：</p><p>下面这张图来自WIKI，图上有若干个点，其中标出了A、B、C、N这四个点，据此来说明这个算法的步骤：</p><p><img src="/2018/11/14/数据挖掘概念与技术/数据挖掘概念与技术笔记（8）：聚类（2）/04.jpg" alt></p><ul><li>1、首先随机选择A点为算法实施的切入点，我们将ϵϵ设置为图中圆的半径，对象密度个数$m（minPts）$设定为4。这里我们看到，A点的ϵϵ领域包含4个对象（自己也包含在内），大于等于$m(minPts)$，则创建A作为核心对象的新簇，簇内其他点都（暂时）标记为边缘点。</li><li>2、然后在标记的边缘点中选取一个重复上一步，寻找并合并核心对象直接密度可达的对象。对暂时标记为边缘点反复递归上述算法，直至没有新的点可以更新簇时，算法结束。这样就形成了一个以A为起始的一个聚类，为图中红色的中心点和黄色的边缘点（黄红点都形成簇）</li><li>3、如果还有Points未处理，再次新产生一个类别来重新启动这个算法过程。遍历所有数据，如果有点既不是边缘点也不是中心点，将其标记为噪音。</li></ul><p><img src="/2018/11/14/数据挖掘概念与技术/数据挖掘概念与技术笔记（8）：聚类（2）/05.webp" alt></p><p>初始，给定数据集D中的所有对象都标记为”unvisited”。DBSCAN随机地选择一个未访问的对象p，标记p为”visited”，并检查p是否为核心对象。如果不是，标记p为噪点，否则为p创建一个新的簇C，并且将领域内所有对象都放到候选集合N中（这个集合会慢慢加大）。<strong>DBSCAN迭代地把N中不属于其他簇的对象添加C中</strong>。在此过程中，对于N中标记为”unvisited”的对象p’ ，标记为”visited”，如果它是核心对象，则将它的领域节点都添加到N中。DBSCAN继续从候选集N中添加到C，直到N的集合为空。此时，簇C完全生成，于是被输出。</p><p>从上述算法可知：</p><ul><li>每个簇至少包含一个核心对象；</li><li>非核心对象可以是簇的一部分，构成了簇的边缘（edge）；</li><li>包含过少对象的簇被认为是噪声；</li></ul><p>DBSCAN的主要优点有：</p><p>　　1） 可以对任意形状的稠密数据集进行聚类，相对的，K-Means之类的聚类算法一般只适用于凸数据集。</p><p>　　2） 可以在聚类的同时发现异常点，对数据集中的异常点不敏感。</p><p>　　3） 聚类结果没有偏倚，相对的，K-Means之类的聚类算法初始值对聚类结果有很大影响。</p><p>DBSCAN的主要缺点有：</p><p>　　1）如果样本集的密度不均匀、聚类间距差相差很大时，聚类质量较差，这时用DBSCAN聚类一般不适合。</p><p>　　2） 如果样本集较大时，聚类收敛时间较长，此时可以对搜索最近邻时建立的KD树或者球树进行规模限制来改进。</p><p>　　3） 调参相对于传统的K-Means之类的聚类算法稍复杂，主要需要对距离阈值ϵ，邻域样本数阈值$m(MinPts)$联合调参，不同的参数组合对最后的聚类效果有较大影响。</p><h3 id="OPTICS-通过点排序识别聚类结构"><a href="#OPTICS-通过点排序识别聚类结构" class="headerlink" title="OPTICS:通过点排序识别聚类结构"></a>OPTICS:通过点排序识别聚类结构</h3><p>在前面介绍的DBSCAN算法中，有两个初始参数Eps（邻域半径）和minPts(Eps邻域最小点数)需要手动设置，并且聚类的结果对这两个参数的取值非常敏感，不同的取值将产生不同的聚类结果。为了克服DBSCAN算法这一缺点，提出了OPTICS算法（Ordering Points to identify the clustering structure），翻译过来就是，对点排序以此来确定簇结构。</p><p>OPTICS是对DBSCAN的一个扩展算法。该算法可以让算法对半径Eps不再敏感。只要确定minPts的值，半径Eps的轻微变化，并不会影响聚类结果 。OPTICS并不显示的产生结果类簇，而是为聚类分析生成一个增广的簇排序，从这个排序中可以得到基于任何参数Eps和minPts的DBSCAN算法的聚类结果。</p><h4 id="核心距离与可达距离"><a href="#核心距离与可达距离" class="headerlink" title="核心距离与可达距离"></a>核心距离与可达距离</h4><p>要搞清楚OPTICS算法，需要搞清楚2个新的定义：<strong>核心距离和可达距离</strong>。</p><ul><li>核心距离：一个对象p的核心距离是<strong>使得其成为核心对象的最小半径</strong>，如果p不是核心点，其可达距离没有定义 。</li><li>可达距离：从q到p的可达距离是$\max {core-distance(q), dist(p,q)}$。如果q不是核心点，其从q到p的可达距离没有定义。另外对象p关于不同的核心对象，p可能有多个可达距离。p的最小可达距离代表离一个稠密簇的距离越短，越处于核心密集地段。</li></ul><p>举例，下图中假设minPts=3，半径是ϵϵ。那么P点的核心距离是d(1,P)，点2的可达距离是d(1,P)，点3的可达距离也是d(1,P)，点4的可达距离则是d(4,P)的距离。</p><p><img src="/2018/11/14/数据挖掘概念与技术/数据挖掘概念与技术笔记（8）：聚类（2）/06.png" alt></p><h4 id="OPTICS算法描述"><a href="#OPTICS算法描述" class="headerlink" title="OPTICS算法描述"></a>OPTICS算法描述</h4><p>输入：样本集D, 邻域半径ϵϵ, 给定点在ϵϵ领域内成为核心对象的最小领域点数MinPts</p><p>输出：具有可达距离信息的样本点输出排序</p><p>首先创建两个队列，有序队列和结果队列。（有序队列用来存储核心对象及其该核心对象的直接可达对象，并按可达距离升序排列；结果队列用来存储样本点的输出次序。你可以把有序队列里面放的理解为待处理的数据，而结果队列里放的是已经处理完的数据）。</p><p>步骤：</p><ul><li>D: 待聚类的集合</li><li>Q: 有序队列，元素按照可达距离排序，可达距离最小的在队首</li><li>O: 结果队列，最后输出结果的点集的有序队列</li></ul><p>首先从D中取出一个核心对象p，首先p要先标记加入结果队列，它的领域则加入有序队列。从有序队列取队首q，先把队首q标记且加入结果队列，若q不为核心对象则继续从Q队列中取队首处理；否则若为核心队列则将q的领域加入到有序队列并重新排列顺序。加入新元素后再取有序队列队首依次循环处理。算法结束，输出结果队列中的有序样本点。</p><p><img src="/2018/11/14/数据挖掘概念与技术/数据挖掘概念与技术笔记（8）：聚类（2）/07.png" alt></p><p>得到结果队列后，使用如下算法得到最终的聚类结果：</p><ul><li>从结果队列中按顺序取出点，如果该点的<strong>可达距离</strong>不大于给定半径ϵϵ，则该点属于当前类别，否则至步骤2</li><li>如果该点的<strong>核心距离</strong>大于给定半径ϵ，则该点为噪声，可以忽略，否则该点属于新的聚类，跳至步骤1</li><li>结果队列遍历结束，则算法结束</li></ul><p><img src="/2018/11/14/数据挖掘概念与技术/数据挖掘概念与技术笔记（8）：聚类（2）/08.png" alt></p><p> 上面的算法处理完后，我们得到了输出结果序列，每个节点的可达距离和核心距离。我们以可达距离为纵轴，样本点输出次序为横轴进行可视化： </p><p><img src="/2018/11/14/数据挖掘概念与技术/数据挖掘概念与技术笔记（8）：聚类（2）/09.png" alt></p><p>其中：</p><ul><li>X轴代表OPTICS算法处理点的顺序，Y轴代表可达距离。</li><li>簇在坐标轴中表述为山谷，并且山谷越深，簇越紧密</li><li>黄色代表的是噪声，它们不形成任何凹陷。</li></ul><p>当你需要提取聚集的时候，参考Y轴和图像，自己设定一个阀值就可以提取聚集了。再来一张凹陷明显的：</p><p><img src="/2018/11/14/数据挖掘概念与技术/数据挖掘概念与技术笔记（8）：聚类（2）/10.png" alt></p><p>OPTICS的核心思想：</p><ul><li>较稠密簇中的对象在簇排序中相互靠近</li><li>一个对象的最小可达距离给出了一个对象连接到一个稠密簇的最短路径</li></ul><h3 id="DPCA算法"><a href="#DPCA算法" class="headerlink" title="DPCA算法"></a>DPCA算法</h3><p>2014年6月，Alex Rodriguez和Alessandro Laio在ScienceScience上发表了一篇名为《Clustering by fast search and find of density peaks》的文章，提供了一种简洁而优美的聚类算法，是一种基于密度的聚类方法，可以识别各种形状的类簇，并且参数很容易确定。它克服了DBSCAN中不同类的密度差别大、邻域范围难以设定的问题，鲁棒性强。 在文章中提出的聚类方法DPCA算法（Desity Peaks Clustering Algorithm）基于这样一种假设：对于一个数据集，聚类中心被一些低局部密度的数据点包围，而且这些低局部密度点距离其他有高局部密度的点的距离都比较大。</p><h4 id="一些概念："><a href="#一些概念：" class="headerlink" title="一些概念："></a>一些概念：</h4><ul><li>局部密度$p_i$ ：即到对象i的距离小于$d_c$的对象个数。</li><li>高局部密度点距离（顾名思义，密度是特别局部的），其定义为：</li></ul><script type="math/tex; mode=display">\delta_i=\min\limits_{j:p_j>p_i}d_{ij}</script><p> 即在局部密度高于对象i的所有对象中，到对象i最近的距离。 而极端地，对于局部密度最大的那个对象(它没有比它更大的了)，我们设置$\delta=max(d_{ij})$，即它与离它最远的点的距离； 只有那些密度是局部或者全局最大的点（即稀疏的点）才会有远大于正常值的高局部密度点距离。 </p><h4 id="聚类过程"><a href="#聚类过程" class="headerlink" title="聚类过程"></a>聚类过程</h4><p>这个聚类实例摘自作者的PPT讲演，在一个二维空间中对数据进行聚类，具体步骤如下：</p><p>1、首先计算每一个点的局部密度ρiρi，如图中，$ρ<em>1=7,ρ_8=5,ρ</em>{10}=4$</p><p><img src="/2018/11/14/数据挖掘概念与技术/数据挖掘概念与技术笔记（8）：聚类（2）/11.jpg" alt></p><p> 2、然后对于每一个点i计算在局部密度高于对象i的所有对象中，到对象i最近的距离，即$ \delta_i $</p><p><img src="/2018/11/14/数据挖掘概念与技术/数据挖掘概念与技术笔记（8）：聚类（2）/12.jpg" alt></p><p> 3、对每一个点，绘制出局部密度与高局部密度点距离的关系散点图 </p><p><img src="/2018/11/14/数据挖掘概念与技术/数据挖掘概念与技术笔记（8）：聚类（2）/13.jpg" alt></p><p> 4、<strong>图上的异常点即为簇中心</strong>。如图所示，1和10两点的局部密度和高局部密度距离都很大，将其作为簇中心。 </p><p><img src="/2018/11/14/数据挖掘概念与技术/数据挖掘概念与技术笔记（8）：聚类（2）/14.jpg" alt></p><p>5、将其他的点分配给距离其最近的有着更高的局部密度的簇。</p><p><img src="/2018/11/14/数据挖掘概念与技术/数据挖掘概念与技术笔记（8）：聚类（2）/15.jpg" alt></p><p> 左图是所有点在二维空间的分布，右图是以ρρ为横坐标，以δδ为纵坐标绘制的决策图。容<strong>易发现，1和10两个点的$ρ_i$和$ \delta_i $都比较大，作为簇的中心点</strong>。<strong>26、27、28三个点的δδ也比较大，但是ρ比较小，所以是异常点</strong>。 </p><h4 id="簇中心的识别"><a href="#簇中心的识别" class="headerlink" title="簇中心的识别"></a>簇中心的识别</h4><p>那些有着比较大的局部密度ρiρi和很大的高局部密度δiδi的点被认为是簇的中心； 而高局部密度距离δiδi较大但局部密度ρiρi较小的点是异常点； 确定簇中心之后，其他点按照距离已知簇的中心最近进行分类，也可以按照密度可达的方法进行分类。</p><p>但是，这里我们在确定聚类中心时，没有定量地分析，而是通过肉眼观察，包含很多的主观因素。因此，作者在文中给出了一种确定聚类中心个数的提醒：计算一个将ρ值和$ \delta$值综合考虑的量</p><script type="math/tex; mode=display">\gamma_i=\rho_i\delta_i</script><p>显然γ值越大，越有可能是聚类中心。因此，只需对其降序排列，然后从前往后截取若干个数据点作为聚类中心就可以了。</p><p>领域阈值$d_c$的选择：一种推荐做法是选择$d_c$，使得平均每个点的邻居数为所有点的1%~2%。</p><h2 id="基于网格的聚类"><a href="#基于网格的聚类" class="headerlink" title="基于网格的聚类"></a>基于网格的聚类</h2><p>基于格子的参考这篇文章吧，感觉很少用啊，主要是STING统计信息网格算法和CLIQUE子空间聚类算法。</p><p><a href="https://cloud.tencent.com/developer/article/1005263" target="_blank" rel="noopener">戳我</a></p><h2 id="谱聚类"><a href="#谱聚类" class="headerlink" title="谱聚类"></a>谱聚类</h2><p>谱聚类似乎也应用较广，这篇博客写的很清晰了</p><p><a href="https://blog.csdn.net/google19890102/article/details/45697695" target="_blank" rel="noopener">戳我</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基于密度的聚类&quot;&gt;&lt;a href=&quot;#基于密度的聚类&quot; class=&quot;headerlink&quot; title=&quot;基于密度的聚类&quot;&gt;&lt;/a&gt;基于密度的聚类&lt;/h2&gt;&lt;p&gt;密度聚类方法的指导思想是，只要样本点的密度大于某阈值，则将该样本添加到最近的簇中。这类算法能克服基于
      
    
    </summary>
    
      <category term="数据挖掘" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
    
      <category term="DBSCAN聚类" scheme="http://yoursite.com/tags/DBSCAN%E8%81%9A%E7%B1%BB/"/>
    
      <category term="聚类" scheme="http://yoursite.com/tags/%E8%81%9A%E7%B1%BB/"/>
    
      <category term="STING聚类" scheme="http://yoursite.com/tags/STING%E8%81%9A%E7%B1%BB/"/>
    
      <category term="DPCA聚类" scheme="http://yoursite.com/tags/DPCA%E8%81%9A%E7%B1%BB/"/>
    
      <category term="谱聚类" scheme="http://yoursite.com/tags/%E8%B0%B1%E8%81%9A%E7%B1%BB/"/>
    
      <category term="OPTICS聚类" scheme="http://yoursite.com/tags/OPTICS%E8%81%9A%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>数据挖掘概念与技术笔记（7）：聚类（1）</title>
    <link href="http://yoursite.com/2018/11/12/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%887%EF%BC%89%EF%BC%9A%E8%81%9A%E7%B1%BB%EF%BC%881%EF%BC%89/"/>
    <id>http://yoursite.com/2018/11/12/数据挖掘概念与技术/数据挖掘概念与技术笔记（7）：聚类（1）/</id>
    <published>2018-11-12T09:06:14.000Z</published>
    <updated>2020-01-05T04:19:47.499Z</updated>
    
    <content type="html"><![CDATA[<p> 下图简单地总结了一些聚类方法的简单划分 </p><p><img src="/2018/11/12/数据挖掘概念与技术/数据挖掘概念与技术笔记（7）：聚类（1）/01.png" alt></p><h2 id="基于划分的聚类"><a href="#基于划分的聚类" class="headerlink" title="基于划分的聚类"></a>基于划分的聚类</h2><p>聚类分析最简单、最基本的版本是基于划分的聚类，它把对象组织成多个互斥的组或簇。为了使得问题说明简洁，我们假定簇个数作为背景知识给定，这个参数是划分方法的起点。</p><h3 id="k-均值（k-mean）-：一种基于形心的技术"><a href="#k-均值（k-mean）-：一种基于形心的技术" class="headerlink" title="k-均值（k-mean） ：一种基于形心的技术"></a>k-均值（k-mean） ：一种基于形心的技术</h3><p><strong>k均值算法非常简单，它用簇$C_i$的形心代表该簇。每次确定K个类别中心，然后将各个结点归属到与之距离最近的中心点所在的Cluster，然后将类别中心更新为属于各Cluster的所有样本的均值</strong>，反复迭代，直至类别中心不再发生变化或变化小于某阈值。 下面给出该算法的伪代码</p><p><img src="/2018/11/12/数据挖掘概念与技术/数据挖掘概念与技术笔记（7）：聚类（1）/02.png" alt></p><ul><li>优点：<ul><li>是解决聚类问题的一种经典算法，简单、快速</li><li>对处理大数据集，该算法保持可伸缩性和高效率</li></ul></li><li>缺点：<ul><li>必须事先给出K，而且对初值敏感，对于不同的初始值，结果可能不同</li><li>只能发现球状Cluster，不适合于发现非凸形状的簇或者大小差别很大的簇</li><li>对噪声和孤立点数据敏感，如簇中含有异常点，将导致均值偏离严重</li></ul></li></ul><p>如何确定k类</p><p><a href="https://www.cnblogs.com/yan2015/p/5239970.html" target="_blank" rel="noopener">https://www.cnblogs.com/yan2015/p/5239970.html</a></p><h3 id="k-中心点（k-mediods）：一种基于代表对象的技术"><a href="#k-中心点（k-mediods）：一种基于代表对象的技术" class="headerlink" title="k-中心点（k-mediods）：一种基于代表对象的技术"></a>k-中心点（k-mediods）：一种基于代表对象的技术</h3><p>k-均值算法对离群点敏感，因为这种对象远离大多数数据，因此分配到一个簇时，它们可能严重地扭曲簇的均值。因此，提出了k-中心点算法，<strong>它挑选实际对象代表簇，每个簇使用一个代表对象。这个代表对象选择的规则是：选择簇内一个点到其他点的距离之和的最小代价值，作为新的中心点</strong>。</p><p>K-中心聚类算法计算的是某点到其它所有点的距离之和最小的点，通过距离之和最短的计算方式可以减少某些孤立数据对聚类过程的影响 。下面给出算法的伪代码</p><p><img src="/2018/11/12/数据挖掘概念与技术/数据挖掘概念与技术笔记（7）：聚类（1）/03.png" alt></p><h2 id="基于层次的聚类"><a href="#基于层次的聚类" class="headerlink" title="基于层次的聚类"></a>基于层次的聚类</h2><p>尽管基于划分的聚类算法能够实现把数据集划分成指定数量的簇，但是在某些情况下，需要把数据集划分成不同层上的簇。<strong>层次聚类方法将数据组成层次结构或簇的”树”</strong></p><p><strong>基于层次的聚类算法（Hierarchical Clustering）可以</strong>是凝聚的（Agglomerative）或者分裂的（Divisive），取决于层次的划分是“自底向上”还是“自顶向下”。</p><ul><li>自顶向下： 它把所有对象至于一个簇中开始，该簇是层次结构的根。然后，它把根上的簇划分为多个较小的子簇，并且递归地把这次簇划分成更小的簇，直到满足终止条件。常见的自顶向下的算法有K-means层次聚类算法。</li><li>自底向上：把数据集中的每个对象最为一个簇开始，迭代地把簇合并成为更大的簇，直到最终形成一个大簇，或者满足某个终止条件。基于自底向上算法有凝聚算法、BIRCH算法、CURE算法、变色龙算法等。</li></ul><h3 id="自顶向下算法"><a href="#自顶向下算法" class="headerlink" title="自顶向下算法"></a>自顶向下算法</h3><h4 id="Hierarchical-K-means算法"><a href="#Hierarchical-K-means算法" class="headerlink" title="Hierarchical K-means算法"></a>Hierarchical K-means算法</h4><p>Hierarchical K-means算法是“自顶向下”的层次聚类算法，用到了基于划分的聚类算法那K-means，算法思路如下：</p><ol><li>首先，把原始数据集放到一个簇C，这个簇形成了层次结构的最顶层；</li><li>使用K-means算法把簇C划分成指定的K个子簇$C_i，i=1,2,…,k$，形成一个新的层；</li><li>对于步骤2所生成的K个簇，递归使用K-means算法划分成更小的子簇，直到每个簇不能再划分（只包含一个数据对象）或者满足设定的终止条件。</li></ol><p>如下图，展示了一组数据进行了二次K-means算法的过程</p><p><img src="/2018/11/12/数据挖掘概念与技术/数据挖掘概念与技术笔记（7）：聚类（1）/04.png" alt></p><p> Hierarchical K-means算法一个很大的问题是，一旦两个点在最开始被划分到了不同的簇，即使这两个点距离很近，在后面的过程中也不会被聚类到一起。 </p><p><img src="/2018/11/12/数据挖掘概念与技术/数据挖掘概念与技术笔记（7）：聚类（1）/05.png" alt></p><p>对于以上的例子，红色椭圆框中的对象聚类成一个簇可能是更优的聚类结果，但是由于橙色对象和绿色对象在第一次K-means就被划分到不同的簇，之后也不再可能被聚类到同一个簇。</p><h3 id="自底向上算法"><a href="#自底向上算法" class="headerlink" title="自底向上算法"></a>自底向上算法</h3><h4 id="Agglomerative-Clustering算法"><a href="#Agglomerative-Clustering算法" class="headerlink" title="Agglomerative Clustering算法"></a>Agglomerative Clustering算法</h4><p>相比于Hierarchical K-means算法存在的问题，Agglomerative Clustering算法能够保证距离近的对象能够被聚类到一个簇中，该算法采用的“自底向上”聚类的思路。</p><p> 算法思路，对于数据集$D，D=x_1,x_2,…,x_n$：</p><ol><li>将数据集中的每个对象生成一个簇，得到簇列表$C，C=c_1,c_2,…,c_n$<ul><li>a) 每个簇只包含一个数据对象：$c_i=x_i$；</li></ul></li><li>重复如下步骤，直到C中只有一个簇：<ul><li>a) 从C中的簇中找到两个“距离”最近的两个簇：$\min D(ci,cj)$；</li><li>b) 合并簇$c<em>i$和$c_j$，形成新的簇$c</em>{ij}；</li><li>c) 从C中删除簇$c<em>i%和$c_j$，添加簇$c</em>{ij}</li></ul></li></ol><h5 id="簇间距离计算"><a href="#簇间距离计算" class="headerlink" title="簇间距离计算"></a>簇间距离计算</h5><p>在上面描述的算法中涉及到计算两个簇之间的距离，对于簇$C_1$和$C_2$，计算$minD(C1,C2)$，有以下几种计算方式：</p><p> <strong>最小距离：</strong> </p><script type="math/tex; mode=display">\min\ dist_{min}(C_i,C_j)=\min \mathop{\min} \limits_{p\in C_i,q\in C_j}\{|p-q|\}</script><p><img src="/2018/11/12/数据挖掘概念与技术/数据挖掘概念与技术笔记（7）：聚类（1）/06.png" alt></p><p>两个簇之间最近的两个点的距离作为簇之间的距离，该方式的缺陷是受噪点影响大，容易产生长条状的簇。</p><p><strong>最大距离：</strong></p><script type="math/tex; mode=display">\min\ dist_{max}(C_i,C_j)=\min \mathop{\max} \limits_{p\in C_i,q\in C_j}\{|p-q|\}</script><p><img src="/2018/11/12/数据挖掘概念与技术/数据挖掘概念与技术笔记（7）：聚类（1）/07.png" alt></p><p>两个簇之间最远的两个点的距离作为簇之间的距离，采用该距离计算方式得到的聚类比较紧凑。</p><p><strong>均值距离：</strong> $m_i$和$m_j$为簇内所有点的均值坐标</p><script type="math/tex; mode=display">\min\ dist_{mean}(C_i,C_j)=\min |m_i-m_j|</script><p> <strong>平均距离：</strong> </p><script type="math/tex; mode=display">\min\ dist_{avg}(C_i,C_j)=\min\ \frac{1}{n_in_j}\mathop{\sum}\limits_{p\in C_i,q\in C_j}\{|p-q|\}</script><h5 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h5><p><img src="/2018/11/12/数据挖掘概念与技术/数据挖掘概念与技术笔记（7）：聚类（1）/09.png" alt></p><p>Agglomerative聚类算法的优点是能够根据需要在不同的尺度上展示对应的聚类结果，缺点同Hierarchical K-means算法一样，一旦两个距离相近的点被划分到不同的簇，之后也不再可能被聚类到同一个簇，即无法撤销先前步骤的工作。另外，Agglomerative性能较低，并且因为聚类层次信息需要存储在内存中，内存消耗大，不适用于大量级的数据聚类，下面介绍一种针对大数据量级的聚类算法BIRCH。</p><h4 id="BIRCH算法：使用聚类特征树"><a href="#BIRCH算法：使用聚类特征树" class="headerlink" title="BIRCH算法：使用聚类特征树"></a>BIRCH算法：使用聚类特征树</h4><p><strong>BIRCH算法利用了一个树结构来帮助实现快速的聚类，这个数结构类似于平衡B+树，一般将它称之为聚类特征树(Clustering Feature Tree，简称CF Tree)。</strong>这颗树的<strong>每一个节点是由若干个聚类特征(Clustering Feature，简称CF)组成</strong>。从下图可以看看聚类特征树是什么样子的：<strong>每个节点包括叶子节点都有若干个CF，而内部节点的CF有指向孩子节点的指针，所有的叶子节点用一个双向链表链接起来</strong>。</p><p><img src="/2018/11/12/数据挖掘概念与技术/数据挖掘概念与技术笔记（7）：聚类（1）/10.png" alt></p><p> <strong>在聚类特征树中，一个聚类特征CF是这样定义的：</strong>每一个CF是一个三元组，可以用（N，LS，SS）表示，其中<strong>N代表了这个CF中拥有的样本点的数量；LS代表了这个CF中拥有的样本点各特征维度的和向量，SS代表了这个CF中拥有的样本点各特征维度的平方和</strong>。 聚类特征本质上是定簇的统计汇总。使用聚类特征，我们可以很容易地推导出簇的许多有用的统计量，例如簇的形心$x_0$、半径R和直径D分别是 </p><script type="math/tex; mode=display">x_0=\frac{\sum_{i=1}^nx_i}{n}=\frac{LS}{n}</script><script type="math/tex; mode=display">R=\sqrt{\frac{\sum_{i=1}^n(x_i-x_0)^2}{n}}</script><script type="math/tex; mode=display">D=\sqrt{\frac{\sum_{i=1}^n\sum_{j=1}^n(x_i-x_j)^2}{n(n-1)}}=\sqrt{\frac{2nSS-2LS^2}{n(n-1)}}</script><p>其中，R是成员对象到形心的平均距离，D是簇中逐对对象的平均距离。<strong>R和D都反映了形心周围簇的紧凑程度</strong>。</p><p>此外，<strong>聚类特征是可加的</strong>，也就是说，对于两个不相交的簇$C_1$和$C_2$，其聚类特征分别是$CF_1[n_1,LS_1,SS_1]$和$CF_2 [n_2,LS_2,SS_2]，合并后的簇的聚类特征是 </p><script type="math/tex; mode=display">CF_1+CF_2=[n_1+n_2,LS_1+LS_2,SS_1+SS_2]</script><p>对于CF Tree，一般有几个重要参数，<strong>第一个参数是每个内部节点的最大CF数B</strong>，<strong>第二个参数是每个叶子节点的最大CF数L</strong>，<strong>第三个参数是针对叶子节点中某个CF中的样本点来说的，它是叶节点每个CF的最大样本半径阈值T</strong>，也就是说，在<strong>这个CF中的所有样本点一定要在半径小于T的一个超球体内</strong>。对于图中的CF Tree，<strong>限定了B=7， L=5， 也就是说内部节点最多有7个CF，而叶子节点最多有5个CF</strong>。</p><p><strong>将所有的训练集样本建立了CF Tree，一个基本的BIRCH算法就完成了，对应的输出就是若干个CF节点，每个节点里的样本点就是一个聚类的簇。也就是说BIRCH算法的主要过程，就是建立CF Tree的过程。</strong></p><h5 id="聚类特征树CF-Tree的生成"><a href="#聚类特征树CF-Tree的生成" class="headerlink" title="聚类特征树CF Tree的生成"></a>聚类特征树CF Tree的生成</h5><p>下面看看怎么生成CF Tree。<strong>先定义好CF Tree的参数： 即内部节点的最大CF数B， 叶子节点的最大CF数L， 叶节点每个CF的最大样本半径阈值T。</strong></p><p><strong>开始时CF Tree是空的，</strong>没有任何样本，我们<strong>从训练集读入第一个样本点，将它放入一个新的CF三元组A</strong>，这个三元组的N=1，将这个新的CF放入根节点，<strong>此时的CF Tree如下图：</strong></p><p><img src="/2018/11/12/数据挖掘概念与技术/数据挖掘概念与技术笔记（7）：聚类（1）/11.png" alt></p><p> <strong>现在继续读入第二个样本点，发现这个样本点和第一个样本点A在半径为T的超球体范围内，即他们属于一个CF，将第二个点也加入CF A,此时需要更新A的三元组的值。</strong>此时A的三元组中N=2。此时的CF Tree如下图： </p><p><img src="/2018/11/12/数据挖掘概念与技术/数据挖掘概念与技术笔记（7）：聚类（1）/12.png" alt></p><p> <strong>此时读取第三个节点，结果发现这个节点不能融入刚才前面的节点形成的超球体内，</strong>也就是说，<strong>需要一个新的CF三元组B来容纳这个新的值。此时根节点有两个CF三元组A和B</strong>，此时的CF Tree如下图： </p><p><img src="/2018/11/12/数据挖掘概念与技术/数据挖掘概念与技术笔记（7）：聚类（1）/13.png" alt></p><p> <strong>当来到第四个样本点时，发现和B在半径小于T的超球体，这样更新后的CF Tree如下图：</strong> </p><p><img src="/2018/11/12/数据挖掘概念与技术/数据挖掘概念与技术笔记（7）：聚类（1）/14.png" alt></p><p>那个什么时候CF Tree的节点需要分裂呢？假设现在的CF Tree 如下图， 叶子节点LN1有三个CF， LN2和LN3各有两个CF。<strong>叶子节点的最大CF数L=3</strong>。此时一个新的样本点来了，发现它离LN1节点最近，因此开始判断它是否在sc1,sc2,sc3这3个CF对应的超球体之内，但是很不幸，它不在，因此它需要建立一个新的CF，即sc8来容纳它。<strong>问题是我们的L=3，也就是说LN1的CF个数已经达到最大值了，不能再创建新的CF了，怎么办？此时就要将LN1叶子节点一分为二了</strong>。</p><p><strong>将LN1里所有CF元组中，找到两个最远的CF做这两个新叶子节点的种子CF，然后将LN1节点里所有CF sc1, sc2, sc3，以及新样本点的新元组sc8划分到两个新的叶子节点上。</strong>将LN1节点划分后的CF Tree如下图：</p><p><img src="/2018/11/12/数据挖掘概念与技术/数据挖掘概念与技术笔记（7）：聚类（1）/15.png" alt></p><p> <strong>如果内部节点的最大CF数B=3，则此时叶子节点一分为二会导致根节点的最大CF数超了，也就是说，根节点现在也要分裂</strong>，分裂的方法和叶子节点分裂一样，分裂后的CF Tree如下图： </p><p><img src="/2018/11/12/数据挖掘概念与技术/数据挖掘概念与技术笔记（7）：聚类（1）/16.png" alt></p><p><strong>有了上面这一系列的图，相信大家对于CF Tree的插入就没有什么问题了，总结下CF Tree的插入：</strong></p><ul><li>1、<strong>从根节点向下寻找</strong>和新样本距离最近的叶子节点和叶子节点里最近的CF节点（判断新节点与NLN1和NLN2谁近一些，然后继续往下）</li><li>2、如果新样本加入后，这个CF节点对应的超球体半径仍然满足小于阈值T，则更新路径上所有的CF三元组，插入结束。否则转入3.</li><li>3、如果当前叶子节点的CF节点个数小于阈值L，则创建一个新的CF节点，放入新样本，将新的CF节点放入这个叶子节点，更新路径上所有的CF三元组，插入结束。否则转入4。</li><li>4、将当前叶子节点划分为两个新叶子节点，选择旧叶子节点中所有CF元组里超球体距离最远的两个CF元组，分布作为两个新叶子节点的第一个CF节点。将其他元组和新样本元组按照距离远近原则放入对应的叶子节点。依次向上检查父节点是否也要分裂，如果需要按和叶子节点分裂方式相同。</li></ul><p>当然，真实的BIRCH算法除了建立CF Tree来聚类，其实还有一些可选的算法步骤的，<strong>现在我们就来看看 BIRCH算法的流程。</strong></p><ul><li>1） 将所有的样本依次读入，在内存中建立一颗CF Tree, 建立的方法参考上一节。</li><li>2）（可选）将第一步建立的CF Tree进行筛选，去除一些异常CF节点，这些节点一般里面的样本点很少。对于一些超球体距离非常近的元组进行合并</li><li>3）（可选）利用其它的一些聚类算法比如K-Means对所有的CF元组进行聚类，得到一颗比较好的CF Tree.这一步的主要目的是消除由于样本读入顺序导致的不合理的树结构，以及一些由于节点CF个数限制导致的树结构分裂。</li><li>4）（可选）利用第三步生成的CF Tree的所有CF节点的质心，作为初始质心点，对所有的样本点按距离远近进行聚类。这样进一步减少了由于CF Tree的一些限制导致的聚类不合理的情况。</li></ul><p><strong>从上面可以看出，BIRCH算法的关键就是步骤1，也就是CF Tree的生成，其他步骤都是为了优化最后的聚类结果。</strong></p><p><strong>优点</strong></p><ul><li>1) 节约内存，所有的样本都在磁盘上，CF Tree仅仅存了CF节点和对应的指针。</li><li>2) 聚类速度快，只需要一遍扫描训练集就可以建立CF Tree，CF Tree的增删改都很快。</li><li>3) 可以识别噪音点，还可以对数据集进行初步分类的预处理</li></ul><p><strong>缺点</strong></p><ul><li>1) 由于CF Tree对每个节点的CF个数有限制，导致聚类的结果可能和真实的类别分布不同.</li><li>2) 对高维特征的数据聚类效果不好。此时可以选择Mini Batch K-Means</li><li>3) 如果数据集的分布簇不是类似于超球体，或者说不是凸的，则聚类效果不好。</li></ul><h4 id="CURE算法"><a href="#CURE算法" class="headerlink" title="CURE算法"></a>CURE算法</h4><p>CURE（Clustering Using Representatives）是一种针对大型数据库的高效的聚类算法。基于划分的传统的聚类算法得到的是球状的，相等大小的聚类，对异常数据比较脆弱。CURE采用了用多个点代表一个簇的方法，可以较好的处理以上问题。并且在处理大数据量的时候采用了随机取样，分区的方法，来提高其效率，使得其可以高效的处理大量数据。</p><p>我们先看一下基于划分聚类算法的缺陷：</p><p><img src="/2018/11/12/数据挖掘概念与技术/数据挖掘概念与技术笔记（7）：聚类（1）/17.png" alt></p><p>如上图所示，基于划分的聚类算法比如Hierarchical K-means聚类算法，不能够很好地区分尺寸差距大的簇，原因是K-means算法基于“质心”加一定“半径”对数据进行划分，导致最后聚类的簇近似“圆形”。</p><p><strong>CURE算法核心的思想是使用一定数量的“分散的”点（scattered points）来代表一个簇（cluster）</strong>，而不像是其他层次聚类算法中，只使用一个点，使得CURE算法有如下优势：</p><ul><li>准确地识别任意形状的簇；</li><li>准确地识别尺寸差距大的簇；</li><li>很好地处理“噪点”</li></ul><p>所以，CURE算法很好地解决了上面提到的聚类结果的缺陷，CURE算法主流程如下：</p><p><strong>Pass 1</strong></p><ul><li>1、从总数据中随机选取一个样本；</li><li>2、利用层次聚类算法把这个样本聚类，形成最初的簇$C_i,(i=1,2,…,k)$；</li><li>3、选取“代表点”（representative pionts）;</li></ul><p>①对于每个簇，选取代表点（比如4个），这些点尽量分散;</p><p>②按照固定的比例α（比如20%），把每个样本点向簇的“质心”收缩，生成代表点</p><script type="math/tex; mode=display">\{p'_{i1},p'_{i2},p'_{i3},p'_{i4}\}</script><p><strong>Pass 2</strong></p><ul><li>重新扫描所有的数据， 对于点p，找到距离p最近的簇，把它放到 “最近的簇”。简单来讲，<strong>是点p到簇$C_i$的距离为点p到簇$C_i$的四个“代表点 中最近的点之间的距离</strong>。</li></ul><p>收缩系数α的取值不同，聚类结果也相应不同。当α趋于0时，所有的“代表点”都汇聚到质心，算法退化为基于“质心”的聚类；当α趋于1时，“代表点”完全没有收缩，算法退化为基于“全连接”的聚类，因此α值需要要根据数据特征灵活选取，才能得到更好的聚类结果</p><h4 id="Chameleon变色龙算法：使用动态建模"><a href="#Chameleon变色龙算法：使用动态建模" class="headerlink" title="Chameleon变色龙算法：使用动态建模"></a>Chameleon变色龙算法：使用动态建模</h4><p>Chameleon（变色龙）是一种层次聚类算法，它采用动态建模来确定一对簇之间的相似度。在Chameleon中，簇的相似性依据以下两点评估：1）簇中对象的连接情况 ；2）簇的邻近性。也就是说，如果两个簇的互连性都很高并且它们之间又靠得很近就将其合并。</p><p><img src="/2018/11/12/数据挖掘概念与技术/数据挖掘概念与技术笔记（7）：聚类（1）/18.png" alt></p><p>整体算法流程：</p><p>1、创建KNN图，每个节点将其最相似的k个节点用一条边连接起来；</p><p>2、使用最大流算法或者最小割算法，将kNN图分隔成小图； 也就是说簇C被划分为子簇CiCi和$C_j$，使得把C二分成$C_i$和$C_j$而被切断的边的权重之和最小。</p><p>3、将小簇进行和并，找对最大的度量值$RC*RI^\alpha$的两个簇，合并条件是$RC*RI^\alpha$大于某个阈值，否则结束合并。RC和RI的一个基本思想是，点之间的链接越多，这些点越可能连接成一个簇，C表示一个簇，是点的集合，|C|是集合的大小，即点的个数, $EC(A,B)$表示两个簇之间的边的数量。</p><p><strong>相似互连度</strong>$RI(C_i,C_j)$</p><script type="math/tex; mode=display">RI(C_i,C_j)=\frac{|EC_{\{C_i,C_j\}}|}{\frac{1}{2}(|EC_{C_i}|+|EC_{C_j}|)}</script><p> 相对接近度$RC(C_i,C_j)$</p><script type="math/tex; mode=display">RC(C_i,C_j)=\frac{\overline S_{EC_{\{C_i,C_j\}}}}{\frac{|C_i|}{|C_i|+|C_j|} \overline S_{EC_{C_i}}+ \frac{|C_i|}{|C_i|+|C_j|} \overline S_{EC_{C_j}}  }</script><p> 其中，分子是连接$C_i$顶点和$C_j$顶点的边的平均权重，分母SECC是最小二分簇$C_i$（或$C_j$）的边的平均权重。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; 下图简单地总结了一些聚类方法的简单划分 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2018/11/12/数据挖掘概念与技术/数据挖掘概念与技术笔记（7）：聚类（1）/01.png&quot; alt&gt;&lt;/p&gt;
&lt;h2 id=&quot;基于划分的聚类&quot;&gt;&lt;a href=&quot;#基于划分的聚类&quot; cl
      
    
    </summary>
    
      <category term="数据挖掘" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
    
      <category term="聚类" scheme="http://yoursite.com/tags/%E8%81%9A%E7%B1%BB/"/>
    
      <category term="k均值" scheme="http://yoursite.com/tags/k%E5%9D%87%E5%80%BC/"/>
    
      <category term="k中心点" scheme="http://yoursite.com/tags/k%E4%B8%AD%E5%BF%83%E7%82%B9/"/>
    
      <category term="层次聚类" scheme="http://yoursite.com/tags/%E5%B1%82%E6%AC%A1%E8%81%9A%E7%B1%BB/"/>
    
      <category term="BIRCH聚类" scheme="http://yoursite.com/tags/BIRCH%E8%81%9A%E7%B1%BB/"/>
    
      <category term="Chameleon变色龙聚类" scheme="http://yoursite.com/tags/Chameleon%E5%8F%98%E8%89%B2%E9%BE%99%E8%81%9A%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>数据挖掘概念与技术笔记（6）：高级分类方法</title>
    <link href="http://yoursite.com/2018/11/09/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%886%EF%BC%89%EF%BC%9A%E9%AB%98%E7%BA%A7%E5%88%86%E7%B1%BB%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2018/11/09/数据挖掘概念与技术/数据挖掘概念与技术笔记（6）：高级分类方法/</id>
    <published>2018-11-09T09:06:14.000Z</published>
    <updated>2019-12-28T13:05:07.539Z</updated>
    
    <content type="html"><![CDATA[<h2 id="贝叶斯信念网络"><a href="#贝叶斯信念网络" class="headerlink" title="贝叶斯信念网络"></a>贝叶斯信念网络</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>朴素贝叶斯分类有一个限制条件，就是特征属性<strong>必须有条件独立或基本独立</strong>（实际上在现实应用中几乎不可能做到完全独立）。当这个条件成立时，朴素贝叶斯分类法的准确率是最高的，但不幸的是，现实中各个特征属性间往往并不条件独立，而是具有<strong>较强的相关性</strong>，这样就限制了朴素贝叶斯分类的能力。 解决这个问题的一种算法叫<strong>贝叶斯网络（又称贝叶斯信念网络或信念网络）</strong>。</p><p>贝叶斯网络由两个成分定义：1）有向无环图（DAG）; 2)条件概率表的集合(Conditional Probability Table，CPT)</p><p><img src="/2018/11/09/数据挖掘概念与技术/数据挖掘概念与技术笔记（6）：高级分类方法/01.png" alt></p><p>上图给出了一个布尔变量的简单贝叶斯信念网络，图中的弧可看做因果知识。<strong>换言之，一旦我们知道变量LungCanner的结果，那么变量FamilyHistory和Smoker就不再提供关于PostiveXRay的任何附近信息</strong>。</p><p>DAG中每一个节点表示一个随机变量，可以是可直接观测变量或隐藏变量，而有向边表示随机变量间的条件依赖；<strong>条件概率表中的每一个元素对应DAG中唯一的节点，存储此节点对于其所有直接前驱节点的联合条件概率</strong>。贝叶斯网络有一条极为重要的性质，就是我们<strong>断言每一个节点在其直接前驱节点的值制定后，这个节点条件独立于其所有非直接前驱前辈节点</strong>。这条特性的<strong>重要意义</strong>在于明确了贝叶斯网络可以方便计算联合概率分布。 一般情况先，多变量非独立联合条件概率分布有如下求取公式：</p><script type="math/tex; mode=display">P(x_1,x_2,..,x_n)=P(x_1)P(x_2|x_1)P(x_3|x_1,x_2)...P(x_n|x_1,x_2,...,x_{n-1})</script><p> 而在贝叶斯网络中，由于存在前述性质，任意随机变量组合的联合条件概率分布被化简成 </p><script type="math/tex; mode=display">P(x_1,x_2,...,x_n)=\prod_{i=1}^nP(x_i|Parents(x_i))</script><p> 其中，$P(x_1,…,x_n)$是X的值的特定组合的概率，Parents表示xi的直接前驱节点的<strong>联合</strong> ，而$P(x_i|Parents(x_i))$的值对应于CPT概率表的值。 </p><p><img src="/2018/11/09/数据挖掘概念与技术/数据挖掘概念与技术笔记（6）：高级分类方法/02.png" alt></p><p>上图是一个有向无环图（DAG） ，不过仅有这个图的话，只能<strong>定性</strong>给出随机变量间的关系，如果要定量，还需要一些数据，这些数据就是每个节点对其直接前驱节点的条件概率（也就是CPT表的概率），而没有前驱节点的节点则使用先验概率表示。</p><p>没有前驱的节点用先验概率表示；以及CPT条件概率，例如P(H=0|R=0)=0.9（真实账号为假，头像也为假的概率）</p><p><img src="/2018/11/09/数据挖掘概念与技术/数据挖掘概念与技术笔记（6）：高级分类方法/03.png" alt></p><p> <strong>有了这些数据，不但能顺向推断，还能通过贝叶斯定理进行逆向推断</strong>。例如，现随机抽取一个账户，已知其头像为假，求其账号也为假的概率： </p><p><img src="/2018/11/09/数据挖掘概念与技术/数据挖掘概念与技术笔记（6）：高级分类方法/04.png" alt></p><p><strong>如果给出所有节点的条件概率表，则可以在观察值不完备的情况下对任意随机变量进行统计推断</strong>。上述方法就是使用了贝叶斯网络。</p><h3 id="训练贝叶斯网络"><a href="#训练贝叶斯网络" class="headerlink" title="训练贝叶斯网络"></a>训练贝叶斯网络</h3><p>构造与训练贝叶斯网络分为以下两步：</p><ul><li>1、确定随机变量间的拓扑关系，形成DAG。<strong>这一步通常需要领域专家完成</strong>，而想要建立一个好的拓扑结构，通常需要不断迭代和改进才可以。</li><li>2、训练贝叶斯网络。如果不训练的，我们只能知道定性的网络，而不能定量。<strong>实际上这一步也就是要完成条件概率表(CPT表)的构造</strong>，如果每个随机变量的值都是可以直接观察的，像我们上面的例子，那么这一步的训练是直观的，方法类似于朴素贝叶斯分类。<strong>但是通常贝叶斯网络的中存在隐藏变量节点，那么训练方法就是比较复杂，例如使用梯度下降法</strong>。</li></ul><h3 id="性能如何"><a href="#性能如何" class="headerlink" title="性能如何"></a>性能如何</h3><p>贝叶斯网络已经广泛于临床，生物，征信等领域。其强大之处在于两点</p><ul><li>1.贝叶斯网络最强大之处在于从每个阶段结果所获得的概率都是数学与科学的反映，换句话说，假设我们了解了足够多的信息，根据这些信息获继而得统计知识，网络就会告诉我们合理的推断。</li><li>2.贝叶斯网络最很容易扩展(或减少,简化),以<strong>适应不断变化的需求和变化的知识</strong>。</li></ul><h2 id="使用频繁模式分类"><a href="#使用频繁模式分类" class="headerlink" title="使用频繁模式分类"></a>使用频繁模式分类</h2><h3 id="关联分类"><a href="#关联分类" class="headerlink" title="关联分类"></a>关联分类</h3><p>回顾一下之前的关联规则，显示了规则的置信度和支持度</p><script type="math/tex; mode=display">age=youth \land credit=ok \Rightarrow buys\_computer=yes \\ [support =20\%，confidence=93\%]</script><p>从分类角度，置信度类似于规则的准准确度。例如，93%的置信度意味着D中身为年轻人并且信誉度为OK的顾客中，93%属于类buysconputer=yes。支持度20%意味着D中20%的顾客是青年，信誉为OK，并且属于类buyscomputer=yes</p><p>一般而言，关联规则的分类包括以下步骤：</p><ul><li>1、挖掘数据，找出频繁项集，即找出数据经常出现的属性-值对</li><li>2、分析频繁项集，产生每个类的关联规则，它们满足置信度和支持度标准</li><li>3、组织规则，形成基于规则的分类器</li></ul><p>这里，我们考察以下三种分类方法1）CBA ; 2) CMAR ; 3)CPAR</p><h4 id="CBA"><a href="#CBA" class="headerlink" title="CBA"></a>CBA</h4><p>最早、最简单的关联分类算法是CBA。CBA使用迭代的方法挖掘频繁项集，类似于Apriori算法。CBA使用了一种启发式方法构造分类器，其中<strong>规则按照它们的置信度和支持度递减优先级排序</strong>，如果当中一组规则具有相同的前件，则选取具有最高置信度的规则代表该集合。<strong>在对新元组分类是，使用满足该元组第一个规则对它进行分类</strong>。分类器还包含一个默认规则，具有最低优先级。</p><h4 id="CMAR"><a href="#CMAR" class="headerlink" title="CMAR"></a>CMAR</h4><p>CMAR和CBA在频繁项集挖掘和构建分类器都不同，<strong>CMAR采用FP-growth算法的变形来发现满足最小支持的最小置信度的规则完全集</strong>。构造分类器时，如果新元组X只匹配一个规则，则简单地把规则的类标号给这个元组。如果多个规则满足X，把这些规则形成一个集合S。CBA将集合S中最大置信度的规则的类标号指派给X，而CMAR考虑多个规则。<strong>它根据S的类标号将规则分类，不同组中的规则具有不同的类标号</strong>，然后CMAR使用X2X2卡方度量，根据组中规则的统计相关联找出相关性“最强的”规则组，再把该类标号指派个X元组。这样，<strong>它就考虑了多个规则，不是像CBA一样只考虑一个规则</strong>。CMAR在准确率和复杂的都比CBA更有效一点。</p><h4 id="CPAR"><a href="#CPAR" class="headerlink" title="CPAR"></a>CPAR</h4><p>CPAR和CMAR相差不多，<strong>它通过FOIL算法而不是FP-growth来挖掘规</strong>则。同样也将集合S的规则按类分组。然而，CPAR根据期望准确率，使用每组中最好的k个规则预测X元组的类标号，<strong>通过考虑组中最好的k个规则而不是所有规则</strong>。在大数据集上，CPAR和CMAR准确率差不多，但产生的规则要比CMAR少的多。</p><h3 id="基于有区别力的频繁模式分类"><a href="#基于有区别力的频繁模式分类" class="headerlink" title="基于有区别力的频繁模式分类"></a>基于有区别力的频繁模式分类</h3><p>如果我们把所有频繁模式都添加到特征空间，可能许多模式是冗余，还可能因特征太多而过分拟合，导致准确率降低。因此，一种好的做法是使用特征选择，删除区别能力较弱的特征，其一般框架步骤(两步法)如下：</p><ul><li>特征产生：频繁模式的集合F形成候选特征</li><li>特征选择： 通过信息增等度量对F进行特征选择，得到选择后的频繁模式FsFs，数据集DD变换成D′D′</li><li>学习分类模型：在数据集D′D′建立分类器</li></ul><p><img src="/2018/11/09/数据挖掘概念与技术/数据挖掘概念与技术笔记（6）：高级分类方法/05.png" alt></p><p>为了提高两步法的效率，考虑将步骤1和步骤2合并为一步。即有可能只挖掘具有高度区别能力的频繁模式的集合，而不是完全集。DDPMine算法采用这种方法，它首先把训练数据变换到一个称频繁模式树或FP树的紧凑树结构，然后再该树种搜索有区别能力的模式。</p><p>在准确率和效率两个方面，DDPMine都优于最先进的关联分类方法。</p><h2 id="k-近邻分类"><a href="#k-近邻分类" class="headerlink" title="k-近邻分类"></a>k-近邻分类</h2><p><strong>对于，k-近邻分类算法，位置元组每次都被指派到它的k个最近邻（距离度量）的多数类</strong>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;贝叶斯信念网络&quot;&gt;&lt;a href=&quot;#贝叶斯信念网络&quot; class=&quot;headerlink&quot; title=&quot;贝叶斯信念网络&quot;&gt;&lt;/a&gt;贝叶斯信念网络&lt;/h2&gt;&lt;h3 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="数据挖掘" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
    
      <category term="贝叶斯信念网络" scheme="http://yoursite.com/tags/%E8%B4%9D%E5%8F%B6%E6%96%AF%E4%BF%A1%E5%BF%B5%E7%BD%91%E7%BB%9C/"/>
    
      <category term="关联分类" scheme="http://yoursite.com/tags/%E5%85%B3%E8%81%94%E5%88%86%E7%B1%BB/"/>
    
      <category term="k近邻" scheme="http://yoursite.com/tags/k%E8%BF%91%E9%82%BB/"/>
    
  </entry>
  
  <entry>
    <title>数据挖掘概念与技术笔记（5）：分类</title>
    <link href="http://yoursite.com/2018/11/06/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89%EF%BC%9A%E5%88%86%E7%B1%BB/"/>
    <id>http://yoursite.com/2018/11/06/数据挖掘概念与技术/数据挖掘概念与技术笔记（5）：分类/</id>
    <published>2018-11-06T09:06:14.000Z</published>
    <updated>2019-12-28T12:57:57.265Z</updated>
    
    <content type="html"><![CDATA[<p>这一章很多概念都是之前就接触了，就不一一记录了，这里记录一些感兴趣的吧。</p><h2 id="决策树剪枝"><a href="#决策树剪枝" class="headerlink" title="决策树剪枝"></a>决策树剪枝</h2><p>为了避免决策树过拟合数据，一般要对决策树进行剪枝：<strong>先剪枝和后剪枝</strong></p><p>在先剪枝方法中，通过提前停止树的构造（例如，通过决定在给定的结点上不再分裂或划分训练样本的子集）而对树“剪枝”。在构造树时，统计意义下的度量，如信息增益、基尼指数等，可以用于评估分裂的优劣。如果在一个结点划分样本将导致低于预定义阈值的分裂，则给定子集的进一步划分将停止。然而，选取一个适当的阈值是困难的。较高的阈值可能导致过分简化的树，而较低的阈值可能使得树的化简太少。</p><p>第二种更常用的方法是后剪枝，它由“完全生长”的树之后再剪去分枝，通过用叶子节点替换要删除的分枝。CART使用的代价复杂度剪枝算法是后剪枝方法的一个实例。该方法把树的复杂度看做树叶节点的个数和树的错误率的函数，如果减去节点N的子树导致较小的代价复杂度，则剪掉该子树；否则，保留该子树。</p><h2 id="可伸缩性与决策树"><a href="#可伸缩性与决策树" class="headerlink" title="可伸缩性与决策树"></a>可伸缩性与决策树</h2><p>已有的决策树算法，如ID3、C4.5和CART都是为相对较小的数据集规模。另外，大部分情况下，大规模的训练数据不能放在内存！因此，由于训练元组在主存和高速缓存换进换出，决策树的构造可能变得效率低下。最近，已经提出了一些可以解决伸缩问题的决策树算法，例如，<strong>RainForest（雨林）能适应可用的内存量，采用了一种新的数据结构形式</strong>。</p><p><img src="/2018/11/06/数据挖掘概念与技术/数据挖掘概念与技术笔记（5）：分类/01.png" alt></p><p> 转为AVC集的聚集信息的数据结构来存放 </p><p><img src="/2018/11/06/数据挖掘概念与技术/数据挖掘概念与技术笔记（5）：分类/02.png" alt></p><p><strong>另外一种方法是采用树构造的自助乐观算法（BOAT）</strong>，它采用了统计学计数，创建给定训练数据的一些较小的样本（或子集），其中每个子集都能放在内存中。使用每个子集构造一颗树，导致多棵树，并使用它们构造一个新树。</p><h2 id="使用IF-THEN规则分类"><a href="#使用IF-THEN规则分类" class="headerlink" title="使用IF-THEN规则分类"></a>使用IF-THEN规则分类</h2><p>基于规则的分类器使用一组IF-THEN规则进行分类。一个IF-THEN的规则R1一般表示形式有如下两种</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">R1:IF age=youth AND student=yes THEN buys_conmputer = yes </span><br><span class="line"></span><br><span class="line">R1:IF age=youth ^ student=yes THEN buys_computer = yes</span><br></pre></td></tr></table></figure><p> 规<strong>则R可以用覆盖率和准确率来评估</strong>。给定类标记的数据集D中的一个元组X，设$n<em>{covers}$为规则R覆盖的元组数，$n</em>{covers}$为R正确分类的元组数，|D|是D中的总元组数，可将R的<strong>覆盖率</strong>和<strong>准确率</strong>定义为： </p><script type="math/tex; mode=display">coverage(R)=\frac{n_{cover}}{|D|} \\ accuracy(R)=\frac{n_{correct}}{n_{covers}}</script><h3 id="如何建立基于规则的分类器呢"><a href="#如何建立基于规则的分类器呢" class="headerlink" title="如何建立基于规则的分类器呢"></a>如何建立基于规则的分类器呢</h3><ul><li>1、根据决策树提取规则</li></ul><p><strong>对从根到树叶节点的每条路经创建一个规则</strong>。沿着给定路经上的每个属性-值的逻辑AND形成规则前件（“IF”部分）。叶结点包含类预测，形成规则后件（“THEN”部分）。<strong>由于这些规则都是直接从书中提取的，所以它们是互斥的和穷举的</strong>（互斥意味不可能存在规则冲突），<strong>因此规则的序不重要——它们是无序的</strong>。</p><p>由于每个树叶对应一个规则，所以提取的规则集的量也很多。所以有两种解决方法，第一种是先对决策树剪枝，然后提取规则。另外一种是直接提取规则，然后修剪规则，对于不能提高规则的估计准确率的任何条件都可以删减，从而泛化该规则。</p><ul><li>2、使用顺序覆盖算法</li></ul><p>顺序覆盖算法是最广泛使用的挖掘分类规则取集的方法，有许多流行的顺序覆盖算法，包括AQ、CN2和最近提出的RIPPER。算法的一般策略如下：一次学习一个规则，每学习一个规则，就删除该规则覆盖的元组，并在剩下的元组上重负该过程。</p><p><img src="/2018/11/06/数据挖掘概念与技术/数据挖掘概念与技术笔记（5）：分类/03.png" alt></p><p>从最一般的规则开始，即从规则前件条件为空的规则开始。该规则是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IF  THEN loan_decision = accept</span><br></pre></td></tr></table></figure><p>然后，我们考虑每个可以添加到该规则中可能属性测试。Learn_One_Rule采用一种贪心策略，每次选择最能提高规则质量的属性。目前，我们使用规则的准确率作为质量度量。假设Learn_One_Rule发现属性测试income=high最大限度地提高了当前（空）规则的准确率。把它添加到条件中，当前规则变成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IF income=high THEN loan_decision = accept</span><br></pre></td></tr></table></figure><p>下一次迭代时，再次考虑可能的属性测试，结果选中credit_rating=excellent，当前规则增长，变成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IF income=high AND credit_rating=excellent THEN loan_decision = accept</span><br></pre></td></tr></table></figure><p>重复该过程，直到结果规则达到可接受的质量水平。另外，贪心策略如果不自觉选到一个很差的属性怎么办，为了减少这种发生的几率，可以选出最好的k个而不是最好的一个属性添加到当前规则。</p><h3 id="规则质量的度量"><a href="#规则质量的度量" class="headerlink" title="规则质量的度量"></a>规则质量的度量</h3><p>Learn_One_Rule需要度量规则的质量，之前我们用的是准确率。但准确率本身并非规则质量的可靠估计。这里介绍几个相对有用的几种度量：1）、熵 ；2）、信息增益；3）考虑覆盖率的统计检验</p><p>我们想知道给定属性测试到condition中是否导致更好的规则，我们称新的条件为condition’，换言之，我们想知道R’是否比R好。</p><p><strong>熵</strong>：D是condition’覆盖元组集合，而$p_i$是D中$C_i$类的概率。熵越小，condition’越好。熵更偏向于覆盖单个类大量元组和少量其他类元组的条件。</p><p><strong>信息增益</strong>：FOIL算法是一种学习一阶逻辑规则的顺序覆盖算法，FOIL用下式估计扩展condition’s而获得信息</p><script type="math/tex; mode=display">FOIL\_Gain=pos'\times (log_2\frac{pos'}{pos'+neg'}-log_2\frac{pos}{pos+neg})</script><p>它偏向于具有高准确率并且覆盖许多正元组的规则</p><p><strong>似然率统计量</strong></p><script type="math/tex; mode=display">Likelihood\_Ratio=2\sum_{i=1}^mf_ilog(\frac{f_i}{e_i})</script><p>其中，m是类数，$f_i$是这些元组类i的观测概率，$e_i$是规则随机预测时类i的期望频率。似然率有助于识别具有显著覆盖率的规则。</p><p>CN2使用熵和似然率检验，而FOIL的信息增益被RIPPER使用。</p><h3 id="规则剪枝"><a href="#规则剪枝" class="headerlink" title="规则剪枝"></a>规则剪枝</h3><p>之前说了可以在决策树生成之后对规则剪枝，有很多剪枝策略。这里介绍FOIL使用的一种简单但很有效的方法，给定规则R，有：</p><script type="math/tex; mode=display">FOIL\_Prune(R)=\frac{pos-neg}{pos+neg}</script><p>其中，pos和neg分别为规则R覆盖的正元组数和负元组数。这个值将随着R在剪枝集上的准确率增加而增加。因此，如果R剪枝后版本的FOIL_Prune值较高，则对R剪枝。</p><h3 id="如何使用规则分类器来预测元组类标号呢？"><a href="#如何使用规则分类器来预测元组类标号呢？" class="headerlink" title="如何使用规则分类器来预测元组类标号呢？"></a>如何使用规则分类器来预测元组类标号呢？</h3><p>如果正常的话，R1是唯一满足的规则，则该规则激活，返回X的类预测。但如果有多个规则被触发，它们指定了不同的类，这时则需要一种解决冲突的策略来决定激活哪一个规则。我们考察两种，即规模序和规则序：</p><p>规模序：方案吧最高优先权赋予给”最苛刻”要求的规则，其中苛刻性用<strong>规则前件的规模度量</strong>（类似于树的深度）</p><p>规则序：这<strong>种序可以是基于类的或基于规则的</strong>。<strong>使用基于类的序</strong>，类按”重要性”递减排序，如按普遍性的降序排序；<strong>基于规则的序</strong>，或者根据领域专家的建议，把规则组织成一个优先权列表。</p><h2 id="使用统计显著性检验选择模型"><a href="#使用统计显著性检验选择模型" class="headerlink" title="使用统计显著性检验选择模型"></a>使用统计显著性检验选择模型</h2><p>在前面我们已经使用了 一些策略来测算分类器的准确率（例如K折交叉验证）。在这里，我们假设经处理，最后生成了两个分类器，他们的评估度量都不相同，那么我们应该选择哪个分类器呢？</p><p>直观的看法当然是选择指标好的那个分类器呀，但是 实际上这种差别很有可能是偶然的。我们为了判定这种差别是否是偶然的，还需要进行<strong>统计显著性检验</strong>。 此外，希望得到平均错误率的置信界，使得我们可以做出这样的陈述：”对于未来样本的95%，观测到的均值将不会偏离正、负两个标准差”或者”一个模型比另外一个模型好，误差幅度为±4±4”</p><p>这里用的是显著性检验是t-检验。知乎上给出了相关的解释 ： <a href="https://www.zhihu.com/question/60321751/answer/399954823" target="_blank" rel="noopener">知乎t检验解释</a> <a href="https://www.zhihu.com/question/60321751/answer/399954823" target="_blank" rel="noopener">https://www.zhihu.com/question/60321751/answer/399954823</a></p><p> 对于10-折交叉验证（k=10）的第ii轮，设$err(M_1)_i$(或$err(M_2)_i$)是模型$M_1$(或$M_2$)在第i轮的错误率。对$M_1$的错误率取平均值得到$M_1$的平均错误率，记为$\overline {err}(M_1)$，类似的，可以得到$\overline {err}(M_2)$。两个模型差的方差记为$var(M_1-M_2)$。在我们的例子中，k=10，这里的k个样本是从每个模型的10-折交叉验证得到的错误率。逐对比较t-统计量按下式计算： </p><script type="math/tex; mode=display">t=\frac{\overline{err}(M_1)-\overline{err}(M_2)}{\sqrt{var(M_1-M_2)/k}}</script><p> 其中 </p><script type="math/tex; mode=display">var(M_1-M_2)=\frac{1}{k}\sum_{i=1}^k[err(M_1)_i-err(M_2)_i-(\overline{err}(M_1)-\overline{err}(M_2))]^2</script><p>为了计算$M_1$和$M_2$是否显著不同，计算t并选择显著水平sig。实践中，通常使用5%或1%的显著水平。然后，查找t-分布表。通常该表以自由度为行（k个样本具有k-1个自由度，对于我们的例子，自由度为9），显著水平为列。假定要确定$M_1$和$M_2$之间的差对总体的95%（即sig=5%或0.05）是否显著不同。然而，由于t分布是对称的，通常只显示分布上部的百分点，因此，找z=sig/2=0.025的表值，其中z也称为置信界。如果t&gt;z或t&lt;-z，则t落在拒斥域，在分布的尾部。这意味着可以拒绝$M_1$和$M_2$的均值相同的原假设，并断言两个模型之间存在统计的显著的差别。否则，如果不能拒绝原假设，于是断言$M_1$和$M_2$之间的差可能是随机的。</p><p>如果有两个检验集而不是单个检验集，则使用t-检验的非逐对版本，其中两个模型的均值之间的方差估计为：</p><script type="math/tex; mode=display">var(M_1-M_2)=\sqrt{\frac{var(M_1)}{k_1}+\frac{var(M_2)}{k_2}}</script><p> 其中，k1和k2分别用于M1和M2的交叉验证样本数（在我们的情况下，10-折交叉验证的轮）。这也称为两个样本的t检验。在查t分布表时，自由度取两个模型的最小自由度。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这一章很多概念都是之前就接触了，就不一一记录了，这里记录一些感兴趣的吧。&lt;/p&gt;
&lt;h2 id=&quot;决策树剪枝&quot;&gt;&lt;a href=&quot;#决策树剪枝&quot; class=&quot;headerlink&quot; title=&quot;决策树剪枝&quot;&gt;&lt;/a&gt;决策树剪枝&lt;/h2&gt;&lt;p&gt;为了避免决策树过拟合数据，一
      
    
    </summary>
    
      <category term="数据挖掘" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
    
      <category term="决策树剪枝" scheme="http://yoursite.com/tags/%E5%86%B3%E7%AD%96%E6%A0%91%E5%89%AA%E6%9E%9D/"/>
    
      <category term="IF-THEN规则分类" scheme="http://yoursite.com/tags/IF-THEN%E8%A7%84%E5%88%99%E5%88%86%E7%B1%BB/"/>
    
      <category term="t检验" scheme="http://yoursite.com/tags/t%E6%A3%80%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>数据挖掘概念与技术笔记（4）：高级模式挖掘</title>
    <link href="http://yoursite.com/2018/11/05/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89%EF%BC%9A%E9%AB%98%E7%BA%A7%E6%A8%A1%E5%BC%8F%E6%8C%96%E6%8E%98/"/>
    <id>http://yoursite.com/2018/11/05/数据挖掘概念与技术/数据挖掘概念与技术笔记（4）：高级模式挖掘/</id>
    <published>2018-11-05T09:06:14.000Z</published>
    <updated>2019-12-28T12:45:54.662Z</updated>
    
    <content type="html"><![CDATA[<p>于大量的研究、问题的多方面扩展和广泛的应用研究。频繁模式挖掘已经远远超过了事务数据。<strong>这里，我们介绍其他多种挖掘模式类型的方法，包括多层模式、多维模式、稀有模式、负模式、受约束的频繁模式和巨型模式挖掘</strong>。书上的内容都是比较浅显，更多的是介绍性的东西，可能需要到实际工作上才能理解更深一些。</p><h2 id="挖掘多层关联规则"><a href="#挖掘多层关联规则" class="headerlink" title="挖掘多层关联规则"></a>挖掘多层关联规则</h2><p>对于许多应用，在较高的抽象层（抽象的大类，例如电脑，而不是具体某种品牌和型号的电脑）发现的强关联规则，可能有很高的支持度，但可能是常识性知识。我们希望往下钻，在更细节的层次发现新颖的模式。另外一方面，在较低或原始抽象层，可能有太多的零散模式，其中一些只不过是较高层模式的平方特化。</p><p>在这种较低层或原始层数据中很难发现有趣的规则模式，例如，“Dell Studio XPS 16 Notebook”和“Logitech VX Nano Cordless Laser Mouse”每个都在很少一部分事务中出现，则可能很难找到涉及它们的强关联规则。少数人同时购买它们，使得该商品集不太可能满足最小支持度。然而，我们预料，在这些商品的泛化抽象之间，如在”Dell Notebook” 和”Cordless Mouse”之间，可望更容易发现强规则。这种在多个抽象层的数据上挖掘产生的规则称为多层关联规则，一般采用如下自顶向下的方法：</p><ul><li><strong>对于所有层使用一致的支持度（称作一致支持度）</strong>：在每一层挖掘时，使用相同的最小支持度阈值</li></ul><p>然<strong>而，一致支持度方法有一些困难。较低层次抽象的项不大可能象较高层次抽象的项出现得那么频繁。如果最小支持度阈值设置太高，可能丢掉出现在较低抽象层中有意义的关联规则。如果阈值设置太低，可能会产生出现在较高抽象层的无兴趣的关联规则。这导致了下面的方法</strong>：</p><ul><li>在较低层使用递减的支持度（称作递减支持度）：每个抽象层有它自己的最小支持度阈值。抽象层越低，对应的阈值越小。</li><li>使用基于项或基于分组的最小支持度：例如，用户可以根据产品价格或者根据感兴趣的商品设置最小支持度，对如”价格超过1000美元的照相机”或”平板电脑” 设置特别低的支持度，以便特别关注这类商品的关联模式</li></ul><p>为了从具有不同支持度阈值的组中挖掘混合项模式，通常在挖掘中取所有组的最低支持度阈值。这将避免过滤掉有价值的模式，该模式包含来自具有最低支持度阈值组的项。同时，每组的最小支持阈值应该保持，以免从每个组产生无趣的项集。</p><h3 id="检查多层关联规则冗余性"><a href="#检查多层关联规则冗余性" class="headerlink" title="检查多层关联规则冗余性"></a>检查多层关联规则冗余性</h3><p>挖掘多层关联规则一个严重的副作用是，由于项之间的“祖先”关系，可能产生一些多个抽象层上的冗余的规则，例如：”desktop computer”是”IBM desktop computer”的祖先，有以下规则：</p><p><img src="/2018/11/05/数据挖掘概念与技术/数据挖掘概念与技术笔记（4）：高级模式挖掘/01.png" alt></p><p>如果后一个具有较小一般性的规则不提供新的信息，应当删除它。让我们看看如何来确定。规则 R1 是规则 R2 的祖先，如果R1能够通过将R2中的项，用它在概念分层（分配比率）中的祖先替换得到，则可以将R2删除。</p><p>以上诉规则例子：假定规则(6.9)具有 70%置信度，8%支持度，<strong>并且大约四分之一的”desktop computer”销售是”IBM desktop computer”</strong>。可以期望规则(6.10)具有大约 70%的置信度（由于所有的”IBM desktop computer”样本也是” desktop computer”样本）和 2%（即，8%×1/4）的支持度。也就是说，根据实际销量的分层可以通过R1推到出R2的规则与规则(6.10)相差无几，则R2规则是冗余的。</p><h2 id="挖掘多维关联规则"><a href="#挖掘多维关联规则" class="headerlink" title="挖掘多维关联规则"></a>挖掘多维关联规则</h2><p>本节，你将学习挖掘多维关联规则的方法。<strong>多维关联规则是涉及多个属性或谓词的规则</strong>（例如，关于顾客的 buys 和顾客的 age 的规则）。<strong>我们把规则中每个不同的谓词称作维</strong>。例如：</p><script type="math/tex; mode=display">age(X, "20...29") \land buys(X, "laptop")⇒buys(X, "HP\ printer")</script><p>其中，数据库属性可能是分类属性和量化属性（数值），对于量化属性，挖掘多维相关规则的计数可以分为两种基本方法：</p><ul><li>第一种方法：使用预定义的概念分层对量化属性离散化，例如，income 的概念分层可以用于以区间值，如“0…20K”代替</li><li>第二种方法：根据数据的分布，将量化属性离散化或聚类到“箱”</li></ul><p>正如前面讨论的，我们可以把量化属性离散化为多个区间，而后在关联挖掘时把它们看做是分类属性。然而，这种简单的离散化可能导致产生大量的规则，其中许多规则可能没什么用。这里我们介绍三种方法，帮助克服这一困难，以便发现新颖的关联关系：</p><ul><li>1、数据立方体方法</li><li>2、基于聚类的方法</li><li>3、揭示异常行为的统计学方法</li></ul><h2 id="挖掘稀有模式和负模式"><a href="#挖掘稀有模式和负模式" class="headerlink" title="挖掘稀有模式和负模式"></a>挖掘稀有模式和负模式</h2><p>迄今为止，介绍的都是挖掘频繁模式，然而，有时令人感兴趣的不是频繁模式，而是发现<strong>稀有的模式</strong>（例如钻石表的销售是稀有的），或发现反映项之间的<strong>负相关的模式</strong>（例如发现顾客频繁地购买经典可口可乐或无糖可乐，但不可能一起都买）。</p><ul><li><strong>稀有模式</strong>：是指其支持度低于（或远低于）用户指定的最小支持度阈值的模式。然而，由于大多数项集的出现频度通常都低于甚至远低于最小支持度阈值，因此实践中允许用户指定稀有模式的其他条件是可取的。</li><li><strong>负相关模式</strong>：如果项集X和Y 都是频繁的，但很少一起出现$(sup(X \cup Y) &lt; sup(X) \times sup(Y))$ ，则项集X和Y是负相关的，并且$X\cup Y$ 是负相关模式.如果$(sup(X \cup Y) \ll sup(X) \times sup(Y))$， 则项集X和Y是强负相关的，并且$X\cup Y$是强负相关模式。 </li></ul><p><strong>然而，上面这个公式度量不是零不变的，只能有效地解决非零事务的数据</strong>。如果数据库存在大量的零事务，则应该使用零不变度量Kulczynski，下面给出具体定义：</p><p><strong>零不变负相关模式</strong>：假设项集X和Y都是频繁的，即$sup(X)\geq min_sup$ ，$sup(Y)\geq min_sup$ ， 其中$min_sup$是最小支持度阈值。如果有$(P(X|Y)+P(Y|X))/2&lt;\epsilon$，其中$\epsilon$是负模式阈值，则$X\cup Y$是负相关模式。 </p><h2 id="基于约束的频繁模式挖掘"><a href="#基于约束的频繁模式挖掘" class="headerlink" title="基于约束的频繁模式挖掘"></a>基于约束的频繁模式挖掘</h2><p><strong>作为限制搜索空间的约束条件</strong>，这种策略称为基于约束的挖掘。</p><p><strong>元规则</strong>就是挖掘用户感兴趣的规则的<strong>语法形式</strong>，例如：</p><script type="math/tex; mode=display">P_1(X,Y)\land P_2(X,W) \Rightarrow buys(X, "officesoftware")</script><p>其中，P1和P2是谓词变量，在挖掘过程中被例示为给定数据库的属性；X是变量，代表顾客；Y和W是分别赋给P1和P2的属性值。</p><p>对于规则约束，如何使用规则约束对搜索空间进行剪枝？主要有两种方法：1、对模式空间剪枝；2、数据空间剪枝</p><h3 id="对模式空间剪枝"><a href="#对模式空间剪枝" class="headerlink" title="对模式空间剪枝"></a>对模式空间剪枝</h3><p>根据约束如何与模式挖掘过程配合，模式剪枝约束可以分为五类：1）反单调的；2）单调的；3）简洁的；4）可转变的；5）不可转变的（这个不重要）</p><ul><li>反单调的：规则约束$”sum(I.price)\leq 100”$，如果一个候选项集中的商品价格和大于 100 美元，则该项集可以由搜索空间剪去，因为向该项集中进一步添加项将会使它更贵，因此不可能满足限制。换一句话说，如果一个项集不满足该规则限制，它的任何超集也不可能满足该规则限制。如果一个规则具有这一性质，则称它是反单调的。 </li><li>单调的：规则约束$”sum(I.price)\geq 100”$，集合中的单价和大于 100，进一步添加更多的项到此项集将增加价格，并且总是满足该限制。因此，在项集 I 上进一步检查该限制是多余的。换言之，如果一个项集满足这个规则限制，它的所有超集也满足。如果一个规则具有这一性质，则称它是单调的。 </li><li>简洁：对于这类约束，我们可以枚举并且仅仅列出所有确保满足该限制的集合。因为有一个精确“公式”，产生满足简洁限制的所有集合，在挖掘过程中不必迭代地检验规则限制 </li><li>可转变的约束：有些限制不属于以上三类。然而，如果项集中的项以特定的次序排列，则对于频繁项集挖掘过程，限制可能成为单调的或反单调的。例如，限制“avg(I.price)”既不是反单调的，也不是单调的。然而，如果事务中的项以单价的递增序添加到项集中，则该限制就成了反单调的。类似的，如果是递减顺序添加则是单调的。 </li></ul><h3 id="对数据空间剪枝"><a href="#对数据空间剪枝" class="headerlink" title="对数据空间剪枝"></a>对数据空间剪枝</h3><p>第二种对基于约束的频繁模式挖掘的搜索空间进行剪枝的方法是对数据空间剪枝。这种策略是剪掉对其后挖掘过程中可满足模式的产生没有贡献的数据片段。例如，对于约束是数据简洁的，如果一个挖掘查询要求被挖掘模式必须包含数码相机，则可以在挖掘过程开始减剪掉所有不包含数码相机的事务。对于约束的反单调的，基于当前模式，如果一个数据项不满足数据反单调约束，则可以剪掉它，因为在剩下的挖掘过程中，它不能对当前模式的超模式的产生有任何贡献。</p><h2 id="巨型模式"><a href="#巨型模式" class="headerlink" title="巨型模式"></a>巨型模式</h2><p>对于数据库有数百或者数千维的数据，用已介绍方法来挖掘高维数据是非常低效的，一种是使用垂直格式数据，之前已经介绍过了。另外一种新的方向是用模型融合，用于巨型模式，即非常长的模式(例如蛋白质的DNA长序列)。这种方法在模式搜索空间中跳跃，得到巨型频繁模式完全集的一个很好的近似解。</p><p>对于Apriori和FP-growth算法，会不可避免产生大量中型模式，使得它不可能达到巨型模式。因此提出了模式融合，它融合了少量较短的频繁模式，形成巨型模式候选。</p><p>书上提到了<strong>核模式</strong>的概念，这里没怎么看懂，觉得是<strong>核模式代表了一定的鲁棒性</strong>。但是书上也直接给出了推论，巨型模式比较短模式有更多的核模式，更鲁棒。也就是说，如果从该模式中去掉少量项，则结果模式会有类似的支集。巨型模式较低层的核模式叫做<strong>核后代</strong>。<strong>所以基于这个特性，模式融合可以融合少量较短的频繁模式</strong>。这也是它为什么被称为模式融合的原因 ，因此巨型模式可以通过合并其核模式的真子集产生，<strong>例如， abcef可以通过它的两个核模式ab和cef产生。而不需要用单个项增量地扩展，而是与池中多个模式进行凝聚，这样能够迅速地到达巨型模式</strong>。</p><p>模型融合包括以下两个阶段：</p><ul><li><p>1、池初始化</p><p>模式融合假定有一个短频繁模式的初始池。这是一个短长度的频繁模式挖掘集。这个初始值可以用任意已有的有效挖掘算法挖掘。</p></li><li><p>2、迭代的模式融合</p><p>用户首先指定一个参数K的值（K代表挖掘模式的最大个数），然后从当前池中随机地选取K个种子，对于每个种子，我们找出直径为ττ的球内的所有模式。然后，每个”球“中的所有模式融合在一起，形成一个超模式集，这些超模式形成新的池，然后再从这个新的池子中随机地找到K个种子，然后重复上面的工作，一直迭代，直到不能融合为止</p></li></ul><p>因此，该方法可以绕过中型模式，通往巨型模式。</p><p>7.5/7.6的内容暂时不是特别重要，用到再补。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;于大量的研究、问题的多方面扩展和广泛的应用研究。频繁模式挖掘已经远远超过了事务数据。&lt;strong&gt;这里，我们介绍其他多种挖掘模式类型的方法，包括多层模式、多维模式、稀有模式、负模式、受约束的频繁模式和巨型模式挖掘&lt;/strong&gt;。书上的内容都是比较浅显，更多的是介绍性的
      
    
    </summary>
    
      <category term="数据挖掘" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
    
      <category term="多层挖掘模式" scheme="http://yoursite.com/tags/%E5%A4%9A%E5%B1%82%E6%8C%96%E6%8E%98%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="多维模式挖掘" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BB%B4%E6%A8%A1%E5%BC%8F%E6%8C%96%E6%8E%98/"/>
    
      <category term="稀有模式和负模式挖掘" scheme="http://yoursite.com/tags/%E7%A8%80%E6%9C%89%E6%A8%A1%E5%BC%8F%E5%92%8C%E8%B4%9F%E6%A8%A1%E5%BC%8F%E6%8C%96%E6%8E%98/"/>
    
      <category term="基于约束模式挖掘" scheme="http://yoursite.com/tags/%E5%9F%BA%E4%BA%8E%E7%BA%A6%E6%9D%9F%E6%A8%A1%E5%BC%8F%E6%8C%96%E6%8E%98/"/>
    
      <category term="巨型模式挖掘" scheme="http://yoursite.com/tags/%E5%B7%A8%E5%9E%8B%E6%A8%A1%E5%BC%8F%E6%8C%96%E6%8E%98/"/>
    
  </entry>
  
  <entry>
    <title>数据挖掘概念与技术笔记（3）：挖掘频繁模式、关联和相关性</title>
    <link href="http://yoursite.com/2018/11/02/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89%EF%BC%9A%E6%8C%96%E6%8E%98%E9%A2%91%E7%B9%81%E6%A8%A1%E5%BC%8F%E3%80%81%E5%85%B3%E8%81%94%E5%92%8C%E7%9B%B8%E5%85%B3%E6%80%A7/"/>
    <id>http://yoursite.com/2018/11/02/数据挖掘概念与技术/数据挖掘概念与技术笔记（3）：挖掘频繁模式、关联和相关性/</id>
    <published>2018-11-02T09:06:14.000Z</published>
    <updated>2020-01-05T04:09:05.215Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="关联规则"><a href="#关联规则" class="headerlink" title="关联规则"></a>关联规则</h3><p>关联规则可以用以下表示：</p><script type="math/tex; mode=display">computer\Rightarrow antivirus\_software[support=2\%;confidence=60\%]</script><p>规则的支持度和置信度是两个规则兴趣度度量，它们分别反映发现规则的有用性和确定性。上诉关联规则<br>的<strong>支持度（表示同时包含A和B的事务占所有事物的比例）为2%，意味所分析的事务的2%显示 计算机和杀毒软件被同时购买。置信度（表示包含A的事务同时也包含B的比例） 60%意味购买计算机的顾客 60%的几率也购买财务管理软件</strong>。一般如果关联规则<strong>满足最小支持度阈值和最小置信度阈值</strong>，则认为关联规则是有趣的，是值得关注的现象。</p><h3 id="频繁项集、闭项集、极大项集"><a href="#频繁项集、闭项集、极大项集" class="headerlink" title="频繁项集、闭项集、极大项集"></a>频繁项集、闭项集、极大项集</h3><p>设任务相关的数据 D 是数据库事务的集合，每一个事务有一个标识符，称作 TID。设A、B是两个项集，有：</p><script type="math/tex; mode=display">support(A\Rightarrow B)=P(A\cup B) \\ confidence(A\Rightarrow B)=P(B\vert A)</script><p>同时满足最小支持度阈值(min_sup)和最小置信度阈值(min_conf)的规则称作强规则</p><p>项的集合称为项集。包含 k 个项的项集称为 k-项集。项集的出现频率是包含项集的事务数，简称为项集的频率、支持计数或计数。如果项集满足最小支持度，则称它为频繁项集。频繁 k -项集的集合通常记作 LkLk。一般而言，关联规则的挖掘是一个两步的过程：</p><p>1、<strong>找出所有频繁项集</strong>：根据定义，这些项集出现的频繁性至少和预定义的最小支持计数一样。</p><p>2、<strong>由频繁项集产生强关联规则</strong>：根据定义，这些规则必须满足最小支持度和最小置信度。</p><p>从大型数据集中挖掘项集的主要挑战是，这种挖掘常常产生大量满足最小支持度（min_sup）阈值的项集，当min_sup设置的很低的时候尤其如此，这是因为如果一个项集的频繁的（项集每个项计数都满足最小支持度），则它的每个子集都是频繁的。因此，得到的频繁项集的总个数太大了，为了更好的计算和存储，引入了闭频繁项集和极大频繁项集的概念。</p><ul><li><strong>闭频繁项集</strong>：指这个项集X既是频繁项集又是闭项集，闭项集是指不存在真超项集Y和此项集X具有相同的支持度计数</li><li><strong>极大频繁项集</strong>：指这个项集X既是频繁项集又是极大项集，极大项集是指不存在频繁的真超项集Y，它已经是最大规模频繁项集了。</li></ul><p>一个举例：(AB项集为非闭是因为和ABC项集具有相同的支持度计数，ABC为非极大是存在频繁项集ABCD)</p><p><img src="/2018/11/02/数据挖掘概念与技术/数据挖掘概念与技术笔记（3）：挖掘频繁模式、关联和相关性/01.png" alt></p><h2 id="挖掘频繁项集的方法"><a href="#挖掘频繁项集的方法" class="headerlink" title="挖掘频繁项集的方法"></a>挖掘频繁项集的方法</h2><h3 id="Apriori-算法"><a href="#Apriori-算法" class="headerlink" title="Apriori 算法"></a>Apriori 算法</h3><p>算法是一种最有影响的挖掘布尔关联规则频繁项集的算法。Apriori 使用一种称作逐层搜索的迭代方法，<strong>k项集用于探索(k+1)项集</strong>。首先，找出频繁 1-项集的集合。该集合记作 L1。L1用于找频繁 2-项集的集合 L2，而L2用于找L3，如此下去，直到不能找到频繁 k-项集.</p><p>所以关键在于须看看如何用频繁项集$L<em>k$找到频繁项集$L</em>{k+1}$.具体是由以下两步组成：</p><p>1、连接步：为找 $L<em>k$，通过$L</em>{k - 1}$与自己连接产生候选 k-项集的集合。假定事务或项集中的项按字典次序排序，如果$L_{k - 1}$它们前(k-2)个项相同的，则可以执行连接操作。</p><p>2、剪枝步：连接操作得到$C<em>k$，$C_k$是 $L_k$的超集，可以通过扫描数据库计算支持度从而在$C_k$里确定$L_k$。然而，$C_k$可能很大，这样所涉及的计算量就很大。为压缩 $C_k$，可以用以下办法使用 Apriori 先验性质：任何非频繁的(k-1)项集都不是可能是频繁 k项集的子集(频繁项集的子集一定是频繁的)。因此，如果一个候选 k项集的(k-1)子集不在 $L\</em>{k - 1}$中 ($L_{k - 1}$包含所有频繁的k-1项集，若某个k-1项集不在里面则是不频繁的)，则该候选也不可能是频繁的，从而可以由$C_k$中删除。</p><p> 一个例子: </p><p><img src="/2018/11/02/数据挖掘概念与技术/数据挖掘概念与技术笔记（3）：挖掘频繁模式、关联和相关性/02.png" alt></p><p> aproori算法过程：假设最小支持度计数为2，即min_sup=2 </p><p><img src="/2018/11/02/数据挖掘概念与技术/数据挖掘概念与技术笔记（3）：挖掘频繁模式、关联和相关性/03.png" alt></p><p> 其中，$L_2$连接步寻找$L_3$，要将$L_2$的前（3-2）个相同的项连接起来，得到{I1,I2,I3}, {I1,I2,I5}, {I1,I3,I5}, {I2,I3,I4}, {I2,I3,I5}, {I2,I4,I5}，然后执行剪枝步，扫描整个数据库，可以得到剩下的{1,I2,I3}, {I1,I2,I5}。或者使用Apriori 先验性质：举{I2,I4,I5}项集为例，{I2,I4,I5}的2项子集为{I2,I4}, {I2,I5} 和 {I4,I5}。但{I4, I5}不是$L_2$的元素，因此不是频繁的。同理L3L3连接步得到{I1, I2, I3, I5}的其中一个3项集{I2,I3,I5}不是$L_3$的元素，因此{I1, I2, I3, I5}也不是频繁的。 </p><h3 id="由频繁项集产生关联规则"><a href="#由频繁项集产生关联规则" class="headerlink" title="由频繁项集产生关联规则"></a>由频繁项集产生关联规则</h3><p>一旦由数据库 D 中的事务找出频繁项集，由它们产生强关联规则是直接了当的（强关联规则满足最小支持度和最小置信度）。对于置信度，可以用下式，其中条件概率用项集支持度计数表示</p><script type="math/tex; mode=display">confidence(A\Rightarrow B)=P(A\vert B)=\frac{support\_count(A\cup B)}{support\_count(A)}</script><p><img src="/2018/11/02/数据挖掘概念与技术/数据挖掘概念与技术笔记（3）：挖掘频繁模式、关联和相关性/04.png" alt></p><h3 id="FP-growth算法"><a href="#FP-growth算法" class="headerlink" title="FP-growth算法"></a>FP-growth算法</h3><p>正如我们已经看到的，在许多情况下，Apriori 的候选产生-检查方法大幅度压缩了候选项集的大小，并导致很好的性能。然而，它可能受两种超高开销的影响：</p><ul><li>它可能需要产生大量候选项集。例如，如果有 10^4个频繁 1-项集，则 Apriori 算法需要产生多达 10^7个候选 2-项集</li><li>它可能需要重复地扫描数据库</li></ul><p>“ 可以设计一种方法，挖掘全部频繁项集，而不产生候选吗？”一种有趣的方法称作<strong>频繁模式增长</strong>，或简单地，FP-增长，它采取如下分治策略：<strong>将提供频繁项集的数据库压缩到一棵频繁模式树（或 FP-树）</strong>，但仍保留项集关联信息；然后，将这种压缩后的数据库分成一组条件数据库（一种特殊类型的投影数据库），每个关联一个频繁项，并分别挖掘每个数据库。</p><p>FP-growth算法的优点是采用了高级的数据结构。那么这种高级的数据结构是什么呢？实际上就是FP树。 FP树是一种输入数据的压缩表示。他通过把事务映射到FP树上来构造一条路径。这样如果不同事务之间的重叠路径越多，那么就有理由认为他们是频繁项集。由于不同的事务可能会有若干个相同的项，因此它们的路径相互重叠越多，则使用FP树结构获得的压缩效果越好。</p><p><strong>FP-growth算法的基本过程1）构建FP数。 2）从FP树中挖掘频繁项集</strong></p><p>依然是用之前那个例子：</p><p><img src="/2018/11/02/数据挖掘概念与技术/数据挖掘概念与技术笔记（3）：挖掘频繁模式、关联和相关性/02.png" alt></p><p>数据库的第一次扫描与 Apriori 相同，它<strong>导出频繁项（1-项集）的集合，并得到它们的支持度计数（频繁性）</strong>。设最小支持度计数为 2。频繁项的集合<strong>按支持度计数的递减序排序。结果集或表记作 L</strong>。这样，<strong>我们有 L = [I2:7, I1:6, I3:6, I4:2, I5:2]。</strong></p><p>然后，FP-树构造如下：首先，创建树的根结点，用“null”标记。二次扫描数据库 D。<strong>每个事务中的项按 L 中的次序处理（即，根据递减支持度计数排序）</strong>并<strong>对每个事务创建一个分枝</strong>。例如，第一个事务“T100: I1, I2, I5”按 L 的次序包含三个项{ I2, I1, I5}，导致构造树的第一个分枝[(I2:1), (I1:1), (I5:1)]。该分枝具有三个结点，其中，I2 作为根的子女链接，I1 链接到 I2，I5 链接到 I1。第二个事务 T200 按 L 的次序包含项 I2 和 I4，它导致一个分枝，其中，I2 链接到根，I4 链接到 I2。然而，该分枝应当与 T100 已存在的路径共享前缀 I2。这样，我们将结点 I2 的计数增加 1，并创建一个新结点(I4:1)，它作为(I2:2)的子女链接。一般地，当为一个事务考虑增加分枝时，沿共同前缀上的每个结点的计数增加 1，为随在前缀之后的项创建结点并链接。</p><p>按TID顺序T100到T900，不断创建节点和连接，并更新节点的支持度计数，知道完成FP树的构建</p><p><img src="/2018/11/02/数据挖掘概念与技术/数据挖掘概念与技术笔记（3）：挖掘频繁模式、关联和相关性/05.png" alt></p><p>构建好FP树后，开始利用FP树挖掘频繁项集。FP-树挖掘处理如下。<strong>由长度为 1 的频繁模式（初始后缀模式）开始，构造它的条件模式基</strong>（一个“子数据库”， 由 FP-树中与后缀模式一起出现的前缀路径集组成）<strong>。然后，构造它的（条件）FP-树，并递归地在该树上进行挖掘。</strong>模式增长通过后缀模式与由条件 FP-树产生的频繁模式连接实现。</p><p>FP-树的挖掘总结在表 6.1 中，细节如下。<strong>让我们首先考虑 I5，它是 L 中的最后一个项，而不是第一个</strong>。其原因随着我们解释 FP-树挖掘过程就会清楚。I5 出现在上图 的 FP-树的两个分枝。（I5 的出现容易通过沿它的结点链到。）<strong>它的两个对应前缀路径是[(I2, I1:1)&gt;和&lt;(I2, I1, I3:1)]</strong>，它们形成I5 的<strong>条件模式基</strong>。<strong>然后以及条件模式基和最小支持度计数构建条件FP树</strong>，它的条件 FP-树只包含单个路径[(I2:2, I1:2)] (括号里面为路径形式，给出构建的FP树种每个节点的支持度计数)；不包含 I3，因为它的支持度计数为 1，小于最小支持度计数。<strong>最后，I5与该路径产生频繁模式的所有组合（I5与路径的所有组合一定是要包含I5的）</strong>。组合的支持度计数是根据与结合的节点的支持数决定的。</p><p><img src="/2018/11/02/数据挖掘概念与技术/数据挖掘概念与技术笔记（3）：挖掘频繁模式、关联和相关性/06.png" alt></p><p> 类似的，对于 I4，它的两个前缀形成条件模式基{(I2 I1:1), (I2:1)}，产生一个单结点的条件 FP-树&lt; I2:2&gt;，并导出一个频繁模式 I2 I4:2。与以上分析类似，I3 的条件模式基是{(I2 I1:2), (I2:2), (I1:2)}。它的条件 FP-树有两个分枝&lt; I2:4, I1:2&gt;和&lt; I1:2&gt;，如图 6.9 所示，它产生模式集：{I2 I3:4, I1 I3:2, I2 I1 I3:2}. </p><p><img src="/2018/11/02/数据挖掘概念与技术/数据挖掘概念与技术笔记（3）：挖掘频繁模式、关联和相关性/07.png" alt></p><p>FP-增长方法将发现长频繁模式的问题转换成递归地发现一些短模式，然后与后缀连接。它使用最不<br>频繁的项作后缀，提供了好的选择性。该方法大大降低了搜索开销。</p><h3 id="使用垂直数据格式挖掘频繁项集"><a href="#使用垂直数据格式挖掘频繁项集" class="headerlink" title="使用垂直数据格式挖掘频繁项集"></a>使用垂直数据格式挖掘频繁项集</h3><p>Apriori算法和FP-growth算法都是从TID-项集格式（即{TID : itemset }）的事务集中挖掘频繁模式，其中TID是事务标识符， 而itemset是事务TID中购买的商品。这种数据格式称为<strong>水平数据格式</strong>。或者，数据也可以用项-TID集格式（即{item ： TID_set}）表示，这种格式称为<strong>垂直数据格式</strong>。</p><p><img src="/2018/11/02/数据挖掘概念与技术/数据挖掘概念与技术笔记（3）：挖掘频繁模式、关联和相关性/08.png" alt></p><p> 通过取每对频繁项的TID集的交，可以在该数据集上进行挖掘。项集的支持度计数为TID-集的元素个数。 </p><p><img src="/2018/11/02/数据挖掘概念与技术/数据挖掘概念与技术笔记（3）：挖掘频繁模式、关联和相关性/09.png" alt></p><h2 id="强规则不一定是有趣的"><a href="#强规则不一定是有趣的" class="headerlink" title="强规则不一定是有趣的"></a>强规则不一定是有趣的</h2><p>大部分关联规则挖掘算法使用支持度-置信度框架。尽管使用最小支持度和置信度阈值排除了一些无兴趣的规则的探<br>查，仍然会产生一些对用户来说不感兴趣的规则。<strong>当A与B是负相关时，规则 A ⇒ B 的置信度有一定的欺骗性</strong>。因此，支持度和置信度度量不足以过滤掉无趣的关联规则，为<strong>了处理这个问题，可以使用相关性度量来扩充关联规则的支持度-置信度框架</strong>。这导致如下形式的相关规则</p><script type="math/tex; mode=display">A\Rightarrow B[support , confidence, correlation]</script><h3 id="提升度（lift）"><a href="#提升度（lift）" class="headerlink" title="提升度（lift）"></a>提升度（lift）</h3><p>提升度（lift）是一种简单的相关性度量，A和B出现之间的<strong>提升度</strong>可以通过计算下式得到</p><script type="math/tex; mode=display">lift(A,B)=\frac{P(A\cup B)}{P(A)P(B)}</script><p>如果lift(A,B)值小于1，则A的出现和B的出现是负相关的，意味一个出现可能导致另一个不出现。如果值大于1，则A和B是正相关的，意味着每一个的出现都蕴含另一个的出现。如果结果值等于1，则A和B是独立的，它们之间没有相关性。</p><h3 id="使用提升度的相关分析"><a href="#使用提升度的相关分析" class="headerlink" title="使用提升度的相关分析"></a>使用提升度的相关分析</h3><p>如果我们要分析如下的关联规则：</p><script type="math/tex; mode=display">buys(X, "computer games")\Rightarrow buys(X, "videos") \\ [support = 40\%, confidence=66\%]</script><p> 且有下面的事务相依表： </p><p><img src="/2018/11/02/数据挖掘概念与技术/数据挖掘概念与技术笔记（3）：挖掘频繁模式、关联和相关性/10.png" alt></p><p><img src="/2018/11/02/数据挖掘概念与技术/数据挖掘概念与技术笔记（3）：挖掘频繁模式、关联和相关性/11.png" alt></p><h3 id="使用卡方检测的相关分析"><a href="#使用卡方检测的相关分析" class="headerlink" title="使用卡方检测的相关分析"></a>使用卡方检测的相关分析</h3><p><img src="/2018/11/02/数据挖掘概念与技术/数据挖掘概念与技术笔记（3）：挖掘频繁模式、关联和相关性/12.png" alt></p><p><img src="/2018/11/02/数据挖掘概念与技术/数据挖掘概念与技术笔记（3）：挖掘频繁模式、关联和相关性/13.png" alt></p><h3 id="模式评估度量比较"><a href="#模式评估度量比较" class="headerlink" title="模式评估度量比较"></a>模式评估度量比较</h3><p>最近，另外一些模式评估度量引起了关注，本书介绍了四种这样的度量：全置信度、最大置信度、Kulczynsji和余弦。然后，比较它们的有效性，并且与提升度和卡方检测$X^2$进行比较。</p><p>全置信度：</p><script type="math/tex; mode=display">all\_conf(A,B)=\frac{sup(A\cup B)}{max\{sup(A), sup(B)\}}=min\{P(A|B),P(B|A)\}</script><p> 最大置信度： </p><script type="math/tex; mode=display">max\_conf(A,B)=max\{P(A|B),P(B|A)\}</script><p> Kulczynski: </p><script type="math/tex; mode=display">Kulc(A,B)=\frac{1}{2}(P(A|B)+P(B|A))</script><p> 余弦： </p><script type="math/tex; mode=display">cosine(A,B)=\frac{sup(A\cup B)}{\sqrt{sup(A)\times sup(B)}}=\sqrt{P(A|B)\times P(B|A)}</script><p> 对于评估所发现的模式联系，哪一个度量最好呢？<strong>对于零事务提升度和卡方检测效果都不好</strong>，<strong>零事务是指不包含任何考察项集的事务。典型地，零事务的个数可能远远大于个体的购买的个数，因为许多人都即不买牛奶也不买咖啡。另一方面，上面的新的四种度量都能解决零事务，因为他们的定义都消除了零事务的影响。</strong>一般的，推荐Kluc优先。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;h3 id=&quot;关联规则&quot;&gt;&lt;a href=&quot;#关联规则&quot; class=&quot;headerlink&quot; title=&quot;关联规则&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="数据挖掘" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
    
      <category term="频繁模式" scheme="http://yoursite.com/tags/%E9%A2%91%E7%B9%81%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Apriori算法" scheme="http://yoursite.com/tags/Apriori%E7%AE%97%E6%B3%95/"/>
    
      <category term="FP-Growth算法" scheme="http://yoursite.com/tags/FP-Growth%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据挖掘概念与技术笔记（2）：数据预处理</title>
    <link href="http://yoursite.com/2018/11/02/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2018/11/02/数据挖掘概念与技术/数据挖掘概念与技术笔记（2）：数据预处理/</id>
    <published>2018-11-02T09:06:13.000Z</published>
    <updated>2019-12-28T12:31:24.120Z</updated>
    
    <content type="html"><![CDATA[<h2 id="冗余和相关分析"><a href="#冗余和相关分析" class="headerlink" title="冗余和相关分析"></a>冗余和相关分析</h2><h3 id="分类属性的-X-2-卡方检测"><a href="#分类属性的-X-2-卡方检测" class="headerlink" title="分类属性的$X^2$卡方检测"></a>分类属性的$X^2$卡方检测</h3><p>对于分类属性，两个属性A和B的相关联系可以通过X2X2(卡方)检测。</p><p>以下为一个典型的<strong>四格卡方检验</strong>，我们想知道喝牛奶对感冒发病率有没有影响：</p><p><img src="/2018/11/02/数据挖掘概念与技术/数据挖掘概念与技术笔记（2）：数据预处理/01.png" alt></p><p>通过简单的统计我们得出喝牛奶组和不喝牛奶组的感冒率为30.94%和25.00%，两者的差别可能是抽样误差导致，也有可能是牛奶对感冒率真的有影响。</p><p>得到的感冒率可能是抽样误差导致，也有可能是牛奶对感冒率真的有影响。</p><p>为了确定真实原因,我们<strong>先假设喝牛奶对感冒发病率是没有影响的</strong>,即喝牛奶喝感冒时独立无关的,所以我们可以得出感冒的<strong>实际发病率</strong>是(43 + 28)/(43 + 28 + 96 + 84)= 28.29%</p><p>所以,<strong>理论的四格表</strong>应该如下表所示:</p><p><img src="/2018/11/02/数据挖掘概念与技术/数据挖掘概念与技术笔记（2）：数据预处理/02.png" alt></p><p> 即下表: </p><p><img src="/2018/11/02/数据挖掘概念与技术/数据挖掘概念与技术笔记（2）：数据预处理/03.png" alt></p><p><strong>如果喝牛奶喝感冒真的是独立无关的,那么四格表里的理论值和实际值差别应该会很小。</strong></p><p>$X^2$卡方检测值可以用下式计算：</p><script type="math/tex; mode=display">x^2=\sum\frac{(A-T)^2}{T}</script><p>其中，A为实际值，T为理论值。$x^2$值用于衡量实际值与理论值的差异程度和相对大小，值越小属性越独立无关，值越大，属性是统计相关的。</p><p>根据上面的卡方检验公式，有</p><script type="math/tex; mode=display">x^2=\frac{(43-39.3231)^2}{39.3231}+\frac{(28-31.6848)^2}{31.6848}+\frac{(96-99.6769)^2}{99.6769}+\frac{(84-80.3152)^2}{80.3152}=1.077</script><p><strong>卡方分布的临界值</strong>:</p><p>上一步我们得到了卡方的值,但是如何通过卡方的值来判断喝牛奶和感冒是否真的是独立无关的?也就是说,怎么知道无关性假设是否可靠?</p><p><img src="/2018/11/02/数据挖掘概念与技术/数据挖掘概念与技术笔记（2）：数据预处理/04.png" alt></p><p><strong>答案是,通过查询卡方分布的临界值表</strong>。这里需要用到一个<strong>自由度的概念</strong>,自由度等于V =(行数- 1)*(列数- 1),对四格表,自由V = 1度。对V = 1,喝牛奶和感概冒95%率不相关的卡方分布的临界概率是:3.84。即如果卡方大于3.84,则认为喝牛奶和感冒有95%的概率相关，有统计联系。</p><p><strong>显然1.077 &lt; 3.84,没有达到卡方分布的临界值,所以喝牛奶和感冒独立不相关的假设成立,说明两者之间没说明联系</strong>。</p><h3 id="数值类型的皮尔逊相关系数"><a href="#数值类型的皮尔逊相关系数" class="headerlink" title="数值类型的皮尔逊相关系数"></a>数值类型的皮尔逊相关系数</h3><script type="math/tex; mode=display">r_{A,B}=\frac{\sum_{i=1}^n(a_i-\bar A)(b_i-\bar B)}{n\sigma_A \sigma_B}</script><p> 其中，$\bar A$和$\bar B$为均值，和$\sigma_A$ 和$\sigma_B$为标准差。 </p><h3 id="数值类型的协方差"><a href="#数值类型的协方差" class="headerlink" title="数值类型的协方差"></a>数值类型的协方差</h3><p>在概率学和统计学中，协方差和方差是两个类型的度量，<strong>评估两个属性如何一起变化。</strong></p><script type="math/tex; mode=display">Cov(A,B)=\frac{\sum_{i=1}^n(a_i-\bar A)(b_i-\bar B)}{n}=E(A\cdot B)-\bar A\bar B</script><p> 其中，$E(A\cdot B)$表示期望 ，用均值表示。</p><p> <strong>协方差值为0表示具有独立性，协方差越大代表两个属性会一起变化。</strong></p><h3 id="小波变换"><a href="#小波变换" class="headerlink" title="小波变换"></a>小波变换</h3><p>知乎这里讲的很清楚了，主要用于选出有效的特征属性。</p><p><a href="https://zhuanlan.zhihu.com/p/22450818" target="_blank" rel="noopener">戳我</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;冗余和相关分析&quot;&gt;&lt;a href=&quot;#冗余和相关分析&quot; class=&quot;headerlink&quot; title=&quot;冗余和相关分析&quot;&gt;&lt;/a&gt;冗余和相关分析&lt;/h2&gt;&lt;h3 id=&quot;分类属性的-X-2-卡方检测&quot;&gt;&lt;a href=&quot;#分类属性的-X-2-卡方检测&quot; cla
      
    
    </summary>
    
      <category term="数据挖掘" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
    
      <category term="卡方检测" scheme="http://yoursite.com/tags/%E5%8D%A1%E6%96%B9%E6%A3%80%E6%B5%8B/"/>
    
      <category term="皮尔逊相关系数" scheme="http://yoursite.com/tags/%E7%9A%AE%E5%B0%94%E9%80%8A%E7%9B%B8%E5%85%B3%E7%B3%BB%E6%95%B0/"/>
    
      <category term="小波变换" scheme="http://yoursite.com/tags/%E5%B0%8F%E6%B3%A2%E5%8F%98%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>数据挖掘概念与技术笔记（1）：数据认识</title>
    <link href="http://yoursite.com/2018/11/01/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E8%AE%A4%E8%AF%86/"/>
    <id>http://yoursite.com/2018/11/01/数据挖掘概念与技术/数据挖掘概念与技术笔记（1）：数据认识/</id>
    <published>2018-11-01T09:06:13.000Z</published>
    <updated>2019-12-28T12:31:05.847Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据的基本统计描述"><a href="#数据的基本统计描述" class="headerlink" title="数据的基本统计描述"></a>数据的基本统计描述</h2><h3 id="中心趋势度量：均值、中位数和众数"><a href="#中心趋势度量：均值、中位数和众数" class="headerlink" title="中心趋势度量：均值、中位数和众数"></a>中心趋势度量：均值、中位数和众数</h3><p>尽管均值是描述数据集的最有用的单个量，但是它并非总是度量数据中心的最佳方法。主要问题是，均值对极端值（例如、离群点）很敏感。为了解决这个问题，我们可以采用结尾均值。结尾均值是丢弃高低极端值后的均值。</p><p>对于倾斜（非对称）数据，数据中心的更好的度量是中位数。</p><h3 id="度量数据散布：极差、四分位数、方差、标准差和四分位数极差"><a href="#度量数据散布：极差、四分位数、方差、标准差和四分位数极差" class="headerlink" title="度量数据散布：极差、四分位数、方差、标准差和四分位数极差"></a>度量数据散布：极差、四分位数、方差、标准差和四分位数极差</h3><p>极差：集合的最大值减去最小值</p><p>四分位数第1个四分位数记作$Q_1$，是第25个百分位数，第2个为50%，第3个四分位数记作$Q_3$，第75个百分位数。其中，第1个和第3个百分位数之间的距离是散布的一种简单度量，它给出被数据的中间一半所覆盖的范围。该距离称为四分位数极差（IQR），定义为</p><script type="math/tex; mode=display">IQR=Q_3-Q_1</script><p>识别离群点的通常规则是，挑选落在第3个四分位数之上或第1个四分位数之下至少1.5×IQR处的值。</p><p>盒图是一种流行的分布的直观表示，盒图表示了五数概括：</p><ul><li>盒的端点一般在Q1和Q3四分位数上，使得盒的长度是四分位数极差</li><li>中位数用盒内的线标记</li><li>盒外的两条线（称为胡须）延伸到集合的最大和最小值</li></ul><p>方差和标准差：标准差是方差的平方根，低的标准差表示数据观测趋向于非常靠近均值。</p><h3 id="分位数图"><a href="#分位数图" class="headerlink" title="分位数图"></a>分位数图</h3><p><strong>分位数图</strong>是一种观察数据分布的简单有效的方法。首先，它显示所有的数据（允许用户评估总的情况和不寻常的出现），并将数据由小到大排序，每个观测值$x_(i)$  与一个百分数 $f_i$ 配对。下图表示了单价数据的分位数图。</p><p><img src="/2018/11/01/数据挖掘概念与技术/数据挖掘概念与技术笔记（1）：数据认识/01.png" alt></p><p><strong>分位数-分位数图</strong>，或 <strong>q-q 图</strong>对着另一个的对应分位数，绘制一个单变量分布的分位数。它是一<br>种强有力的直观表示工具，使得用户可以观察从一个分布到另一个是否有移位。</p><p>假定对于变量单价，我们有两个观测集，取自两个不同的分店。每组数据都已按递增序排序。下图给出两个部门的QQ图（分位数-分位数图） </p><p><img src="/2018/11/01/数据挖掘概念与技术/数据挖掘概念与技术笔记（1）：数据认识/02.png" alt></p><h2 id="度量数据的相似性和相异性"><a href="#度量数据的相似性和相异性" class="headerlink" title="度量数据的相似性和相异性"></a>度量数据的相似性和相异性</h2><p>一般的，<strong>如果两个对象i和j不相似</strong>，则他们的相似性度量将<strong>返回0</strong>。<strong>反之两个对象相似则返回1</strong>。</p><h3 id="数据矩阵和相异性矩阵"><a href="#数据矩阵和相异性矩阵" class="headerlink" title="数据矩阵和相异性矩阵"></a>数据矩阵和相异性矩阵</h3><p>数据矩阵称对象-属性结构，形式为n×p（n个对象p个属性）矩阵存放n个数据对象，每行对应于一个对象；相异性矩阵存放n个对象两两之间的相似度量，是个n×n对称矩阵(类似皮尔逊相关系数)</p><h3 id="分类属性的邻近性度量"><a href="#分类属性的邻近性度量" class="headerlink" title="分类属性的邻近性度量"></a>分类属性的邻近性度量</h3><p>如何计算分类属性所刻画对象之间的相异性？两个对象i和j之间的相异性可以根据不匹配率来计算：</p><script type="math/tex; mode=display">d(i,j)=\frac{p-m}{p}</script><p> 其中，m是匹配的数目（即i和j取值相同状态的属性数），而p是刻画对象的属性总数。<strong>假设我们有表2.2中的4个对象的数据样本</strong>，每个对象3个属性，<strong>其中只有一个分类属性test-1</strong>，在上面的式子中，当对象i和j属性匹配时， $d(i,j)=0$ 当对象不匹配时，  $d(i,j)=1$.</p><p><img src="/2018/11/01/数据挖掘概念与技术/数据挖掘概念与技术笔记（1）：数据认识/03.png" alt></p><p><img src="/2018/11/01/数据挖掘概念与技术/数据挖掘概念与技术笔记（1）：数据认识/04.png" alt></p><h3 id="布尔属性的邻近性度量"><a href="#布尔属性的邻近性度量" class="headerlink" title="布尔属性的邻近性度量"></a>布尔属性的邻近性度量</h3><h3 id><a href="#" class="headerlink" title></a><img src="/2018/11/01/数据挖掘概念与技术/数据挖掘概念与技术笔记（1）：数据认识/05.png" alt></h3><p><strong>上面表示两个对象的取0或1的属性数目(q,s,r,t)</strong></p><p>对于<strong>对称的二元属性（布尔属性），是指每个属性都同样重要。基于对称二元属性的相异性称作对称的二元相异性</strong>。如果对象i和j都用对称的二元属性刻画，则i和j的<strong>相异性</strong>为：</p><script type="math/tex; mode=display">d(i,j)=\frac{r+s}{q+r+s+t}</script><p> 互补的,相似性可用下式计算： </p><script type="math/tex; mode=display">sim(i，j)=1-d(i,j)</script><p> 一个例子：下面gender为对称属性，其余为非对称属性（共6个），<strong>这里我们只考虑患者(对象)非对称属性</strong>，值Y(yes)和P(positive)都设置为1，N(no,negative)为0. <strong>采用上面非对称的二元相异性计算公式</strong>。 </p><p><img src="/2018/11/01/数据挖掘概念与技术/数据挖掘概念与技术笔记（1）：数据认识/06.png" alt></p><p><img src="/2018/11/01/数据挖掘概念与技术/数据挖掘概念与技术笔记（1）：数据认识/07.png" alt></p><h3 id="数值属性的相异性：闵可夫斯基距离"><a href="#数值属性的相异性：闵可夫斯基距离" class="headerlink" title="数值属性的相异性：闵可夫斯基距离"></a>数值属性的相异性：闵可夫斯基距离</h3><script type="math/tex; mode=display">d(i,j)=\sqrt[p]{|x_{i1}-x_{j1}|^p+|x_{i2}-x_{j2}|^p+...+|x_{i1}-x_{j1}|^p}</script><h3 id="偏序属性的邻近性度量"><a href="#偏序属性的邻近性度量" class="headerlink" title="偏序属性的邻近性度量"></a>偏序属性的邻近性度量</h3><p>偏序属性的值之间具有意义的序或排位，例如size属性的序列值[small, medium, large]. 计算这种偏序属性首先计算状态在序数属性上的排名，并映射到[0, 1]数值上。然后把转换后的数值用闵可夫斯基距离来计算相似性。排名转换公式如下：</p><script type="math/tex; mode=display">z_{if}=\frac{r_{if}-1}{M_f-1}</script><p>其中，属性$f$有$M<em>f$个有序的状态，表示排位$1,2…M_f$。排位$r</em>{if}$表示当前属性状态排名。</p><p>一个例子：</p><p><img src="/2018/11/01/数据挖掘概念与技术/数据挖掘概念与技术笔记（1）：数据认识/03.png" alt></p><p> test-2偏序属性，有三个状态，即$M_f$=3，四个对象转换为排位分别为3、1、2、3。然后分别映射为1.0、0.0、0.5、1.0数值，最后可以使用欧几里得距离来计算如下的相异性矩阵。</p><p><img src="/2018/11/01/数据挖掘概念与技术/数据挖掘概念与技术笔记（1）：数据认识/08.png" alt></p><h3 id="混合类型属性的相异性"><a href="#混合类型属性的相异性" class="headerlink" title="混合类型属性的相异性"></a>混合类型属性的相异性</h3><p>解决这种情况的方法是讲所有类型一起处理，<strong>把所有有意义的属性转换到共同区间[0.0 , 1.0]上</strong></p><p> <img src="/2018/11/01/数据挖掘概念与技术/数据挖掘概念与技术笔记（1）：数据认识/09.png" alt></p><p>1、如果是数值，用归一化。2、如果是类别属性，匹配为1不匹配为0。3、偏序将排位先转为数值，再按数值的归一化处理。</p><p>一个例子：（混合了分类、偏序、和数值）</p><p><img src="/2018/11/01/数据挖掘概念与技术/数据挖掘概念与技术笔记（1）：数据认识/03.png" alt></p><p>之前，处理test-1(分类属性)和test-2(偏序属性)的过程已经给出，可以使用它们之前的相异性矩阵。所以这里首先计算test-3(数值属性)的相异性矩阵。有max=64，min=22，比较对象用归一化处理后，得到test-3的相异性矩阵：</p><p><img src="/2018/11/01/数据挖掘概念与技术/数据挖掘概念与技术笔记（1）：数据认识/10.png" alt></p><p>其中，d(3,1)是对象1和对象3每个不同属性的相似性矩阵计算得到的值，总的处理方式还是归一化。</p><h3 id="余弦相似性"><a href="#余弦相似性" class="headerlink" title="余弦相似性"></a>余弦相似性</h3><p>给出了四个文档的词频向量，用于比较这些文档之间的相似性。</p><p><img src="/2018/11/01/数据挖掘概念与技术/数据挖掘概念与技术笔记（1）：数据认识/11.png" alt></p><p><img src="/2018/11/01/数据挖掘概念与技术/数据挖掘概念与技术笔记（1）：数据认识/12.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数据的基本统计描述&quot;&gt;&lt;a href=&quot;#数据的基本统计描述&quot; class=&quot;headerlink&quot; title=&quot;数据的基本统计描述&quot;&gt;&lt;/a&gt;数据的基本统计描述&lt;/h2&gt;&lt;h3 id=&quot;中心趋势度量：均值、中位数和众数&quot;&gt;&lt;a href=&quot;#中心趋势度量：均值
      
    
    </summary>
    
      <category term="数据挖掘" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
    
      <category term="相似性" scheme="http://yoursite.com/tags/%E7%9B%B8%E4%BC%BC%E6%80%A7/"/>
    
      <category term="分位数图" scheme="http://yoursite.com/tags/%E5%88%86%E4%BD%8D%E6%95%B0%E5%9B%BE/"/>
    
      <category term="QQ图" scheme="http://yoursite.com/tags/QQ%E5%9B%BE/"/>
    
      <category term="相异性" scheme="http://yoursite.com/tags/%E7%9B%B8%E5%BC%82%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>动态规划</title>
    <link href="http://yoursite.com/2018/09/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://yoursite.com/2018/09/24/数据结构与算法/动态规划/</id>
    <published>2018-09-24T09:06:13.000Z</published>
    <updated>2019-12-28T09:25:54.757Z</updated>
    
    <content type="html"><![CDATA[<h2 id="五问动态规划"><a href="#五问动态规划" class="headerlink" title="五问动态规划"></a>五问动态规划</h2><p>问：动态规划是什么？</p><p><strong>答：</strong>动态规划是一种通过“大而化小”的思路解决问题的算法。区别于一些固定形式的算法，如二分法，宽度优先搜索法，动态规划没有实际的步骤来规定第一步做什么第二步做什么。所以更加确切的说，动态规划是一种解决问题的思想。这种思想的本质是，一个规模比较大的问题（假如用2-3个参数可以表示），是通过规模比较小的若干问题的结果来得到的（通过取最大，取最小，或者加起来之类的运算）所以我们经常看到的动态规划的核心——状态转移方程都长成这样：</p><script type="math/tex; mode=display">f[i][j] = f[i - 1][j] + f[i][j - 1]</script><script type="math/tex; mode=display">f[i] = max\{f[j]    if   j < i and …\} + 1</script><script type="math/tex; mode=display">f[i][j] = f[0][j - 1] \&\& judge(1,i)   ||   f[1][j - 1] \&\& judge(2,i) ||</script><p>问：动态规划什么时候可以用？</p><p>答：动态规划解决的一定是最优化问题。一个问题必须有重叠的子问题和最优子结构，才能使用动态规划取解决问题。</p><p>问：动态规划的常见类型有哪些？</p><ul><li>矩阵型</li><li>序列型</li><li>双序列型</li><li>划分型</li><li>区间型</li><li>背包型</li></ul><p>问：什么样的问题适合使用动态规划？</p><p><strong>答：</strong>可以使用动态规划的问题一般都有一些特点可以遵循。如题目的问法一般是三种方式：</p><ol><li>求最大值/最小值</li><li>求可不可行</li><li>求方案总数</li></ol><p>如果你碰到一个问题，是问你这三个问题之一的，那么有90%的概率是使用动态规划来求解。要重点说明的是，如果一个问题让你求出“所有的”方案和结果，则肯定不是使用动态规划。</p><p>解决一个动态规划问题的步骤是什么？</p><p><strong>答：</strong>首先判断是否是动态规划的问题，如果是，则尝试将其进行分类常见类型，找到对应的类别和相似的问题。接着从下面的4个要素去逐步剖析解决这道题：</p><ol><li>状态是什么</li><li>状态转移方程是什么</li><li>状态的初始值是什么</li><li>问题要求的最后答案是什么</li></ol><p>每个步骤分析完成之后，就基本上解决了整道动态规划的问题。</p><h2 id="动态规划相关题"><a href="#动态规划相关题" class="headerlink" title="动态规划相关题"></a>动态规划相关题</h2><h3 id="交叉字符串"><a href="#交叉字符串" class="headerlink" title="交叉字符串"></a>交叉字符串</h3><p><strong>题目</strong>：给出三个字符串:s1、s2、s3，判断s3是否由s1和s2交叉构成。</p><p><strong>样例</strong></p><p>比如 s1 = <strong>“aabcc”</strong> s2 = <strong>“dbbca”</strong></p><ul><li>当 s3 = <strong>“aadbbcbcac”</strong>，返回 true.</li></ul><ul><li>当 s3 = <strong>“aadbbbaccc”</strong>， 返回 false.</li></ul><p><strong>思路：</strong></p><p> 1.这题我们利用动态规划加记忆化搜索。如果能够进行交叉组成，利用动态规划，建立 $boolean    dp[i][j]$， 意思是s1的第i为 和s2的第j为是否能够够成s3的i + j 长度的交叉字符串。不一定要每个字符交替插入，s1 = aa, s2 = d 也可以组成s3 = aad。记忆矩阵这里要清楚定义，一个维度是s1的长度，一个维度是s2的长度。 </p><p> 2.因此状态转移方程就可以写成: </p><script type="math/tex; mode=display">dp[i][j] = 1) dp[i][j-1] if s3[i+j -1] == s2[j-1] 2) dp[i-1][j] if s3[i+j-1] == s1[i-1]</script><p> 3.初始条件要注意，我们这里是把记忆矩阵建立为$test$，因此第一行就是没有s1的情况下看看s2能不能与s3配对，第一列就是在没有s2的情况下能不能与s3配对。<br>4.最后就是看最右下角的dp。时间复杂度是o(n*m)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @params s1, s2, s3: Three strings as description.</span></span><br><span class="line"><span class="string">    @return: return True if s3 is formed by the interleaving of</span></span><br><span class="line"><span class="string">             s1 and s2 or False if not.</span></span><br><span class="line"><span class="string">    @hint: you can use [[True] * m for i in range (n)] to allocate a n*m matrix.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isInterleave</span><span class="params">(self, s1, s2, s3)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">if</span> s1 <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> s2 <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> s3 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> len(s1) + len(s2) != len(s3):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 初始边界s1行s2列的false</span></span><br><span class="line">        interleave = [[<span class="literal">False</span>] * (len(s2) + <span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s1) + <span class="number">1</span>)]</span><br><span class="line">        interleave[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s1)):</span><br><span class="line">            interleave[i + <span class="number">1</span>][<span class="number">0</span>] = s1[:i + <span class="number">1</span>] == s3[:i + <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s2)):</span><br><span class="line">            interleave[<span class="number">0</span>][i + <span class="number">1</span>] = s2[:i + <span class="number">1</span>] == s3[:i + <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s1)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(s2)):</span><br><span class="line">                interleave[i + <span class="number">1</span>][j + <span class="number">1</span>] = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">if</span> s1[i] == s3[i + j + <span class="number">1</span>]:</span><br><span class="line">                    interleave[i + <span class="number">1</span>][j + <span class="number">1</span>] = interleave[i][j + <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> s2[j] == s3[i + j + <span class="number">1</span>]:</span><br><span class="line">                    interleave[i + <span class="number">1</span>][j + <span class="number">1</span>] |= interleave[i + <span class="number">1</span>][j]</span><br><span class="line">        <span class="keyword">return</span> interleave[len(s1)][len(s2)]</span><br></pre></td></tr></table></figure><h3 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h3><p><strong>描述</strong>：给定一个整数序列，找到最长上升子序列（LIS，<strong>不要求一定连续</strong>），返回LIS的长度。例如现在有序列A={1,2,3,-1,-2,7,9}，它的最长上升子序列为{1,2,3,7,9}，长度为5.</p><p>思路：dp[i] 表示走到第i个元素时的当前最大连续子序列的长度 ，这样对A[i]有两种可能：</p><p>1、如果A[i]之前的元素A[j]，其中$jdp[i]$，那么可以把A[i]拼接到A[j]的后面</p><p>2、如果之前的元素都比A[i]大，则A[i]自己成为最大的上升自序，长度为1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param nums: The integer array</span></span><br><span class="line"><span class="string">    @return: The length of LIS (longest increasing subsequence)</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestIncreasingSubsequence</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">if</span> nums <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [<span class="number">1</span>] * len(nums) <span class="comment"># 边界初始条件</span></span><br><span class="line">        <span class="keyword">for</span> curr, val <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">for</span> prev <span class="keyword">in</span> xrange(curr):</span><br><span class="line">                <span class="keyword">if</span> nums[prev] &lt; val:  <span class="comment"># 如果之前的元素大于等于curr，则dp[curr]为初始的1</span></span><br><span class="line">                    dp[curr] = max(dp[curr], dp[prev] + <span class="number">1</span>) <span class="comment">#状态转移方程</span></span><br><span class="line">        <span class="keyword">return</span> max(dp)</span><br></pre></td></tr></table></figure><h3 id="单词拆分"><a href="#单词拆分" class="headerlink" title="单词拆分 ++"></a>单词拆分 ++</h3><p><strong>描述</strong>：给定字符串 s 和单词字典 dict，确定 s 是否可以分成一个或多个以空格分隔的子串，并且这些子串都在字典中存在。</p><p><strong>样例</strong>：给出s = <strong>“lintcode”</strong>，dict = <strong>[“lint”,”code”]</strong>返回 true 因为<strong>“lintcode”</strong>可以被空格切分成<strong>“lint code”</strong></p><p>思路：如果最大字典长度为k，f[i]的状态由前面i-k到i-1之间决定，这中间任何一段属于dict则f[I]为True</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param s: A string s</span></span><br><span class="line">    <span class="comment"># @param dict: A dictionary of words dict</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wordBreak</span><span class="params">(self, s, dict)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(dict) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> len(s) == <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">        n = len(s)</span><br><span class="line">        f = [<span class="literal">False</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        f[<span class="number">0</span>] = <span class="literal">True</span>  <span class="comment"># 初始边界</span></span><br><span class="line">        </span><br><span class="line">        maxLength = max([len(w) <span class="keyword">for</span> w <span class="keyword">in</span> dict]) <span class="comment">#先计算字典中最大长度，减少复杂度</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, min(i, maxLength) + <span class="number">1</span>): <span class="comment">#不必遍历i之前的所有j</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> f[i - j]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> s[i - j:i] <span class="keyword">in</span> dict:</span><br><span class="line">                    f[i] = <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">break</span> <span class="comment"># 有一个满足即可判断下一个f[i+1]</span></span><br><span class="line">        <span class="keyword">return</span> f[n]</span><br></pre></td></tr></table></figure><h3 id="数字三角形"><a href="#数字三角形" class="headerlink" title="数字三角形"></a>数字三角形</h3><p><strong>描述</strong>：给定一个数字三角形，找到从顶部到底部的最小路径和。每一步可以移动到下面一行的相邻数字上</p><p><strong>样例</strong>：比如，给出下列数字三角形：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">     [<span class="number">2</span>],</span><br><span class="line">    [<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">   [<span class="number">6</span>,<span class="number">5</span>,<span class="number">7</span>],</span><br><span class="line">  [<span class="number">4</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">3</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>从顶到底部的最小路径和为11 ( 2 + 3 + 5 + 1 = 11)。</p><p><strong>思路</strong>：自底向上的动态规划, 当前位置由左下或者右下最小值决定，时间复杂度O(n), python3 实现 ， triangle数组代表第i行第j个数字</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param triangle: a list of lists of integers</span></span><br><span class="line"><span class="string">    @return: An integer, minimum path sum</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumTotal</span><span class="params">(self, triangle)</span>:</span></span><br><span class="line">        rows = len(triangle)</span><br><span class="line">        dp = [[<span class="number">0</span>] * len(triangle[row]) <span class="keyword">for</span> row <span class="keyword">in</span> range(rows)] </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(triangle[rows - <span class="number">1</span>])):</span><br><span class="line">            dp[rows - <span class="number">1</span>][i] = triangle[rows - <span class="number">1</span>][i] <span class="comment">#初始边界</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(rows - <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>):</span><br><span class="line">                dp[i][j] = min(dp[i + <span class="number">1</span>][j], dp[i + <span class="number">1</span>][j + <span class="number">1</span>]) + triangle[i][j] <span class="comment">#状态转移方程</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h3 id="最小路径和"><a href="#最小路径和" class="headerlink" title="最小路径和"></a>最小路径和</h3><p>描述：给定一个只含非负整数的m×n网格，找到一条<strong>从左上角到右下角</strong>的可以使数字和最小的路径。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param grid: a list of lists of integers.</span></span><br><span class="line"><span class="string">    @return: An integer, minimizes the sum of all numbers along its path</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minPathSum</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(grid)): </span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(grid[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">and</span> j &gt; <span class="number">0</span>:</span><br><span class="line">                    grid[i][j] += grid[i][j<span class="number">-1</span>] <span class="comment"># 第一行，只在左边</span></span><br><span class="line">                <span class="keyword">elif</span> j == <span class="number">0</span> <span class="keyword">and</span> i &gt; <span class="number">0</span>:</span><br><span class="line">                    grid[i][j] += grid[i<span class="number">-1</span>][j] <span class="comment"># 第一列，只在右边</span></span><br><span class="line">                <span class="keyword">elif</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> j &gt; <span class="number">0</span>:</span><br><span class="line">                    grid[i][j] += min(grid[i<span class="number">-1</span>][j], grid[i][j<span class="number">-1</span>])  <span class="comment"># 由上面和左面的最小路径决定</span></span><br><span class="line">        <span class="keyword">return</span> grid[len(grid) - <span class="number">1</span>][len(grid[<span class="number">0</span>]) - <span class="number">1</span>]</span><br></pre></td></tr></table></figure><h3 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯 ++"></a>爬楼梯 ++</h3><p>描述：假设你正在爬楼梯，需要n步你才能到达顶部。但每次你只能爬一步或者两步，你能有多少种不同的方法？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param n: An integer</span></span><br><span class="line"><span class="string">    @return: An integer</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        result=[<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-2</span>):</span><br><span class="line">            result.append(result[<span class="number">-2</span>]+result[<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> result[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h3 id="不同的路径"><a href="#不同的路径" class="headerlink" title="不同的路径"></a>不同的路径</h3><p><strong>描述</strong>：有一个机器人的位于一个 m × n 个网格左上角。机器人每一时刻只能向下或者向右移动一步。机器人试图达到网格的右下角。问有多少条不同的路径？</p><p><strong>思路</strong>：有左边一格的路径数和上面一格的路径数决定</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span><span class="params">(self, m, n)</span>:</span></span><br><span class="line">        paths = [[<span class="number">0</span>] * n <span class="keyword">for</span> i <span class="keyword">in</span> range(m)] <span class="comment">#初始边界</span></span><br><span class="line">        <span class="comment"># initial rows</span></span><br><span class="line">        paths[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">            paths[x][<span class="number">0</span>] = paths[x - <span class="number">1</span>][<span class="number">0</span>] <span class="comment">#边界</span></span><br><span class="line">        <span class="comment"># initail columns</span></span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            paths[<span class="number">0</span>][y] = paths[<span class="number">0</span>][y - <span class="number">1</span>] <span class="comment">#边界</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">                paths[x][y] = paths[x <span class="number">-1</span>][y] + paths[x][y - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> paths[m - <span class="number">1</span>][n - <span class="number">1</span>]</span><br></pre></td></tr></table></figure><h3 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离 +"></a>编辑距离 +</h3><p><strong>题目</strong>：给出两个单词word1和word2，计算出将word1 转换为word2的最少操作次数。你总共三种操作方法：</p><ul><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ul><p><strong>样例</strong>：给出 work1=”mart” 和 work2=”karma”，返回 3。（先进行2个替换，后面进行1个插入）</p><p>思路：f[i][j代表第一个字符串以i结尾匹配上（编辑成）第二个字符串以j结尾的字符串，最少需要多少次编辑。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param word1: A string</span></span><br><span class="line"><span class="string">    @param word2: A string</span></span><br><span class="line"><span class="string">    @return: The minimum number of steps.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDistance</span><span class="params">(self, word1, word2)</span>:</span></span><br><span class="line">        n, m = len(word1), len(word2)</span><br><span class="line">        f = [[<span class="number">0</span>] * (m + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n + <span class="number">1</span>)]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n + <span class="number">1</span>):</span><br><span class="line">            f[i][<span class="number">0</span>] = i <span class="comment"># 边界</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(m + <span class="number">1</span>):</span><br><span class="line">            f[<span class="number">0</span>][j] = j <span class="comment"># 边界</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]:</span><br><span class="line">                    f[i][j] = min(f[i - <span class="number">1</span>][j - <span class="number">1</span>], f[i - <span class="number">1</span>][j] + <span class="number">1</span>, f[i][j - <span class="number">1</span>] + <span class="number">1</span>)</span><br><span class="line">                    <span class="comment"># equivalent to f[i][j] = f[i - 1][j - 1]</span></span><br><span class="line">                <span class="keyword">else</span>: <span class="comment">#分别代表替换，插入，删除</span></span><br><span class="line">                    f[i][j] = min(f[i - <span class="number">1</span>][j - <span class="number">1</span>], f[i - <span class="number">1</span>][j], f[i][j - <span class="number">1</span>]) + <span class="number">1</span></span><br><span class="line">                        </span><br><span class="line">        <span class="keyword">return</span> f[n][m]</span><br></pre></td></tr></table></figure><h3 id="正则表达式匹配"><a href="#正则表达式匹配" class="headerlink" title="正则表达式匹配 ++"></a>正则表达式匹配 ++</h3><p><strong>描述</strong>：实现支持<strong>‘.’</strong>和<strong>‘*‘</strong>的正则表达式匹配。’.’匹配任意一个字母。’*’匹配零个或者多个前面的元素。匹配应该覆盖整个输入字符串，而不仅仅是一部分。返回true 和 false</p><p><strong>样例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">isMatch(<span class="string">"aa"</span>,<span class="string">"a"</span>) → false</span><br><span class="line"></span><br><span class="line">isMatch(<span class="string">"aa"</span>,<span class="string">"aa"</span>) → true</span><br><span class="line"></span><br><span class="line">isMatch(<span class="string">"aaa"</span>,<span class="string">"aa"</span>) → false</span><br><span class="line"></span><br><span class="line">isMatch(<span class="string">"aa"</span>, <span class="string">"a*"</span>) → true</span><br><span class="line"></span><br><span class="line">isMatch(<span class="string">"aa"</span>, <span class="string">".*"</span>) → true</span><br><span class="line"></span><br><span class="line">isMatch(<span class="string">"ab"</span>, <span class="string">".*"</span>) → true</span><br><span class="line"></span><br><span class="line">isMatch(<span class="string">"aab"</span>, <span class="string">"c*a*b"</span>) → true</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># DP</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s, p)</span>:</span></span><br><span class="line">        dp = [[<span class="literal">False</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(p) + <span class="number">1</span>)] <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, len(s) + <span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(p) + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> (p[i - <span class="number">1</span>] == <span class="string">'*'</span>):</span><br><span class="line">                dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i - <span class="number">2</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(s) + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(p) + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> p[j - <span class="number">1</span>] == <span class="string">'*'</span>:</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">2</span>]</span><br><span class="line">                    <span class="keyword">if</span> s[i - <span class="number">1</span>] == p[j - <span class="number">2</span>] <span class="keyword">or</span> p[j - <span class="number">2</span>] == <span class="string">'.'</span>:</span><br><span class="line">                        dp[i][j] |= dp[i<span class="number">-1</span>][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> s[i - <span class="number">1</span>] == p[j - <span class="number">1</span>] <span class="keyword">or</span> p[j - <span class="number">1</span>] == <span class="string">'.'</span>:</span><br><span class="line">                        dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> dp[len(s)][len(p)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 懒癌版</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s, p)</span>:</span></span><br><span class="line">        <span class="comment"># '$'字符规则代表匹配字符串的末尾，匹配返回一个Match 对象，否则返回None</span></span><br><span class="line">        <span class="keyword">return</span> re.match(p + <span class="string">'$'</span>, s) != <span class="literal">None</span></span><br></pre></td></tr></table></figure><h3 id="不同的二叉查找树-II"><a href="#不同的二叉查找树-II" class="headerlink" title="不同的二叉查找树 II"></a>不同的二叉查找树 II</h3><p><strong>描述：</strong>给出n，生成所有由1…n为节点组成的不同的二叉查找树</p><p><strong>样例</strong>：给出n = 3，生成所有5种不同形态的二叉查找树：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>         <span class="number">3</span>     <span class="number">3</span>       <span class="number">2</span>    <span class="number">1</span></span><br><span class="line"> \       /     /       / \    \</span><br><span class="line">  <span class="number">3</span>     <span class="number">2</span>     <span class="number">1</span>       <span class="number">1</span>   <span class="number">3</span>    <span class="number">2</span></span><br><span class="line"> /     /       \                \</span><br><span class="line"><span class="number">2</span>     <span class="number">1</span>         <span class="number">2</span>                <span class="number">3</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Definition of TreeNode:</span></span><br><span class="line"><span class="string">class TreeNode:</span></span><br><span class="line"><span class="string">    def __init__(self, val):</span></span><br><span class="line"><span class="string">        this.val = val</span></span><br><span class="line"><span class="string">        this.left, this.right = None, None</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @paramn n: An integer</span></span><br><span class="line">    <span class="comment"># @return: A list of root</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateTrees</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">return</span> self.dfs(<span class="number">1</span>, n)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, start, end)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> start &gt; end: <span class="keyword">return</span> [<span class="literal">None</span>]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> rootval <span class="keyword">in</span> range(start, end+<span class="number">1</span>):</span><br><span class="line">            LeftTree = self.dfs(start, rootval<span class="number">-1</span>)</span><br><span class="line">            RightTree = self.dfs(rootval+<span class="number">1</span>, end)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> LeftTree:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> RightTree:</span><br><span class="line">                    root = TreeNode(rootval)</span><br><span class="line">                    root.left = i</span><br><span class="line">                    root.right = j</span><br><span class="line">                    res.append(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="乘积最大子序列"><a href="#乘积最大子序列" class="headerlink" title="乘积最大子序列 +"></a>乘积最大子序列 +</h3><p><strong>描述</strong>：找出一个序列中乘积最大的连续子序列（至少包含一个数）</p><p><strong>样例</strong>：比如, 序列 <code>[2,3,-2,4]</code> 中乘积最大的子序列为 <code>[2,3]</code> ，其乘积为<code>6</code>。</p><p>思路：这道题和maximal subarray思路一样，不同的是对于加法加上负数会变小，加上正数会变大；而对于乘法，乘以正数有可能变大也有可能变小（原数是负数的情况下），乘以负数也有可能变大或者变小</p><p>所以需要两个变量：<br>min_p表示行进到当前subarray能得到的最小的积<br>max_p表示行进到当前subarray能得到的最大的积</p><p>对于某一个subarray来说，它最大的积，有可能来自之前的最大积乘以一个正数，或者之前的最小积乘以一个负数，或者nums[i]就是最大的<br>因此 $max_p = max(nums[i], max_p × nums[i], min_p × nums[i])$<br>最小积同理</p><p>最后用res变量跟踪一下全局最大</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param nums: An array of integers</span></span><br><span class="line"><span class="string">    @return: An integer</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProduct</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            </span><br><span class="line">        global_max = prev_max = prev_min = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums[<span class="number">1</span>:]:</span><br><span class="line">            <span class="keyword">if</span> num &gt; <span class="number">0</span>:</span><br><span class="line">                curt_max = max(num, prev_max * num)</span><br><span class="line">                curt_min = min(num, prev_min * num)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                curt_max = max(num, prev_min * num)</span><br><span class="line">                curt_min = min(num, prev_max * num)</span><br><span class="line">            </span><br><span class="line">            global_max = max(global_max, curt_max)</span><br><span class="line">            prev_max, prev_min = curt_max, curt_min</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> global_max</span><br></pre></td></tr></table></figure><h3 id="通配符匹配"><a href="#通配符匹配" class="headerlink" title="通配符匹配"></a>通配符匹配</h3><p><strong>描述</strong>：判断两个可能包含通配符“？”和“*”的字符串是否匹配。匹配规则如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'?'</span> 可以匹配任何单个字符。</span><br><span class="line"><span class="string">'*'</span> 可以匹配任意字符串（包括空字符串）。</span><br><span class="line">两个串完全匹配才算匹配成功。</span><br></pre></td></tr></table></figure><p>样例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">isMatch(<span class="string">"aa"</span>,<span class="string">"a"</span>) → false</span><br><span class="line">isMatch(<span class="string">"aa"</span>,<span class="string">"aa"</span>) → true</span><br><span class="line">isMatch(<span class="string">"aaa"</span>,<span class="string">"aa"</span>) → false</span><br><span class="line">isMatch(<span class="string">"aa"</span>, <span class="string">"*"</span>) → true</span><br><span class="line">isMatch(<span class="string">"aa"</span>, <span class="string">"a*"</span>) → true</span><br><span class="line">isMatch(<span class="string">"ab"</span>, <span class="string">"?*"</span>) → true</span><br><span class="line">isMatch(<span class="string">"aab"</span>, <span class="string">"c*a*b"</span>) → false</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param s: A string</span></span><br><span class="line"><span class="string">    @param p: A string includes "?" and "*"</span></span><br><span class="line"><span class="string">    @return: A boolean</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s, p)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        m = len(p)</span><br><span class="line">        f = [[<span class="literal">False</span>] * (m + <span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(n + <span class="number">1</span>)]</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">and</span> p.count(<span class="string">'*'</span>) == m:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, m + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> j &gt; <span class="number">0</span>:</span><br><span class="line">                    f[i][j] |= f[i<span class="number">-1</span>][j<span class="number">-1</span>] <span class="keyword">and</span> (s[i<span class="number">-1</span>] == p[j<span class="number">-1</span>] <span class="keyword">or</span> p[j - <span class="number">1</span>] <span class="keyword">in</span> [<span class="string">'?'</span>, <span class="string">'*'</span>])</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> j &gt; <span class="number">0</span>:</span><br><span class="line">                    f[i][j] |= f[i - <span class="number">1</span>][j] <span class="keyword">and</span> p[j - <span class="number">1</span>] == <span class="string">'*'</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> j &gt; <span class="number">0</span>:</span><br><span class="line">                    f[i][j] |= f[i][j - <span class="number">1</span>] <span class="keyword">and</span> p[j - <span class="number">1</span>] == <span class="string">'*'</span></span><br><span class="line">        <span class="keyword">return</span> f[n][m]</span><br></pre></td></tr></table></figure><h3 id="打劫房屋"><a href="#打劫房屋" class="headerlink" title="打劫房屋 ++"></a>打劫房屋 ++</h3><p><strong>描述</strong>：假设你是一个专业的窃贼，准备沿着一条街打劫房屋。每个房子都存放着特定金额的钱。你面临的唯一约束条件是：相邻的房子装着相互联系的防盗系统，且 <strong>当相邻的两个房子同一天被打劫时，该系统会自动报警</strong>。给定一个非负整数列表，表示每个房子中存放的钱， 算一算，如果今晚去打劫，你最多可以得到多少钱 <strong>在不触动报警装置的情况下</strong>。</p><p> <strong>样例</strong>：给定 <code>[3, 8, 4]</code>, 返回 <code>8</code>. </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param A: An array of non-negative integers</span></span><br><span class="line"><span class="string">    @return: The maximum amount of money you can rob tonight</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">houseRobber</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> A:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(A) &lt;= <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> max(A)</span><br><span class="line">            </span><br><span class="line">        f = [<span class="number">0</span>] * len(A)</span><br><span class="line">        f[<span class="number">0</span>], f[<span class="number">1</span>] = A[<span class="number">0</span>], max(A[<span class="number">0</span>], A[<span class="number">1</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(A)):</span><br><span class="line">            f[i] = max(f[i - <span class="number">1</span>], f[i - <span class="number">2</span>] + A[i])</span><br><span class="line">        <span class="keyword">return</span> f[len(A) - <span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 使用滚动数组版本</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param A: An array of non-negative integers</span></span><br><span class="line"><span class="string">    @return: The maximum amount of money you can rob tonight</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">houseRobber</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> A:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(A) &lt;= <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> max(A)</span><br><span class="line">            </span><br><span class="line">        f = [<span class="number">0</span>] * <span class="number">3</span></span><br><span class="line">        f[<span class="number">0</span>], f[<span class="number">1</span>] = A[<span class="number">0</span>], max(A[<span class="number">0</span>], A[<span class="number">1</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(A)):</span><br><span class="line">            f[i % <span class="number">3</span>] = max(f[(i - <span class="number">1</span>) % <span class="number">3</span>], f[(i - <span class="number">2</span>) % <span class="number">3</span>] + A[i])</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> f[(len(A) - <span class="number">1</span>) % <span class="number">3</span>]</span><br></pre></td></tr></table></figure><h3 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a>买卖股票的最佳时机</h3><p><strong>描述</strong>：假设你有一个数组，它的第i个元素是一支给定的股票在第i天的价格。设计一个算法来找到最大的利润。你最多可以完成 <code>k</code> 笔交易。你不可以同时参与多笔交易(你必须在再次购买前出售掉之前的股票)</p><p>样例：给定价格 = <code>[4,4,6,1,1,4,2,5]</code>, 且 k = <code>2</code>, 返回 <code>6</code>.（1买4卖，2买5卖）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param k: an integer</span></span><br><span class="line"><span class="string">    @param prices: an integer array</span></span><br><span class="line"><span class="string">    @return: an integer which is maximum profit</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, k, prices)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        size = len(prices)</span><br><span class="line">        <span class="keyword">if</span> k &gt;= size / <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> self.quickSolve(size, prices)</span><br><span class="line">        dp = [<span class="literal">None</span>] * (<span class="number">2</span> * k + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(size):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(min(<span class="number">2</span> * k, i + <span class="number">1</span>) , <span class="number">0</span> , <span class="number">-1</span>):</span><br><span class="line">                dp[j] = max(dp[j], dp[j - <span class="number">1</span>] + prices[i] * [<span class="number">1</span>, <span class="number">-1</span>][j % <span class="number">2</span>])</span><br><span class="line">        <span class="keyword">return</span> max(dp)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quickSolve</span><span class="params">(self, size, prices)</span>:</span></span><br><span class="line">        sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(size - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> prices[x + <span class="number">1</span>] &gt; prices[x]:</span><br><span class="line">                sum += prices[x + <span class="number">1</span>] - prices[x]</span><br><span class="line">        <span class="keyword">return</span> sum</span><br></pre></td></tr></table></figure><h3 id="解码方法"><a href="#解码方法" class="headerlink" title="解码方法+"></a>解码方法+</h3><p><strong>描述</strong>：有一个消息包含<code>A-Z</code>通过以下规则编码，现在给你一个加密过后的消息，问有几种解码的方式</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">'A' -&gt; 1</span><br><span class="line">'B' -&gt; 2</span><br><span class="line">...</span><br><span class="line">'Z' -&gt; 26</span><br></pre></td></tr></table></figure><p><strong>样例</strong>：给你的消息为<code>12</code>，有两种方式解码 AB(12) 或者 L(12). 所以返回 <code>2</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param &#123;string&#125; s a string,  encoded message</span></span><br><span class="line">    <span class="comment"># @return &#123;int&#125; an integer, the number of ways decoding</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numDecodings</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># Write your code here</span></span><br><span class="line">        <span class="keyword">if</span> s == <span class="string">""</span> <span class="keyword">or</span> s[<span class="number">0</span>] == <span class="string">'0'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        dp=[<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,len(s) + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="number">10</span> &lt;= int(s[i - <span class="number">2</span> : i]) &lt;=<span class="number">26</span> <span class="keyword">and</span> s[i - <span class="number">1</span>] != <span class="string">'0'</span>:</span><br><span class="line">                dp.append(dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>])</span><br><span class="line">            <span class="keyword">elif</span> int(s[i<span class="number">-2</span> : i]) == <span class="number">10</span> <span class="keyword">or</span> int(s[i - <span class="number">2</span> : i]) == <span class="number">20</span>:</span><br><span class="line">                dp.append(dp[i - <span class="number">2</span>])</span><br><span class="line">            <span class="keyword">elif</span> s[i<span class="number">-1</span>] != <span class="string">'0'</span>:</span><br><span class="line">                dp.append(dp[i<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[len(s)]</span><br></pre></td></tr></table></figure><h3 id="完美平方"><a href="#完美平方" class="headerlink" title="完美平方"></a>完美平方</h3><p><strong>描述</strong>：给一个正整数 n, 找到若干个完全平方数(比如1, 4, 9, … )使得他们的和等于 n。你需要让平方数的个数最少。</p><p><strong>样例</strong>：</p><p>给出 n = <code>12</code>, 返回 <code>3</code> 因为 <code>12 = 4 + 4 + 4</code>。<br>给出 n = <code>13</code>, 返回 <code>2</code> 因为 <code>13 = 4 + 9</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numSquares</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        dp = []</span><br><span class="line">        <span class="keyword">import</span> sys</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n+<span class="number">1</span>):</span><br><span class="line">            dp.append(sys.maxint)</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i * i &lt;= n:</span><br><span class="line">            dp[i*i] = <span class="number">1</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n+<span class="number">1</span>):</span><br><span class="line">            j = <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j * j &lt;= i:</span><br><span class="line">                dp[i] = min(dp[i], dp[i-j*j] + <span class="number">1</span>)</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;五问动态规划&quot;&gt;&lt;a href=&quot;#五问动态规划&quot; class=&quot;headerlink&quot; title=&quot;五问动态规划&quot;&gt;&lt;/a&gt;五问动态规划&lt;/h2&gt;&lt;p&gt;问：动态规划是什么？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;答：&lt;/strong&gt;动态规划是一种通过“大而化小”的思
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>重点掌握</title>
    <link href="http://yoursite.com/2018/09/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%87%8D%E7%82%B9%E6%8E%8C%E6%8F%A1/"/>
    <id>http://yoursite.com/2018/09/21/数据结构与算法/重点掌握/</id>
    <published>2018-09-21T09:06:13.000Z</published>
    <updated>2019-12-28T09:07:46.445Z</updated>
    
    <content type="html"><![CDATA[<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#节点类</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,data = <span class="number">-1</span>)</span>:</span></span><br><span class="line">        self.data = data</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#树类</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.root = Node()</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self,data)</span>:</span></span><br><span class="line">        <span class="comment"># 为树加入节点</span></span><br><span class="line">        node  = Node(data)</span><br><span class="line">        <span class="keyword">if</span> self.root.data == <span class="number">-1</span>:        <span class="comment">#如果树为空，就对根节点赋值</span></span><br><span class="line">            self.root = node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            myQueue = []</span><br><span class="line">            treeNode = self.root</span><br><span class="line">            myQueue.append(treeNode)</span><br><span class="line">            <span class="keyword">while</span> myQueue:              <span class="comment">#对已有的节点进行层次遍历</span></span><br><span class="line">                treeNode = myQueue.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> treeNode.left:</span><br><span class="line">                    treeNode.left = node</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">elif</span> <span class="keyword">not</span> treeNode.right:</span><br><span class="line">                    treeNode.right = node</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    myQueue.append(treeNode.left)</span><br><span class="line">                    myQueue.append(treeNode.right)</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pre_order_recursion</span><span class="params">(self,root)</span>:</span>     <span class="comment">#递归实现前序遍历</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">print</span> root.data,</span><br><span class="line">        self.pre_order_recursion(root.left)</span><br><span class="line">        self.pre_order_recursion(root.right)</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pre_order_stack</span><span class="params">(self,root)</span>:</span>         <span class="comment">#堆栈实现前序遍历（非递归）</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        myStack = []</span><br><span class="line">        node = root</span><br><span class="line">        <span class="keyword">while</span> myStack <span class="keyword">or</span> node:</span><br><span class="line">            <span class="keyword">while</span> node:       <span class="comment">#从根节点开始，一直寻找他的左子树</span></span><br><span class="line">                <span class="keyword">print</span> node.data,     <span class="comment"># 先序，进栈前就要读取了</span></span><br><span class="line">                myStack.append(node) <span class="comment"># 先存进栈，以后还需要它的右节点</span></span><br><span class="line">                node = node.left</span><br><span class="line">            node = myStack.pop()    <span class="comment">#while结束表示当前节点node为空，即前一个节点没有左子树了</span></span><br><span class="line">            node = node.right       <span class="comment">#开始查看它的右子树</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">in_order_recursion</span><span class="params">(self,root)</span>:</span>      <span class="comment">#递归实现中序遍历</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.in_order_recursion(root.left)</span><br><span class="line">        <span class="keyword">print</span> root.data,</span><br><span class="line">        self.in_order_recursion(root.right)</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">in_order_stack</span><span class="params">(self,root)</span>:</span>        <span class="comment">#堆栈实现中序遍历（非递归）</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        myStack = []</span><br><span class="line">        node = root</span><br><span class="line">        <span class="keyword">while</span> myStack <span class="keyword">or</span> node:     <span class="comment">#从根节点开始，一直寻找它的左子树</span></span><br><span class="line">            <span class="keyword">while</span> node:</span><br><span class="line">                myStack.append(node) </span><br><span class="line">                node = node.left</span><br><span class="line">            node = myStack.pop() <span class="comment"># 中序，弹出来后才读取</span></span><br><span class="line">            <span class="keyword">print</span> node.data,</span><br><span class="line">            node = node.right</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post_order_recursion</span><span class="params">(self,root)</span>:</span>     <span class="comment">#递归实现后序遍历</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.post_order_recursion(root.left)</span><br><span class="line">        self.post_order_recursion(root.right)</span><br><span class="line">        <span class="keyword">print</span> root.data,</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post_order_stack</span><span class="params">(self, root)</span>:</span>  <span class="comment"># 堆栈实现后序遍历（非递归）</span></span><br><span class="line">        <span class="comment"># 先遍历根节点，再遍历右子树，最后是左子树，这样就可以转化为和先序遍历一个类型了，最后只把遍历结果逆序输出就OK了。</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        myStack1 = []</span><br><span class="line">        myStack2 = []</span><br><span class="line">        node = root</span><br><span class="line">        <span class="keyword">while</span> myStack1 <span class="keyword">or</span> node:</span><br><span class="line">            <span class="keyword">while</span> node:</span><br><span class="line">                myStack2.append(node)</span><br><span class="line">                myStack1.append(node)</span><br><span class="line">                node = node.right</span><br><span class="line">            node = myStack1.pop()</span><br><span class="line">            node = node.left</span><br><span class="line">        <span class="keyword">while</span> myStack2:</span><br><span class="line">            <span class="keyword">print</span> myStack2.pop().data,</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">level_order_queue</span><span class="params">(self,root)</span>:</span>       <span class="comment">#队列实现层次遍历（非递归）</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root :</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        myQueue = []</span><br><span class="line">        node = root</span><br><span class="line">        myQueue.append(node)</span><br><span class="line">        <span class="keyword">while</span> myQueue:</span><br><span class="line">            node = myQueue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">print</span> node.data,</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                myQueue.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                myQueue.append(node.right)</span><br><span class="line">                </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment">#主函数</span></span><br><span class="line">    datas = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line">    tree = Tree()          <span class="comment">#新建一个树对象</span></span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> datas:</span><br><span class="line">        tree.add(data)      <span class="comment">#逐个加入树的节点</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">print</span> <span class="string">'递归实现前序遍历：'</span></span><br><span class="line">    tree.pre_order_recursion(tree.root)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">print</span> <span class="string">'\n堆栈实现前序遍历'</span></span><br><span class="line">    tree.pre_order_stack(tree.root)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">print</span> <span class="string">"\n\n递归实现中序遍历："</span></span><br><span class="line">    tree.in_order_recursion(tree.root)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">print</span> <span class="string">"\n堆栈实现中序遍历："</span></span><br><span class="line">    tree.in_order_stack(tree.root)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">print</span> <span class="string">'\n\n递归实现后序遍历：'</span></span><br><span class="line">    tree.post_order_recursion(tree.root)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">print</span> <span class="string">'\n堆栈实现后序遍历：'</span></span><br><span class="line">    tree.post_order_stack(tree.root)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">print</span> <span class="string">'\n\n队列实现层次遍历：'</span></span><br><span class="line">    tree.level_order_queue(tree.root)！</span><br></pre></td></tr></table></figure><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  二分查找</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">BinarySearch</span><span class="params">(array,t)</span>:</span></span><br><span class="line">    low = <span class="number">0</span></span><br><span class="line">    height = len(array)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> low &lt; height:</span><br><span class="line">        mid = (low+height)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> array[mid] &lt; t:</span><br><span class="line">            low = mid + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> array[mid] &gt; t:</span><br><span class="line">            height = mid - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> array[mid]</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">print</span> BinarySearch([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">34</span>,<span class="number">56</span>,<span class="number">57</span>,<span class="number">78</span>,<span class="number">87</span>],<span class="number">57</span>)</span><br></pre></td></tr></table></figure><h3 id="广度优先与深度优先"><a href="#广度优先与深度优先" class="headerlink" title="广度优先与深度优先"></a>广度优先与深度优先</h3><p><strong>下面的代码强调一下: dfs和bfs区别（重点）</strong></p><ol><li>pop()和pop(0)</li><li>order加入w的时机</li><li>判断w的条件</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">深度优先遍历： 是一种用于遍历树或者图的算法。沿着树的深度遍历树的节点，尽可能深地搜索树的分支。当节点v的所在边都被搜索过了。搜索将回溯到节点v的那条边的起始节点。直到已发现从源节点可达的所有节点为止。如果还存在未发现的节点，则选择其中一个作为源节点并重复上述过程，整个进程反复进行直到所有节点都被访问为止.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">广度优先遍历：从根节点开始，沿着树的宽度遍历树的节点，如果所有节点都被访问，则算法终止</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, nodes, sides)</span>:</span></span><br><span class="line">        <span class="comment"># nodes表示用户输入的点，int型，sides表示用户输入的边，是一个二元组(u, v)</span></span><br><span class="line">        <span class="comment"># self.sequence是字典，key是点，value是与key相连的边</span></span><br><span class="line">        self.sequence = &#123;&#125;</span><br><span class="line">        <span class="comment"># self.side是临时变量，主要用于保存与 指定点v 相连接的点</span></span><br><span class="line">        self.side = []</span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> nodes:</span><br><span class="line">            <span class="keyword">for</span> side <span class="keyword">in</span> sides:</span><br><span class="line">                u, v = side</span><br><span class="line">                <span class="keyword">if</span> node == u:</span><br><span class="line">                    self.side.append(v)</span><br><span class="line">                <span class="keyword">elif</span> node == v:</span><br><span class="line">                    self.side.append(u)</span><br><span class="line">            <span class="comment"># 第二层主要是遍历属于这个点的所有边，然后将点和边组成字典</span></span><br><span class="line">            self.sequence[node] = self.side</span><br><span class="line">            self.side = []</span><br><span class="line">        <span class="comment"># print self.sequence</span></span><br><span class="line">        <span class="comment"># &#123;1: [2, 3], 2: [1, 4, 5], 3: [1, 6, 7], 4: [2, 8], 5: [2, 8], 6: [3, 7], 7: [3, 6], 8: [4, 5]&#125;</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, node0)</span>:</span></span><br><span class="line">        <span class="comment"># order里面存放的是具体的访问路径，已经遍历的了</span></span><br><span class="line">        queue, order = [], []</span><br><span class="line">        queue.append(node0)</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            v = queue.pop()  <span class="comment"># 取出最后一个，为上一个刚加入节点的连接节点</span></span><br><span class="line">            order.append(v) <span class="comment"># 深度优先先加入，注意这个order的加入顺序</span></span><br><span class="line">            <span class="keyword">for</span> w <span class="keyword">in</span> self.sequence[v]: <span class="comment"># 两边</span></span><br><span class="line">                <span class="comment"># 不在order表示没被遍历，</span></span><br><span class="line">                <span class="keyword">if</span> w <span class="keyword">not</span> <span class="keyword">in</span> order <span class="keyword">and</span> w <span class="keyword">not</span> <span class="keyword">in</span> queue:</span><br><span class="line">                    queue.append(w)</span><br><span class="line">        <span class="keyword">return</span> order</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># bfs同理</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(self, node0)</span>:</span></span><br><span class="line">        queue, order = [], []</span><br><span class="line">        queue.append(node0)</span><br><span class="line">        order.append(node0)</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            v = queue.pop(<span class="number">0</span>)  <span class="comment"># 层次遍历按迅速取出</span></span><br><span class="line">            <span class="keyword">for</span> w <span class="keyword">in</span> self.sequence[v]:</span><br><span class="line">                <span class="comment"># if w not in order and w not in queue:</span></span><br><span class="line">                <span class="keyword">if</span> w <span class="keyword">not</span> <span class="keyword">in</span> order</span><br><span class="line">                    order.append(w) <span class="comment"># 没被遍历就直接将两边加入order</span></span><br><span class="line">                    queue.append(w)</span><br><span class="line">        <span class="keyword">return</span> order</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">        nodes = [i+<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">8</span>)]</span><br><span class="line">        sides = [(<span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line">                 (<span class="number">1</span>, <span class="number">3</span>),</span><br><span class="line">                 (<span class="number">2</span>, <span class="number">4</span>),</span><br><span class="line">                 (<span class="number">2</span>, <span class="number">5</span>),</span><br><span class="line">                 (<span class="number">4</span>, <span class="number">8</span>),</span><br><span class="line">                 (<span class="number">5</span>, <span class="number">8</span>),</span><br><span class="line">                 (<span class="number">3</span>, <span class="number">6</span>),</span><br><span class="line">                 (<span class="number">3</span>, <span class="number">7</span>),</span><br><span class="line">                 (<span class="number">6</span>, <span class="number">7</span>)]</span><br><span class="line"> </span><br><span class="line">        G = Graph(nodes, sides)</span><br><span class="line">        <span class="keyword">print</span> G.dfs(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">print</span> G.bfs(<span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;二叉树&quot;&gt;&lt;a href=&quot;#二叉树&quot; class=&quot;headerlink&quot; title=&quot;二叉树&quot;&gt;&lt;/a&gt;二叉树&lt;/h3&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>字符串解题</title>
    <link href="http://yoursite.com/2018/09/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E9%A2%98/"/>
    <id>http://yoursite.com/2018/09/19/数据结构与算法/字符串解题/</id>
    <published>2018-09-19T09:06:13.000Z</published>
    <updated>2019-12-28T09:05:19.783Z</updated>
    
    <content type="html"><![CDATA[<p>字符串相关题_python版</p><h3 id="最长无重复字符子串长度"><a href="#最长无重复字符子串长度" class="headerlink" title="最长无重复字符子串长度"></a>最长无重复字符子串长度</h3><p><strong>题目</strong>：给定一个字符串，请找出其中无重复字符的最长子字符串。例如，在”abcabcbb”中，其无重复字符的最长子字符串是”abc”，其长度为 3。</p><p><strong>思路</strong>：遍历字符串中的每一个元素。借助一个辅助键值对来存储某个元素最后一次出现的下标。用一个整形变量存储当前无重复字符的子串开始的下标。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 分析 a b c d e f g d 此时从最近重复的前一个字符d的后一位开始记，即e标记为start。此时继续取下一个数， 例如a，它的前一个字符下标为d[s[i]]=0，若d[s[i]]&lt;start，则不需要更新start,否则更新start。新的无重复子串变为e f g d a</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param: s: a string</span></span><br><span class="line"><span class="string">    @return: an integer</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> s <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> len(s) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        d = &#123;&#125; <span class="comment"># 存储某个元素最后一次出现的下标</span></span><br><span class="line">        tmp = <span class="number">0</span> <span class="comment"># 存储每次循环中最长的子串长度</span></span><br><span class="line">        start = <span class="number">0</span>  <span class="comment"># 记录最近重复字符所在的位置+1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)): <span class="comment"># 下标</span></span><br><span class="line">            <span class="comment"># 判断当前字符是否在字典中和当前字符的下标是否大于等于最近重复字符的所在位置</span></span><br><span class="line">            <span class="keyword">if</span> s[i] <span class="keyword">in</span> d <span class="keyword">and</span> d[s[i]] &gt;= start: <span class="comment"># 这里的d[s[i]]为前一个重复的下标</span></span><br><span class="line">                start = d[s[i]] + <span class="number">1</span></span><br><span class="line">            tmp = i - start + <span class="number">1</span></span><br><span class="line">            d[s[i]] = i</span><br><span class="line">            res = max(res, tmp)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="最长回文字符串"><a href="#最长回文字符串" class="headerlink" title="最长回文字符串"></a>最长回文字符串</h3><p>思路一：中心扩展法。根据回文的特性，显然所有的回文串都是对称的。<strong>长度为奇数回文串以最中间字符的位置为对称轴左右对称，而长度为偶数的回文串的对称轴在中间两个字符之间的空隙</strong>。可否利用这种对称性来提高算法效率呢？答案是肯定的。我们知道整个字符串中的所有字符，以及字符间的空隙，都可能是某个回文子串的对称轴位置。<strong>可以遍历这些位置，在每个位置上同时向左和向右扩展，直到左右两边的字符不同，或者达到边界</strong>。对于一个长度为n的字符串，这样的位置一共有n+n-1=2n-1个 ，时间复杂度O(n^2)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        str_length = len(s)</span><br><span class="line">        max_length = <span class="number">0</span>   <span class="comment"># 记录最大字符串长度,不是对称长度</span></span><br><span class="line">        start = <span class="number">0</span>  <span class="comment"># 记录位置</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(str_length): <span class="comment"># 当前下标位置</span></span><br><span class="line">            <span class="comment"># 对称位置在对称轴间隙，偶数</span></span><br><span class="line">            <span class="keyword">if</span> i - max_length &gt;= <span class="number">1</span> <span class="keyword">and</span> s[i-max_length<span class="number">-1</span>: i+<span class="number">1</span>] == s[i-max_length<span class="number">-1</span>: i+<span class="number">1</span>][::<span class="number">-1</span>]:</span><br><span class="line">                <span class="comment"># 记录当前开始位置</span></span><br><span class="line">                start = i - max_length - <span class="number">1</span></span><br><span class="line">                max_length += <span class="number">2</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 对称位置在对称字符，奇数</span></span><br><span class="line">            <span class="keyword">if</span> i - max_length &gt;= <span class="number">0</span> <span class="keyword">and</span> s[i-max_length: i+<span class="number">1</span>] == s[i-max_length: i+<span class="number">1</span>][::<span class="number">-1</span>]:</span><br><span class="line">                start = i - max_length</span><br><span class="line">                max_length += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 返回最长回文子串</span></span><br><span class="line">        <span class="keyword">return</span> s[start: start + max_length]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = <span class="string">"babad"</span></span><br><span class="line">    <span class="comment"># s = "cbbd"</span></span><br><span class="line">    sl = Solution()</span><br><span class="line">    print(sl.longestPalindrome(s))</span><br></pre></td></tr></table></figure><p>思路二：马拉车算法</p><p><a href="https://segmentfault.com/a/1190000003914228#articleHeader0" target="_blank" rel="noopener">看这篇</a></p><h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><p><a href="http://www.ruanyifeng.com/blog/2013/05/Knuth–Morris–Pratt_algorithm.html" target="_blank" rel="noopener">过程描述看这篇</a></p><p>其实就是,<strong>对模式串p进行预处理,得到前后缀的部分匹配表,使得我们可以借助已知信息,算出可以右移多少位.即 kmp = 朴素匹配 + 移动多位</strong>.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#KMP</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kmp_match</span><span class="params">(self, s, p)</span>:</span>  </span><br><span class="line">        m = len(s)</span><br><span class="line">        n = len(p)  </span><br><span class="line">        cur = <span class="number">0</span>  <span class="comment"># 起始指针cur，累积移动数  </span></span><br><span class="line">        table = self.partial_table(p)  </span><br><span class="line">        <span class="keyword">while</span> cur &lt;= m-n: <span class="comment"># 长度不够就终止  </span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n):  <span class="comment"># 一次p从头开始匹配的长度 </span></span><br><span class="line">                <span class="keyword">if</span> s[i+cur] != p[i]:  </span><br><span class="line">                    <span class="comment"># 移动位数 = 已匹配的字符数 - 对应的部分匹配值</span></span><br><span class="line">                    <span class="comment"># 有了部分匹配表,我们不只是单纯的1位1位往右移,可以一次移动多位  </span></span><br><span class="line">                    cur += max(i - table[i<span class="number">-1</span>], <span class="number">1</span>) </span><br><span class="line">                    <span class="keyword">break</span>  </span><br><span class="line">            <span class="keyword">else</span>: <span class="comment"># 执行了break就不会执行这句，相当于for循环里所有都满足 s[i+cur] == p[i]</span></span><br><span class="line">                <span class="keyword">return</span> cur <span class="comment"># 返回匹配开始的位置</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>  <span class="comment"># 匹配失败</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#部分匹配表  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partial_table</span><span class="params">(self, p)</span>:</span>  </span><br><span class="line">        <span class="string">'''''partial_table("ABCDABD") -&gt; [0, 0, 0, 0, 1, 2, 0]'''</span>  </span><br><span class="line">        prefix = set()  </span><br><span class="line">        table = [<span class="number">0</span>]  </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(p)):  <span class="comment"># 从1开始进行前后缀比较  </span></span><br><span class="line">            prefix.add(p[:i])  <span class="comment"># 前缀每次累加就行</span></span><br><span class="line">            postfix = set()</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, i+<span class="number">1</span>):  <span class="comment"># i+1 因为i需要包括</span></span><br><span class="line">                postfix.add(p[j:i+<span class="number">1</span>]) </span><br><span class="line">            <span class="comment"># print(prefix, postfix)</span></span><br><span class="line">            <span class="comment"># print(prefix&amp;postfix, len(prefix&amp;postfix))</span></span><br><span class="line">            <span class="comment"># table.append(len((sorted((prefix&amp;postfix),key = len)or &#123;''&#125;).pop()))</span></span><br><span class="line">            <span class="keyword">if</span> prefix&amp;postfix:</span><br><span class="line">                table.append(max(map(len,prefix&amp;postfix)))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                table.append(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> table</span><br></pre></td></tr></table></figure><h3 id="字符串去重"><a href="#字符串去重" class="headerlink" title="字符串去重"></a>字符串去重</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string = <span class="string">'abc123456ab2s'</span>r = <span class="string">''</span>.join(x <span class="keyword">for</span> i, x <span class="keyword">in</span> enumerate(string) <span class="keyword">if</span> string.index(x) == i)</span><br></pre></td></tr></table></figure><h3 id="统计一个字符串中英文字母、空格、数字的个数"><a href="#统计一个字符串中英文字母、空格、数字的个数" class="headerlink" title="统计一个字符串中英文字母、空格、数字的个数"></a>统计一个字符串中英文字母、空格、数字的个数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line">s = raw_input(<span class="string">'请输入一个字符串:\n'</span>)</span><br><span class="line">letters = <span class="number">0</span></span><br><span class="line">space = <span class="number">0</span></span><br><span class="line">digit = <span class="number">0</span></span><br><span class="line">others = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">    <span class="keyword">if</span> c.isalpha():</span><br><span class="line">        letters += <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> c.isspace():</span><br><span class="line">        space += <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> c.isdigit():</span><br><span class="line">        digit += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        others += <span class="number">1</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'char = %d,space = %d,digit = %d,others = %d'</span> % (letters,space,digit,others)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;字符串相关题_python版&lt;/p&gt;
&lt;h3 id=&quot;最长无重复字符子串长度&quot;&gt;&lt;a href=&quot;#最长无重复字符子串长度&quot; class=&quot;headerlink&quot; title=&quot;最长无重复字符子串长度&quot;&gt;&lt;/a&gt;最长无重复字符子串长度&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;题目&lt;/
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数组解题</title>
    <link href="http://yoursite.com/2018/09/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84%E8%A7%A3%E9%A2%98/"/>
    <id>http://yoursite.com/2018/09/16/数据结构与算法/数组解题/</id>
    <published>2018-09-16T09:06:13.000Z</published>
    <updated>2019-12-28T09:02:49.369Z</updated>
    
    <content type="html"><![CDATA[<p> 数组相关题_python版 </p><h3 id="寻找某个值的区间（leetcode-34-Search-for-a-Range）"><a href="#寻找某个值的区间（leetcode-34-Search-for-a-Range）" class="headerlink" title="寻找某个值的区间（leetcode 34 Search for a Range）"></a>寻找某个值的区间（leetcode 34 Search for a Range）</h3><p>题目：这题要求在一个排好序可能有重复元素的数组里面找到包含某个值的区间范围。<strong>要求使用O(log n)的时间</strong>，所以我们采用两次二分查找。</p><blockquote><p>For Example：<br>Given [5, 7, 7, 8, 8, 10] and target value 8,<br>return [3, 4].</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param A, a list of integers</span></span><br><span class="line">    <span class="comment"># @param target, an integer to be searched</span></span><br><span class="line">    <span class="comment"># @return a list of length 2, [index1, index2]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchRange</span><span class="params">(self, A, target)</span>:</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = len(A) - <span class="number">1</span>      </span><br><span class="line">        result = [<span class="number">-1</span>, <span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = (left + right) / <span class="number">2</span>           </span><br><span class="line">            <span class="keyword">if</span> A[mid] &gt; target:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> A[mid] &lt; target:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: <span class="comment"># 找到时</span></span><br><span class="line">                result[<span class="number">0</span>] = mid</span><br><span class="line">                result[<span class="number">1</span>] = mid</span><br><span class="line">                </span><br><span class="line">                i = mid - <span class="number">1</span> <span class="comment"># 向前找</span></span><br><span class="line">                <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> A[i] == target:</span><br><span class="line">                    result[<span class="number">0</span>] = i</span><br><span class="line">                    i -= <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">                i = mid + <span class="number">1</span> <span class="comment"># 向后找</span></span><br><span class="line">                <span class="keyword">while</span> i &lt; len(A) <span class="keyword">and</span> A[i] == target:</span><br><span class="line">                    result[<span class="number">1</span>] = i</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h3 id="第K个数的问题"><a href="#第K个数的问题" class="headerlink" title="第K个数的问题"></a>第K个数的问题</h3><p>题目：这题是一道很好的面试题目，首先题目短小，很快就能说清题意而且有很多种解法。从简单到复杂的解法都有，梯度均匀。解决它不需要预先知道特殊领域知识。</p><p>这题有很多思路：</p><ol><li>按从大到小全排序，然后取第k个元素，时间复杂度O(nlogn)，空间复杂度O(1)</li><li>利用堆进行部分排序。维护一个大根堆，将数组元素全部压入堆，然后弹出k次，第k个就是答案。时间复杂度O(klogn)O(klogn)，空间复杂度O(n)O(n)</li><li>选择排序，第k次选择后即可得到第k大的数，时间复杂度O(nk)，空间复杂度O(1)</li></ol><p>以上三种方法时间复杂度太高。下面介绍两种<strong>更好的方法</strong>：</p><blockquote><p>维持K大小的堆排序（优先队列）</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">用容量为K的最大堆来存储最小的K个数。最大堆的堆顶元素就是最小K个数中的最大的一个。每次扫描一个数据X，如果X比堆顶元素Y大，则不需要改变原来的堆。如果X比堆顶元素小，那么用X替换堆顶元素Y，在替换之后，X可能破坏了最大堆的结构，需要调整堆来维持堆的性质。用优先队列思想也一样，只不过k大小的队列每次移动的元素量较大，堆会好一些。</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># 使用了heapq的内置数据结构，用了一个trick 因为默认是创建小顶堆，所以在添加元素的时候加个 负号就变成大顶堆了。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetLeastNumbers_Solution</span><span class="params">(self, tinput, k)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> k &gt; len(tinput) <span class="keyword">or</span> k == <span class="number">0</span>: <span class="keyword">return</span> []</span><br><span class="line">        heap = []</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> tinput:</span><br><span class="line">            <span class="keyword">if</span> len(heap) &lt; k:</span><br><span class="line">                heapq.heappush(heap, -num)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> -num &gt; heap[<span class="number">0</span>]:</span><br><span class="line">                    heapq.heapreplace(heap, -num)</span><br><span class="line">        <span class="keyword">return</span> sorted(list(map(<span class="keyword">lambda</span> x: x*<span class="number">-1</span>, heap)))</span><br></pre></td></tr></table></figure><blockquote><p> 快速排序，时间复杂度近似O（n） </p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">利用快速排序的思想，从数组S中随机找出一个元素X，把数组分为两部分Sa和Sb。Sa中的元素大于等于X，Sb中元素小于X。这时有两种情况：</span></span><br><span class="line"><span class="string">1. Sa中元素的个数小于k，则Sb中的第k-|Sa|个元素即为第k大数；</span></span><br><span class="line"><span class="string">2. Sa中元素的个数大于等于k，则返回Sa中的第k大数。时间复杂度近似为O(n)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">qselect</span><span class="params">(A,k)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(A)&lt;k:<span class="keyword">return</span> A</span><br><span class="line">    pivot = A[<span class="number">-1</span>]</span><br><span class="line">    right = [pivot] + [x <span class="keyword">for</span> x <span class="keyword">in</span> A[:<span class="number">-1</span>] <span class="keyword">if</span> x&gt;=pivot]</span><br><span class="line">    rlen = len(right)</span><br><span class="line">    <span class="keyword">if</span> rlen==k:</span><br><span class="line">        <span class="keyword">return</span> right</span><br><span class="line">    <span class="keyword">if</span> rlen&gt;k:</span><br><span class="line">        <span class="keyword">return</span> qselect(right, k)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        left = [x <span class="keyword">for</span> x <span class="keyword">in</span> A[:<span class="number">-1</span>] <span class="keyword">if</span> x&lt;pivot]</span><br><span class="line">        <span class="keyword">return</span> qselect(left, k-rlen) + right</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">    <span class="keyword">print</span> qselect([<span class="number">11</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">9</span>], i)</span><br></pre></td></tr></table></figure><h3 id="求根算法（-LeetCode-69）"><a href="#求根算法（-LeetCode-69）" class="headerlink" title="求根算法（ LeetCode 69）"></a>求根算法（ LeetCode 69）</h3><p>题目：计算并返回 x 的平方根，其中 x 是非负整数。 由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p><p>思路一：直接从1到x/2之间遍历，判断是否是平方根的条件是，i*i小于等于x并且小于等于x并且(i+1)*(i+1)大于x，则返回i。超时 。</p><p>思路二：二分查找法。初始化i=0，j=x，mid=0。进入循环，找到中间值mid = (i + j) / 2，如果mid&gt;x / mid，表示mid不是平方根，且数值过大，则j=mid。如果mid小于等于x / mid，则判断(mid + 1) &gt; x / (mid + 1)，表示mid*mid小于x，并且mid再加1后的平方就会比x大，这表示mid就是那个平方根，返回mid。否则表示mid过小，i=mid。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type x: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> x==<span class="number">0</span> <span class="keyword">or</span> x==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">        i=<span class="number">0</span></span><br><span class="line">        j=x</span><br><span class="line">        mid=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            mid=(i+j)/<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> mid&gt;x/mid:</span><br><span class="line">                j=mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> (mid+<span class="number">1</span>)&gt;x/(mid+<span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">return</span> mid</span><br><span class="line">                i=mid</span><br></pre></td></tr></table></figure><h3 id="数组中后面的数减前面的数的差的最大值"><a href="#数组中后面的数减前面的数的差的最大值" class="headerlink" title="数组中后面的数减前面的数的差的最大值"></a>数组中后面的数减前面的数的差的最大值</h3><p>题目：如何求数组中数对差最大。数对差是指一个数组中某两个元素a和b（并且a排在b的前面），a减去b所得到的差值。</p><p>思路一：遍历存储最大值</p><p>思路二：首先求出数组中任意一对相邻的数据之间的差值，得到一个新的数组。如果某两个数据之间的数对差最大，也就是说这两个数据之间的差值最大。假设这两个数据的位置是i和j，那么这两个位置之间的数据是a[i]，a[i+1]，a[i+2]……，a[j-1]，a[j]。那么a[i]-a[j]=(a[i]-a[i+1])+(a[i+1]-a[i+2])+……(a[j-1]-a[j])，括号中的数据是相邻数据的差值，都已经在前面求出来了。<strong>然后这个问题就转化为了求数组中连续的子数组和最大的问题</strong>，这个问题可以通过动态规划问题求出来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Max</span><span class="params">(firstNum,secondNum)</span>:</span></span><br><span class="line"><span class="keyword">if</span> firstNum&gt;=secondNum:</span><br><span class="line"><span class="keyword">return</span> firstNum</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">return</span> secondNum</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Count</span><span class="params">(array)</span>:</span></span><br><span class="line">gapArray=[]</span><br><span class="line">length=len(array)</span><br><span class="line"><span class="comment">#遍历一遍记录相邻两个之间的gap</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(length<span class="number">-1</span>):</span><br><span class="line">gap=array[i]-array[i+<span class="number">1</span>]</span><br><span class="line">gapArray.append(gap)</span><br><span class="line"><span class="comment">#转化为子集合最大和问题</span></span><br><span class="line">max=-((<span class="number">1</span>&lt;&lt;<span class="number">32</span>)<span class="number">-1</span>)</span><br><span class="line">sum=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(gapArray)):</span><br><span class="line">sum+=gapArray[i]</span><br><span class="line">max=Max(max,sum)</span><br><span class="line"><span class="keyword">if</span> sum&lt;<span class="number">0</span>:</span><br><span class="line">sum=<span class="number">0</span></span><br><span class="line"><span class="keyword">return</span> max</span><br><span class="line"> </span><br><span class="line">array=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">20</span>):</span><br><span class="line">array.append(random.randint(<span class="number">0</span>,<span class="number">50</span>))</span><br><span class="line"><span class="keyword">print</span> array</span><br><span class="line"><span class="keyword">print</span> <span class="string">"max gap:"</span>+str(Count(array))</span><br></pre></td></tr></table></figure><h3 id="合并多个有序数组"><a href="#合并多个有序数组" class="headerlink" title="合并多个有序数组"></a>合并多个有序数组</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#采用归并排序算法</span></span><br><span class="line"><span class="comment">#拆解到最后，实际变成两个数组进行排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MergeSort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="comment">#请牢记传入的参数是多维数组</span></span><br><span class="line">    <span class="comment">#此处是递归出口</span></span><br><span class="line">    <span class="keyword">if</span> len(nums) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    mid = len(nums) // <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#记住此处得到的也是多维数组</span></span><br><span class="line">    Left = MergeSort(nums[:mid])</span><br><span class="line">    Right = MergeSort(nums[mid:])</span><br><span class="line"></span><br><span class="line">    <span class="comment">#print(Left[0], Right[0])</span></span><br><span class="line">    <span class="comment">#要传入的参数是数组中第一个索引处的值</span></span><br><span class="line">    <span class="keyword">return</span> Sort_list(Left[<span class="number">0</span>], Right[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Sort_list</span><span class="params">(Left, Right)</span>:</span></span><br><span class="line">    <span class="comment">#存储排序后的值</span></span><br><span class="line">    res = []</span><br><span class="line">    a = <span class="number">0</span></span><br><span class="line">    b = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> a &lt; len(Left) <span class="keyword">and</span> b &lt; len(Right):</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> Left[a] &lt; Right[b]:</span><br><span class="line">            res.append(Left[a])</span><br><span class="line">            a += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res.append(Right[b])</span><br><span class="line">            b += <span class="number">1</span></span><br><span class="line">    res = res + Left[a:] + Right[b:]</span><br><span class="line">    <span class="comment"># 转为二维数组</span></span><br><span class="line">    res = [res]</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="两个有序数组求差集"><a href="#两个有序数组求差集" class="headerlink" title="两个有序数组求差集"></a>两个有序数组求差集</h3><p>思路一：依次取出较小数组的元素，然后再另外一个数组上进行二分查找</p><p>思路二：用齐头并进的两个下标</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intersect</span><span class="params">(self, nums1, nums2)</span>:</span></span><br><span class="line">        nums3 = []</span><br><span class="line">        nums1.sort()</span><br><span class="line">        nums2.sort()</span><br><span class="line">        m = len(nums1)</span><br><span class="line">        n = len(nums2)</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;m <span class="keyword">and</span> j&lt;n:</span><br><span class="line">            <span class="keyword">if</span> nums1[i] == nums2[j]:</span><br><span class="line">                nums3.append(nums1[i])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums1[i] &gt; nums2[j]:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> nums3</span><br></pre></td></tr></table></figure><h3 id="两个集合如何求并集，交集；"><a href="#两个集合如何求并集，交集；" class="headerlink" title="两个集合如何求并集，交集；"></a>两个集合如何求并集，交集；</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">python集合支持一系列标准操作，包括并集、交集、差集和对称差集，例如：  </span><br><span class="line"></span><br><span class="line">a = t | s          <span class="comment"># t 和 s的并集  </span></span><br><span class="line">  </span><br><span class="line">b = t &amp; s          <span class="comment"># t 和 s的交集  </span></span><br><span class="line">  </span><br><span class="line">c = t – s          <span class="comment"># 求差集（项在t中，但不在s中）</span></span><br></pre></td></tr></table></figure><h3 id="给定一个数组求中位数"><a href="#给定一个数组求中位数" class="headerlink" title="给定一个数组求中位数"></a>给定一个数组求中位数</h3><p>(中位数，就是数组排序后处于数组最中间的那个元素)</p><p>思路：和TOP k问题一样，这里就不写了。（先排序再取中位数不优）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; 数组相关题_python版 &lt;/p&gt;
&lt;h3 id=&quot;寻找某个值的区间（leetcode-34-Search-for-a-Range）&quot;&gt;&lt;a href=&quot;#寻找某个值的区间（leetcode-34-Search-for-a-Range）&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>链表解题</title>
    <link href="http://yoursite.com/2018/09/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8%E8%A7%A3%E9%A2%98/"/>
    <id>http://yoursite.com/2018/09/11/数据结构与算法/链表解题/</id>
    <published>2018-09-11T09:06:13.000Z</published>
    <updated>2019-12-28T08:57:17.195Z</updated>
    
    <content type="html"><![CDATA[<p>链表相关题_python版</p><h3 id="在O-1-时间删除链表结点"><a href="#在O-1-时间删除链表结点" class="headerlink" title="在O(1)时间删除链表结点"></a>在O(1)时间删除链表结点</h3><p><strong>题目</strong>：给定单向链表的头指针和一个结点指针，定义一个函数在O(1)时间删除该结点。</p><p><strong>思路</strong>：我们要删除结点i，先把i的下一个结点i.next的内容复制到i，然后在把i的指针指向i.next结点的下一个结点即i.next.next，它的效果刚好是把结点i给删除了。<strong>需要考虑如果这个节点是链表的尾节点那么就需要从头遍历这个链表了。</strong>（通常，在单向链表中，删除一个链表的结点，都会先从表头开始遍历整个链表，找到需要删除的结点的前一个结点，然后将这个结点的(指向下一个结点的)指针元素指向需要删除结点的下一个结点，最后把需要删除的结点删除．但此过程的平均时间复杂度为 O(n)． ）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self.value = value</span><br><span class="line">        self.next_ = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span><span class="params">(self,pHead,Node)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> Node == <span class="literal">None</span> <span class="keyword">or</span> pHead == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> Node.next != <span class="literal">None</span>: <span class="comment"># else情况1：只有一个Node节点；情况2：Node节点在尾巴</span></span><br><span class="line">            Node.val = Node.next.val</span><br><span class="line">            Node.next = Node.next.next</span><br><span class="line">        <span class="keyword">elif</span> Node == pHead:<span class="comment"># 如果链表只有一个节点，那么就把头节点删掉就好了</span></span><br><span class="line">            pHead.val = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pNode = pHead  <span class="comment"># 把Node节点删除，然后接上一个None</span></span><br><span class="line">            <span class="keyword">while</span> pNode.next != Node:</span><br><span class="line">                pNode = pNode.next</span><br><span class="line">            pNode.next = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> pHead</span><br></pre></td></tr></table></figure><h3 id="合并两个排序的链表-要求不新建链表"><a href="#合并两个排序的链表-要求不新建链表" class="headerlink" title="合并两个排序的链表(要求不新建链表)"></a>合并两个排序的链表(要求不新建链表)</h3><p><strong>题目</strong>：输入两个递增排序的链表，合并这两个链表并使新链表中的结点仍然是按照递增排序的。</p><p><strong>思路</strong>：非递归情况：<strong>找到两个链表中头节点值相对更小的链表，将其作为主链表，第二个链表中的元素则不断加入到主链表中</strong>。具体策略是：主链表定义两个指针，指向两个相邻的元素。<strong>当第二个链表中的元素值小于主链表中第二个指针时，将第二个链表的当前元素插入到主链表两个指针指向的元素中间</strong>，并调整指针指向。 不要让链表断开，考虑链表为空的几种情况。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  ============非递归版本===============</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Merge</span><span class="params">(self, pHead1, pHead2)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> pHead1:</span><br><span class="line">        <span class="keyword">return</span> pHead2</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> pHead2:</span><br><span class="line">        <span class="keyword">return</span>  pHead1</span><br><span class="line">    mainHead = pHead1 <span class="keyword">if</span> pHead1.val &lt;= pHead2.val <span class="keyword">else</span> pHead2 <span class="comment"># 主链</span></span><br><span class="line">    secHead = pHead2 <span class="keyword">if</span> mainHead == pHead1 <span class="keyword">else</span> pHead1 <span class="comment"># 副链</span></span><br><span class="line">    mergeHead = mainHead</span><br><span class="line">    mainNext = mainHead.next <span class="comment"># 主链第二个指针</span></span><br><span class="line">    <span class="keyword">while</span> mainNext <span class="keyword">and</span> secHead: </span><br><span class="line">        <span class="keyword">if</span> secHead.val &lt;= mainNext.val: <span class="comment"># 副链节点插入到两个指针之间</span></span><br><span class="line">            mainHead.next = secHead <span class="comment"># 第一个指针连接到副链头指针</span></span><br><span class="line">            secHead = secHead.next <span class="comment"># 副链头指针后移</span></span><br><span class="line">            mainHead.next.next = mainNext <span class="comment"># 副链头指针连接到第二个指针</span></span><br><span class="line">            mainHead = mainHead.next <span class="comment"># 第一个指针后移（变成原副链的头指针），插入操作第二个指针不需要后移</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            mainHead = mainNext</span><br><span class="line">            mainNext = mainNext.next</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> mainNext: <span class="comment"># 副链元素都比第二个指针要大，不能插入，要拼接</span></span><br><span class="line">        mainHead.next = secHead</span><br><span class="line">    <span class="keyword">return</span> mergeHead</span><br><span class="line"><span class="comment"># ==================递归版本=================</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回合并后列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Merge</span><span class="params">(self, pHead1, pHead2)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> pHead1 <span class="keyword">is</span> <span class="literal">None</span>: <span class="comment"># 处理末尾状态，pHead1为空，要拼接的就是pHead2了</span></span><br><span class="line">            <span class="keyword">return</span> pHead2</span><br><span class="line">        <span class="keyword">if</span> pHead2 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> pHead1</span><br><span class="line">        <span class="keyword">if</span> pHead1.val &lt; pHead2.val:</span><br><span class="line">            pHead1.next = self.Merge(pHead1.next,pHead2)</span><br><span class="line">            <span class="keyword">return</span> pHead1 <span class="comment"># 返回整段拼接后的链表</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pHead2.next = self.Merge(pHead1,pHead2.next)</span><br><span class="line">            <span class="keyword">return</span> pHead2</span><br></pre></td></tr></table></figure><h3 id="二叉搜索树与双向链表"><a href="#二叉搜索树与双向链表" class="headerlink" title="二叉搜索树与双向链表"></a>二叉搜索树与双向链表</h3><p><strong>题目</strong>：输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向 ，例如</p><p><img src="/2018/09/11/数据结构与算法/链表解题/01.jpg" alt></p><p><strong>思路</strong>：</p><ol><li>核心算法依旧是中序遍历</li><li>不是从根节点开始，而是从中序遍历得到的第一个节点开始</li><li>定义两个辅助节点listHead(链表头节点)、listTail(链表尾节点)。事实上，二叉树只是换了种形式的链表；<strong>listHead用于记录链表的头节点，用于最后算法的返回；listTail用于定位当前需要更改指向的节点</strong>。了解了listHead和listTail的作用，代码理解起来至少顺畅80%。</li></ol><p>过程图示例</p><p><img src="/2018/09/11/数据结构与算法/链表解题/03.png" alt></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">稍微多说一句，其实这段代码也就5行，2行是中序遍历的代码；3行是更改节点指向的代码，为if、else行。if语句段只有在中序遍历到第一个节点时调用，自此之后listHead不变，listTail跟随算法的进度。对比中序遍历可以看出来，实际上只是中序遍历中的第八行代码被上述的if-else语句替代了，仅此而已。</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line">        self.val = x</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.listHead = <span class="literal">None</span></span><br><span class="line">        self.listTail = <span class="literal">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Convert</span><span class="params">(self, pRootOfTree)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> pRootOfTree==<span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.Convert(pRootOfTree.left)</span><br><span class="line">        <span class="keyword">if</span> self.listHead==<span class="literal">None</span>:  <span class="comment"># if/else替换中序遍历存储值</span></span><br><span class="line">            self.listHead = pRootOfTree <span class="comment"># if这一段只有中序遍历的第一个节点出现，即最左子树</span></span><br><span class="line">            self.listTail = pRootOfTree <span class="comment"># 此时，链表头尾指针都指向中序第一个节点</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.listTail.right = pRootOfTree <span class="comment"># 尾指针与中序下一个节点互连，有right属性是因为上一步self.listTail和self.listHead已经指向pRootOfTree了</span></span><br><span class="line">            pRootOfTree.left = self.listTail</span><br><span class="line">            self.listTail = pRootOfTree <span class="comment"># 尾指针指向中序下一个节点</span></span><br><span class="line">        self.Convert(pRootOfTree.right)</span><br><span class="line">        <span class="keyword">return</span> self.listHead</span><br></pre></td></tr></table></figure><h3 id="翻转部分链表"><a href="#翻转部分链表" class="headerlink" title="翻转部分链表"></a>翻转部分链表</h3><p>题目：给定一个单链表的头指针 head， 以及两个整数 a 和 b下标，在单链表中反转 linked_list[a-b] 的结点，然后返回整个链表的头指针 。</p><p>思路：采用翻转单链表的思路，回顾一下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">翻转单链表</span></span><br><span class="line"><span class="string">思路很简单：1-&gt;2-&gt;3-&gt;4-&gt;5，遍历链表，把1的next置为None，2的next置为1，以此类推，5的next置为4。得到反转链表。</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回ListNode</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ReverseList</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> pHead==<span class="literal">None</span> <span class="keyword">or</span> pHead.next==<span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> pHead</span><br><span class="line">        pre = <span class="literal">None</span> <span class="comment"># 前指针</span></span><br><span class="line">        cur = pHead <span class="comment"># 当前指针</span></span><br><span class="line">        <span class="keyword">while</span> cur!=<span class="literal">None</span>:</span><br><span class="line">            tmp = cur.next <span class="comment"># 记录下一个指针，为下一步当前指针后移准备</span></span><br><span class="line">            cur.next = pre</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = tmp</span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 翻转部分链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBetween</span><span class="params">(self, head, m, n)</span>:</span></span><br><span class="line">        <span class="comment"># 计算需要逆至的节点数</span></span><br><span class="line">        reverse_length = n - m + <span class="number">1</span></span><br><span class="line">        pre_head = <span class="literal">None</span> <span class="comment"># 初始化要记录的前驱节点</span></span><br><span class="line">        result = head   <span class="comment"># 最终转换后要返回的链表头结点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将head向后移动m-1个位置</span></span><br><span class="line">        <span class="keyword">while</span> head <span class="keyword">and</span> m &gt; <span class="number">1</span>:</span><br><span class="line">            pre_head = head</span><br><span class="line">            head = head.next</span><br><span class="line">            m -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 记录翻转后的链表尾部，翻转后的尾巴即为当前head</span></span><br><span class="line">        modify_list_tail = head</span><br><span class="line">        pre = <span class="literal">None</span> <span class="comment"># 前指针</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 逆置n - m + 1个节点</span></span><br><span class="line">        <span class="keyword">while</span> head <span class="keyword">and</span> reverse_length: <span class="comment">#和翻转单链表一样，翻转后和第一、第三段是断开的</span></span><br><span class="line">            tmp = head.next </span><br><span class="line">            head.next = pre</span><br><span class="line">            pre = head</span><br><span class="line">            head = tmp</span><br><span class="line">            reverse_length -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 此时，尾巴为空， modify_list_tail指向最后一个非空元素</span></span><br><span class="line">        <span class="comment"># 连接逆置后的链表尾与第三段的头结点结合，此时head已经指向第三段正序的头结点</span></span><br><span class="line">        modify_list_tail.next = head</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果pre_head不为空，说明不是从第一个节点开始逆至，即m&gt;1</span></span><br><span class="line">        <span class="keyword">if</span> pre_head <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># pre_head指向第一段最后一个元素，连接逆序后的头结点</span></span><br><span class="line">            pre_head.next = pre <span class="comment">#pre指向逆序后头结点，head为第三段的头结点</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 此时m=1，则逆置后的头结点就是链表的头结点，即翻转整个单链表</span></span><br><span class="line">            result = pre</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h3 id="链表插入排序-leetcode-147-Insertion-Sort-List"><a href="#链表插入排序-leetcode-147-Insertion-Sort-List" class="headerlink" title="链表插入排序(leetcode 147 Insertion Sort List)"></a>链表插入排序(leetcode 147 Insertion Sort List)</h3><p>题目：利用插入排序对链表进行排序</p><p>思路：1-&gt;3-&gt;2-&gt;4-&gt;null，将头结点和后面的部分断开，变成1-&gt;null和3-&gt;2-&gt;4-&gt;null，1-&gt;null看做是排好序的部分，添加的时候依次取后面的那部分的节点，比如在这里，先取3，然后对前面排好序的链表从前往后遍历，找到应该插入的位置即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Definition of ListNode</span></span><br><span class="line"><span class="string">class ListNode(object):</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    def __init__(self, val, next=None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.next = next</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param: head: The first node of linked list.</span></span><br><span class="line"><span class="string">    @return: The head of linked list.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertionSortList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> head.next <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        l=ListNode(<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            node=l <span class="comment"># 每次从头开始</span></span><br><span class="line">            fol=head.next <span class="comment"># 保持下一个，防止断开</span></span><br><span class="line">            <span class="keyword">while</span> node.next <span class="keyword">and</span> node.next.val &lt; head.val: <span class="comment"># 插入到node和node.next之间</span></span><br><span class="line">                node = node.next</span><br><span class="line">            head.next = node.next  <span class="comment"># 先连接后面head-&lt;node.next</span></span><br><span class="line">            node.next = head     <span class="comment"># 再连接前面</span></span><br><span class="line">            head = fol</span><br><span class="line">        <span class="keyword">return</span> l.next</span><br></pre></td></tr></table></figure><h3 id="链表归并排序-leetcode-148-Sort-List"><a href="#链表归并排序-leetcode-148-Sort-List" class="headerlink" title="链表归并排序(leetcode 148 Sort List)"></a>链表归并排序(leetcode 148 Sort List)</h3><p>题目：要求我们用O(nlogn)算法对链表进行排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, val, next=None)</span>:</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.next = next</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 归并法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> head.next <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        pre = head</span><br><span class="line">        slow = head               <span class="comment"># 使用快慢指针来确定中点</span></span><br><span class="line">        fast = head</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">            pre = slow</span><br><span class="line">            slow = slow.next</span><br><span class="line">            fast = fast.next.next</span><br><span class="line">        </span><br><span class="line">        left = head  </span><br><span class="line">        right = pre.next  <span class="comment"># 第二段头结点</span></span><br><span class="line">        pre.next = <span class="literal">None</span>           <span class="comment"># 从中间打断链表</span></span><br><span class="line">        left = self.sortList(left)  </span><br><span class="line">        right = self.sortList(right)  </span><br><span class="line">        <span class="keyword">return</span> self.merge(left,right)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, left, right)</span>:</span> <span class="comment">#合并两个有序链表</span></span><br><span class="line">        pre = ListNode(<span class="number">-1</span>) <span class="comment"># 新链表</span></span><br><span class="line">        first = pre <span class="comment"># 新链表头结点</span></span><br><span class="line">        <span class="keyword">while</span> left <span class="keyword">and</span> right:</span><br><span class="line">            <span class="keyword">if</span> left.val &lt; right.val:</span><br><span class="line">                pre.next = left</span><br><span class="line">                pre = left</span><br><span class="line">                left = left.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre.next = right</span><br><span class="line">                pre = right</span><br><span class="line">                right = right.next</span><br><span class="line">        <span class="keyword">if</span> left:</span><br><span class="line">            pre.next = left</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pre.next = right             </span><br><span class="line">        <span class="keyword">return</span> first.next</span><br></pre></td></tr></table></figure><h3 id="两两交换链表中相邻的两个元素"><a href="#两两交换链表中相邻的两个元素" class="headerlink" title="两两交换链表中相邻的两个元素"></a>两两交换链表中相邻的两个元素</h3><p><strong>题目</strong>：交换链表中相邻的两个元素。 注意第一个节点与第二个节点要交换位置，而第二个节点不用与第三个节点交换位置。 如要交换链表中A-&gt;B-&gt;C-&gt;D中的B和C需要做如下操作（<strong>交换B和C</strong>）：</p><ul><li>将A指向C</li><li>将B指向D</li><li>将C指向B</li></ul><p>思路：在头节点之前加一个假节点就可以使所有的交换都符合上面的情况。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        dummy = ListNode(<span class="number">-1</span>)</span><br><span class="line">        dummy.next = head <span class="comment"># 假结点连接原链表</span></span><br><span class="line">        temp = dummy <span class="comment"># 头结点</span></span><br><span class="line">        <span class="keyword">while</span> temp.next <span class="keyword">and</span> temp.next.next:</span><br><span class="line">            node1 = temp.next  <span class="comment"># node1是B</span></span><br><span class="line">            node2 = temp.next.next  <span class="comment"># node2是C</span></span><br><span class="line">            temp.next = node2  <span class="comment"># A指向C</span></span><br><span class="line">            node1.next = node2.next  <span class="comment"># B指向D</span></span><br><span class="line">            node2.next = node1  <span class="comment"># C指向B</span></span><br><span class="line">            temp = temp.next.next  <span class="comment"># 跳过两个</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure><h3 id="判断两个链表相交和相交的第一个节点"><a href="#判断两个链表相交和相交的第一个节点" class="headerlink" title="判断两个链表相交和相交的第一个节点"></a>判断两个链表相交和相交的第一个节点</h3><p>思路1：链表两个链表的长度差diff，然后快指针先走diff步，然后快慢指针一起走。直到两个指针相同，否则无相交节点。（需要先遍历得到两个链表长度）</p><p>思路2：两个指针一起走，当一个指针p1走到终点时，说明p1所在的链表比较短，让p1指向另一个链表的头结点开始走，直到p2走到终点，让p2指向短的链表的头结点，那么，接下来两个指针要走的长度就一样了 ，然后就可以一起走，直到两个指针相同。(若无交点，可以一开始在链表尾巴的设置一个标志点)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 思路二</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindFirstCommonNode</span><span class="params">(self, pHead1, pHead2)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead1 <span class="keyword">or</span> <span class="keyword">not</span> pHead2:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        p1, p2 = pHead1, pHead2</span><br><span class="line">        <span class="keyword">while</span> p1 != p2:</span><br><span class="line">            p1 = pHead2 <span class="keyword">if</span> <span class="keyword">not</span> p1 <span class="keyword">else</span> p1.next</span><br><span class="line">            p2 = pHead1 <span class="keyword">if</span> <span class="keyword">not</span> p2 <span class="keyword">else</span> p2.next</span><br><span class="line">        <span class="keyword">return</span> p1</span><br></pre></td></tr></table></figure><h3 id="分隔链表"><a href="#分隔链表" class="headerlink" title="分隔链表"></a>分隔链表</h3><p><strong>题目：</strong>给定一个链表以及一个目标值，把小于该目标值的所有节点都移至链表的前端，大于或等于目标值的节点移至链表的尾端，同时要保持这两部分在原先链表中的相对位置。</p><p><strong>思路</strong>：两个链表指针，一个负责收集比目标小的，一个收集大于等于目标的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, head, x)</span>:</span></span><br><span class="line">        dummy = ListNode(<span class="number">-1</span>)</span><br><span class="line">        dummy.next = head</span><br><span class="line">        small_dummy = ListNode(<span class="number">-1</span>)</span><br><span class="line">        large_dummy = ListNode(<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># small_prev和large_prev往后遍历增加，small_dummy和large_dummy则负责最后作为返回头结点</span></span><br><span class="line">        small_prev = small_dummy</span><br><span class="line">        large_prev = large_dummy</span><br><span class="line">        <span class="keyword">while</span> dummy.next:  <span class="comment"># head第一个节点</span></span><br><span class="line">            curr = dummy.next</span><br><span class="line">            <span class="keyword">if</span> curr.val &lt; x:</span><br><span class="line">                small_prev.next = curr</span><br><span class="line">                small_prev = small_prev.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                large_prev.next = curr</span><br><span class="line">                large_prev = large_prev.next</span><br><span class="line">            dummy = dummy.next</span><br><span class="line"></span><br><span class="line">        large_prev.next = <span class="literal">None</span>  <span class="comment"># 最后指针置为none</span></span><br><span class="line">        small_prev.next = large_dummy.next  <span class="comment"># large_dummy对应的是大链表的第一个数</span></span><br><span class="line">        <span class="keyword">return</span> small_dummy.next  <span class="comment"># 返回的是small_dummy</span></span><br></pre></td></tr></table></figure><h3 id="重排链表"><a href="#重排链表" class="headerlink" title="重排链表"></a>重排链表</h3><p>将单向链表L0→L1→…→Ln-1→Ln转化为L0→Ln→L1→Ln-1→L2→Ln-2→…的形式，也就是从头部取一个节点，从尾部取一个节点，直到将原链表转化成新的链表。</p><p>思路：</p><ol><li>去中间节点，将链表分为两段.</li><li>翻转后一段</li><li>拼接</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reorderList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># split &#123;1,2,3,4,5&#125; to &#123;1,2,3&#125;&#123;4,5&#125;</span></span><br><span class="line">        fast = slow = head </span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">            slow = slow.next</span><br><span class="line">            fast = fast.next.next</span><br><span class="line">        head1 = head</span><br><span class="line">        head2 = slow.next</span><br><span class="line">        slow.next = <span class="literal">None</span></span><br><span class="line">        <span class="comment"># reverse the second &#123;4,5&#125; to &#123;5,4&#125;</span></span><br><span class="line">        cur, pre = head2, <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            tmp = cur.next <span class="comment"># 标记下一个</span></span><br><span class="line">            cur.next = pre</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = tmp</span><br><span class="line">        <span class="comment"># merge</span></span><br><span class="line">        cur1, cur2 = head1, pre</span><br><span class="line">        <span class="keyword">while</span> cur2:</span><br><span class="line">            nex1, nex2 = cur1.next, cur2.next</span><br><span class="line">            cur1.next = cur2</span><br><span class="line">            cur2.next = nex1</span><br><span class="line">            cur1, cur2 = nex1, nex2</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;链表相关题_python版&lt;/p&gt;
&lt;h3 id=&quot;在O-1-时间删除链表结点&quot;&gt;&lt;a href=&quot;#在O-1-时间删除链表结点&quot; class=&quot;headerlink&quot; title=&quot;在O(1)时间删除链表结点&quot;&gt;&lt;/a&gt;在O(1)时间删除链表结点&lt;/h3&gt;&lt;p&gt;&lt;stro
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>经典排序总结</title>
    <link href="http://yoursite.com/2018/09/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/09/11/数据结构与算法/经典排序总结/</id>
    <published>2018-09-11T09:06:11.000Z</published>
    <updated>2019-12-28T08:49:56.449Z</updated>
    
    <content type="html"><![CDATA[<p>先看一个排序算法可视化大概了解一下经典的排序算法。</p><p><a href="http://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html" target="_blank" rel="noopener">排序算法可视化</a></p><h2 id="冒泡排序-BubbleSort"><a href="#冒泡排序-BubbleSort" class="headerlink" title="冒泡排序 BubbleSort"></a>冒泡排序 BubbleSort</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>冒泡排序(bubble sort)：每个回合都从第一个元素开始和它后面的元素比较，如果比它后面的元素更大的话就交换，一直重复，直到这个元素到了它能到达的位置。每次遍历都将剩下的元素中最大的那个放到了序列的“最后”(除去了前面已经排好的那些元素)。注意检测是否已经完成了排序，如果已完成就可以退出了。</p><p><img src="/2018/09/11/数据结构与算法/经典排序总结/01.jpg" alt></p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li>对第0个到第n-1个数据做同样的工作。这时，最大的数就“浮”到了数组最后的位置上。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ol><h3 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h3><p><strong>Python源代码（错误版本）：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(arry)</span>:</span></span><br><span class="line">    n = len(arry)                   <span class="comment">#获得数组的长度</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span>  arry[i] &gt; arry[j] :       <span class="comment">#如果前者比后者大</span></span><br><span class="line">                arry[i],arry[j] = arry[j],arry[i]      <span class="comment">#则交换两者</span></span><br><span class="line">    <span class="keyword">return</span> arry</span><br></pre></td></tr></table></figure><blockquote><p> 注：上述代码是没有问题的，但是实现却不是冒泡排序，而是选择排序（原理见选择排序），注意冒泡排序的本质是“相邻元素”的顺序交换，而非每次完成一个最小数字的选定。 </p></blockquote><p> <strong>Python源代码（正确版本）：</strong> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(arry)</span>:</span></span><br><span class="line">    n = len(arry)                   <span class="comment">#获得数组的长度</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">    <span class="comment"># 这里n-i有可能是最后的下标，如果用j和j+1会超过数组限制，所以应该用j-1和j，把 range改为（1，n-i）</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n-i):     <span class="comment"># 每轮找到最大数值，n-i因为前面已经确定i个最大值，只需比较剩下n-i个</span></span><br><span class="line">            <span class="keyword">if</span>  arry[j<span class="number">-1</span>] &gt; arry[j] :       <span class="comment">#如果前者比后者大</span></span><br><span class="line">                arry[j<span class="number">-1</span>],arry[j] = arry[j],arry[j<span class="number">-1</span>]      <span class="comment">#则交换两者</span></span><br><span class="line">    <span class="keyword">return</span> arry</span><br></pre></td></tr></table></figure><p><strong>优化1：</strong></p><p>某一趟遍历如果没有数据交换，则说明已经排好序了，因此不用再进行迭代了。用一个标记记录这个状态即可。</p><p><strong>Python源代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort2</span><span class="params">(ary)</span>:</span></span><br><span class="line">    n = len(ary)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        flag = <span class="literal">False</span>    <span class="comment"># 标记</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n - i):</span><br><span class="line">            <span class="keyword">if</span> ary[j] &lt; ary[j<span class="number">-1</span>]:</span><br><span class="line">                ary[j], ary[j<span class="number">-1</span>] = ary[j<span class="number">-1</span>], ary[j]</span><br><span class="line">                flag = <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 某一趟遍历如果没有数据交换，则说明已经排好序了，因此不用再进行迭代了</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> flag:    </span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> ary</span><br></pre></td></tr></table></figure><h2 id="选择排序-SelectionSort"><a href="#选择排序-SelectionSort" class="headerlink" title="选择排序 SelectionSort"></a>选择排序 SelectionSort</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>每个回合都选择出剩下的元素中最大的那个，选择的方法是首先默认第一元素是最大的，如果后面的元素比它大的话，那就更新剩下的最大的元素值，找到剩下元素中最大的之后将它放入到合适的位置就行了。和冒泡排序类似，只是找剩下的元素中最大的方式不同而已。</p><p><img src="/2018/09/11/数据结构与算法/经典排序总结/02.jpg" alt></p><h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h3><ol><li>在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</li><li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li><li>以此类推，直到所有元素均排序完毕。</li></ol><h3 id="源代码-1"><a href="#源代码-1" class="headerlink" title="源代码"></a>源代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_sort</span><span class="params">(ary)</span>:</span></span><br><span class="line">    n = len(ary)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,n):</span><br><span class="line">        min = i                             <span class="comment"># 最小元素下标标记，这句是最重要的</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">if</span> ary[j] &lt; ary[min] :</span><br><span class="line">                min = j                     <span class="comment"># 找到最小值的下标</span></span><br><span class="line">        ary[min],ary[i] = ary[i],ary[min]   <span class="comment"># 交换两者</span></span><br><span class="line">    <span class="keyword">return</span> ary</span><br></pre></td></tr></table></figure><h2 id="插入排序-Insertion-Sort"><a href="#插入排序-Insertion-Sort" class="headerlink" title="插入排序 Insertion Sort"></a>插入排序 Insertion Sort</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p>插入排序的工作原理是，<strong>对于每个未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入</strong>。 对具有nn个数据元素的序列进行排序时，插入排序需要进行n−1n−1趟插入。进行第j(1≥j≥n−1)j(1≥j≥n−1)趟插入时，前面已经有jj个元素排好序了，第jj趟将aj+1aj+1插入到已经排好序的序列中，这样既可使前面的j+1j+1个数据排好序。</p><p><img src="/2018/09/11/数据结构与算法/经典排序总结/03.gif" alt></p><h3 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤"></a>步骤</h3><ol><li>从第一个元素开始，该元素可以认为已经被排序</li><li>取出下一个元素，<strong>在已经排序的元素序列中从后向前扫描</strong></li><li><strong>如果被扫描的元素（已排序）大于新元素，将该元素后移一位</strong></li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li><li>将新元素插入到该位置后</li><li>重复步骤2~5</li></ol><h3 id="源代码-2"><a href="#源代码-2" class="headerlink" title="源代码"></a>源代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span><span class="params">(ary)</span>:</span></span><br><span class="line">    n = len(ary)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">        pre_key = i - <span class="number">1</span> <span class="comment"># 往前的下标</span></span><br><span class="line">        mark = ary[i] <span class="comment"># 记录当前元素 这两句很重要</span></span><br><span class="line">        <span class="keyword">while</span> pre_key &gt;= <span class="number">0</span> <span class="keyword">and</span> ary[pre_key] &gt; mark:  <span class="comment"># 找到第一个比mark的小的元素或到头时结束</span></span><br><span class="line">            ary[pre_key+<span class="number">1</span>] = ary[pre_key]  <span class="comment"># 往后移一位</span></span><br><span class="line">            pre_key -= <span class="number">1</span></span><br><span class="line">        ary[pre_key+<span class="number">1</span>] = mark   <span class="comment"># 找到并插入（想象一个简单的例子）</span></span><br><span class="line">    <span class="keyword">return</span> ary</span><br></pre></td></tr></table></figure><h2 id="希尔排序-ShellSort"><a href="#希尔排序-ShellSort" class="headerlink" title="希尔排序 ShellSort"></a>希尔排序 ShellSort</h2><h3 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h3><p>希尔排序，也称递减增量排序算法，实质是<strong>分组插入排序</strong>。由 Donald Shell 于1959年提出。希尔排序是非稳定排序算法。</p><p>希尔排序的基本思想是：先将整个待排元素序列分割成若干个子序列（由相隔某个“增量”的元素组成的）<strong>分别进行直接插入排序</strong>，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。因为直接插入排序在元素基本有序的情况下（接近最好情况），效率是很高的，因此希尔排序在时间效率上比前两种方法有较大提高。</p><p>n=10的一个数组49, 38, 65, 97, 26, 13, 27, 49, 55, 4为例</p><p><strong>第一次 gap = 10/2 = 5</strong></p><p>49 38 65 97 26 13 27 49 55 4</p><p>1A 1B 2A 2B 3A 3B 4A 4B 5A 5B</p><blockquote><p> 1A, 1B, 2A, 2B等为分组标记，数字相同的表示在同一组，同组进行直接插入排序 </p></blockquote><p><strong>第二次 gap = 5 / 2 = 2</strong>，排序后</p><p>13 27 49 55 4 49 38 65 97 26</p><p>1A 1B 1C 1D 1E 2A 2B 2C 2D 2E</p><p><strong>第三次 gap = 2 / 2 = 1</strong></p><p>4 26 13 27 38 49 49 55 97 65</p><p>1A 1B 1C 1D 1E 1F 1G 1H 1I 1J</p><p><strong>第四次 gap = 1 / 2 = 0</strong> 排序完成得到数组：</p><p>4 13 26 27 38 49 49 55 65 97</p><h3 id="源代码-3"><a href="#源代码-3" class="headerlink" title="源代码"></a>源代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shell_sort</span><span class="params">(ary)</span>:</span></span><br><span class="line">        count = len(ary)</span><br><span class="line">        gap = round(count/<span class="number">2</span>)   <span class="comment"># round精度不够可以考虑用math.floor()  </span></span><br><span class="line">        <span class="comment"># 双杠用于整除（向下取整），在python直接用 “/” 得到的永远是浮点数，用round()得到四舍五入值</span></span><br><span class="line">        <span class="keyword">while</span> gap &gt;= <span class="number">1</span>: <span class="comment"># 不要忘了这句</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(gap, count): <span class="comment"># 前面的gap间隔数组视为已排好序，每次插入到排好序数组中</span></span><br><span class="line">                cur = ary[i] </span><br><span class="line">                preindex = i -gap <span class="comment"># 往前的下标</span></span><br><span class="line">                <span class="keyword">while</span> preindex &gt;= <span class="number">0</span> <span class="keyword">and</span> ary[preindex] &gt; cur:  <span class="comment"># 到这里与插入排序一样了</span></span><br><span class="line">                    ary[preindex+gap] = ary[preindex]  <span class="comment"># 往后移</span></span><br><span class="line">                    preindex -= gap</span><br><span class="line">                ary[preindex+gap] = cur  <span class="comment"># 插入</span></span><br><span class="line">            gap = round(gap/<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> ary</span><br></pre></td></tr></table></figure><h2 id="归并排序-Merge-Sort"><a href="#归并排序-Merge-Sort" class="headerlink" title="归并排序 Merge Sort"></a>归并排序 Merge Sort</h2><h3 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h3><p>归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。</p><p>首先考虑下如何将将二个有序数列合并。这个非常简单，只要从比较二个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可。</p><p><img src="/2018/09/11/数据结构与算法/经典排序总结/04.gif" alt></p><h3 id="源代码-4"><a href="#源代码-4" class="headerlink" title="源代码"></a>源代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 归并排序</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(self, ary)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> len(ary) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> ary</span><br><span class="line"></span><br><span class="line">        median = int(len(ary)/<span class="number">2</span>)    <span class="comment"># 二分分解</span></span><br><span class="line">        left = self.merge_sort(ary[:median]) <span class="comment"># 先自调用，最里一层只有一个单元素</span></span><br><span class="line">        right = self.merge_sort(ary[median:])</span><br><span class="line">        <span class="keyword">return</span> self.merge(left, right)    <span class="comment"># 合并成有序数组</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, left, right)</span>:</span></span><br><span class="line">     <span class="string">'''合并操作，将两个有序数组left[]和right[]合并成一个大的有序数组'''</span></span><br><span class="line">        res = []</span><br><span class="line">        i = j = k = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; len(left) <span class="keyword">and</span> j &lt; len(right)):</span><br><span class="line">            <span class="keyword">if</span> left[i] &lt; right[j]:</span><br><span class="line">                res.append(left[i])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(right[j])</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        res = res + left[i:] + right[j:]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="快速排序-QuickSort"><a href="#快速排序-QuickSort" class="headerlink" title="快速排序 QuickSort"></a>快速排序 QuickSort</h2><h3 id="介绍-5"><a href="#介绍-5" class="headerlink" title="介绍"></a>介绍</h3><p>快速排序是图灵奖得主C.R.A Hoare于1960年提出的一种划分交换排序。它采用了一种分治的策略，通常称其为分治法。分治法的基本思想是：将原问题分解为若干个规模更小但结构与原问题相似的子问题。递归地解这些子问题，然后将这些子问题组合为原问题的解。</p><p><img src="/2018/09/11/数据结构与算法/经典排序总结/05.gif" alt></p><p><img src="/2018/09/11/数据结构与算法/经典排序总结/06.gif" alt></p><p>以一个数组作为示例，取区间第一个数为基准数。</p><blockquote><p>0 1 2 3 4 5 6 7 8 9</p><p>72 6 57 88 60 42 83 73 48 85</p></blockquote><p>初始时，i = 0; j = 9; X = a[i] = 72</p><p>由于已经将a[0]中的数保存到X中，可以理解成在数组a[0]上挖了个坑，可以将其它数据填充到这来。</p><p>从j开始向前找一个比X小或等于X的数。当j=8，符合条件，将a[8]挖出再填到上一个坑a[0]中。a[0]=a[8]; i++; 这样一个坑a[0]就被搞定了，但又形成了一个新坑a[8]，这怎么办了？简单，再找数字来填a[8]这个坑。这次从i开始向后找一个大于X的数，当i=3，符合条件，将a[3]挖出再填到上一个坑中a[8]=a[3]; j–;</p><p>数组变为：</p><blockquote><p>0 1 2 3 4 5 6 7 8 9</p><p>48 6 57 88 60 42 83 73 88 85</p></blockquote><p>i = 3; j = 7; X=72</p><p>再重复上面的步骤，<strong>先从后向前找，再从前向后找。</strong></p><h3 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤"></a>步骤</h3><p>利用分治法可将快速排序分为三步：</p><ol><li>从数列中挑出一个元素作为“基准”（pivot）。</li><li>分区过程，将比基准数大的放到右边，小于或等于它的数都放到左边。这个操作称为“分区操作”，分区操作结束后，基准元素所处的位置就是最终排序后它的位置</li><li>再对“基准”左右两边的子集不断重复第一步和第二步，直到所有子集只剩下一个元素为止。</li></ol><h3 id="源代码-5"><a href="#源代码-5" class="headerlink" title="源代码"></a>源代码</h3><h4 id="版本一"><a href="#版本一" class="headerlink" title="版本一"></a>版本一</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(self, ary)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> qsort(ary, <span class="number">0</span>, len(ary)<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">qsort</span><span class="params">(self, ary, start, end)</span>:</span>  <span class="comment"># ary为原数组，其他为下标</span></span><br><span class="line">    <span class="keyword">if</span> start &lt; end: <span class="comment"># 这句不能忘！！！</span></span><br><span class="line">        left = start</span><br><span class="line">        right = end</span><br><span class="line">        key = ary[start]</span><br><span class="line">        <span class="keyword">while</span> left &lt; right: <span class="comment"># 这里都没有等号，left=right是最后key赋值</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> ary[right] &gt;= key: <span class="comment"># 核心</span></span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> left &lt; right:    <span class="comment">#说明打破while循环的原因是ary[right] &lt;= key</span></span><br><span class="line">                ary[left] = ary[right] <span class="comment"># 填坑</span></span><br><span class="line">                left += <span class="number">1</span> <span class="comment"># 换位继续</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> ary[left] &lt; key:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> left &lt; right:    <span class="comment">#说明打破while循环的原因是ary[left] &gt;= key</span></span><br><span class="line">                ary[right] = ary[left]</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">        ary[left] = key    <span class="comment">#此时，left=right，用key来填坑</span></span><br><span class="line">        self.qsort(ary, start, left<span class="number">-1</span>)  <span class="comment"># 注意这里的下标顺序</span></span><br><span class="line">        self.qsort(ary, left+<span class="number">1</span>, end)</span><br><span class="line">    <span class="keyword">return</span> ary</span><br></pre></td></tr></table></figure><h4 id="版本二"><a href="#版本二" class="headerlink" title="版本二"></a>版本二</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quickSort</span><span class="params">(array)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(array)&lt;<span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> array</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        base = array[<span class="number">0</span>] <span class="comment"># 元素，return时要变为列表</span></span><br><span class="line">        <span class="comment">#小于等于基准值的元素组成的数组</span></span><br><span class="line">        less = [i <span class="keyword">for</span> i <span class="keyword">in</span> array[<span class="number">1</span>:] <span class="keyword">if</span> i&lt;=base]</span><br><span class="line">        <span class="comment">#大于基准值的元素组成的数组</span></span><br><span class="line">        greater = [i <span class="keyword">for</span> i <span class="keyword">in</span> array[<span class="number">1</span>:] <span class="keyword">if</span> i&gt; base]</span><br><span class="line">        <span class="comment">#将数组串起来</span></span><br><span class="line">        <span class="keyword">return</span> quickSort(less)+[base]+quickSort(greater)</span><br><span class="line"></span><br><span class="line">print(quickSort([<span class="number">45</span>, <span class="number">26</span>, <span class="number">34</span>, <span class="number">2</span>, <span class="number">888</span>, <span class="number">54</span>, <span class="number">23</span>, <span class="number">45</span>, <span class="number">76</span>, <span class="number">2</span>]))</span><br></pre></td></tr></table></figure><h2 id="堆排序-HeapSort"><a href="#堆排序-HeapSort" class="headerlink" title="堆排序 HeapSort"></a>堆排序 HeapSort</h2><h3 id="介绍-6"><a href="#介绍-6" class="headerlink" title="介绍"></a>介绍</h3><p>堆排序在 top K 问题中使用比较频繁。堆排序是采用二叉堆的数据结构来实现的，虽然实质上还是一维数组。堆（二叉堆）可以视为一棵完全的二叉树，完全二叉树的一个“优秀”的性质是，除了最底层之外，每一层都是满的，这使得堆可以利用数组来表示（普通的一般的二叉树通常用链表作为基本容器表示），每一个结点对应数组中的一个元素。</p><p>如下图，是一个堆和数组的相互关系，<strong>可看做堆的初始化</strong></p><p><img src="/2018/09/11/数据结构与算法/经典排序总结/07.jpg" alt></p><p>对于给定的某个结点的下标 i，可以很容易的计算出这个结点的父结点、孩子结点的下标：</p><ul><li>Parent(i) = floor(i/2)，i 的父节点下标</li><li>Left(i) = 2i，i 的左子节点下标</li><li>Right(i) = 2i + 1，i 的右子节点下标</li></ul><p><img src="/2018/09/11/数据结构与算法/经典排序总结/08.jpg" alt></p><p>二叉堆具有以下性质：</p><ol><li>父节点的键值总是大于或等于（小于或等于）任何一个子节点的键值。</li><li>每个节点的左右子树都是一个二叉堆（都是最大堆或最小堆）。</li></ol><p><img src="/2018/09/11/数据结构与算法/经典排序总结/09.gif" alt></p><p><img src="/2018/09/11/数据结构与算法/经典排序总结/10.gif" alt></p><h3 id="步骤-4"><a href="#步骤-4" class="headerlink" title="步骤"></a>步骤</h3><ol><li>构造最大堆（Build_Max_Heap）<strong>自底向上</strong>：若数组下标范围为0~n，<strong>考虑到单独一个元素是大根堆，则从下标n/2开始的元素均为大根堆</strong>。<strong>于是只要从n/2-1开始(最后一个非叶子节点开始)</strong>，<strong>分别与左孩子和右孩子比较大小，如果最大，则不用调整，否则和孩子中的值最大的一个交换位置，若交换之后还比此节点的孩子要小，继续向下交换（这里是自顶向下）</strong> 。并向前依次构造大根堆，这样就能保证，构造到某个节点时，它的左右子树都已经是大根堆。</li><li>堆排序（HeapSort）：由于堆是用数组模拟的。<strong>得到一个最大根堆后</strong>，数组内部并不是有序的。因此需要将堆化数组有序化。<strong>思想是总是移除根节点（用最后一个元素来填补空缺）</strong>，并做最大堆调整的递归运算。<strong>第一次将heap[0]与heap[n-1]交换，再对heap[0…n-2]做最大堆调整</strong>。第二次将heap[0]与heap[n-2]交换，再对heap[0…n-3]做最大堆调整。重复该操作直至heap[0]和heap[1]交换。由于每次都是将最大的数并入到后面的有序区间，故操作完后整个数组就是有序的了。</li><li>最大堆调整（Max_Heapify）：该方法是提供给上述两个过程调用的。目的是将堆的末端子节点作调整，使得子节点永远小于父节点 。</li></ol><p><strong>构造最大堆：</strong>先自底向上，再自顶向下</p><p><img src="/2018/09/11/数据结构与算法/经典排序总结/11.png" alt></p><p> <strong>调整最大堆</strong>：交换之后，被交换的节点从顶向下调整，调完继续交换，依次递归。 </p><p><img src="/2018/09/11/数据结构与算法/经典排序总结/12.png" alt></p><h3 id="源代码-6"><a href="#源代码-6" class="headerlink" title="源代码"></a>源代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_sort</span><span class="params">(ary)</span>:</span></span><br><span class="line">    n = len(ary)</span><br><span class="line">    first = int(n/<span class="number">2</span><span class="number">-1</span>)    <span class="comment">#最后一个非叶子节点</span></span><br><span class="line">    <span class="keyword">for</span> start <span class="keyword">in</span> range(first,<span class="number">-1</span>,<span class="number">-1</span>):    <span class="comment">#构建最大堆</span></span><br><span class="line">        max_heapify(ary,start,n<span class="number">-1</span>)</span><br><span class="line">    <span class="comment"># range(n-1,0,-1)因为0时不用和顶点自己交换</span></span><br><span class="line">    <span class="keyword">for</span> end <span class="keyword">in</span> range(n<span class="number">-1</span>,<span class="number">0</span>,<span class="number">-1</span>): <span class="comment">#堆排，将最大跟堆转换成有序数组，</span></span><br><span class="line">        ary[end],ary[<span class="number">0</span>] = ary[<span class="number">0</span>], ary[end]    <span class="comment">#将根节点元素与最后叶子节点进行互换，取出最大根节点元素，对剩余节点重新构建最大堆</span></span><br><span class="line">        max_heapify(ary,<span class="number">0</span>,end<span class="number">-1</span>)    <span class="comment">#因为end上面取的是n-1，故而这里直接放end-1，相当于忽略了最后最大根节点元素ary[n-1]</span></span><br><span class="line">    <span class="keyword">return</span> ary</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#最大堆调整：将堆的末端子节点作调整，使得子节点永远小于父节点</span></span><br><span class="line"><span class="comment">#start为当前需要调整最大堆的位置，end为调整边界</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max_heapify</span><span class="params">(ary,start,end)</span>:</span></span><br><span class="line">    root = start</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:  <span class="comment"># 记住这一句</span></span><br><span class="line">        child = root * <span class="number">2</span> + <span class="number">1</span>    <span class="comment">#调整节点的子节点,这里要注意数值下标从0开始，左节点为root * 2 + 1，这里都是下标表示</span></span><br><span class="line">        <span class="keyword">if</span> child &gt; end: <span class="comment"># 左子树超过边界，右子树肯定也超了</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> child + <span class="number">1</span> &lt;= end <span class="keyword">and</span> ary[child] &lt; ary[child+<span class="number">1</span>]: <span class="comment">#两个都没超，选数值大的下标</span></span><br><span class="line">            child = child + <span class="number">1</span>   <span class="comment">#取较大的子节点</span></span><br><span class="line">        <span class="comment"># 满足父节点比子节点小才叫交换</span></span><br><span class="line">        <span class="keyword">if</span> ary[root] &lt; ary[child]:    <span class="comment"># 子节点成为父节点；child为左子树或上一步较大的子节点</span></span><br><span class="line">            ary[root], ary[child] = ary[child], ary[root]    <span class="comment">#交换</span></span><br><span class="line">            root = child <span class="comment"># 调整时候要自顶向下继续调整，不要忘了这一句</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h2 id="时空复杂度总结"><a href="#时空复杂度总结" class="headerlink" title="时空复杂度总结"></a>时空复杂度总结</h2><p><img src="/2018/09/11/数据结构与算法/经典排序总结/13.png" alt></p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><blockquote><p>＂快些以O(nlog2n)O(nlog2n)的速度归队＂</p></blockquote><p>即快，希，归，堆都是O(nlog2n)O(nlog2n)，其他都是O(n2)O(n2)，基数排序例外，是O(d(n+rd))O(d(n+rd))</p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><ul><li>快排O(log2n)O(log2n)</li><li>归并O(n)O(n)</li><li>基数O(rd)O(rd)</li><li>其他O(1)O(1)</li></ul><h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><blockquote><p>＂心情不稳定，快些找一堆朋友聊天吧＂</p></blockquote><p>即不稳定的有：快，希，堆</p><h3 id="其他性质"><a href="#其他性质" class="headerlink" title="其他性质"></a>其他性质</h3><ul><li>直接插入排序，初始基本有序情况下，是O(n)O(n)</li><li>冒泡排序，初始基本有序情况下，是O(n)O(n)</li><li>快排在初始状态越差的情况下算法效果越好．</li><li>堆排序适合记录数量比较大的时候，从n个记录中选择k个记录．</li><li>经过一趟排序，元素可以在它最终的位置的有：交换类的（冒泡，快排），选择类的（简单选择，堆）</li><li>比较次数与初始序列无关的是：简单选择与折半插入</li><li>排序趟数与原始序列有关的是：交换类的（冒泡和快排）</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;先看一个排序算法可视化大概了解一下经典的排序算法。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html&quot; target=&quot;_blank&quot; rel=&quot;noopene
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="经典排序算法" scheme="http://yoursite.com/tags/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer解题_Python版</title>
    <link href="http://yoursite.com/2018/09/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer%E8%A7%A3%E9%A2%98_Python%E7%89%88/"/>
    <id>http://yoursite.com/2018/09/07/数据结构与算法/剑指offer解题_Python版/</id>
    <published>2018-09-07T09:06:11.000Z</published>
    <updated>2019-12-28T08:37:09.856Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-二维数组中的查找"><a href="#1-二维数组中的查找" class="headerlink" title="1.二维数组中的查找"></a>1.二维数组中的查找</h3><p><strong>题目：</strong> 在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p><strong>思路：</strong>遍历每一行，查找该元素是否在该行之中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># array 二维列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Find</span><span class="params">(self, target, array)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> array:</span><br><span class="line">            <span class="keyword">if</span> target <span class="keyword">in</span> i:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h3 id="2-替换空格"><a href="#2-替换空格" class="headerlink" title="2.替换空格"></a>2.替换空格</h3><p><strong>题目：</strong> 请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p><p><strong>思路：</strong>利用字符串中的replace直接替换即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># s 源字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replaceSpace</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> s.replace(<span class="string">' '</span>,<span class="string">'%20'</span>)</span><br></pre></td></tr></table></figure><h3 id="3-从尾到头打印链表"><a href="#3-从尾到头打印链表" class="headerlink" title="3.从尾到头打印链表"></a>3.从尾到头打印链表</h3><p><strong>题目：</strong>输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。</p><p><strong>思路：</strong>将链表中的值记录到list之中，然后进行翻转list。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回从尾部到头部的列表值序列，例如[1,2,3]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printListFromTailToHead</span><span class="params">(self, listNode)</span>:</span></span><br><span class="line">        l = list()</span><br><span class="line">        <span class="keyword">while</span> listNode:</span><br><span class="line">            l.append(listNode.val)</span><br><span class="line">            listNode=listNode.next</span><br><span class="line">        <span class="keyword">return</span> l[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h3 id="4-重建二叉树-flag"><a href="#4-重建二叉树-flag" class="headerlink" title="4.重建二叉树(flag)"></a>4.重建二叉树(flag)</h3><p><strong>题目：</strong>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p><p><strong>题解：</strong>首先前序遍历的第一个元素为二叉树的根结点，<strong>那么便能够在中序遍历之中找到根节点，那么在根结点左侧则是左子树；在根结点右侧，便是右子树</strong>。然后在递归遍历左子树和右子树。这里要注意一点，<strong>pre的左右子树分割长度与中序的左右子树分割长度一致</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回构造的TreeNode根节点</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reConstructBinaryTree</span><span class="params">(self, pre, tin)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(pre)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> len(pre)==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> TreeNode(pre[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            flag = TreeNode(pre[<span class="number">0</span>])</span><br><span class="line">            <span class="comment">#pre的左右子树分割长度与中序的左右子树分割长度一致。</span></span><br><span class="line">            flag.left = self.reConstructBinaryTree(pre[<span class="number">1</span>:tin.index(pre[<span class="number">0</span>])+<span class="number">1</span>],tin[:tin.index(pre[<span class="number">0</span>])])  </span><br><span class="line">            flag.right = self.reConstructBinaryTree(pre[tin.index(pre[<span class="number">0</span>])+<span class="number">1</span>:],tin[tin.index(pre[<span class="number">0</span>])+<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">return</span> flag</span><br></pre></td></tr></table></figure><h3 id="5-用两个栈实现队列-flag"><a href="#5-用两个栈实现队列-flag" class="headerlink" title="5.用两个栈实现队列(flag)"></a>5.用两个栈实现队列(flag)</h3><p><strong>题目：</strong>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p><p><strong>题解：</strong>申请两个栈Stack1和Stack2，Stack1当作输入，Stack2当作pop。<strong>当Stack2空的时候</strong>，将Stack1进行反转，并且输入到Stack2。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.Stack1=[]</span><br><span class="line">        self.Stack2=[]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        self.Stack1.append(node)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># return xx</span></span><br><span class="line">        <span class="keyword">if</span> self.Stack2==[]:</span><br><span class="line">            <span class="keyword">while</span> self.Stack1:</span><br><span class="line">                self.Stack2.append(self.Stack1.pop())</span><br><span class="line">            <span class="keyword">return</span> self.Stack2.pop()</span><br><span class="line">        <span class="keyword">return</span> self.Stack2.pop()</span><br></pre></td></tr></table></figure><h3 id="6-旋转数组的最小数字"><a href="#6-旋转数组的最小数字" class="headerlink" title="6.旋转数组的最小数字"></a>6.旋转数组的最小数字</h3><p><strong>题目：</strong>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumberInRotateArray</span><span class="params">(self, rotateArray)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> rotateArray:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            <span class="keyword">return</span> min(rotateArray)</span><br></pre></td></tr></table></figure><h3 id="7-斐波那契数列-flag"><a href="#7-斐波那契数列-flag" class="headerlink" title="7.斐波那契数列(flag)"></a>7.斐波那契数列(flag)</h3><p><strong>题目：</strong>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。n&lt;=39。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Fibonacci</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">1</span> <span class="keyword">or</span> n==<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        a,b=<span class="number">1</span>,<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-2</span>):</span><br><span class="line">            a,b=b,a+b</span><br><span class="line">        <span class="keyword">return</span> b</span><br></pre></td></tr></table></figure><h3 id="8-跳台阶"><a href="#8-跳台阶" class="headerlink" title="8.跳台阶"></a>8.跳台阶</h3><p><strong>题目：</strong>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p><p><strong>题解：</strong>ans[n]=ans[n-1]+ans[n-2]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jumpFloor</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> number:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> number==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> number==<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        a,b=<span class="number">1</span>,<span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(number<span class="number">-2</span>):</span><br><span class="line">            a,b=b,a+b</span><br><span class="line">        <span class="keyword">return</span> b</span><br></pre></td></tr></table></figure><h3 id="9-变态跳台阶"><a href="#9-变态跳台阶" class="headerlink" title="9.变态跳台阶"></a>9.变态跳台阶</h3><p><strong>题目：</strong>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><p><strong>题解：</strong>ans[n]=ans[n-1]+ans[n-2]+ans[n-3]+…+ans[n-n]，ans[n-1]=ans[n-2]+ans[n-3]+…+ans[n-n]，ans[n]=2*ans[n-1]。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jumpFloorII</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> number:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> number==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> number==<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>**(number<span class="number">-1</span>)</span><br></pre></td></tr></table></figure><h3 id="10-矩形覆盖"><a href="#10-矩形覆盖" class="headerlink" title="10.矩形覆盖"></a>10.矩形覆盖</h3><p><strong>题目：</strong>我们可以用2<em>1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2</em>1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p><p><strong>题解：</strong>新增加的小矩阵竖着放，则方法与n-1时相同，新增加的小矩阵横着放，则方法与n-2时相同，于是f(n)=f(n-1)+f(n-2)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rectCover</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> number:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> number==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> number==<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        a,b=<span class="number">1</span>,<span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(number<span class="number">-2</span>):</span><br><span class="line">            a,b=b,a+b</span><br><span class="line">        <span class="keyword">return</span> b</span><br></pre></td></tr></table></figure><h3 id="11-二进制中1的个数-flag"><a href="#11-二进制中1的个数-flag" class="headerlink" title="11.二进制中1的个数(flag)"></a>11.二进制中1的个数(flag)</h3><p><strong>题目：</strong>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p><p><strong>题解：</strong>每次进行右移一位，然后与1进行相与，如果是1则进行加1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 向右移1位可以看成除以2，向左移一位可以看成乘以2。移动n位可以看成乘以或者除以2的n次方。</span></span><br><span class="line"><span class="comment"># 负数原码（int整型用32位表示）所有位取反码然后+1得到补码；正数的补码为其自身</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>  <span class="comment">#转为字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">NumberOf1</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n&gt;<span class="number">0</span>:</span><br><span class="line">            a=bin(n).count(<span class="string">'1'</span>)</span><br><span class="line">            <span class="keyword">return</span> a</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            a=bin(<span class="number">2</span>**<span class="number">32</span>+n).count(<span class="string">'1'</span>)</span><br><span class="line">            <span class="keyword">return</span> a</span><br><span class="line">            </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span> <span class="comment">#每次移一位，看此为是否为1，负数的表示内部已经是补码了</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">NumberOf1</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">            count += (n &gt;&gt; i) &amp; <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><h3 id="12-数值的整次方"><a href="#12-数值的整次方" class="headerlink" title="12.数值的整次方"></a>12.数值的整次方</h3><p><strong>题目：</strong>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Power</span><span class="params">(self, base, exponent)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        ans=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,abs(exponent)):</span><br><span class="line">            ans=ans*base</span><br><span class="line">        <span class="keyword">if</span> exponent&gt;<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>/ans</span><br></pre></td></tr></table></figure><h3 id="13-调整数组顺序使奇数位于偶数前面"><a href="#13-调整数组顺序使奇数位于偶数前面" class="headerlink" title="13.调整数组顺序使奇数位于偶数前面"></a>13.调整数组顺序使奇数位于偶数前面</h3><p><strong>题目：</strong>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p><p><strong>题解：</strong>申请奇数数组和偶数数组，分别存放奇数值和偶数值，数组相加便为结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reOrderArray</span><span class="params">(self, array)</span>:</span></span><br><span class="line">        array=list(array)</span><br><span class="line">        a=[]</span><br><span class="line">        b=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> array:</span><br><span class="line">            <span class="keyword">if</span> i%<span class="number">2</span>==<span class="number">1</span>:</span><br><span class="line">                a.append(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                b.append(i)</span><br><span class="line">        <span class="keyword">return</span> a+b</span><br></pre></td></tr></table></figure><h3 id="14-链表中倒数第K个节点"><a href="#14-链表中倒数第K个节点" class="headerlink" title="14.链表中倒数第K个节点"></a>14.链表中倒数第K个节点</h3><p><strong>题目：</strong>输入一个链表，输出该链表中倒数第k个结点。</p><p><strong>题解：</strong>快慢指针。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindKthToTail</span><span class="params">(self, head, k)</span>:</span></span><br><span class="line">        l=[]</span><br><span class="line">        count=<span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        a1=head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> a1:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                a1=a1.next</span><br><span class="line">        a2=head</span><br><span class="line">        <span class="keyword">while</span> a1:</span><br><span class="line">            a1=a1.next</span><br><span class="line">            a2=a2.next</span><br><span class="line">        <span class="keyword">return</span> a2</span><br></pre></td></tr></table></figure><h3 id="15-反转链表-flag"><a href="#15-反转链表-flag" class="headerlink" title="15.反转链表(flag)"></a>15.反转链表(flag)</h3><p><strong>题目：</strong>输入一个链表，反转链表后，输出新链表的表头。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回ListNode</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ReverseList</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead.next:</span><br><span class="line">            <span class="keyword">return</span> pHead</span><br><span class="line">        Pre=<span class="literal">None</span></span><br><span class="line">        Next=<span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> pHead:</span><br><span class="line">            Next=pHead.next <span class="comment"># 暂存当前节点的下一个节点信息</span></span><br><span class="line">            pHead.next=Pre  <span class="comment"># 断开链表, 反转节点, 这两句都是为了保护链表断开不丢失next的指向</span></span><br><span class="line">            Pre=pHead</span><br><span class="line">            pHead=Next</span><br><span class="line">        <span class="keyword">return</span> Pre</span><br></pre></td></tr></table></figure><h3 id="16-合并两个排序的列表"><a href="#16-合并两个排序的列表" class="headerlink" title="16.合并两个排序的列表"></a>16.合并两个排序的列表</h3><p><strong>题目：</strong>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回合并后列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Merge</span><span class="params">(self, pHead1, pHead2)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead1 <span class="keyword">and</span> <span class="keyword">not</span> pHead2:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead1 <span class="keyword">or</span> <span class="keyword">not</span> pHead2:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> pHead1:</span><br><span class="line">                <span class="keyword">return</span> pHead2</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> pHead1</span><br><span class="line">        merge=ListNode(<span class="number">0</span>)<span class="comment"># 新一个头结点数值为x的链表</span></span><br><span class="line">        p=merge    <span class="comment">#返回时的指向头结点的指针</span></span><br><span class="line">        <span class="keyword">while</span> pHead1 <span class="keyword">and</span> pHead2:</span><br><span class="line">            <span class="keyword">if</span> pHead1.val&lt;=pHead2.val:</span><br><span class="line">                merge.next=pHead1</span><br><span class="line">                pHead1=pHead1.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                merge.next=pHead2</span><br><span class="line">                pHead2=pHead2.next</span><br><span class="line">            merge=merge.next</span><br><span class="line">        <span class="keyword">while</span> pHead1:</span><br><span class="line">            merge.next=pHead1</span><br><span class="line">            pHead1=pHead1.next</span><br><span class="line">            merge=merge.next</span><br><span class="line">        <span class="keyword">while</span> pHead2:</span><br><span class="line">            merge.next=pHead2</span><br><span class="line">            pHead2=pHead2.next</span><br><span class="line">            merge=merge.next</span><br><span class="line">        <span class="keyword">return</span> p.next</span><br></pre></td></tr></table></figure><h3 id="17-树的子结构-flag"><a href="#17-树的子结构-flag" class="headerlink" title="17.树的子结构(flag)"></a>17.树的子结构(flag)</h3><p><strong>题目：</strong>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）。</p><p><strong>题解：</strong>递归；或者将树转变为中序序列，然后转变为str类型，最后判断是否包含。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">HasSubtree</span><span class="params">(self, pRoot1, pRoot2)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot1 <span class="keyword">or</span> <span class="keyword">not</span> pRoot2:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        root1 = pRoot1</span><br><span class="line">        root2 = pRoot2</span><br><span class="line">        result = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> root1.val==root2.val:  <span class="comment"># HasSubtree条件出口，满足根节点相同才继续判断子树结构</span></span><br><span class="line">            result = self.hastree(root1,root2)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> result:</span><br><span class="line">            result = self.HasSubtree(root1.left,root2)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> result:</span><br><span class="line">            result = self.HasSubtree(root1.right,root2)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hastree</span><span class="params">(self,root1,root2)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root2==<span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> root1==<span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> root1.val==root2.val:</span><br><span class="line">            <span class="keyword">return</span> self.hastree(root1.left,root2.left) <span class="keyword">and</span> self.hastree(root1.right,root2.right)</span><br><span class="line">        <span class="keyword">if</span> root1.val!=root2.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h3 id="18-二叉树的镜像"><a href="#18-二叉树的镜像" class="headerlink" title="18.二叉树的镜像"></a>18.二叉树的镜像</h3><p><strong>题目：</strong> 操作给定的二叉树，将其变换为源二叉树的镜像。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回镜像树的根节点</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Mirror</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            root.left,root.right=root.right,root.left</span><br><span class="line">            self.Mirror(root.left)</span><br><span class="line">            self.Mirror(root.right)</span><br></pre></td></tr></table></figure><h3 id="19-顺时针打印矩阵-flag"><a href="#19-顺时针打印矩阵-flag" class="headerlink" title="19.顺时针打印矩阵(flag)"></a>19.顺时针打印矩阵(flag)</h3><p><strong>题目:</strong> 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># matrix类型为二维列表，需要返回列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printMatrix</span><span class="params">(self, matrix)</span>:</span></span><br><span class="line">        rows=len(matrix)</span><br><span class="line">        cols=len(matrix[<span class="number">0</span>])</span><br><span class="line">        l=[]</span><br><span class="line">        <span class="keyword">if</span> rows==<span class="number">1</span> <span class="keyword">and</span> cols==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> [matrix[<span class="number">0</span>][<span class="number">0</span>]]</span><br><span class="line">        left,right, up, down = <span class="number">0</span>,cols<span class="number">-1</span>,<span class="number">0</span>,rows<span class="number">-1</span>  <span class="comment">#这个是数组下标</span></span><br><span class="line">        <span class="keyword">while</span> left&lt;=right <span class="keyword">and</span> up&lt;=down:    </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(left,right+<span class="number">1</span>):     <span class="comment">#range函数接收参数从小到大，大的数值不计入</span></span><br><span class="line">                l.append(matrix[up][i])</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(up+<span class="number">1</span>,down+<span class="number">1</span>):</span><br><span class="line">                l.append(matrix[j][right])</span><br><span class="line">            <span class="keyword">if</span> down-up&gt;=<span class="number">1</span>:   <span class="comment">#相等时为剩余单行</span></span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(left,right)[::<span class="number">-1</span>]:   <span class="comment">#这里注意逆序的数组下标</span></span><br><span class="line">                    l.append(matrix[down][k])</span><br><span class="line">            <span class="keyword">if</span> right-left&gt;=<span class="number">1</span>:   <span class="comment">#相等时为剩余单列</span></span><br><span class="line">                <span class="keyword">for</span> p <span class="keyword">in</span> range(up+<span class="number">1</span>,down)[::<span class="number">-1</span>]:</span><br><span class="line">                    l.append(matrix[p][left])</span><br><span class="line">            up=up+<span class="number">1</span></span><br><span class="line">            down=down<span class="number">-1</span></span><br><span class="line">            left=left+<span class="number">1</span></span><br><span class="line">            right=right<span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> l</span><br></pre></td></tr></table></figure><h3 id="20-包含Min函数的栈-flag"><a href="#20-包含Min函数的栈-flag" class="headerlink" title="20.包含Min函数的栈(flag)"></a>20.包含Min函数的栈(flag)</h3><p><strong>题目：</strong>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.stack=[]</span><br><span class="line">        self.minstack=[]      <span class="comment">#pop()删除列表的最后一个元素,[-1]获取最后一个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, node)</span>:</span>     <span class="comment">#最小栈存储 整个原栈的最小元素，若最小元素在原栈删除，则也要删除最小栈</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.minstack <span class="keyword">or</span> node&lt;self.minstack[<span class="number">-1</span>]:   </span><br><span class="line">            self.minstack.append(node)</span><br><span class="line">        self.stack.append(node)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.stack:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">elif</span> self.stack[<span class="number">-1</span>]==self.minstack[<span class="number">-1</span>]:</span><br><span class="line">            self.minstack.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.stack.pop()</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.stack[<span class="number">-1</span>]</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">min</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.minstack[<span class="number">-1</span>]</span><br><span class="line">        <span class="comment"># write code here</span></span><br></pre></td></tr></table></figure><h3 id="21-栈的压入弹出序列-flag"><a href="#21-栈的压入弹出序列-flag" class="headerlink" title="21.栈的压入弹出序列(flag)"></a>21.栈的压入弹出序列(flag)</h3><p><strong>题目：</strong>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）。</p><p><strong>题解：</strong>构建压入和活动栈，只有处于压入栈栈顶或者活动栈内才可弹出；或者新构建一个中间栈，来模拟栈的输入和栈的输出，比对输入结果和输出结果是否相等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">IsPopOrder</span><span class="params">(self, pushV, popV)</span>:</span>  </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pushV:   </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        fixed=[]   <span class="comment">#压下去的辅助栈，处于栈顶可以出栈</span></span><br><span class="line">        left=pushV[:]   <span class="comment">#剩余的可活动栈，p元素位置之前的都要压入辅助栈</span></span><br><span class="line">        flag=<span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> popV:</span><br><span class="line">            <span class="keyword">if</span> p <span class="keyword">not</span> <span class="keyword">in</span> pushV:   <span class="comment">#还要判断pushV和popV元素不同的情况</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> p <span class="keyword">in</span> left:</span><br><span class="line">                k=left.index(p)</span><br><span class="line">                fixed=fixed+left[:k+<span class="number">1</span>]</span><br><span class="line">                left=left[k+<span class="number">1</span>:]</span><br><span class="line">                fixed.pop()</span><br><span class="line">            <span class="keyword">elif</span> fixed:  <span class="comment">#避免fixed[-1]越界</span></span><br><span class="line">                <span class="keyword">if</span> p!=fixed[<span class="number">-1</span>]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">else</span>:fixed.pop()</span><br><span class="line">        <span class="keyword">return</span> flag</span><br></pre></td></tr></table></figure><h3 id="22-从上往下打印二叉树"><a href="#22-从上往下打印二叉树" class="headerlink" title="22.从上往下打印二叉树"></a>22.从上往下打印二叉树</h3><p><strong>题目：</strong>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p><p><strong>思路：</strong>层次遍历，用队列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回从上到下每个节点值列表，例：[1,2,3]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">PrintFromTopToBottom</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        res=[]</span><br><span class="line">        value=[]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []  <span class="comment">#返回空列表，而不是None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res.append(root)</span><br><span class="line">            value.append(root.val)</span><br><span class="line">        <span class="keyword">while</span> res:</span><br><span class="line">            p=res.pop(<span class="number">0</span>)   <span class="comment"># pop(0)才是第一个元素</span></span><br><span class="line">            <span class="keyword">if</span> p.left:</span><br><span class="line">                res.append(p.left)</span><br><span class="line">                value.append(p.left.val)</span><br><span class="line">            <span class="keyword">if</span> p.right:</span><br><span class="line">                res.append(p.right)</span><br><span class="line">                value.append(p.right.val)</span><br><span class="line">        <span class="keyword">return</span> value</span><br></pre></td></tr></table></figure><h3 id="23-二叉树的后续遍历序列-flag"><a href="#23-二叉树的后续遍历序列-flag" class="headerlink" title="23.二叉树的后续遍历序列(flag)"></a>23.二叉树的后续遍历序列(flag)</h3><p><strong>题目：</strong>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p><p><strong>思路：</strong>二叉搜索树的特性是所有左子树值都小于中节点，所有右子树的值都大于中节点，递归遍历左子树和右子树的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># 后续遍历要满足 去除序列最后一个元素（根）后，将小于和大于这个元素直接分成两段，递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">VerifySquenceOfBST</span><span class="params">(self, sequence)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> sequence:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> len(sequence)==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        front=[]</span><br><span class="line">        back=[]</span><br><span class="line">        flag=<span class="number">0</span>  <span class="comment"># 辅助与分段的标记，第一个大于p元素之后的都放在back断</span></span><br><span class="line">        p=sequence.pop()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> sequence:</span><br><span class="line">            <span class="keyword">if</span> i&lt;=p <span class="keyword">and</span> flag==<span class="number">0</span>:</span><br><span class="line">                front.append(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                flag=<span class="number">1</span></span><br><span class="line">                back.append(i)</span><br><span class="line">        <span class="keyword">if</span> front <span class="keyword">and</span> max(front)&gt;p:  <span class="comment">#front要满足所有元素都小于p</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> back <span class="keyword">and</span> min(back)&lt;p: <span class="comment">#back要满足所有元素都大于p</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        LEFT=<span class="literal">True</span>  <span class="comment">#递归出口</span></span><br><span class="line">        RIGHT=<span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> front:</span><br><span class="line">            LEFT=self.VerifySquenceOfBST(front)</span><br><span class="line">        <span class="keyword">if</span> back:</span><br><span class="line">            RIGHT=self.VerifySquenceOfBST(back)</span><br><span class="line">        <span class="keyword">return</span> LEFT <span class="keyword">and</span> RIGHT</span><br></pre></td></tr></table></figure><h3 id="24-二叉树中和为某一值的路径-flag"><a href="#24-二叉树中和为某一值的路径-flag" class="headerlink" title="24.二叉树中和为某一值的路径(flag)"></a>24.二叉树中和为某一值的路径(flag)</h3><p><strong>题目：</strong>输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回二维列表，内部每个列表表示找到的路径</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindPath</span><span class="params">(self, root, expectNumber)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment"># 这题不太会，记一下</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="comment">#即是一开始条件语句，也是递归出口，若叶子节点不满足条件，left或者right返回空</span></span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">and</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right <span class="keyword">and</span> root.val == expectNumber:</span><br><span class="line">            <span class="keyword">return</span> [[root.val]]  <span class="comment">#递归出口，即叶子节点满足条件，不会执行以下任何语句；</span></span><br><span class="line">                                 </span><br><span class="line">        res = [] <span class="comment">#每次清空</span></span><br><span class="line">        <span class="comment"># 先会一直先递归left，相当于深度优先搜索</span></span><br><span class="line">        left = self.FindPath(root.left, expectNumber-root.val) <span class="comment">#left_left1_left11_right11_...right1</span></span><br><span class="line">        right = self.FindPath(root.right, expectNumber-root.val)</span><br><span class="line">        <span class="comment"># 遍历后的操作</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> left+right:  <span class="comment">#是指里面的元素，[[root.val]]得到的元素是[root.val]</span></span><br><span class="line">            res.append([root.val]+i)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">   <span class="comment">#      6        左图所示，left返回[[3]],right返回的res为[].append([2]+[1])=[[2,1]]</span></span><br><span class="line">    <span class="comment">#   3   2      最后一层返回[[6,3],[6,2,1]]</span></span><br><span class="line">     <span class="comment">#     1</span></span><br></pre></td></tr></table></figure><h3 id="25-复杂链表的复制-flag"><a href="#25-复杂链表的复制-flag" class="headerlink" title="25.复杂链表的复制(flag)"></a>25.复杂链表的复制(flag)</h3><p><strong>题目：</strong>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）。</p><p><strong>思路：</strong></p><p>1、遍历链表，复制每个结点，如复制结点A得到A1，将结点A1插到结点A后面（暂不处理随机节点）；</p><p>2、重新遍历链表，复制老结点的随机指针给新结点，如A1.random = A.random.next;</p><p>3、拆分链表，将链表拆分为原链表和复制后的链表</p><p><img src="/2018/09/07/数据结构与算法/剑指offer解题_Python版/01.png" alt></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.label = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line">        self.random = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回 RandomListNode</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Clone</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        pCur = pHead</span><br><span class="line">        <span class="keyword">while</span> pCur:</span><br><span class="line">            node = RandomListNode(pCur.label)</span><br><span class="line">            node.next = pCur.next</span><br><span class="line">            pCur.next = node</span><br><span class="line">            pCur = node.next</span><br><span class="line">        pCur = pHead</span><br><span class="line">        <span class="keyword">while</span> pCur:</span><br><span class="line">            <span class="keyword">if</span> pCur.random:</span><br><span class="line">                pCur.next.random = pCur.random</span><br><span class="line">            pCur = pCur.next.next</span><br><span class="line">        pCur = pHead</span><br><span class="line">        cur = pHead.next</span><br><span class="line">        h = cur</span><br><span class="line">        <span class="keyword">while</span> cur:  <span class="comment">#拆分</span></span><br><span class="line">            pCur.next = cur.next</span><br><span class="line">            <span class="keyword">if</span> pCur.next:</span><br><span class="line">                cur.next = pCur.next.next</span><br><span class="line">            pCur = pCur.next</span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="keyword">return</span> h</span><br></pre></td></tr></table></figure><h3 id="26-二叉搜索树与双向列表"><a href="#26-二叉搜索树与双向列表" class="headerlink" title="26.二叉搜索树与双向列表"></a>26.二叉搜索树与双向列表</h3><p><strong>题目：</strong>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p><p><strong>思路：</strong>中序遍历，然后添加一个pre指针</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.a=[]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Convert</span><span class="params">(self, pRootOfTree)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">         </span><br><span class="line">        <span class="keyword">if</span> pRootOfTree==<span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        self.Convert(pRootOfTree.left)</span><br><span class="line">        self.a.append(pRootOfTree)</span><br><span class="line">        self.Convert(pRootOfTree.right)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(self.a)<span class="number">-1</span>):</span><br><span class="line">            self.a[i].right=self.a[i+<span class="number">1</span>]</span><br><span class="line">            self.a[i+<span class="number">1</span>].left=self.a[i]</span><br><span class="line">        <span class="keyword">return</span> self.a[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h3 id="27-字符串的排列-flag"><a href="#27-字符串的排列-flag" class="headerlink" title="27.字符串的排列(flag)"></a>27.字符串的排列(flag)</h3><p><strong>题目：</strong>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p><p><strong>输入：</strong>输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。</p><p><strong>思路：</strong>用itertools.permutations;或者通过将固定每一位的字符，然后进行和后面的每个字符进行交换，得到所有结果集。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Permutation</span><span class="params">(self, ss)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> ss:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">return</span> sorted(list(set(map(<span class="string">''</span>.join, itertools.permutations(ss)))))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#  abc</span></span><br><span class="line">    <span class="comment">#  itertools.permutations(ss)输出('a','b','c') ('a','c','b')...等</span></span><br><span class="line">    <span class="comment">#  map函数后为abc acb..</span></span><br></pre></td></tr></table></figure><h3 id="28-数组中出现次数超过一般的数字"><a href="#28-数组中出现次数超过一般的数字" class="headerlink" title="28.数组中出现次数超过一般的数字"></a>28.数组中出现次数超过一般的数字</h3><p><strong>题目：</strong>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0</p><p><strong>题解：</strong>判断是否有超过一半的元素，如果有则在数组中间的元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(self, numbers)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> numbers:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(numbers)==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> numbers[<span class="number">0</span>]</span><br><span class="line">        l=len(numbers)//<span class="number">2</span></span><br><span class="line">        k=sorted(list(numbers))  <span class="comment">#排序，满足条件处于中间位置的为最多元素</span></span><br><span class="line">        count=<span class="number">0</span>                  <span class="comment">#不满足条件则遍历判断 此元素maxcount是否超过一半</span></span><br><span class="line">        maxcount=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(k)<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> k[i]==k[i+<span class="number">1</span>]:</span><br><span class="line">                count=count+<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> count&gt;maxcount:</span><br><span class="line">                    maxcount=count</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count=<span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> maxcount&gt;=l:</span><br><span class="line">            <span class="keyword">return</span> k[l]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="29-最小的K个数"><a href="#29-最小的K个数" class="headerlink" title="29.最小的K个数"></a>29.最小的K个数</h3><p><strong>题目：</strong>输入n个整数，找出其中最小的K个数，例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetLeastNumbers_Solution</span><span class="params">(self, tinput, k)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> len(tinput)&lt;k:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res=sorted(tinput)</span><br><span class="line">        <span class="keyword">return</span> res[:k]</span><br></pre></td></tr></table></figure><h3 id="30-连续子数组的最大和-flag"><a href="#30-连续子数组的最大和-flag" class="headerlink" title="30.连续子数组的最大和(flag)"></a>30.连续子数组的最大和(flag)</h3><p><strong>题目：</strong>HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。你会不会被他忽悠住？(子向量的长度至少是1)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(self, array)</span>:</span></span><br><span class="line">        <span class="comment"># write code here  只需要返回最大数，下标不管</span></span><br><span class="line">        <span class="comment"># 思路：创建一个列表储存要加入的元素，当累积和小于0则清空前面一段</span></span><br><span class="line">        <span class="comment"># 另外一个更简单的思路PART2</span></span><br><span class="line">        <span class="keyword">if</span> len(array)==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> array[<span class="number">0</span>]  </span><br><span class="line">        <span class="keyword">if</span> max(array)&lt;=<span class="number">0</span>:  <span class="comment">#全是负数</span></span><br><span class="line">            <span class="keyword">return</span> max(array)</span><br><span class="line">        <span class="keyword">if</span> min(array)&gt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> sum(array)</span><br><span class="line">        cum_max=<span class="number">0</span></span><br><span class="line">        maxnum=<span class="number">0</span></span><br><span class="line">        res=[]</span><br><span class="line">        <span class="keyword">for</span>  k, i <span class="keyword">in</span> enumerate(array):  </span><br><span class="line">            <span class="keyword">if</span> cum_max+i&gt;=<span class="number">0</span> <span class="keyword">and</span> max(array[k:])&gt;<span class="number">0</span>: <span class="comment"># 注意一点，当前数组后面全是负数，不能再加了</span></span><br><span class="line">                res.append(i)</span><br><span class="line">                cum_max=cum_max+i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment">#curmax=0  #此时可以记下标，这里不要求</span></span><br><span class="line">                cum_max=<span class="number">0</span></span><br><span class="line">                <span class="keyword">if</span> sum(res)&gt;maxnum:</span><br><span class="line">                    maxnum=sum(res)</span><br><span class="line">                res=[]</span><br><span class="line">        <span class="keyword">return</span> max(maxnum,sum(res))    <span class="comment">#sum(res)是最后数组res一直加入元素而没有更新maxnum </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># ======================part2：==========================</span></span><br><span class="line">    <span class="comment"># class Solution:</span></span><br><span class="line">    <span class="comment">#    def FindGreatestSumOfSubArray(self, array):</span></span><br><span class="line">    <span class="comment">#        maxnum= float(-inf)</span></span><br><span class="line">    <span class="comment">#        cum_max= 0</span></span><br><span class="line">    <span class="comment">#        for i in array:</span></span><br><span class="line">    <span class="comment">#            if cum_max+i&lt;0:</span></span><br><span class="line">    <span class="comment">#                cum_max=i        #这一句是精华，什么都不作处理，下一个值当做cum_max</span></span><br><span class="line">    <span class="comment">#            else:</span></span><br><span class="line">    <span class="comment">#                cum_max=cum_max+i</span></span><br><span class="line">    <span class="comment">#            if cum_max&gt;maxnum:</span></span><br><span class="line">    <span class="comment">#                maxnum=cum_max</span></span><br><span class="line">    <span class="comment">#            return maxnum</span></span><br></pre></td></tr></table></figure><h3 id="31-整数中1出现的次数"><a href="#31-整数中1出现的次数" class="headerlink" title="31.整数中1出现的次数"></a>31.整数中1出现的次数</h3><p><strong>题目：</strong>求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        count=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>+n):</span><br><span class="line">            count=count+str(i).count(<span class="string">'1'</span>)</span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><h3 id="32-把数组排成最小的数-flag"><a href="#32-把数组排成最小的数-flag" class="headerlink" title="32.把数组排成最小的数(flag)"></a>32.把数组排成最小的数(flag)</h3><p><strong>题目：</strong>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p><p><strong>思路：</strong>将数组转换成字符串之后，进行两两比较字符串的大小，比如3,32的大小由332和323确定，即3+32和32+3确定。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">PrintMinNumber</span><span class="params">(self, numbers)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> numbers:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">        cmp_def = <span class="keyword">lambda</span> x1,x2: int(str(x1)+str(x2))-int(str(x2)+str(x1))</span><br><span class="line">        a=sorted(numbers,cmp=cmp_def)  <span class="comment">#sortef创建副本，sort原地</span></span><br><span class="line">        b=list(map(<span class="keyword">lambda</span> x:str(x),a)) <span class="comment">#列表数字转字符串</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(b)  <span class="comment">#jion反馈一个字符串</span></span><br></pre></td></tr></table></figure><h3 id="33-丑数-flag"><a href="#33-丑数-flag" class="headerlink" title="33.丑数(flag)"></a>33.丑数(flag)</h3><p><strong>题目：</strong>把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p><p><strong>思路：</strong>每一个丑数必然是由之前的某个丑数与2，3或5的乘积得到的，这样下一个丑数就用之前的丑数分别乘以2，3，5，找出这三这种最小的并且大于当前最大丑数的值，即为下一个要求的丑数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        <span class="comment"># write code herei</span></span><br><span class="line">        <span class="comment"># 思路，创建一个数组存储丑数；创建三个丑数数组独立下标对应乘以235，最小为当前丑数</span></span><br><span class="line">        <span class="keyword">if</span> index==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> index==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        uglyarr=[<span class="number">1</span>]</span><br><span class="line">        a2,a3,a5=<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(index<span class="number">-1</span>):</span><br><span class="line">            n1,n2,n3=uglyarr[a2]*<span class="number">2</span>,uglyarr[a3]*<span class="number">3</span>,uglyarr[a5]*<span class="number">5</span>        </span><br><span class="line">            min_num=min(n1,n2,n3)</span><br><span class="line">            uglyarr.append(min_num)</span><br><span class="line">            <span class="keyword">if</span> min_num==n1:</span><br><span class="line">                a2=a2+<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> min_num==n2:</span><br><span class="line">                a3=a3+<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> min_num==n3:</span><br><span class="line">                a5=a5+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> uglyarr[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h3 id="34-第一个只出现一次的字符"><a href="#34-第一个只出现一次的字符" class="headerlink" title="34.第一个只出现一次的字符"></a>34.第一个只出现一次的字符</h3><p><strong>题目：</strong>在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        ss=list(s)</span><br><span class="line">        <span class="keyword">for</span> i,e <span class="keyword">in</span> enumerate(ss):</span><br><span class="line">            <span class="keyword">if</span> s.count(e)==<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h3 id="35-数组中的逆序对-Flag"><a href="#35-数组中的逆序对-Flag" class="headerlink" title="35.数组中的逆序对(Flag)"></a>35.数组中的逆序对(Flag)</h3><p><strong>题目描述：</strong>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007。</p><p><strong>输入描述：</strong>题目保证输入的数组中没有的相同的数字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">/*</span></span><br><span class="line"><span class="string">归并排序的改进，把数据分成前后两个数组(递归分到每个数组仅有一个数据项)，合并数组，合并时，出现前面的数组值array[i]大于后面数组值array[j]时；则前面数组array[i]~array[mid]都是大于array[j]的，</span></span><br><span class="line"><span class="string">count += mid+1 - i参考剑指Offer，但是感觉剑指Offer归并过程少了一步拷贝过程。还有就是测试用例输出结果比较大，对每次返回的count mod(1000000007)求余</span></span><br><span class="line"><span class="string">*/</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">InversePairs</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> self.inverseCount(data[:], <span class="number">0</span>, len(data)<span class="number">-1</span>, data[:])%<span class="number">1000000007</span></span><br><span class="line">       </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inverseCount</span><span class="params">(self, tmp, start, end, data)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> end-start &lt;<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> end - start == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> data[start]&lt;=data[end]:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        mid = (start+end)//<span class="number">2</span></span><br><span class="line">        cnt = self.inverseCount(data, start, mid, tmp) + self.inverseCount(data, mid+<span class="number">1</span>, end, tmp)</span><br><span class="line">        <span class="comment"># print(start, mid, end, cnt, data)</span></span><br><span class="line">        i = start</span><br><span class="line">        j = mid + <span class="number">1</span></span><br><span class="line">        ind = start  <span class="comment"># 用于tmp的下标</span></span><br><span class="line">           </span><br><span class="line">        <span class="keyword">while</span>(i &lt;= mid <span class="keyword">and</span> j &lt;= end): <span class="comment"># tmp排序</span></span><br><span class="line">            <span class="keyword">if</span> data[i] &lt;= data[j]:</span><br><span class="line">                tmp[ind] = data[i]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tmp[ind] = data[j]</span><br><span class="line">                cnt += mid - i + <span class="number">1</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            ind += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid):</span><br><span class="line">            tmp[ind] = data[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            ind += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span>(j&lt;=end):</span><br><span class="line">            tmp[ind] = data[j]</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">            ind += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> cnt</span><br></pre></td></tr></table></figure><h3 id="36-两个链表的第一个公共节点"><a href="#36-两个链表的第一个公共节点" class="headerlink" title="36.两个链表的第一个公共节点"></a>36.两个链表的第一个公共节点</h3><p><strong>题目：</strong>输入两个链表，找出它们的第一个公共结点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#有些题的输入指针，没有val属性，只有next</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindFirstCommonNode</span><span class="params">(self, pHead1, pHead2)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead1 <span class="keyword">or</span> <span class="keyword">not</span> pHead2:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> pHead1:</span><br><span class="line">            p2=pHead2  </span><br><span class="line">            <span class="keyword">while</span> p2:</span><br><span class="line">                <span class="keyword">if</span> pHead1==p2:</span><br><span class="line">                    <span class="keyword">return</span> pHead1</span><br><span class="line">                p2=p2.next</span><br><span class="line">            pHead1=pHead1.next</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><h3 id="37-数字在排序数组中出现的次数"><a href="#37-数字在排序数组中出现的次数" class="headerlink" title="37.数字在排序数组中出现的次数"></a>37.数字在排序数组中出现的次数</h3><p><strong>题目：</strong>统计一个数字在排序数组中出现的次数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetNumberOfK</span><span class="params">(self, data, k)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        count=<span class="number">0</span></span><br><span class="line">        flag=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> data:</span><br><span class="line">            <span class="keyword">if</span> i==k:</span><br><span class="line">                count=count+<span class="number">1</span></span><br><span class="line">                flag=<span class="number">1</span>  <span class="comment">#设置处在相同阶段的标志</span></span><br><span class="line">            <span class="keyword">if</span> count&gt;<span class="number">0</span> <span class="keyword">and</span> flag!=<span class="number">1</span>: <span class="comment">#不在相同阶段就break </span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><h3 id="38-二叉树的深度-flag"><a href="#38-二叉树的深度-flag" class="headerlink" title="38.二叉树的深度(flag)"></a>38.二叉树的深度(flag)</h3><p><strong>题目：</strong>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">TreeDepth</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left=self.TreeDepth(pRoot.left)  <span class="comment">#操作放在后面，想象后序遍历</span></span><br><span class="line">        right=self.TreeDepth(pRoot.right)</span><br><span class="line">        <span class="keyword">return</span> max(left,right)+<span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="39-平衡二叉树-flag"><a href="#39-平衡二叉树-flag" class="headerlink" title="39.平衡二叉树(flag)"></a>39.平衡二叉树(flag)</h3><p><strong>题目：</strong>输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p><p><strong>题解：</strong>平衡二叉树是左右子数的距离不能大于1，因此递归左右子树，判断子树距离是否大于1。用Maxdeep递归求深度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">IsBalanced_Solution</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment"># 递归且有一个实现求深度的递归函数</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> abs(self.Maxdeep(pRoot.left)-self.Maxdeep(pRoot.right))&gt;<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> self.IsBalanced_Solution(pRoot.left) <span class="keyword">and</span> self.IsBalanced_Solution(pRoot.right)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Maxdeep</span><span class="params">(self,pRoot)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left = self.Maxdeep(pRoot.left)</span><br><span class="line">        right = self.Maxdeep(pRoot.right)</span><br><span class="line">        <span class="keyword">return</span> max(left,right)+<span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="40-数组中只出现一次的数字"><a href="#40-数组中只出现一次的数字" class="headerlink" title="40.数组中只出现一次的数字"></a>40.数组中只出现一次的数字</h3><p><strong>题目：</strong>一个整型数组里除了两个数字之外，其他的数字都出现了偶数次。请写程序找出这两个只出现一次的数字。</p><p><strong>题解：</strong>转为字符串；或者将数组中数转到set之中，然后利用dict存储每个数字出现的次数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回[a,b] 其中ab是出现一次的两个数字</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindNumsAppearOnce</span><span class="params">(self, array)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> array:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> len(array)==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> array[<span class="number">0</span>]</span><br><span class="line">        l=[]</span><br><span class="line">        arr_str_list=list(map(<span class="keyword">lambda</span> x:str(x),array))</span><br><span class="line">        arr_str=<span class="string">''</span>.join(arr_str_list) <span class="comment">#输入要为字符列表</span></span><br><span class="line">        <span class="keyword">for</span> i,e <span class="keyword">in</span> enumerate(arr_str_list):</span><br><span class="line">            <span class="keyword">if</span> arr_str.count(e)==<span class="number">1</span>:</span><br><span class="line">                l.append(i)</span><br><span class="line">        ll=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> l:</span><br><span class="line">            ll.append(array[i])</span><br><span class="line">        <span class="keyword">return</span> ll</span><br><span class="line"><span class="comment"># ====================================</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回[a,b] 其中ab是出现一次的两个数字</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindNumsAppearOnce</span><span class="params">(self, array)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        arrayset=set(array)</span><br><span class="line">        dict=&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> arrayset:</span><br><span class="line">            dict[num]=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(array)):</span><br><span class="line">            dict[array[i]]=dict[array[i]]+<span class="number">1</span></span><br><span class="line">        ans=[]</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> arrayset:</span><br><span class="line">            <span class="keyword">if</span> dict[num]==<span class="number">1</span>:</span><br><span class="line">                ans.append(num)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="41-和为S的连续正整数序列"><a href="#41-和为S的连续正整数序列" class="headerlink" title="41.和为S的连续正整数序列"></a>41.和为S的连续正整数序列</h3><p><strong>题目：</strong>小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!</p><p><strong>输出描述：</strong>输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindContinuousSequence</span><span class="params">(self, tsum)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment">#若是100,只需要从1：50找就可以了，+2是考虑到下标0开始，让搜索范围大一些</span></span><br><span class="line">        bitsum=tsum//<span class="number">2</span>+<span class="number">2</span> </span><br><span class="line">        ori=list(range(<span class="number">1</span>,bitsum)) </span><br><span class="line">        res=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,bitsum):</span><br><span class="line">            l=[]</span><br><span class="line">            summ=i <span class="comment">#累积总和</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,bitsum):</span><br><span class="line">                summ=summ+j</span><br><span class="line">                <span class="keyword">if</span> summ==tsum:</span><br><span class="line">                    l=ori[i<span class="number">-1</span>:j] <span class="comment">#i,j看做下标返回满足条件的数组</span></span><br><span class="line">                <span class="keyword">if</span> summ&gt;tsum:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> l:</span><br><span class="line">                res.append(l)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="42-和为S的两个数字-flag"><a href="#42-和为S的两个数字-flag" class="headerlink" title="42.和为S的两个数字(flag)"></a>42.和为S的两个数字(flag)</h3><p><strong>题目：</strong>输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。</p><p><strong>输出描述：</strong>对应每个测试案例，输出两个数，小的先输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindNumbersWithSum</span><span class="params">(self, array, tsum)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment"># 返回列表类型的，若不满足条件则[]</span></span><br><span class="line">        <span class="keyword">if</span> len(array)&lt;=<span class="number">1</span> <span class="keyword">or</span> min(array)&gt;tsum:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(array)):  <span class="comment"># 都是索引下标循环</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,len(array)): </span><br><span class="line">                <span class="keyword">if</span> array[i]+array[j]==tsum:</span><br><span class="line">                    <span class="comment"># 从头开始搜索这时候得到的应该是乘积最小的，可以直接退出外层循环</span></span><br><span class="line">                    res.append(array[i])</span><br><span class="line">                    res.append(array[j])</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> array[j]&gt;tsum:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment"># 上面循环正常结束才会执行，若上面循环执行break则这条语句不执行</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">if</span> res:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure><h3 id="43-左旋字符子串"><a href="#43-左旋字符子串" class="headerlink" title="43.左旋字符子串"></a>43.左旋字符子串</h3><p><strong>题目：</strong>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">LeftRotateString</span><span class="params">(self, s, n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> len(s)&lt;n <span class="keyword">or</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        <span class="keyword">return</span> s[n:]+s[:n]</span><br></pre></td></tr></table></figure><h3 id="44-反转单词顺序-flag"><a href="#44-反转单词顺序-flag" class="headerlink" title="44.反转单词顺序(flag)"></a>44.反转单词顺序(flag)</h3><p><strong>题目：</strong>牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ReverseSentence</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        ss=s.split(<span class="string">' '</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">' '</span>.join(ss[::<span class="number">-1</span>])</span><br></pre></td></tr></table></figure><h3 id="45-扑克牌顺序"><a href="#45-扑克牌顺序" class="headerlink" title="45.扑克牌顺序"></a>45.扑克牌顺序</h3><p><strong>题目：</strong>LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\小王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">IsContinuous</span><span class="params">(self, numbers)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment"># 只需要判断没有0的数组里数值是唯一且max-min&lt;5即可</span></span><br><span class="line">        <span class="keyword">if</span> len(numbers)&lt;<span class="number">5</span> <span class="keyword">and</span> <span class="keyword">not</span> numbers:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        grost_num=<span class="number">0</span></span><br><span class="line">        without_gro=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> numbers:</span><br><span class="line">            <span class="keyword">if</span> i==<span class="number">0</span>:</span><br><span class="line">                grost_num+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> i <span class="keyword">in</span> without_gro <span class="keyword">and</span> i!=<span class="number">0</span>: <span class="comment">#唯一</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                without_gro.append(i)</span><br><span class="line">        <span class="keyword">if</span> max(without_gro)-min(without_gro)&lt;<span class="number">5</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h3 id="46-孩子们的圈圈-圈圈中最后剩下的数-flag"><a href="#46-孩子们的圈圈-圈圈中最后剩下的数-flag" class="headerlink" title="46.孩子们的圈圈(圈圈中最后剩下的数)(flag)"></a>46.孩子们的圈圈(圈圈中最后剩下的数)(flag)</h3><p><strong>题目：</strong>每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">LastRemaining_Solution</span><span class="params">(self, n, m)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment"># flag=0</span></span><br><span class="line">        <span class="comment"># 把index想象为连续拼接数组</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n <span class="keyword">or</span> <span class="keyword">not</span> m:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        num = list(range(n))</span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> len(num)&gt;<span class="number">1</span>: <span class="comment"># 剩余两个都要继续执行</span></span><br><span class="line">            index=(index+m<span class="number">-1</span>)%len(num) <span class="comment">#index为上一次停的地方，加上m-1为重新第m-1个出列</span></span><br><span class="line">            num.pop(index)</span><br><span class="line">        <span class="keyword">return</span> num[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h3 id="47-求1-2-3-…-n"><a href="#47-求1-2-3-…-n" class="headerlink" title="47.求1+2+3+…+n"></a>47.求1+2+3+…+n</h3><p><strong>题目：</strong>求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Sum_Solution</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> n+self.Sum_Solution(n<span class="number">-1</span>)</span><br></pre></td></tr></table></figure><h3 id="48-不用加减乘除做加法"><a href="#48-不用加减乘除做加法" class="headerlink" title="48.不用加减乘除做加法"></a>48.不用加减乘除做加法</h3><p><strong>题目：</strong>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。</p><p><strong>思路：</strong>二进制异或进位。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Add</span><span class="params">(self, num1, num2)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment"># 位操作不懂</span></span><br><span class="line">        <span class="keyword">return</span> sum([num1,num2])</span><br><span class="line">        </span><br><span class="line"><span class="comment"># ============================</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">首先看十进制是如何做的： 5+7=12，三步走</span></span><br><span class="line"><span class="string">第一步：相加各位的值，不算进位，得到2。</span></span><br><span class="line"><span class="string">第二步：计算进位值，得到10. 如果这一步的进位值为0，那么第一步得到的值就是最终结果。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">第三步：重复上述两步，只是相加的值变成上述两步的得到的结果2和10，得到12。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">同样我们可以用三步走的方式计算二进制值相加： 5-101，7-111 第一步：相加各位的值，不算进位，得到010，二进制每位相加就相当于各位做异或操作，101^111。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">第二步：计算进位值，得到1010，相当于各位做与操作得到101，再向左移一位得到1010，(101&amp;111)&lt;&lt;1。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">第三步重复上述两步， 各位相加 010^1010=1000，进位值为100=(010&amp;1010)&lt;&lt;1。</span></span><br><span class="line"><span class="string">     继续重复上述两步：1000^100 = 1100，进位值为0，跳出循环，1100为最终结果。</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Add</span><span class="params">(self, num1, num2)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">while</span> num2!=<span class="number">0</span>:</span><br><span class="line">            sum=num1^num2</span><br><span class="line">            carry=(num1&amp;num2)&lt;&lt;<span class="number">1</span></span><br><span class="line">            num1=sum</span><br><span class="line">            num2=carry</span><br><span class="line">        <span class="keyword">return</span> num1</span><br></pre></td></tr></table></figure><h3 id="49-把字符串转换成整数"><a href="#49-把字符串转换成整数" class="headerlink" title="49.把字符串转换成整数"></a>49.把字符串转换成整数</h3><p><strong>题目：</strong>将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。</p><p><strong>输入描述：</strong>输入一个字符串,包括数字字母符号,可以为空输出描述:如果是合法的数值表达则返回该数字，否则返回0。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">StrToInt</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        l=[s]</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            num=list(map(eval,l))  </span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> num[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h3 id="50-数组中重复的数字"><a href="#50-数组中重复的数字" class="headerlink" title="50.数组中重复的数字"></a>50.数组中重复的数字</h3><p><strong>题目：</strong>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p><p><strong>思路：</strong>利用dict计算重复数字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 这里要特别注意~找到任意重复的一个值并赋值到duplication[0]</span></span><br><span class="line">    <span class="comment"># 函数返回True/False</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">duplicate</span><span class="params">(self, numbers, duplication)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> numbers:</span><br><span class="line">            <span class="keyword">if</span> numbers.count(i)&gt;<span class="number">1</span>:</span><br><span class="line">                duplication[<span class="number">0</span>]=i</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h3 id="51-构建乘积数组"><a href="#51-构建乘积数组" class="headerlink" title="51.构建乘积数组"></a>51.构建乘积数组</h3><p><strong>题目</strong>:给定数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1];其中B中的元素B[i]=A[0]<em>A[1]…A[i-1]</em>A[i+1]…A[n-1]。不能使用除法。</p><p><strong>注意</strong>：没有A[i]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">multiply</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> A:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> len(A)==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        B=[<span class="literal">None</span>]*len(A)</span><br><span class="line">        <span class="keyword">for</span> i,e <span class="keyword">in</span> enumerate(A):</span><br><span class="line">            cumpower=<span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> ii,ee <span class="keyword">in</span> enumerate(A):</span><br><span class="line">                <span class="keyword">if</span> ii!=i:</span><br><span class="line">                    cumpower=cumpower*ee</span><br><span class="line">            B[i]=cumpower</span><br><span class="line">        <span class="keyword">return</span> B</span><br></pre></td></tr></table></figure><h3 id="52-正则表达式匹配-flag"><a href="#52-正则表达式匹配-flag" class="headerlink" title="52.正则表达式匹配(flag)"></a>52.正则表达式匹配(flag)</h3><p><strong>题目：</strong>请实现一个函数用来匹配包括’ , ‘和’ * ‘的正则表达式。模式中的字符’ , ‘表示任意一个字符，而’ * ‘表示它前面的字符可以出现任意次（包含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但是与”aa.a”和”ab*a”均不匹配。</p><p> 思路: </p><blockquote><p>当模式中的第二个字符不是 *时：</p><ul><li>如果字符串第一个字符和模式中的第一个字符相匹配，那么字符串和模式都后移一个字符，然后匹配剩余的。</li><li>如果字符串第一个字符和模式中的第一个字符相不匹配，直接返回false。</li></ul><p>当模式中的第二个字符是 *时：</p><ul><li>如果字符串第一个字符跟模式第一个字符不匹配，则模式后移2个字符，继续匹配。</li><li>如果字符串第一个字符跟模式第一个字符匹配，可以有3种匹配方式。<ul><li>模式后移2字符，相当于 x<em>被忽略。即模式串中</em>与他前面的字符和字符串匹配0次。</li><li>字符串后移1字符，模式后移2字符。即模式串中*与他前面的字符和字符串匹配1次。</li><li>字符串后移1字符，模式不变，即继续匹配字符下一位，因为 <em>可以匹配多位。即模式串中</em>与他前面的字符和字符串匹配多次。</li></ul></li></ul></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># s, pattern都是字符串</span></span><br><span class="line">    <span class="comment"># flag=0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">match</span><span class="params">(self, s, pattern)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> (len(s) == <span class="number">0</span> <span class="keyword">and</span> len(pattern) == <span class="number">0</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> (len(s) &gt; <span class="number">0</span> <span class="keyword">and</span> len(pattern) == <span class="number">0</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> (len(pattern) &gt; <span class="number">1</span> <span class="keyword">and</span> pattern[<span class="number">1</span>] == <span class="string">'*'</span>):</span><br><span class="line">            <span class="keyword">if</span> (len(s) &gt; <span class="number">0</span> <span class="keyword">and</span> (s[<span class="number">0</span>] == pattern[<span class="number">0</span>] <span class="keyword">or</span> pattern[<span class="number">0</span>] == <span class="string">'.'</span>)):</span><br><span class="line">                <span class="keyword">return</span> (self.match(s, pattern[<span class="number">2</span>:]) <span class="keyword">or</span> self.match(s[<span class="number">1</span>:], pattern[<span class="number">2</span>:]) <span class="keyword">or</span> self.match(s[<span class="number">1</span>:], pattern))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> self.match(s, pattern[<span class="number">2</span>:])</span><br><span class="line">        <span class="keyword">if</span> (len(s) &gt; <span class="number">0</span> <span class="keyword">and</span> (pattern[<span class="number">0</span>] == <span class="string">'.'</span> <span class="keyword">or</span> pattern[<span class="number">0</span>] == s[<span class="number">0</span>])):</span><br><span class="line">            <span class="keyword">return</span> self.match(s[<span class="number">1</span>:], pattern[<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h3 id="53-表示数值的字符串"><a href="#53-表示数值的字符串" class="headerlink" title="53.表示数值的字符串"></a>53.表示数值的字符串</h3><p><strong>题目：</strong>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># s字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isNumeric</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        l=[s]</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            b=float(s)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h3 id="54-字符流中第一个不重复的字符-flag"><a href="#54-字符流中第一个不重复的字符-flag" class="headerlink" title="54.字符流中第一个不重复的字符(flag)"></a>54.字符流中第一个不重复的字符(flag)</h3><p><strong>题目：</strong>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。</p><p><strong>输出描述：</strong>如果当前字符流没有存在出现一次的字符，返回#字符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># flag=0</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回对应char</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.s=<span class="string">''</span></span><br><span class="line">        self.dict=&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FirstAppearingOnce</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> self.s:</span><br><span class="line">            <span class="keyword">if</span> self.dict[i]==<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'#'</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Insert</span><span class="params">(self, char)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        self.s+=char</span><br><span class="line">        <span class="keyword">if</span> char <span class="keyword">in</span> self.dict:</span><br><span class="line">            self.dict[char]+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.dict[char]=<span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="55-链表中环的入口节点-flag"><a href="#55-链表中环的入口节点-flag" class="headerlink" title="55.链表中环的入口节点(flag)"></a>55.链表中环的入口节点(flag)</h3><p><strong>题目：</strong>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。</p><p><strong>思路：</strong>第一步，找环中相汇点。分别用p1，p2指向链表头部，p1每次走一步，p2每次走二步，直到p1==p2找到在环中的相汇点。第二步，找环的入口。接上步，当p1==p2时，p2所经过节点数为2x,p1所经过节点数为x,设环中有n个节点,p2比p1多走一圈有2x=n+x;n=x;可以看出p1实际走了一个环的步数，再让p2指向链表头部，p1位置不变，p1,p2每次走一步直到p1==p2; 此时p1指向环的入口：直线+小段环=整环，故p1再走整环-小段环到达起点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">EntryNodeOfLoop</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        fast,slow=pHead,pHead</span><br><span class="line">        <span class="keyword">if</span> fast <span class="keyword">and</span> fast.next: </span><br><span class="line">            fast=fast.next.next</span><br><span class="line">            slow=slow.next</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.next <span class="keyword">and</span> fast!=slow:</span><br><span class="line">            fast=fast.next.next</span><br><span class="line">            slow=slow.next</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> fast.next: </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        fast=pHead</span><br><span class="line">        <span class="keyword">while</span> fast!=slow:</span><br><span class="line">            fast=fast.next</span><br><span class="line">            slow=slow.next</span><br><span class="line">        <span class="keyword">return</span> fast</span><br></pre></td></tr></table></figure><h3 id="56-删除链表中重复的节点-flag"><a href="#56-删除链表中重复的节点-flag" class="headerlink" title="56.删除链表中重复的节点(flag)"></a>56.删除链表中重复的节点(flag)</h3><p><strong>题目：</strong>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留(全部删除)，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplication</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        result = ListNode(<span class="number">0</span>)</span><br><span class="line">        res = result</span><br><span class="line">        tmp = pHead</span><br><span class="line">        <span class="keyword">while</span> tmp <span class="keyword">and</span> tmp.next:</span><br><span class="line">            <span class="keyword">if</span> tmp.val == tmp.next.val:</span><br><span class="line">                <span class="keyword">while</span> tmp.next <span class="keyword">and</span> tmp.val == tmp.next.val:</span><br><span class="line">                    tmp = tmp.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.next = tmp  <span class="comment">#把整个tmp之后的链表都接上去了</span></span><br><span class="line">                res = res.next</span><br><span class="line">            tmp = tmp.next</span><br><span class="line">        res.next = tmp</span><br><span class="line">        <span class="keyword">return</span> result.next</span><br><span class="line">            </span><br><span class="line"><span class="comment"># 一开始res为&#123;-1&#125;，1和2不同，res.next = tmp得到&#123;-1，1,2,3,3,4,4,5&#125;，res和tmp指针往下</span></span><br><span class="line"><span class="comment"># 第二次2和3不同，res.next = tmp得到&#123;-1，1，+，2,3,3,4,4,5&#125;，+号前为res指针位置</span></span><br><span class="line"><span class="comment"># 第三次3和3相同，tmp指针到4的位置，下一次res.next=tmp得到&#123;-1,1,2，+，4,4,5&#125;</span></span><br></pre></td></tr></table></figure><h3 id="57-二叉树中的下一个节点"><a href="#57-二叉树中的下一个节点" class="headerlink" title="57. 二叉树中的下一个节点"></a>57. 二叉树中的下一个节点</h3><p><strong>题目：</strong>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p><p><strong>思路：</strong>分析二叉树的下一个节点，一共有以下情况：1.二叉树为空，则返回空；2.节点右孩子存在，则设置一个指针从该节点的右孩子出发，一直沿着指向左子结点的指针找到的叶子节点即为下一个节点；3.节点不是根节点。如果该节点是其父节点的左孩子，则返回父节点；否则继续向上遍历其父节点的父节点，重复之前的判断，返回结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeLinkNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetNext</span><span class="params">(self, pNode)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pNode:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> pNode.right:</span><br><span class="line">            pNode=pNode.right</span><br><span class="line">            <span class="keyword">while</span> pNode.left:</span><br><span class="line">                pNode=pNode.left</span><br><span class="line">            <span class="keyword">return</span> pNode</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>: <span class="comment">#存在该节点在父节点右边，且一直递归，这时要找爷爷节点 型如"\"</span></span><br><span class="line">            <span class="keyword">while</span> pNode.next:</span><br><span class="line">                <span class="keyword">if</span> pNode.next.left==pNode:</span><br><span class="line">                    <span class="keyword">return</span> pNode.next</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    pNode=pNode.next</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><h3 id="58-对称的二叉树-flag"><a href="#58-对称的二叉树-flag" class="headerlink" title="58.对称的二叉树(flag)"></a>58.对称的二叉树(flag)</h3><p><strong>题目：</strong>请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p><p><strong>思路：</strong>采用递归的方法来判断两数是否相同。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"><span class="comment">#  设计一个递归求issame的函数,issame(root1.left,root2.right)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetrical</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot.left <span class="keyword">and</span> <span class="keyword">not</span> pRoot.right:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> pRoot.left <span class="keyword">and</span> pRoot.right:</span><br><span class="line">            <span class="keyword">return</span> self.issame(pRoot.left,pRoot.right)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">issame</span><span class="params">(self, root1, root2)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root1 <span class="keyword">and</span> <span class="keyword">not</span> root2:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> root1 <span class="keyword">and</span> root2:</span><br><span class="line">            <span class="keyword">if</span> root1.val==root2.val:</span><br><span class="line">                <span class="keyword">return</span> self.issame(root1.left,root2.right) <span class="keyword">and</span> self.issame(root2.left,root1.right)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h3 id="59-按之字形顺序打印二叉树-flag"><a href="#59-按之字形顺序打印二叉树-flag" class="headerlink" title="59.按之字形顺序打印二叉树(flag)"></a>59.按之字形顺序打印二叉树(flag)</h3><p><strong>题目：</strong>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Print</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        res=[]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        level=[pRoot]</span><br><span class="line">        reverseflag=<span class="literal">False</span></span><br><span class="line">        <span class="keyword">while</span> level:</span><br><span class="line">            levelvalue=[]</span><br><span class="line">            nextlevel=[]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> level:</span><br><span class="line">                levelvalue.append(i.val)</span><br><span class="line">                <span class="keyword">if</span> i.left:</span><br><span class="line">                    nextlevel.append(i.left)</span><br><span class="line">                <span class="keyword">if</span> i.right:</span><br><span class="line">                    nextlevel.append(i.right)</span><br><span class="line">            <span class="keyword">if</span> reverseflag:</span><br><span class="line">                levelvalue.reverse()</span><br><span class="line">            <span class="keyword">if</span> levelvalue:</span><br><span class="line">                res.append(levelvalue)</span><br><span class="line">                <span class="comment"># for j in levelvalue:</span></span><br><span class="line">                <span class="comment">#     res.append(j) </span></span><br><span class="line">            reverseflag = <span class="keyword">not</span> reverseflag</span><br><span class="line">            level=nextlevel</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="60-把二叉树打印成多行"><a href="#60-把二叉树打印成多行" class="headerlink" title="60.把二叉树打印成多行"></a>60.把二叉树打印成多行</h3><p><strong>题目：</strong>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回二维列表[[1,2],[4,5]]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Print</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res=[]</span><br><span class="line">        level = [pRoot]</span><br><span class="line">        <span class="keyword">while</span> level:</span><br><span class="line">            levelvalue=[]</span><br><span class="line">            nextlevel=[]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> level:</span><br><span class="line">                levelvalue.append(i.val)</span><br><span class="line">                <span class="keyword">if</span> i.left:</span><br><span class="line">                    nextlevel.append(i.left)</span><br><span class="line">                <span class="keyword">if</span> i.right:</span><br><span class="line">                    nextlevel.append(i.right)</span><br><span class="line">            <span class="keyword">if</span> levelvalue:</span><br><span class="line">                res.append(levelvalue)</span><br><span class="line">            level = nextlevel</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="61-序列化二叉树-flag"><a href="#61-序列化二叉树-flag" class="headerlink" title="61.序列化二叉树(flag)"></a>61.序列化二叉树(flag)</h3><p><strong>题目：</strong>请实现两个函数，分别用来序列化和反序列化二叉树。</p><p><strong>思路：</strong>转变成前序遍历，空元素利用”#”代替，然后进行解序列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"><span class="comment">#序列化指的是遍历二叉树为字符串；所谓反序列化指的是依据字符串重新构造成二叉树。</span></span><br><span class="line"><span class="comment">#当在遍历二叉树时碰到Null指针时，这些Null指针被序列化为一个特殊的字符“#”,结点之间的数值用逗号隔开。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Serialize</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">Pre_Order</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> root:</span><br><span class="line">                result.append(str(root.val))</span><br><span class="line">                Pre_Order(root.left)</span><br><span class="line">                Pre_Order(root.right)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result.append(<span class="string">'#'</span>)</span><br><span class="line">        result = []</span><br><span class="line">        Pre_Order(root)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">','</span>.join(result)</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Deserialize</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        s = s.split(<span class="string">','</span>)</span><br><span class="line">         </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">Change</span><span class="params">(num)</span>:</span></span><br><span class="line">            num[<span class="number">0</span>] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> num[<span class="number">0</span>] &lt; len(s):</span><br><span class="line">                <span class="keyword">if</span> s[num[<span class="number">0</span>]] == <span class="string">'#'</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">                root = TreeNode(int(s[num[<span class="number">0</span>]]))</span><br><span class="line">                root.left = Change(num)</span><br><span class="line">                root.right = Change(num)</span><br><span class="line">                <span class="keyword">return</span> root</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        num = [<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> Change(num)</span><br></pre></td></tr></table></figure><h3 id="62-二叉搜索树中的第K个节点"><a href="#62-二叉搜索树中的第K个节点" class="headerlink" title="62.二叉搜索树中的第K个节点"></a>62.二叉搜索树中的第K个节点</h3><p><strong>题目：</strong>给定一棵二叉搜索树，请找出其中的第k小的结点。例如（5，3，7，2，4，6，8）中，按结点数值大小顺序第三小结点的值为4。</p><p><strong>思路：</strong>中序遍历后，返回第K个节点值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回对应节点TreeNode</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.res = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">KthNode</span><span class="params">(self, pRoot, k)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment">#pnode=pRoot  # 为啥要加这一句呢？</span></span><br><span class="line">        self.sorttree(pRoot)</span><br><span class="line">        <span class="keyword">if</span> len(self.res)&lt;k <span class="keyword">or</span> k&lt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.res[k<span class="number">-1</span>]</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sorttree</span><span class="params">(self,pRoot)</span>:</span> <span class="comment"># 中序排序</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        left = self.sorttree(pRoot.left)</span><br><span class="line">        self.res.append(pRoot)</span><br><span class="line">        right = self.sorttree(pRoot.right)</span><br></pre></td></tr></table></figure><h3 id="63-数据流中的中位数"><a href="#63-数据流中的中位数" class="headerlink" title="63.数据流中的中位数"></a>63.数据流中的中位数</h3><p><strong>题目：</strong>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.arr=[]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Insert</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        self.arr.append(num)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetMedian</span><span class="params">(self,arr)</span>:</span> <span class="comment">#为啥这里要加 arr 作为输入,换为其他参数也行，必须要占位？</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        res=sorted(self.arr)</span><br><span class="line">        <span class="keyword">if</span> len(res)%<span class="number">2</span>==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> (res[len(res)//<span class="number">2</span><span class="number">-1</span>]+res[len(res)//<span class="number">2</span>])/<span class="number">2.0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> res[len(res)//<span class="number">2</span>]</span><br></pre></td></tr></table></figure><h3 id="64-滑动窗口的最大值"><a href="#64-滑动窗口的最大值" class="headerlink" title="64.滑动窗口的最大值"></a>64.滑动窗口的最大值</h3><p><strong>题目：</strong>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}，{2,3,4,2,6,[2,5,1]}。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxInWindows</span><span class="params">(self, num, size)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> size&lt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">if</span> size==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> num</span><br><span class="line">        res=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(num)-size+<span class="number">1</span>):</span><br><span class="line">            res.append(max(num[i:i+size]))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="65-矩阵中的路径-flag"><a href="#65-矩阵中的路径-flag" class="headerlink" title="65.矩阵中的路径(flag)"></a>65.矩阵中的路径(flag)</h3><p><strong>题目：</strong>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。例如 a b c e s f c s a d e e 这样的3 X 4 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</p><p><strong>思路：</strong>当起点第一个字符相同时，开始进行递归搜索，设计搜索函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPath</span><span class="params">(self, matrix, rows, cols, path)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(rows):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(cols):</span><br><span class="line">                <span class="keyword">if</span> matrix[i*cols+j]==path[<span class="number">0</span>]:</span><br><span class="line">                    <span class="keyword">if</span> self.findpath(list(matrix),rows,cols,path[<span class="number">1</span>:],i,j):</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findpath</span><span class="params">(self, matrix, rows, cols, path ,i ,j)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> path:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        matrix[i*cols+j]=<span class="string">'0'</span></span><br><span class="line">        <span class="keyword">if</span> j+<span class="number">1</span>&lt;cols <span class="keyword">and</span> matrix[i*cols+j+<span class="number">1</span>]==path[<span class="number">0</span>]:  <span class="comment">#j+1&lt;cols 这里是下标，不能等于</span></span><br><span class="line">            <span class="keyword">return</span> self.findpath(matrix, rows, cols, path[<span class="number">1</span>:],i,j+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">elif</span> j<span class="number">-1</span>&gt;=<span class="number">0</span> <span class="keyword">and</span> matrix[i*cols+j<span class="number">-1</span>]==path[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> self.findpath(matrix, rows, cols, path[<span class="number">1</span>:],i,j<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">elif</span> i+<span class="number">1</span>&lt;rows <span class="keyword">and</span> matrix[(i+<span class="number">1</span>)*cols+j]==path[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> self.findpath(matrix, rows, cols, path[<span class="number">1</span>:],i+<span class="number">1</span>,j)</span><br><span class="line">        <span class="keyword">elif</span> i<span class="number">-1</span>&gt;=<span class="number">0</span> <span class="keyword">and</span> matrix[(i<span class="number">-1</span>)*cols+j]==path[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> self.findpath(matrix, rows, cols, path[<span class="number">1</span>:],i<span class="number">-1</span>,j)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h3 id="66-机器人的运动范围"><a href="#66-机器人的运动范围" class="headerlink" title="66.机器人的运动范围"></a>66.机器人的运动范围</h3><p><strong>题目：</strong>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">movingCount</span><span class="params">(self, threshold, rows, cols)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment"># 回溯的出口 ： 所有self.findgrid回溯出口的不满足if条件就停止</span></span><br><span class="line">        matrix = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(cols)] <span class="keyword">for</span> j <span class="keyword">in</span> range(rows)]</span><br><span class="line">        count = self.findgrid(threshold,rows,cols,matrix,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findgrid</span><span class="params">(self,threshold,rows,cols,matrix,i,j)</span>:</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span>&lt;=i&lt;rows <span class="keyword">and</span> <span class="number">0</span>&lt;=j&lt;cols <span class="keyword">and</span> (sum(map(int, str(i) + str(j))) &lt;= threshold) <span class="keyword">and</span> matrix[i][j]==<span class="number">0</span>:</span><br><span class="line">            matrix[i][j] = <span class="number">1</span></span><br><span class="line">            count = <span class="number">1</span> + self.findgrid(threshold,rows,cols,matrix,i,j<span class="number">-1</span>)\</span><br><span class="line">            + self.findgrid(threshold,rows,cols,matrix,i,j+<span class="number">1</span>)\</span><br><span class="line">            + self.findgrid(threshold,rows,cols,matrix,i+<span class="number">1</span>,j)\</span><br><span class="line">            + self.findgrid(threshold,rows,cols,matrix,i<span class="number">-1</span>,j)</span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-二维数组中的查找&quot;&gt;&lt;a href=&quot;#1-二维数组中的查找&quot; class=&quot;headerlink&quot; title=&quot;1.二维数组中的查找&quot;&gt;&lt;/a&gt;1.二维数组中的查找&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;题目：&lt;/strong&gt; 在一个二维数组中（每个一维数组的长
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
</feed>
