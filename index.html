<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="Mosbyllc" type="application/atom+xml">






<meta name="description" content="Sometimes thing have to fall apart to make way for better things.">
<meta property="og:type" content="website">
<meta property="og:title" content="Mosbyllc">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Mosbyllc">
<meta property="og:description" content="Sometimes thing have to fall apart to make way for better things.">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Mosbyllc">
<meta name="twitter:description" content="Sometimes thing have to fall apart to make way for better things.">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"right","display":"always","offset":12,"b2t":true,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>Mosbyllc</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Mosbyllc</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>

<link href="https://cdn.bootcss.com/KaTeX/0.7.1/katex.min.css" rel="stylesheet">



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/04/年终总结/2019年终总结：成为大海，刻不容缓/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mosbyllc">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mosbyllc">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/04/年终总结/2019年终总结：成为大海，刻不容缓/" itemprop="url">2019年终总结：成为大海，刻不容缓</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-01-04T20:20:19+08:00">
                2020-01-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/年终总结/" itemprop="url" rel="index">
                    <span itemprop="name">年终总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2,395
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  8
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="/2020/01/04/年终总结/2019年终总结：成为大海，刻不容缓/00.jpg" alt></p>
<hr>
<p>​        2019，被大多数温暖环绕，偶尔一些人生瞬间变得冰冷和坚硬，无法躲避。但还好，一切终将过去。总的来说，2019并不简单，生活频繁出拳（胖虎的300斤铁拳，直立对打，凭着经验和运气躲过一些，另外一些结结实实地砸在脸上。可以说每一拳都不含糊，一击重拳，甚至可以感受到在脸上凝固停滞的拳气。不过今年也算是和生活对过几招了，本想着步步清风认真生活，凭阅历自撰一本《人间攻略》，大摇大摆地走上建设社会的征途，没想到生活反手甩一本《人间骚浪贱指南》，害，2019全线崩溃，2020推倒重来，希望今年和生活再次交手能从容一些了。</p>
<blockquote>
<p> 「说真的，你将来打算怎么办呢？」「我打算喝完这一杯」</p>
</blockquote>
<h2 id="研究生毕业失与得"><a href="#研究生毕业失与得" class="headerlink" title="研究生毕业失与得"></a>研究生毕业失与得</h2><ol>
<li><strong>毕业</strong> </li>
</ol>
<p>研究生三年，形象地说， 从一个小池塘跳到另外一个小池塘中，激起一朵Information Sciences期刊论文小浪花，然后扑通入水无踪影，从二十几岁精壮小伙想掏空世界的功利心来看，不值当。很难想象，这朵靠着身体抽搐翻腾出来小破花有多艰难，为啥别人的象牙塔是导师领进豪华直升电梯，直通塔顶，而我们要一步一爬，唉哟连特么象牙塔都是自己垒起来的，还好最后实验室人手一篇领域(次)顶刊，纷纷告别科研学术，有着不错的工作落脚处，也算是纯粹地感受了一把学术上知其然也知其所以然过程，人生历程多了一份体验，虽然不符预期，但也感激经历。</p>
<p>学校这几年忙忙忙，感觉也没忙出啥东西来，没发展别的兴趣，甜甜的恋爱还是没轮到我，好像蓝色大门里说的「 夏天就要过去了，我们好像什么都没做」「 是啊，就这样跑来跑去，什么都没做 」「那总会留下些什么吧，留下了什么，我们就会成为怎么样的大人 」</p>
<p>真要说有哪些值得关注的改变话，觉得还是有一些：</p>
<ul>
<li>喜欢上了摇滚乐</li>
<li>性格从怂包变得小型社恐（到今天似乎消除了，大家都一样，五五开）</li>
<li>资源搜索能力加强，有需要的东西可以独立自学</li>
<li>处理感情还是一塌糊涂，不能成熟表达爱与索取爱</li>
<li>总在试探，都在权衡，消散热爱的能力</li>
</ul>
<p>毕业的话，希望自己的期刊论文每年多一次引用吧，谷歌学术搜索排名能前一点，这个新年学术愿望不过分吧。</p>
<ol>
<li><strong>就业</strong></li>
</ol>
<p>面试造火箭，上班拧螺丝的故事早有耳闻，人力小姐姐萝莉外表杀人诛心可不含糊，论实力与面试的迷一样的相关函数，求职路上太多有意思的故事了，这一路也不容易。</p>
<p>忙着论文错过了秋招，磕磕碰碰地走上春招这条血路，太难了呀，简直比沥青未干的蜀道还难！一场场大型面试崩溃招聘现场， 黑压压一片学生，排着队递简历，精神上首先就完了。投了简历石沉大海，回来路上，真的是天空突然一道光打在你身上，自我怀疑的高光时刻。二十五岁这场人生三分之一考试，每次到交答卷才发现真的准备的不够充分。春招凭着发表的论文和一些算法竞赛的获奖，获得较多的面试机会，磕磕碰碰，沉舟侧畔，最后也算成功上岸了，有两个比较有印象的故事：</p>
<p> 1）投了一些大厂算法类的岗位无果后，参加了一个猎头帮改简历的招聘会，那天去的早， 现场没啥人，改完简历后和猎头大叔聊了起来，咔咔咔一顿哭诉当代年轻人的不容易，委屈大王，心酸2019，为啥生活不如意都落我这个失意年轻人的大头上！（那段时间感情状态、生活状态各方面真的是DOWN到深海几万里）。猎头大叔当时说啥我忘记了，总之谈了很久，他让我加油坚持，不要放低要求去小企业得以慰藉，年轻人要有年轻人的样子！我心中一顿爆暖，离开的时候还喊了我回来，握了握手，说很开心和我谈话。</p>
<p>2）一家基金公司，总裁面，到了给offer阶段，我说还有另外一家在考虑，她说来不来她这里没关系，年轻人找工作要好好考虑，要选对行业和团队，不要盯着一个岗位就上，并给了很多中肯的年轻人意见。我是很信仰人生经验攻略的，这些年一路过来，可太缺参考物了，最后没去还是很谢谢这些不给年轻人画饼，并愿意指导年轻人意见的大佬。</p>
<p>给毕业求职的同学一些建议：</p>
<ol>
<li>不要错过秋春招</li>
<li>清楚自己的满意和愿意接受的岗位</li>
<li>校招不像做饭，不需要等万事俱备才开始</li>
<li>每次多总结复盘，打铁还需自身硬</li>
<li>小心人力大姐</li>
</ol>
<blockquote>
<p>以上其实都是废话，多面几次自己就有谱了</p>
</blockquote>
<p>不管怎样，还是顺利毕业了嘿！</p>
<p><img src="/2020/01/04/年终总结/2019年终总结：成为大海，刻不容缓/02.jpg" alt></p>
<h2 id="自我管理"><a href="#自我管理" class="headerlink" title="自我管理"></a>自我管理</h2><p>​        <strong>1.睡眠</strong></p>
<p><img src="/2020/01/04/年终总结/2019年终总结：成为大海，刻不容缓/03.jpg" alt></p>
<p>出来搬砖以来，睡眠变得规律很多，七点起床，十点半准时雇人敲晕自己。睡眠时间大概维持在七个半小时，午休半小时，持续搬砖问题不大。周末一般会把一周攒起来的抖音刷一遍，看看天地之间的沙雕，安心睡去。</p>
<ol>
<li><strong>记账</strong></li>
</ol>
<p><img src="/2020/01/04/年终总结/2019年终总结：成为大海，刻不容缓/05.jpg" alt></p>
<p>​        不得不说，当代年轻人独立买房还是很艰难，看着每项支出其实也还好，但是汇到一起每月支出都会比想象的多，要是活动多一些也存不了几个钱。今年出来搬砖后，把银行和朋友借的钱都还清，自己日常支出也能稳定下来，这个感觉还是很棒的！</p>
<p>​        定投指数基金，3000点入场，做一颗茁壮成长的韭菜！</p>
<ol>
<li><strong>健康</strong></li>
</ol>
<p><img src="/2020/01/04/年终总结/2019年终总结：成为大海，刻不容缓/07.jpg" alt></p>
<p>​        今年做了个手术，还确诊了过敏性鼻炎，是要提醒自己该更加注意身体健康这一方面了。另外鼻炎应该是学校宿舍那台旧空调造成的，风口对着床吹，还滴水，每次在宿舍鼻子难受的不行，去到实验室马上就好了，弄到这个不治的毛病还是很痛苦的。目前的策略是上班走路走路走路！枸杞枸杞枸杞！泡脚泡脚泡脚！ 健身是没戏了，在学校都没能坚持下来，希望明年能坚持去游个泳吧。</p>
<h2 id="关于书影音"><a href="#关于书影音" class="headerlink" title="关于书影音"></a>关于书影音</h2><p>​        <img src="/2020/01/04/年终总结/2019年终总结：成为大海，刻不容缓/09.jpg" alt></p>
<p>五星电影：</p>
<ul>
<li>极限职业（韩）</li>
<li>调音师（印度）</li>
<li>海蒂和爷爷（德）</li>
<li>复仇者联盟4（美）</li>
<li>摇摆狂潮（韩）</li>
</ul>
<p>书籍：</p>
<ul>
<li>《代码整洁之道—程序员的职业素养》</li>
<li>《代码整洁之道—Clean》</li>
<li>《黑客与画家》</li>
<li>《交换梦想》</li>
<li>《宇宙超度指南》</li>
<li>《如何成为一个厉害的人》</li>
</ul>
<p>音乐演出</p>
<ul>
<li>陈知游园惊梦 2019避雨屋檐巡演</li>
<li>Brett乐队 2019巡演</li>
<li>文雀乐队 2019她从来不唱我们的歌巡演</li>
</ul>
<p><img src="/2020/01/04/年终总结/2019年终总结：成为大海，刻不容缓/10.png" alt></p>
<p>今年观影70+，还为观影事业买了个投影仪，每个周末的夜晚，100寸电子辐射的快乐，碳水化合物乐园，灵魂像膨化食品被打开时一样开心的裂开。听歌方面依然是摇滚为主，流行和民谣听一些，没想到居然Andrew Applepie成为了年度歌手，一度认为人类必须牵着手才能听Applepie，哎呀哎呀摇滚死了呀。</p>
<p>今年看书希望多看些编程类的工具书，数据库、理解框架是目前搬砖进阶的目标。</p>
<blockquote>
<p>不要为今年读书太少而难过，去年你也没读多少</p>
</blockquote>
<h2 id="Flag！Flag！Flag！"><a href="#Flag！Flag！Flag！" class="headerlink" title="Flag！Flag！Flag！"></a>Flag！Flag！Flag！</h2><ul>
<li><p>希望今年可以更自信地表达自己</p>
</li>
<li><p>搬出来一个人住，养条狗，或养个女朋友</p>
</li>
<li><p>尝试视频内容创作</p>
</li>
<li><p>开源一个自己感兴趣的工程项目</p>
</li>
<li><p>逛一逛动物园，打卡深圳所有公园</p>
</li>
<li><p>存钱买老婆</p>
</li>
</ul>
<p>总的来说，2019并不值得被总结，是经历当中最难的一年，有很多至暗时刻不愿提及，没必要铭记些什么，2019过去了就过去了。用一些不太恰当又很冗长的比喻就是， 就像聊了18个月的心理医生突然告诉你，我不能再给你做咨询了，因为我已经爱上你了； 就像一个易碎的老年人正盯着你并且缓缓插队，而你只好故作无睹 ；就像班上倒数第二辅导倒数第一课后习题，并且给出详细的解题思路 。2020不敢说万事顺利，希望新一年遇到的问题都是不太复杂自己慢慢能处理好的，新年加油！</p>
<p>新的一年，就不祝一帆风顺了，祝大家乘风破浪吧！</p>
<p>以上</p>

          
        
      
    </div>
    
    
    
    
    
    
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/24/java/java入门基础（二）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mosbyllc">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mosbyllc">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/24/java/java入门基础（二）/" itemprop="url">java入门基础（二）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-24T13:54:44+08:00">
                2019-01-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  6,420
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  24
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>下面是一个异常处理块的通常形式： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// block of code to monitor for errors</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ExceptionType1 exOb) &#123;</span><br><span class="line">    <span class="comment">// exception handler for ExceptionType1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ExceptionType2 exOb) &#123; <span class="comment">//构造catch子句的目的是解决异常情况并且像错误没有发生一样继续运行。</span></span><br><span class="line">    <span class="comment">// exception handler for ExceptionType2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// block of code to be executed before try block ends</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，ExceptionType 是发生异常的类型。</p>
<h2 id="未被捕获的异常"><a href="#未被捕获的异常" class="headerlink" title="未被捕获的异常"></a>未被捕获的异常</h2><p>在你学习在程序中处理异常之前，看一看如果你不处理它们会有什么情况发生是很有好处的。下面的小程序包括一个故意导致被零除错误的表达式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Exc0</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> d = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">42</span> / d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当Java运行时系统检查到被零除的情况，它构造一个新的异常对象然后抛出该异常。这导致Exc0的执行停止，<strong>因为一旦一个异常被抛出，它必须被一个异常处理程序捕获并且被立即处理</strong>。该例中，<strong>我们没有提供任何我们自己的异常处理程序，所以异常被Java运行时系统的默认处理程序捕获。任何不是被你程序捕获的异常最终都会被该默认处理程序处理</strong>。默认处理程序显示一个描述异常的字符串，打印异常发生处的堆栈轨迹并且终止程序。</p>
<h2 id="throws子句"><a href="#throws子句" class="headerlink" title="throws子句"></a>throws子句</h2><p><strong>throws的作用是如果一个方法可以引发异常，而它本身并不对该异常处理，那么它必须将这个异常抛给调用它的方法。让容器、框架等更高层的东东去捕获异常并处理。</strong> </p>
<p>如果一个方法可以导致一个异常但不处理它，它必须指定这种行为以使方法的调用者可以保护它们自己而不发生异常。做到这点你可以在方法声明中包含一个throws子句。一个 throws 子句列举了一个方法可能抛出的所有异常类型。这对于除Error或RuntimeException及它们子类以外类型的所有异常是必要的。一个方法可以抛出的所有其他类型的异常必须在throws子句中声明。如果不这样做，将会导致编译错误。</p>
<p>下面是包含一个throws子句的方法声明的通用形式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type method-name(parameter-list) <span class="keyword">throws</span> exception-list&#123;</span><br><span class="line">    <span class="comment">// body of method</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，exception-list是该方法可以抛出的以有逗号分割的异常列表。</p>
<h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p>断言用于证明和测试程序的假设，比如“这里的值大于 5”。</p>
<p>断言有两种方法：</p>
<ul>
<li>一种是 assert&lt;&lt;布尔表达式&gt;&gt; ；</li>
<li>另一种是 assert&lt;&lt;布尔表达式&gt;&gt; ：&lt;&lt;细节描述&gt;&gt;。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> x == <span class="number">10</span> : <span class="string">"Our assertion failed"</span>;</span><br></pre></td></tr></table></figure>
<h1 id="深入理解java异常处理机制"><a href="#深入理解java异常处理机制" class="headerlink" title="深入理解java异常处理机制"></a>深入理解java异常处理机制</h1><p>Java通 过API中Throwable类的众多子类描述各种不同的异常。因而，Java异常都是对象，是Throwable子类的实例，描述了出现在一段编码中的 错误条件。当条件生成时，错误将引发异常。 </p>
<h2 id="Exception（异常）和-Error（错误）"><a href="#Exception（异常）和-Error（错误）" class="headerlink" title="Exception（异常）和 Error（错误）"></a>Exception（异常）和 Error（错误）</h2><p>Throwable： 有两个重要的子类：Exception（异常）和 Error（错误），二者都是 Java 异常处理的重要子类，各自都包含大量子类。 </p>
<ul>
<li>Error（错误）:是程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。例如，Java虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。这些错误表示故障发生于虚拟机自身、或者发生在虚拟机试图执行应用时，如Java虚拟机运行错误（Virtual MachineError）、类定义错误（NoClassDefFoundError）等。这些错误是不可查的，因为它们在应用程序的控制和处理能力之 外，而且绝大多数是程序运行时不允许出现的状况。对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状况。在 Java中，错误通过Error的子类描述。</li>
<li>Exception（异常）:是程序本身可以处理的异常。Exception 类有一个重要的子类 RuntimeException。RuntimeException 类及其子类表示“JVM 常用操作”引发的错误。例如，若试图使用空值对象引用、除数为零或数组越界，则分别引发运行时异常（NullPointerException、ArithmeticException）和 ArrayIndexOutOfBoundException。</li>
</ul>
<p>注意：异常和错误的区别：异常能被程序本身可以处理，错误是无法处理。</p>
<h2 id="可查异常（checked-exceptions）和不可查异常（unchecked-exceptions）"><a href="#可查异常（checked-exceptions）和不可查异常（unchecked-exceptions）" class="headerlink" title="可查异常（checked exceptions）和不可查异常（unchecked exceptions）"></a>可查异常（checked exceptions）和不可查异常（unchecked exceptions）</h2><p>Java的异常(包括Exception和Error)分为可查的异常（checked exceptions）和不可查的异常（unchecked exceptions）。</p>
<blockquote>
<p>可查异常（编译器要求必须处置的异常）：</p>
</blockquote>
<p>正确的程序在运行中，很容易出现的、情理可容的异常状况。可查异常虽然是异常状况，但在一定程度上它的发生是可以预计的，而且一旦发生这种异常状况，就必须采取某种方式进行处理。 除了RuntimeException及其子类以外，其他的Exception类及其子类都属于可查异常。这种异常的特点是Java编译器会检查它，<strong>也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过</strong>。</p>
<blockquote>
<p>不可查异常(编译器不要求强制处置的异常):</p>
</blockquote>
<p>包括运行时异常（RuntimeException与其子类）和错误（Error）。</p>
<h2 id="处理异常机制"><a href="#处理异常机制" class="headerlink" title="处理异常机制"></a>处理异常机制</h2><p>在Java应用程序中，异常处理机制为：抛出异常，捕捉异常。</p>
<p>从方法中抛出的任何异常都必须使用throws子句。</p>
<p>捕捉异常通过try-catch语句或者try-catch-finally语句实现。</p>
<p>总体来说，Java规定，对于可查异常必须捕捉、或者声明抛出。允许忽略不可查的RuntimeException和Error。</p>
<h1 id="常用库类、向量与哈希"><a href="#常用库类、向量与哈希" class="headerlink" title="常用库类、向量与哈希"></a>常用库类、向量与哈希</h1><h2 id="Java基础类库"><a href="#Java基础类库" class="headerlink" title="Java基础类库"></a>Java基础类库</h2><p>Java 常用包的简单介绍如下：</p>
<ul>
<li>java.lang 包：主要含有与语言相关的类。java.lang 包由解释程序自动加载，不需要显示说明。</li>
<li>java.io 包：主要含有与输入/输出相关的类，这些类提供了对不同的输入和输出设备读写数据的支持，这些输入和输出设备包括键盘、显示器、打印机、磁盘文件等。</li>
<li>java.util 包：包括许多具有特定功能的类，有日期、向量、哈希表、堆栈等，其中 Date类支持与时间有关的操作。</li>
<li>java.swing 包和 java.awt 包：提供了创建图形用户界面元素的类。通过这些元素，编程者可以控制所写的 Applet 或 Application 的外观界面。包中包含了窗口、对话框、菜单等类。</li>
<li>java.net 包：含有与网络操作相关的类，如 TCP Scokets、URL 等工具。</li>
<li>java.applet 包：含有控制 HTML 文档格式、应用程序中的声音等资源的类，其中 Applet类是用来创建包含于 HTML 的 Applet 必不可少的类。</li>
<li>java.beans 包：定义了应用程序编程接口（API），Java Beans 是 Java 应用程序环境的中性平台组件结构。</li>
</ul>
<h2 id="Java语言包-java-lang-简介"><a href="#Java语言包-java-lang-简介" class="headerlink" title="Java语言包(java.lang)简介"></a>Java语言包(java.lang)简介</h2><p>Java语言包（java.lang）定义了Java中的大多数基本类，由Java语言自动调用，不需要显示声明。该包中包含了Object类，Object类是整个类层次结构的根结点，同时还定义了基本数据类型的类，如：String、Boolean、Byter、Short等。这些类支持数字类型的转换和字符串的操作等，下面将进行简单介绍。</p>
<p>Math类提供了常用的数学运算方法以及Math.PI和Math.E两个数学常量。该类是final的，不能被继承，类中的方法和属性全部是静态，不允许在类的外部创建Math类的对象。因此，只能使用Math类的方法而不能对其作任何更改。</p>
<h3 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h3><p>包含许多常用数学计算的方法功能</p>
<h3 id="字符串类"><a href="#字符串类" class="headerlink" title="字符串类"></a>字符串类</h3><p>字符串是字符的序列。在 Java 中，字符串无论是常量还是变量都是用类的对象来实现的。java.lang 提供了两种字符串类：String 类和 StringBuffer 类。</p>
<h2 id="日期和时间类"><a href="#日期和时间类" class="headerlink" title="日期和时间类"></a>日期和时间类</h2><p>Java 的日期和时间类位于 java.util 包中。利用日期时间类提供的方法，可以获取当前的日期和时间，创建日期和时间参数，计算和比较时间。</p>
<h3 id="Date-类"><a href="#Date-类" class="headerlink" title="Date 类"></a>Date 类</h3><p>Date 类是 Java 中的日期时间类，其构造方法比较多，下面是常用的两个：</p>
<ul>
<li>Date()：使用当前的日期和时间初始化一个对象。</li>
<li>Date(long millisec)：从1970年01月01日00时（格林威治时间）开始以毫秒计算时间，计算 millisec 毫秒。如果运行 Java 程序的本地时区是北京时区（与格林威治时间相差 8 小时），Date dt1=new Date(1000);，那么对象 dt1 就是1970年01月01日08时00分01秒。</li>
</ul>
<h3 id="Calendar-类"><a href="#Calendar-类" class="headerlink" title="Calendar 类"></a>Calendar 类</h3><p>抽象类 Calendar 提供了一组方法，允许把以毫秒为单位的时间转换成一些有用的时间组成部分。Calendar 不能直接创建对象，但可以使用静态方法 getInstance() 获得代表当前日期的日历对象，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Calendar calendar=Calendar.getInstance();</span><br></pre></td></tr></table></figure>
<p>该对象可以调用下面的方法将日历翻到指定的一个时间：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> year,<span class="keyword">int</span> month,<span class="keyword">int</span> date)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> year,<span class="keyword">int</span> month,<span class="keyword">int</span> date,<span class="keyword">int</span> hour,<span class="keyword">int</span> minute)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> year,<span class="keyword">int</span> month,<span class="keyword">int</span> date,<span class="keyword">int</span> hour,<span class="keyword">int</span> minute,<span class="keyword">int</span> second)</span></span>;</span><br></pre></td></tr></table></figure>
<p>若要调用有关年份、月份、小时、星期等信息，可以通过调用下面的方法实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> field)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中，参数 field 的值由 Calendar 类的静态常量决定。其中：YEAR 代表年，MONTH 代表月，HOUR 代表小时，MINUTE 代表分，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">calendar.get(Calendar.MONTH);</span><br></pre></td></tr></table></figure>
<p>如果返回值为 0 代表当前日历是一月份，如果返回 1 代表二月份，依此类推。</p>
<h3 id="GregorianCalendar-类"><a href="#GregorianCalendar-类" class="headerlink" title="GregorianCalendar 类"></a>GregorianCalendar 类</h3><p>GregorianCalendar 是一个具体实现 Calendar 类的类，该类实现了公历日历。Calendar 类的 getInstance() 方法返回一个 GregorianCalendar，它被初始化为默认的地域和时区下的当前日期和时间。</p>
<h2 id="哈希表及其应用"><a href="#哈希表及其应用" class="headerlink" title="哈希表及其应用"></a>哈希表及其应用</h2><p>哈希表也称为散列表，是用来存储群体对象的集合类结构。</p>
<p>Java 使用哈希表类（Hashtable）来实现哈希表，以下是与哈希表相关的一些概念：</p>
<ul>
<li>容量（Capacity）：Hashtable 的容量不是固定的，随对象的加入其容量也可以自动增长。</li>
<li>关键字（Key）：每个存储的对象都需要有一个关键字，key 可以是对象本身，也可以是对象的一部分（如某个属性）。要求在一个 Hashtable 中的所有关键字都是唯一的。</li>
<li>哈希码（Hash Code）：若要将对象存储到 Hashtable 上，就需要将其关键字 key 映射到一个整型数据，成为 key 的哈希码。</li>
<li>项（Item）：Hashtable 中的每一项都有两个域，分别是关键字域 key 和值域 value（存储的对象）。Key 和 value 都可以是任意的 Object 类型的对象，但不能为空。</li>
<li>装填因子（Load Factor）：装填因子表示为哈希表的装满程度，其值等于元素数比上哈希表的长度。</li>
</ul>
<h3 id="哈希表的使用"><a href="#哈希表的使用" class="headerlink" title="哈希表的使用"></a>哈希表的使用</h3><p>哈希表类主要有三种形式的构造方法：</p>
<ul>
<li>Hashtable(); //默认构造函数，初始容量为 101，最大填充因子 0.75</li>
<li>Hashtable(int capacity);</li>
<li>Hashtable(int capacity,float loadFactor)</li>
</ul>
<h1 id="内部类、抽象类、接口"><a href="#内部类、抽象类、接口" class="headerlink" title="内部类、抽象类、接口"></a>内部类、抽象类、接口</h1><h2 id="Java内部类及其实例化"><a href="#Java内部类及其实例化" class="headerlink" title="Java内部类及其实例化"></a>Java内部类及其实例化</h2><p>首先看看什么是内部类：在类的内部定义另一个类。没错，定义就这么简单。如果在类Outer的内部再定义一个类Inner，此时Inner就称为内部类，而Outer则称为外部类。 </p>
<p>使用内部类有什么好处；</p>
<p>1）实现多重继承; </p>
<p>2）内部类可以很好的实现隐藏：一般的非内部类，是不允许有 private 与protected权限的，但内部类可以</p>
<p> 3）减少了类文件编译后的产生的字节码文件的大小</p>
<p>使用内部类的缺点：使程序结构不清楚。</p>
<p>内部类在编译完成后也会产生.class文件，但文件名称是：外部类名称$内部类名称.class</p>
<h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p>成员内部类也叫实例内部类。应用场合：每一个外部类对象都需要一个内部类的实例，<strong>内部类离不开外部类存在</strong>（相当于心脏对人体）。外部类要想访问内部类的成员变量和方法，则需要通过内部类的对象来获取。 </p>
<p>使用格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Outer outer = <span class="keyword">new</span> Outer(); <span class="comment">// 外部类实例</span></span><br><span class="line">Outer.Inner inner = outer.<span class="keyword">new</span> Inner();</span><br></pre></td></tr></table></figure>
<p>代码演示： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 成员内部类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Body</span> </span>&#123;</span><br><span class="line">    String arm;</span><br><span class="line">    String leg;</span><br><span class="line">    String blood;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Body</span><span class="params">(String arm, String leg, String blood)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.arm = arm;</span><br><span class="line">       <span class="keyword">this</span>.leg = leg;</span><br><span class="line">        <span class="keyword">this</span>.blood = blood;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//内部类Heart</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Heart</span></span>&#123;</span><br><span class="line">        String name;</span><br><span class="line">         <span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"心脏正在给"</span>+arm+leg+<span class="string">"输"</span>+blood);</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;       </span><br><span class="line">        Body body=<span class="keyword">new</span> Body(<span class="string">"两个胳膊"</span>,<span class="string">"两条腿"</span>,<span class="string">"血"</span>);</span><br><span class="line">        Body.Heart  heart=body.<span class="keyword">new</span> Heart();</span><br><span class="line">        heart.work();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>1、内部类如果使用static声明（类共享一份副本，可以直接通过类名调用，不需要实例），则此内部类就称为静态内部类。（其实也相当于外部类）可以通过外部类 . 内部类来访问。</p>
<p>2、静态内部类使用场合：内部类不需要外部类的实例（注意区分成员内部类），静态内部类存在仅仅为外部类提供服务或者逻辑上属于外部类，且逻辑上可以单独存在。</p>
<p>3、静态内部类的特征：</p>
<p>静态内部类不会持有外部类的引用</p>
<p>静态内部类可以访问外部的静态变量，如果访问外部类的成员变量必须通过外部类的实例访问</p>
<p>4、Java中只有内部类才可以是静态的</p>
<p>使用格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Outer.Inner inner = <span class="keyword">new</span> Outer.Inner();</span><br></pre></td></tr></table></figure>
<p>演示代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 静态内部</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Company</span> </span>&#123;</span><br><span class="line">    String companyNam;</span><br><span class="line">    <span class="keyword">static</span> String country;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Clear</span></span>&#123;</span><br><span class="line">        String name;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Clear</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>();</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">            String na=<span class="keyword">new</span> Company().companyNam=<span class="string">"联想"</span>;</span><br><span class="line">            country=<span class="string">"中国"</span>;</span><br><span class="line">            System.out.println(name+<span class="string">"为"</span>+na+<span class="string">"打扫卫生，该公司属于"</span>+country);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Company.Clear zcl=<span class="keyword">new</span> Company.Clear();</span><br><span class="line">        zcl.work(<span class="string">"shen_hua"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>1、如果一个内部类在整个操作中只使用一次的话，就可以定义为匿名内部类。匿名内部类也就是没有名字的内部类，这是java为了方便我们编写程序而设计的一个机制，因为有时候有的内部类只需要创建一个它的对象就可以了，以后再不会用到这个类，这时候使用匿名内部类就比较合适。</p>
<p>2、使用场合：简化内部类的使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> class <span class="title">Father</span><span class="params">()</span></span>&#123;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">   Father f1 = <span class="keyword">new</span> Father()&#123; .... &#125;  <span class="comment">//这里就是有个匿名内部类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="抽象类的概念和使用"><a href="#抽象类的概念和使用" class="headerlink" title="抽象类的概念和使用"></a>抽象类的概念和使用</h2><p>这种只给出方法定义而不具体实现的方法被称为抽象方法，抽象方法是没有方法体的，在代码的表达上就是没有“{}”。包含一个或多个抽象方法的类也必须被声明为抽象类。</p>
<p>使用 abstract 修饰符来表示抽象方法和抽象类。</p>
<p>抽象类除了包含抽象方法外，还可以包含具体的变量和具体的方法。类即使不包含抽象方法，也可以被声明为抽象类，防止被实例化。</p>
<p>抽象类不能被实例化，抽象方法必须在子类中被实现。请看下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Teacher t = <span class="keyword">new</span> Teacher();</span><br><span class="line">        t.setName(<span class="string">"王明"</span>);</span><br><span class="line">        t.work();</span><br><span class="line">       </span><br><span class="line">        Driver d = <span class="keyword">new</span> Driver();</span><br><span class="line">        d.setName(<span class="string">"小陈"</span>);</span><br><span class="line">        d.work();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;  <span class="comment">// 实例变量</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 共有的 setter 和 getter 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">extends</span> <span class="title">People</span></span>&#123;</span><br><span class="line">    <span class="comment">// 必须实现该方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">        out.println(<span class="string">"我的名字叫"</span> + <span class="keyword">this</span>.getName() + <span class="string">"，我正在讲课，请大家不要东张西望..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Driver</span> <span class="keyword">extends</span> <span class="title">People</span></span>&#123;</span><br><span class="line">    <span class="comment">// 必须实现该方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">        out.println(<span class="string">"我的名字叫"</span> + <span class="keyword">this</span>.getName() + <span class="string">"，我正在开车，不能接听电话..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于抽象类的几点说明：</p>
<ul>
<li>抽象类不能直接使用，必须用子类去实现抽象类，然后使用其子类的实例。然而可以创建一个变量，其类型是一个抽象类，并让它指向具体子类的一个实例，也就是可以使用抽象类来充当形参，实际实现类作为实参，也就是多态的应用。</li>
<li>不能有抽象构造方法或抽象静态方法。</li>
</ul>
<h2 id="接口的概念和使用"><a href="#接口的概念和使用" class="headerlink" title="接口的概念和使用"></a>接口的概念和使用</h2><h3 id="接口的概念"><a href="#接口的概念" class="headerlink" title="接口的概念"></a>接口的概念</h3><p>在抽象类中，可以包含一个或多个抽象方法；但在接口(interface)中，所有的方法必须都是抽象的，不能有方法体，它比抽象类更加“抽象”。</p>
<p>接口使用 interface 关键字来声明，可以看做是一种特殊的抽象类，可以指定一个类必须做什么，而不是规定它如何去做。</p>
<blockquote>
<p>注意：接口中声明的成员变量默认都是 public static final 的，必须显式地初始化。因而在常量声明时可以省略这些修饰符。 </p>
</blockquote>
<p>接口是若干常量和抽象方法的集合，目前看来和抽象类差不多。确实如此，接口本就是从抽象类中演化而来的，因而除特别规定，接口享有和类同样的“待遇”。比如，源程序中可以定义多个类或接口，但最多只能有一个public 的类或接口，如果有则源文件必须取和public的类和接口相同的名字。和类的继承格式一样，接口之间也可以继承，子接口可以继承父接口中的常量和抽象方法并添加新的抽象方法等。 </p>
<p>但接口有其自身的一些特性，归纳如下。</p>
<ul>
<li>1) 接口中只能定义抽象方法，这些方法默认为 public abstract 的，因而在声明方法时可以省略这些修饰符。试图在接口中定义实例变量、非抽象的实例方法及静态方法，都是非法的。例如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SataHdd</span></span>&#123;</span><br><span class="line">    <span class="comment">//连接线的数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> connectLine; <span class="comment">//编译出错，connectLine被看做静态常量，必须显式初始化</span></span><br><span class="line">    <span class="comment">//写数据</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">writeData</span><span class="params">(String data)</span></span>; <span class="comment">//编译出错，必须是public类型</span></span><br><span class="line">    <span class="comment">//读数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">readData</span><span class="params">()</span></span>&#123; <span class="comment">//编译出错，接口中不能包含静态方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"数据"</span>; <span class="comment">//编译出错，接口中只能包含抽象方法，</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>2) 接口中没有构造方法，不能被实例化。</li>
<li>3) 一个接口不实现另一个接口，但可以继承多个其他接口。接口的多继承特点弥补了类的单继承。例如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//串行硬盘接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SataHdd</span> <span class="keyword">extends</span> <span class="title">A</span>,<span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="comment">// 连接线的数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONNECT_LINE = <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 写数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeData</span><span class="params">(String data)</span></span>;</span><br><span class="line">    <span class="comment">// 读数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">readData</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="为什么使用接口"><a href="#为什么使用接口" class="headerlink" title="为什么使用接口"></a>为什么使用接口</h3><p>大型项目开发中，可能需要从继承链的中间插入一个类，让它的子类具备某些功能而不影响它们的父类。例如 A -&gt; B -&gt; C -&gt; D -&gt; E，A 是祖先类，如果需要为C、D、E类添加某些通用的功能，最简单的方法是让C类再继承另外一个类。但是问题来了，Java 是一种单继承的语言，不能再让C继承另外一个父类了，只到移动到继承链的最顶端，让A再继承一个父类。这样一来，对C、D、E类的修改，影响到了整个继承链，不具备可插入性的设计。</p>
<p>接口是可插入性的保证。在一个继承链中的任何一个类都可以实现一个接口，这个接口会影响到此类的所有子类，但不会影响到此类的任何父类。此类将不得不实现这个接口所规定的方法，而子类可以从此类自动继承这些方法，这时候，这些子类具有了可插入性。 </p>
<h3 id="接口的使用"><a href="#接口的使用" class="headerlink" title="接口的使用"></a>接口的使用</h3><p>接口的使用与类的使用有些不同。在需要使用类的地方，会直接使用new关键字来构建一个类的实例，但接口不可以这样使用，因为接口不能直接使用 new 关键字来构建实例。</p>
<p>接口必须通过类来实现(implements)它的抽象方法，然后再实例化类。类实现接口的关键字为implements。</p>
<p>如果一个类不能实现该接口的所有抽象方法，那么这个类必须被定义为抽象方法。</p>
<p>不允许创建接口的实例，但允许定义接口类型的引用变量，该变量指向了实现接口的类的实例。</p>
<p>一个类只能继承一个父类，但却可以实现多个接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">实现接口的格式如下：</span><br><span class="line">修饰符 <span class="class"><span class="keyword">class</span> 类名 <span class="keyword">extends</span> 父类 <span class="keyword">implements</span> 多个接口 </span>&#123;</span><br><span class="line">实现方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="headerlink" title="接口和抽象类的区别"></a>接口和抽象类的区别</h3><p>类是对象的模板，抽象类和接口可以看做是具体的类的模板。</p>
<p>由于从某种角度讲，接口是一种特殊的抽象类，它们的渊源颇深，有很大的相似之处，所以在选择使用谁的问题上很容易迷糊。我们首先分析它们具有的相同点。</p>
<ul>
<li>都代表类树形结构的抽象层。在使用引用变量时，尽量使用类结构的抽象层，使方法的定义和实现分离，这样做对于代码有松散耦合的好处。</li>
<li>都不能被实例化。</li>
<li>都能包含抽象方法。抽象方法用来描述系统提供哪些功能，而不必关心具体的实现。</li>
</ul>
<p>下面说一下抽象类和接口的主要区别。</p>
<ul>
<li>1) 抽象类可以为部分方法提供实现，避免了在子类中重复实现这些方法，提高了代码的可重用性，这是抽象类的优势；而接口中只能包含抽象方法，不能包含任何实现。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//A method2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//B method1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//C method1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>抽象类A有两个子类B、C，由于A中有方法method2的实现，子类B、C中不需要重写method2方法，我们就说A为子类提供了公共的功能，或A约束了子类的行为。method2就是代码可重用的例子。A 并没有定义 method1的实现，也就是说B、C 可以根据自己的特点实现method1方法，这又体现了松散耦合的特性。</p>
<p>再换成接口看看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//B method1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//B method2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//C method1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//C method2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口A无法为实现类B、C提供公共的功能，也就是说A无法约束B、C的行为。B、C可以自由地发挥自己的特点现实 method1和 method2方法，接口A毫无掌控能力。</p>
<ul>
<li>2) <strong>一个类只能继承一个直接的父类（可能是抽象类），但一个类可以实现多个接口，这个就是接口的优势</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">A</span>,<span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//C method1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//C method2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可以如此灵活的使用C，并且C还有机会进行扩展，实现其他接口</span></span><br><span class="line">A a=<span class="keyword">new</span> C();</span><br><span class="line">B b=<span class="keyword">new</span> C();</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//C method1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//C method2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于C类，将没有机会继承其他父类了。</p>
<p>综上所述，接口和抽象类各有优缺点，在接口和抽象类的选择上，必须遵守这样一个原则：</p>
<ul>
<li>行为模型应该总是通过接口而不是抽象类定义，所以通常是优先选用接口，尽量少用抽象类。</li>
<li>选择抽象类的时候通常是如下情况：需要定义子类的行为，又要为子类提供通用的功能。</li>
</ul>

          
        
      
    </div>
    
    
    
    
    
    
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/20/java/java入门基础（一）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mosbyllc">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mosbyllc">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/20/java/java入门基础（一）/" itemprop="url">java入门基础（一）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-20T23:07:23+08:00">
                2019-01-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  7,093
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  27
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前言：java在研究生阶段几乎没有再碰，很多都已经忘的差不多了。最近在看一些大数据的知识，需要捡起来一些，所以有了这篇总结文，这里的内容参考Free Will的<a href="https://plushunter.github.io/2017/08/20/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%EF%BC%9A%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/" target="_blank" rel="noopener">java学习笔记系列</a>，这里进行了一些增删查补，算是一个较为系统的回顾把。</p>
<hr>
<h1 id="语法基础"><a href="#语法基础" class="headerlink" title="语法基础"></a>语法基础</h1><p>Java是完全面向对象的语言。通过虚拟机的运行机制，实现“跨平台”的理念。一次编译，永久使用。 </p>
<p>下面两点有关Java的书写方式：</p>
<ul>
<li>Java中的语句要以 ; 结尾 (与C/C++相同)。</li>
<li>用花括号 {} 来整合语句，形成程序块。通过程序块，我们可以知道程序的不同部分的范围，比如类从哪里开始，到哪里结束。</li>
</ul>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>Java和C语言都是静态类型的语言。<strong>在使用变量之前，要声明变量的类型。</strong></p>
<p>变量(variable) 占据一定的内存空间。不同类型的变量占据不同的大小。Java中的变量类型如下：</p>
<p><img src="/2019/01/20/java/java入门基础（一）/01.png" alt></p>
<p>你可以在程序中的任意位置声明变量。 比如: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Declare in the middle:"</span>);</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        a = <span class="number">5</span>;</span><br><span class="line">        System.out.println(a);  <span class="comment">// print an integer</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组包含相同类型的多个数据。我用下面方法来声明一个整数数组: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a;</span><br></pre></td></tr></table></figure>
<p>在声明数组时，数组所需的空间并没有真正分配给数组。我可以在声明的同时，用new来创建数组所需空间:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br></pre></td></tr></table></figure>
<p>这里创建了可以容纳100个整数的数组。相应的内存分配也完成了。</p>
<p>我还可以在声明的同时，给数组赋值。数组的大小也同时确定。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h3><p>你可以在声明数组的同时进行初始化（静态初始化），也可以在声明以后进行初始化（动态初始化）。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态初始化</span></span><br><span class="line"><span class="comment">// 静态初始化的同时就为数组元素分配空间并赋值</span></span><br><span class="line"><span class="keyword">int</span> intArray[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">String stringArray[] = &#123;<span class="string">"程序员"</span>, <span class="string">"http://www.baidu.com"</span>, <span class="string">"一切编程语言都是纸老虎"</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态初始化</span></span><br><span class="line"><span class="keyword">float</span> floatArray[] = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">3</span>];</span><br><span class="line">floatArray[<span class="number">0</span>] = <span class="number">1.0f</span>;</span><br><span class="line">floatArray[<span class="number">1</span>] = <span class="number">132.63f</span>;</span><br><span class="line">floatArray[<span class="number">2</span>] = <span class="number">100F</span>;</span><br></pre></td></tr></table></figure>
<h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><p>二维数组的声明、初始化和引用与一维数组相似：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> intArray[ ][ ] = &#123; &#123;<span class="number">1</span>,<span class="number">2</span>&#125;, &#123;<span class="number">2</span>,<span class="number">3</span>&#125;, &#123;<span class="number">4</span>,<span class="number">5</span>&#125; &#125;;</span><br><span class="line"><span class="keyword">int</span> a[ ][ ] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">a[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">12</span>;</span><br><span class="line">a[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">34</span>;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">a[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">93</span>;</span><br></pre></td></tr></table></figure>
<p>Java语言中，由于把二维数组看作是数组的数组，数组空间不是连续分配的，所以不要求二维数组每一维的大小相同。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> intArray[ ][ ] = &#123; &#123;<span class="number">1</span>,<span class="number">2</span>&#125;, &#123;<span class="number">2</span>,<span class="number">3</span>&#125;, &#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125; &#125;;</span><br><span class="line"><span class="keyword">int</span> a[ ][ ] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][ ];</span><br><span class="line">a[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">a[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>几点说明</p>
</blockquote>
<ul>
<li>上面讲的是静态数组。静态数组一旦被声明，它的容量就固定了，不容改变。所以在声明数组时，一定要考虑数组的最大容量，防止容量不够的现象。</li>
<li>如果想在运行程序时改变容量，就需要用到数组列表(ArrayList，也称动态数组)或向量(Vector)。</li>
<li>正是由于静态数组容量固定的缺点，实际开发中使用频率不高，被 ArrayList 或 Vector 代替，因为实际开发中经常需要向数组中添加或删除元素，而它的容量不好预估。</li>
</ul>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>从表面上看，字符串就是双引号之间的数据，例如“java”等。在Java中，可以使用下面的方法定义字符串：<br>String stringName = “string content”;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String webName = <span class="string">"java学习"</span>;</span><br></pre></td></tr></table></figure>
<p><strong>字符串可以通过“+”连接，基本数据类型与字符串进行“+”操作一般也会自动转换为字符串</strong>，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String stuName = <span class="string">"小明"</span>;</span><br><span class="line">        <span class="keyword">int</span> stuAge = <span class="number">17</span>;</span><br><span class="line">        <span class="keyword">float</span> stuScore = <span class="number">92.5f</span>;</span><br><span class="line">       </span><br><span class="line">        String info = stuName + <span class="string">"的年龄是 "</span> + stuAge + <span class="string">"，成绩是 "</span> + stuScore;</span><br><span class="line">        System.out.println(info);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>String字符串与数组有一个共同点，就是它们被初始化后，<strong>长度是不变的，并且内容也不变</strong>。如果要改变它的值，就会产生一个新的字符串 .</p>
<p>实际上，String 是java.lang包下的一个类，按照标准的面向对象的语法，其格式应该为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String stringName = <span class="keyword">new</span> String(<span class="string">"string content"</span>);</span><br></pre></td></tr></table></figure>
<p>例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String url = <span class="keyword">new</span> String(<span class="string">"http://www.baidu.com"</span>);</span><br></pre></td></tr></table></figure>
<p>但是由于String特别常用，所以Java提供了一种简化的语法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String webName = <span class="string">"java学习"</span>;</span><br></pre></td></tr></table></figure>
<h3 id="常用的String对象方法"><a href="#常用的String对象方法" class="headerlink" title="常用的String对象方法"></a>常用的String对象方法</h3><h4 id="length-方法"><a href="#length-方法" class="headerlink" title="length()方法"></a>length()方法</h4><p>length() 返回字符串的长度.</p>
<h4 id="charAt-方法"><a href="#charAt-方法" class="headerlink" title="charAt()方法"></a>charAt()方法</h4><p>charAt() 方法的作用是按照索引值获得字符串中的指定字符。Java规定，字符串中第一个字符的索引值是0，第二个字符的索引值是1，依次类推。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"123456789"</span>;</span><br><span class="line">System.out.println(str.charAt(<span class="number">0</span>) + <span class="string">"    "</span> + str.charAt(<span class="number">5</span>) + <span class="string">"    "</span> + str.charAt(<span class="number">8</span>))</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>    <span class="number">6</span>    <span class="number">9</span></span><br></pre></td></tr></table></figure>
<h4 id="contain-方法"><a href="#contain-方法" class="headerlink" title="contain()方法"></a>contain()方法</h4><p>contains() 方法用来检测字符串是否包含某个子串，返回布尔值，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"baidu"</span>;</span><br><span class="line">System.out.println(str.contains(<span class="string">"bai"</span>));</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure>
<h4 id="replace-方法"><a href="#replace-方法" class="headerlink" title="replace()方法"></a>replace()方法</h4><p>字符串替换，用来替换字符串中所有指定的子串，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ring str1 = <span class="string">"The url of baidu is www.google.com!"</span>;</span><br><span class="line">String str2 = str1.replace(<span class="string">"baidu"</span>, <span class="string">"google"</span>);</span><br><span class="line">System.out.println(str1);</span><br><span class="line">System.out.println(str2);</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The url of baidu is www.google.com!</span><br><span class="line">The url of google is www.google.com!</span><br></pre></td></tr></table></figure>
<p>注意：replace() 方法不会改变原来的字符串，而是生成一个新的字符串。</p>
<h4 id="split-方法"><a href="#split-方法" class="headerlink" title="split()方法"></a>split()方法</h4><p>以指定字符串作为分隔符，对当前字符串进行分割，分割的结果是一个数组，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String str = <span class="string">"wei_xue_yuan_is_good"</span>;</span><br><span class="line">        String strArr[] = str.split(<span class="string">"_"</span>);</span><br><span class="line">        System.out.println(Arrays.toString(strArr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[wei, xue, yuan, is, good]</span><br></pre></td></tr></table></figure>
<p>以上仅仅列举了几个常用的String对象的方法，更多方法和详细解释请参考API文档。</p>
<h3 id="StringBuffer与StringBuider"><a href="#StringBuffer与StringBuider" class="headerlink" title="StringBuffer与StringBuider"></a>StringBuffer与StringBuider</h3><p>String 的值是不可变的，每次对String的操作都会生成新的String对象，不仅效率低，而且耗费大量内存空间。</p>
<p><strong>StringBuffer类和String类一样，也用来表示字符串，但是StringBuffer的内部实现方式和String不同，在进行字符串处理时，不生成新的对象，在内存使用上要优于String。</strong></p>
<p><strong>StringBuffer 默认分配16字节长度的缓冲区，当字符串超过该大小时，会自动增加缓冲区长度，而不是生成新的对象</strong>。</p>
<h4 id="StringBuffer类的主要方法"><a href="#StringBuffer类的主要方法" class="headerlink" title="StringBuffer类的主要方法"></a>StringBuffer类的主要方法</h4><p>StringBuffer类中的方法主要偏重于对于字符串的操作，例如追加、插入和删除等，这个也是StringBuffer类和String类的主要区别。实际开发中，如果需要对一个字符串进行频繁的修改，建议使用 StringBuffer。</p>
<ul>
<li>1) append() 方法</li>
</ul>
<p>append() 方法用于向当前字符串的末尾追加内容，类似于字符串的连接。调用该方法以后，StringBuffer对象的内容也发生改变，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer str = <span class="keyword">new</span> StringBuffer(“biancheng100”);</span><br><span class="line">str.append(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>
<p>则对象str的值将变成”biancheng100true”。注意是str指向的内容变了，不是str的指向变了。</p>
<ul>
<li>2) deleteCharAt()</li>
</ul>
<p>deleteCharAt() 方法用来删除指定位置的字符，并将剩余的字符形成新的字符串。</p>
<ul>
<li>3) insert()方法</li>
</ul>
<p>insert() 用来在指定位置插入字符串，可以认为是append()的升级版。</p>
<ul>
<li>4) setCharAt() 方法</li>
</ul>
<p>setCharAt() 方法用来修改指定位置的字符。</p>
<h4 id="String和StringBuffer的效率对比"><a href="#String和StringBuffer的效率对比" class="headerlink" title="String和StringBuffer的效率对比"></a>String和StringBuffer的效率对比</h4><p>建议在涉及大量字符串操作时使用StringBuffer。 </p>
<h4 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h4><p>StringBuilder类和StringBuffer类功能基本相似，方法也差不多，主要区别在于StringBuffer类的方法是多线程安全的，而StringBuilder不是线程安全的，相比而言，StringBuilder类会略微快一点。</p>
<p>总结一下： </p>
<p>线程安全：</p>
<ul>
<li>StringBuffer：线程安全</li>
<li>StringBuilder：线程不安全</li>
</ul>
<p>速度：</p>
<ul>
<li>一般情况下，速度从快到慢为 StringBuilder &gt; StringBuffer &gt; String，当然这是相对的，不是绝对的。</li>
</ul>
<p>使用环境：</p>
<ul>
<li>操作少量的数据使用 String；</li>
<li>单线程操作大量数据使用 StringBuilder；</li>
<li>多线程操作大量数据使用 StringBuffer。</li>
</ul>
<h1 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h1><h2 id="类的定义及其实例化"><a href="#类的定义及其实例化" class="headerlink" title="类的定义及其实例化"></a>类的定义及其实例化</h2><p><strong>类必须先定义才能使用。类是创建对象的模板，创建对象也叫类的实例化</strong>。 </p>
<p><strong>一个类可以包含以下类型变量</strong>：</p>
<ul>
<li>局部变量：在方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。</li>
<li>成员变量：成员变量是定义在类中、方法体之外的变量。这种变量在创建对象的时候实例化（分配内存）。成员变量可以被类中的方法和特定类的语句访问。</li>
<li>类变量：类变量也声明在类中，方法体之外，但必须声明为static类型。</li>
</ul>
<p>在Java中，使用new关键字来创建对象，一般有以下三个步骤：</p>
<ul>
<li>声明：声明一个对象，包括对象名称和对象类型。</li>
<li>实例化：使用关键字new来创建一个对象。</li>
<li>初始化：<strong>使用new创建对象时，会调用构造方法初始化对象</strong>。</li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Dog myDog;  <span class="comment">// 声明一个对象</span></span><br><span class="line">myDog = <span class="keyword">new</span> Dog(<span class="string">"花花"</span>, <span class="number">3</span>);  <span class="comment">// 实例化</span></span><br></pre></td></tr></table></figure>
<p>也可以在声明的同时进行初始化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Dog myDog = <span class="keyword">new</span> Dog(<span class="string">"花花"</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<h2 id="Java访问修饰符"><a href="#Java访问修饰符" class="headerlink" title="Java访问修饰符"></a>Java访问修饰符</h2><p>Java 通过修饰符来控制类、属性和方法的访问权限和其他功能，通常放在语句的最前端.访问控制分为四种级别：</p>
<p>　　（1）<strong>public</strong>： 用public修饰的类、类属变量及方法，包内及包外的任何类（包括子类和普通类）均可以访问；</p>
<p>　　（2）<strong>protected</strong>： 用protected修饰的类、类属变量及方法，包内的任何类及<strong>包外那些继承了该类的子类才能访问（此处稍后解释），protected重点突出继承；</strong></p>
<p>　　（3）<strong>default</strong>： 如果一个类、类属变量及方法没有用任何修饰符（即没有用public、protected及private中任何一种修饰），则其访问权限为default（默认访问权限）。默认访问权限的类、类属变量及方法，包内的任何类（包括继承了此类的子类）都可以访问它，而对于包外的任何类都不能访问它（包括包外继承了此类的子类）。<strong>default重点突出包</strong>；</p>
<p>　　（4）<strong>private</strong>： 用private修饰的类、类属变量及方法，只有本类可以访问，而包内包外的任何类均不能访问它。</p>
<p><img src="/2019/01/20/java/java入门基础（一）/02.png" alt></p>
<p><strong>最终总结，就一句话:</strong>protected修饰符所修饰的类（这句话中指父类）属成员变量和方法，只可以被子类访问，而不管子类是不是和父类位于同一个包中。default修饰符所修饰的类属成员变量和方法，只可被同一个包中的其他类访问，而不管其他类是不是该类的子类。protected属于子类限制修饰符，而default属于包限制修饰符.</p>
<h2 id="访问控制和继承"><a href="#访问控制和继承" class="headerlink" title="访问控制和继承"></a>访问控制和继承</h2><p>请注意以下方法继承的规则：</p>
<ul>
<li>父类中声明为public的方法在子类中也必须为public。</li>
<li>父类中声明为protected的方法在子类中要么声明为protected，要么声明为public。不能声明为private。</li>
<li>父类中默认修饰符声明的方法，能够在子类中声明为private。</li>
<li>父类中声明为private的方法，不能够被继承。</li>
</ul>
<h2 id="Java变量的作用域"><a href="#Java变量的作用域" class="headerlink" title="Java变量的作用域"></a>Java变量的作用域</h2><p>在Java中，变量的作用域分为四个级别：类级、对象实例级、方法级、块级。</p>
<ul>
<li>类级变量：又称全局级变量或静态变量，需要使用static关键字修饰，你可以与 C/C++ 中的 static 变量对比学习。类级变量在类定义后就已经存在，占用内存空间，可以通过类名来访问，不需要实例化。</li>
<li>对象实例级变量：就是成员变量，实例化后才会分配内存空间，才能访问。</li>
<li>方法级变量：就是在方法内部定义的变量，就是局部变量。</li>
<li>块级变量：就是定义在一个块内部的变量，变量的生存周期就是这个块，出了这个块就消失了，比如 if、for 语句的块。块是指由大括号包围的代码</li>
</ul>
<h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h2><p>this 关键字用来表示当前对象本身，或当前类的一个实例 。同样super表示父类对象本身。</p>
<h2 id="基本运行顺序"><a href="#基本运行顺序" class="headerlink" title="基本运行顺序"></a>基本运行顺序</h2><p>我们以下面的类来说明一个基本的 Java 类的运行顺序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Demo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        name = <span class="string">"java学习"</span>;</span><br><span class="line">        age = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Demo obj = <span class="keyword">new</span> Demo();</span><br><span class="line">        System.out.println(obj.name + <span class="string">"的年龄是"</span> + obj.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基本运行顺序是：</p>
<ul>
<li>先运行到第 9 行，这是程序的入口。</li>
<li>然后运行到第 10 行，这里要 new 一个Demo，就要调用 Demo 的构造方法。</li>
<li>就运行到第 5 行，注意：可能很多人觉得接下来就应该运行第 6 行了，错！初始化一个类，必须先初始化它的属性。</li>
<li>因此运行到第 2 行，然后是第 3 行。</li>
<li>属性初始化完过后，才回到构造方法，执行里面的代码，也就是第 6 行、第 7 行。</li>
<li>然后是第8行，表示 new 一个Demo实例完成。</li>
<li>然后回到 main 方法中执行第 11 行。</li>
<li>然后是第 12 行，main方法执行完毕。</li>
</ul>
<h1 id="继承、覆盖、重载"><a href="#继承、覆盖、重载" class="headerlink" title="继承、覆盖、重载"></a>继承、覆盖、重载</h1><h2 id="继承的概念与实现"><a href="#继承的概念与实现" class="headerlink" title="继承的概念与实现"></a>继承的概念与实现</h2><p>继承使用 extends 关键字。 </p>
<p>单继承性：Java 允许一个类仅能继承一个其它类，即一个类只能有一个父类，这个限制被称做单继承性。后面将会学到接口(interface)的概念，接口允许多继承。 </p>
<h2 id="继承中的方法的覆盖和重载"><a href="#继承中的方法的覆盖和重载" class="headerlink" title="继承中的方法的覆盖和重载"></a>继承中的方法的覆盖和重载</h2><p>覆盖和重载的不同：</p>
<ul>
<li>方法覆盖要求参数列表必须一致，而方法重载要求参数列表必须不一致。</li>
<li>方法覆盖要求返回类型必须一致，方法重载对此没有要求。</li>
<li>方法覆盖只能用于子类覆盖父类的方法，方法重载用于同一个类中的所有方法（包括从父类中继承而来的方法）。</li>
<li>方法覆盖对方法的访问权限和抛出的异常有特殊的要求，而方法重载在这方面没有任何限制。</li>
<li>父类的一个方法只能被子类覆盖一次，而一个方法可以在所有的类中可以被重载多次</li>
</ul>
<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>多态存在的三个必要条件：要有继承、要有重写、父类变量引用子类对象。 </p>
<h2 id="instanceof运算符"><a href="#instanceof运算符" class="headerlink" title="instanceof运算符"></a>instanceof运算符</h2><p>Java 使用 instanceof 操作符判断一个变量所实际引用的对象的类型 。，注意是它引用的对象的类型，不是变量的类型。 </p>
<h2 id="强制类型转换、向上转型、向下转型"><a href="#强制类型转换、向上转型、向下转型" class="headerlink" title="强制类型转换、向上转型、向下转型"></a>强制类型转换、向上转型、向下转型</h2><p> 在Java中，之所以需要强制类型转换是为了防止程序员在不知情的情况下把A类型数据错当成B类型的数据。<strong>如果这两种是兼容的，那么Java将执行自动转换</strong>，例如int和long，将int类型赋值给long类型的变量，总是可行的。但不是所有的类型都兼容。例如，没有将double类型转换为byte型的定义。<strong>但是不兼容的类型之间的转换仍然是可能的。达到这个目的，就需要使用强制类型转换。完成两个不兼容类型的强制转换。</strong></p>
<h3 id="自动类型转换和强制类型转换"><a href="#自动类型转换和强制类型转换" class="headerlink" title="自动类型转换和强制类型转换"></a>自动类型转换和强制类型转换</h3><p>在Java中由于继承和向上转型，子类可以非常自然地转换成父类，但是父类转换成子类则需要强制转换。因为子类拥有比父类更多的属性、更强的功能，所以父类转换为子类需要强制。</p>
<p>当我们用一个类型的构造器构造出一个对象时，这个对象的类型就已经确定的，也就说它的本质是不会再发生变化了。在Java中我们可以通过继承、向上转型的关系使用父类类型来引用它，这个时候我们是使用功能较弱的类型引用功能较强的对象，这是可行的。但是将功能较弱的类型强制转功能较强的对象时，就不一定可以行了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Father father = <span class="keyword">new</span> Son();</span><br><span class="line">Son son = (Son)father; <span class="comment">// 强制转换成功</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//编译出错，ClassCastException</span></span><br><span class="line">Father father = <span class="keyword">new</span> Father();</span><br><span class="line">Son son = (Son) father;</span><br></pre></td></tr></table></figure>
<p> <strong>在第一个例子中，father被指向一个子类对象，子类也可以指向子类对象。而第二个例子中，father被传给一个父类对象，子类引用不能指向父类对象。</strong>即很重要的概念是：父类引用指向子类对象。将父类转换为子类之前，应该用instanceof检查。 </p>
<p> <strong>总结</strong>：<strong>父类引用可以指向子类对象，子类引用不能指向父类对象（子类可以指向子类对象）</strong>。<strong>把子类对象直接赋给父类引用叫做向上转型，向上转型不用强制转型</strong>，如Father f1=new Son()，<strong>把指向子类对象的父类引用赋给子类引用叫做向下转型，要强制转型，如Son s1 = (Son)f1</strong>。<strong>向上转型会丢失子类特有的方法，但是子类overriding父类的方法，子类方法有效。</strong> </p>
<h3 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.sheepmu;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class"> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"父类的 eating..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span> <span class="keyword">extends</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class"></span>&#123;	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"子类重写的父类的  eatting..."</span>);</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"子类新方法  flying..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sys</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		Animal b=<span class="keyword">new</span> Bird(); <span class="comment">//向上转型</span></span><br><span class="line">		b.eat(); </span><br><span class="line">		<span class="comment">//  b.fly(); b虽指向子类对象，但此时子类作为向上的代价丢失和父类不同的fly()方法</span></span><br><span class="line">		sleep(<span class="keyword">new</span> Male());</span><br><span class="line">		sleep(<span class="keyword">new</span> Female());<span class="comment">//传入的参数是子类-----！！</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(Human h)</span> <span class="comment">//方法的参数是父类------！！！</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line"> 		 h.sleep();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sheepmu;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"父类人类   sleep.."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Male</span> <span class="keyword">extends</span> <span class="title">Human</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"男人 sleep.."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Female</span> <span class="keyword">extends</span> <span class="title">Human</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"女人 sleep.."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//子类重写的父类的  eatting...</span></span><br><span class="line"><span class="comment">//男人 sleep..</span></span><br><span class="line"><span class="comment">//女人 sleep..</span></span><br></pre></td></tr></table></figure>
<p>解释：</p>
<ul>
<li><p>向上转型的实现         </p>
<pre><code>  Animal b=new Bird(); //向上转型
  b.eat(); // 调用的是子类的eat()方法
  b.fly(); // 报错!!!!!-b虽指向子类对象，但此时子类作为向上转型的代价丢失和父类不同的fly()法
</code></pre></li>
<li><p>为何不直接Bird b=new Bird();b.eat() 呢？</p>
<pre><code> 这样就没有体现出面向对象的抽象的编程思想呀，降低了代码的可扩展性.
</code></pre></li>
<li><p>向上转型的好处？</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  sleep(<span class="keyword">new</span> Male());<span class="comment">//调用方法时传入的参数是子类</span></span><br><span class="line">  sleep(<span class="keyword">new</span> Female());</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(Human h)</span> <span class="comment">//方法的参数是父类，若不用向上转型则需要传入各种子类</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     h.sleep();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上代码就是用的向上转型，若是不用向上转型，那么有多少个子类就得在这儿写多少种不同的睡觉方法</p>
<h3 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sheepmu;</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Fruit</span></span></span><br><span class="line"><span class="class">  </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"我是父类  水果..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span></span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myName</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123; </span><br><span class="line">		System.out.println(<span class="string">"我是子类  苹果..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myMore</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"我是你的小呀小苹果~~~~~~"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sys</span></span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">		Fruit a=<span class="keyword">new</span> Apple(); <span class="comment">//向上转型</span></span><br><span class="line">		a.myName();</span><br><span class="line">		</span><br><span class="line">		Apple aa=(Apple)a; <span class="comment">//向下转型,编译和运行皆不会出错(正确的)</span></span><br><span class="line">		aa.myName();<span class="comment">//向下转型时调用的是子类的</span></span><br><span class="line">		aa.myMore();;</span><br><span class="line">		  </span><br><span class="line">		Fruit f=<span class="keyword">new</span> Fruit();</span><br><span class="line">         Apple aaa=(Apple)f; <span class="comment">//-出错，不安全的---向下转型,编译无错但会运行会出错</span></span><br><span class="line">  		aaa.myName();</span><br><span class="line">  		aaa.myMore(); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输出：</span></span><br><span class="line"><span class="comment">我是子类  苹果...</span></span><br><span class="line"><span class="comment">我是子类  苹果... </span></span><br><span class="line"><span class="comment">我是你的小呀小苹果~~~~~~</span></span><br><span class="line"><span class="comment">Exception in thread "main" java.lang.ClassCastException: com.sheepmu.Fruit cannot be cast to com.sheepmu.Apple at com.sheepmu.Sys.main(Sys.java:30)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>解释：</p>
<ul>
<li>正确的向下转型    </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     Fruit a=<span class="keyword">new</span> Apple(); <span class="comment">//向上转型</span></span><br><span class="line">     a.myName(); </span><br><span class="line">     Apple aa=(Apple)a; <span class="comment">//向下转型,编译和运行皆不会出错(正确的)</span></span><br><span class="line">     aa.myName();</span><br><span class="line">     aa.myMore();</span><br></pre></td></tr></table></figure>
<p><strong>a指向子类的对象，所以子类的实例aa也可以指向a啊。向下转型后因为都是指向子类对象，所以调用的当然全是子类的方法</strong></p>
<ul>
<li>不安全的向下转型（儿子不能指爸爸）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Fruit f=<span class="keyword">new</span> Fruit();</span><br><span class="line">Apple aaa=(Apple)f; <span class="comment">//-不安全的---向下转型,编译无错但会运行会出错</span></span><br><span class="line">aaa.myName();</span><br><span class="line">aaa.myMore();</span><br></pre></td></tr></table></figure>
<p>f是父类对象，子类的实例aaa肯定不能指向父类f啊</p>
<ul>
<li>Java为了解决不安全的向下转型问题，引入泛型的概念</li>
<li>为了安全的类型转换，最好先用 if(A instanceof  B) 判断一下下</li>
</ul>
<h1 id="static、final关键字和Object类"><a href="#static、final关键字和Object类" class="headerlink" title="static、final关键字和Object类"></a>static、final关键字和Object类</h1><h2 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h2><p>static 修饰符能够与变量、方法一起使用，<strong>表示是“静态”的</strong>。静态变量和静态方法能够通过类名来访问，<strong>不需要创建一个类的对象来访问该类的静态成员，所以static修饰的成员又称作类变量和类方法</strong>。静态变量与实例变量不同，<strong>实例变量总是通过对象来访问，因为它们的值在对象和对象之间有所不同。</strong>请看下面的例子： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    Demo() &#123;</span><br><span class="line">        <span class="keyword">this</span>.j = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"类变量 i="</span> + Demo.i); <span class="comment">//静态方法和变量通过类名访问</span></span><br><span class="line">        Demo obj = <span class="keyword">new</span> Demo();</span><br><span class="line">        System.out.println(<span class="string">"实例变量 j="</span> + obj.j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类变量 i=<span class="number">10</span></span><br><span class="line">实例变量 j=<span class="number">20</span></span><br></pre></td></tr></table></figure>
<h3 id="static的内存分配"><a href="#static的内存分配" class="headerlink" title="static的内存分配"></a>static的内存分配</h3><p>静态变量属于类，不属于任何独立的对象，所以无需创建类的实例就可以访问静态变量。之所以会产生这样的结果，是<strong>因为编译器只为整个类创建了一个静态变量的副本，也就是只分配一个内存空间，虽然有多个实例，但这些实例共享该内存</strong>(也就是该静态变量会被多个实例共同修改)。<strong>实例变量则不同，每创建一个对象，都会分配一次内存空间，不同变量的内存相互独立，互不影响</strong>（各独立一份，不会被共同修改），改变 a 对象的实例变量不会影响 b 对象。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo obj1 = <span class="keyword">new</span> Demo();</span><br><span class="line">        obj1.i = <span class="number">10</span>;</span><br><span class="line">        obj1.j = <span class="number">20</span>;</span><br><span class="line">       </span><br><span class="line">        Demo obj2 = <span class="keyword">new</span> Demo();</span><br><span class="line">       </span><br><span class="line">        System.out.println(<span class="string">"obj1.i="</span> + obj1.i + <span class="string">", obj1.j="</span> + obj1.j);</span><br><span class="line">        System.out.println(<span class="string">"obj2.i="</span> + obj2.i + <span class="string">", obj2.j="</span> + obj2.j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj1.i=<span class="number">10</span>, obj1.j=<span class="number">20</span></span><br><span class="line">obj2.i=<span class="number">10</span>, obj2.j=<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>注意：静态变量虽然也可以通过对象来访问，但是不被提倡，编译器也会产生警告。</p>
<p>上面的代码中，i 是静态变量，通过 obj1 改变 i 的值，会影响到 obj2；j 是实例变量，通过 obj1 改变 j 的值，不会影响到 obj2。这是因为 obj1.i 和 obj2.i 指向同一个内存空间（为整个类只分配一个静态变量的空间），而 obj1.j 和 obj2.j 指向不同的内存空间，请看下图：</p>
<p><img src="/2019/01/20/java/java入门基础（一）/03.png" alt></p>
<p>注意：static 的变量是在类装载的时候就会被初始化。也就是说，只要类被装载，不管你是否使用了这个static 变量，它都会被初始化。</p>
<p>小结：类变量(class variables)用关键字 static 修饰，在类加载的时候，分配类变量的内存，以后再生成类的实例对象时，将共享这块内存（类变量），任何一个对象对类变量的修改，都会影响其它对象。外部有两种访问方式：通过对象来访问或通过类名来访问。</p>
<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>静态方法是一种不能向对象实施操作的方法。例如，Math 类的 pow() 方法就是一个静态方法，语法为 Math.pow(x, a)，用来计算 x 的 a 次幂，在使用时无需创建任何 Math 对象。</p>
<p>因为静态方法不能操作对象，所以不能在静态方法中访问实例变量，只能访问自身类的静态变量。</p>
<p>关于静态变量和静态方法的总结：</p>
<ul>
<li>一个类的静态方法只能访问静态变量；</li>
<li>一个类的静态方法不能够直接调用非静态方法；</li>
<li>如访问控制权限允许，静态变量和静态方法也可以通过对象来访问，但是不被推荐；</li>
<li>静态方法中不存在当前对象，因而不能使用 this，当然也不能使用 super；</li>
<li>静态方法不能被非静态方法覆盖；</li>
<li>构造方法不允许声明为 static 的；</li>
<li>局部变量不能使用static修饰。</li>
</ul>
<blockquote>
<p> 注意：实例变量只能通过对象来访问，不能通过类访问。 </p>
</blockquote>
<h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><p>在 Java 中，声明类、变量和方法时，可使用关键字 final 来修饰。final 所修饰的数据具有“终态”的特征，表示“最终的”意思。具体规定如下：</p>
<ul>
<li>final 修饰的类不能被继承。</li>
<li>final 修饰的方法不能被子类重写。</li>
<li>final 修饰的变量（成员变量或局部变量）即成为常量，只能赋值一次。</li>
<li>final 修饰的成员变量必须在声明的同时赋值，如果在声明的时候没有赋值，那么只有 一次赋值的机会，而且只能在构造方法中显式赋值，然后才能使用。</li>
<li>final 修饰的局部变量可以只声明不赋值，然后再进行一次性的赋值。</li>
</ul>
<p>final 一般用于修饰那些通用性的功能、实现方式或取值不能随意被改变的数据，以避免被误用，例如实现数学三角方法、幂运算等功能的方法，以及数学常量π=3.141593、e=2.71828 等。</p>
<p>需要注意的是，如果将引用类型（任何类的类型）的变量标记为 final，那么该变量不能指向任何其它对象。但可以改变对象的内容，因为只有引用本身是 final 的。</p>
<p>如果变量被标记为 final，其结果是使它成为常数。想改变 final 变量的值会导致一个编译错误。</p>
<p>常量因为有 final 修饰，所以不能被继承。 </p>
<p>final 也可以用来修饰类（放在 class 关键字前面），阻止该类再派生出子类 。</p>
<p>方法也可以被 final 修饰，被 final 修饰的方法不能被覆盖 </p>
<h2 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h2><p>Object 类位于 java.lang 包中，是所有 Java 类的祖先，Java 中的每个类都由它扩展而来。定义Java类时如果没有显示的指明父类，那么就默认继承了 Object 类。</p>
<p>Object 类定义了一些有用的方法，由于是根类，这些方法在其他类中都存在，一般是进行了重载或覆盖，实现了各自的具体功能。 </p>
<h3 id="equals-方法"><a href="#equals-方法" class="headerlink" title="equals() 方法"></a>equals() 方法</h3><p>Object 类中的 equals() 方法用来检测一个<strong>对象</strong>是否等价于另外一个<strong>对象</strong></p>
<h3 id="hashCode-方法"><a href="#hashCode-方法" class="headerlink" title="hashCode()方法"></a>hashCode()方法</h3><p>散列码(hashCode)是按照一定的算法由对象得到的一个数值，散列码没有规律。如果 x 和 y 是不同的对象，x.hashCode() 与 y.hashCode() 基本上不会相同。hashCode() 方法主要用来在集合中实现快速查找等操作，也可以用于对象的比较。</p>
<h3 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString()方法"></a>toString()方法</h3><p>toString() 方法是 Object 类中定义的另一个重要方法，是对象的字符串表现形式</p>

          
        
      
    </div>
    
    
    
    
    
    
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/18/深度学习/深度学习（四）：循环神经网络/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mosbyllc">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mosbyllc">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/18/深度学习/深度学习（四）：循环神经网络/" itemprop="url">深度学习（四）：循环神经网络</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-18T17:06:13+08:00">
                2018-12-18
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/深度学习/" itemprop="url" rel="index">
                    <span itemprop="name">深度学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3,943
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  15
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在本章中，我们将看到循环神经网络背后的基本概念，他们所面临的主要问题（换句话说，在之前中讨论的消失／爆炸的梯度），以及广泛用于反抗这些问题的方法：LSTM 和 GRU cell（单元）。 循环神经网路主要解决带有时序性质的问题。</p>
<h2 id="基本循环神经"><a href="#基本循环神经" class="headerlink" title="基本循环神经"></a>基本循环神经</h2><p>看下图中一个简单的循环神经网络图，它由输入层、一个隐藏层和一个输出层组成。我们可以看到，循环神经网络的隐藏层的值s不仅仅取决于当前这次的输入x，<strong>还取决于上一次隐藏层的值s</strong>（结果向前和向后传播后的上一次这个位置的值）。</p>
<p><img src="/2018/12/18/深度学习/深度学习（四）：循环神经网络/01.jpg" alt></p>
<p>如果我们把上面的图展开，循环神经网络也可以画成下面这个样子：</p>
<p><img src="/2018/12/18/深度学习/深度学习（四）：循环神经网络/02.jpg" alt></p>
<p> 现在看起来就清楚不少了，这个网络在t时刻接收到输入$X<em>t$之后，隐藏层的值是$S_t$，输出值是$o_t$。关键一点是，$s_t$的值不仅仅取决于$X_t$，还取决于$S</em>{t−1}$。我们可以使用下面的公式来表示循环神经网络的计算方法： (U,V,W都为权重) </p>
<script type="math/tex; mode=display">
o_t=g(Vs_t)\\s_t=f(Ux_t+Ws_{t-1})</script><p>式1是输出层的计算公式，输出层是一个全连接层，也就是它的每个节点都和隐藏层的每个节点相连。V是输出层的权重矩阵，g是激活函数。式2是隐藏层的计算公式，它是循环层。U是输入x的权重矩阵，W是上一次的值st−1st−1作为这一次的输入的权重矩阵，f是激活函数。</p>
<p>从上面的公式可以看出，循环层和全连接层的区别就是多了一个权重矩阵W。</p>
<p>若反复把式2代入带式1，我们将得到：</p>
<script type="math/tex; mode=display">
o_t=g(Vs_t)=g(Vf(Ux_t+Ws_{t-1}))</script><script type="math/tex; mode=display">
=g(Vf(Ux_t+Wf(Ux_{t-1}+Ws_{t-2 })))</script><script type="math/tex; mode=display">
=g(Vf(Ux_t+Wf(Ux_{t-1}+Wf(Ux_{t-2}+Ws_{t-3 }))))</script><p> 从上面可以看出，循环神经网络的输出值$o<em>t$，是受前面历次输入值$x_t$、$x</em>{t−1}$、$x_{t−2}$…的影响的，这就是为什么循环神经网络可以往前看任意多个输入值的原因。 </p>
<p> 再来看一个清晰一点的循环神经元层，见下图， 在每个时间步t，每个神经元都接收输入向量$x^{(t)}$和前一个时间步的输出向量$y^{(t−1)}$，如图所示。 请注意，输入和输出都是向量（当只有一个神经元时，输出是一个标量）。 </p>
<p><img src="/2018/12/18/深度学习/深度学习（四）：循环神经网络/03.png" alt></p>
<p> 每个循环神经元有两组权重：一组用于输入 $x^{(t)}$，另一组用于前一时间步长 $y^{(t−1)}$的输出。我们称这些权重向量为$w_x$和$w_y$。如下面公式所示（<code>b</code>是偏差项，<code>φ(·)</code>是激活函数，例如 ReLU），可以计算单个循环神经元的输出。 </p>
<p><img src="/2018/12/18/深度学习/深度学习（四）：循环神经网络/04.png" alt></p>
<p> 就像前馈神经网络一样，我们可以使用上一个公式的向量化形式，对整个小批量计算整个层的输出。 </p>
<p><img src="/2018/12/18/深度学习/深度学习（四）：循环神经网络/05.png" alt></p>
<ul>
<li>$Y^{(t)}$是$m×n<em>{neurons}$矩阵，包含在最小批次中每个实例在时间步<code>t</code>处的层输出（<code>m</code>是小批次中的实例数， $n</em>{neurons}$是神经元数</li>
<li>$X^{(t)}$是$m×n<em>{inputs}$矩阵，包含所有实例的输入的（$n</em>{inputs}$是输入特征的数量 ）</li>
<li>$W<em>x$是$ n</em>{inputs}×n_{neurons} $矩阵，包含当前时间步的输入的连接权重的。</li>
<li>$W<em>y$是$n</em>{neurons}×n_{neurons}$矩阵，包含上一个时间步的输出的连接权重。</li>
<li>权重矩阵$W<em>x$和$W_y$通常连接成单个矩阵W，形状为$(n</em>{inputs}+n<em>{neurons})×n</em>{neurons}$（见上述公式第二行）</li>
<li><code>b</code>是大小为 $n_{neurons}$的向量，包含每个神经元的偏置项</li>
</ul>
<blockquote>
<p>注意， 在第一个时间步，<code>t = 0</code>，没有以前的输出，所以它们通常被假定为全零。</p>
</blockquote>
<h2 id="TensorFlow-中的解释基本-RNN"><a href="#TensorFlow-中的解释基本-RNN" class="headerlink" title="TensorFlow 中的解释基本 RNN"></a>TensorFlow 中的解释基本 RNN</h2><p>首先，我们来实现一个非常简单的 RNN 模型，而不使用任何 TensorFlow 的 RNN 操作，以更好地理解发生了什么。 我们将<strong>使用 tanh 激活函数创建由 5 个循环神经元的循环层组成的 RNN</strong>（如下图所示的 RNN）。</p>
<p><img src="/2018/12/18/深度学习/深度学习（四）：循环神经网络/03.png" alt></p>
<p> 我们将假设 RNN <strong>只运行两个时间步</strong>，每个时间步输入大小为 3 的向量。 下面的代码构建了这个 RNN，展开了两个时间步骤： </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">n_inputs = <span class="number">3</span></span><br><span class="line">n_neurons = <span class="number">5</span></span><br><span class="line">X0 = tf.placeholder(tf.float32, [<span class="literal">None</span>, n_inputs])</span><br><span class="line"><span class="comment"># 充当经过向前向后传播后的下一时刻的输入值</span></span><br><span class="line">X1 = tf.placeholder(tf.float32, [<span class="literal">None</span>, n_inputs]) </span><br><span class="line">Wx = tf.Variable(tf.random_normal(shape=[n_inputs, n_neurons], dtype=tf.float32))</span><br><span class="line">Wy = tf.Variable(tf.random_normal(shape=[n_neurons, n_neurons], dtype=tf.float32))</span><br><span class="line">b = tf.Variable(tf.zeros([<span class="number">1</span>, n_neurons], dtype=tf.float32))</span><br><span class="line">Y0 = tf.tanh(tf.matmul(X0, Wx) + b)</span><br><span class="line">Y1 = tf.tanh(tf.matmul(Y0, Wy) + tf.matmul(X1, Wx) + b) <span class="comment"># 主要理解这句</span></span><br><span class="line">init = tf.global_variables_initializer()</span><br></pre></td></tr></table></figure>
<h2 id="双向循环神经网络"><a href="#双向循环神经网络" class="headerlink" title="双向循环神经网络"></a>双向循环神经网络</h2><p>对于语言模型来说，很多时候光看前面的词是不够的，比如下面这句话：</p>
<blockquote>
<p>我的手机坏了，我打算<em>__</em>一部新手机。</p>
</blockquote>
<p>可以想象，如果我们只看横线前面的词，手机坏了，那么我是打算修一修？换一部新的？还是大哭一场？这些都是无法确定的，但是如果我们也看到了后面的词是“一部新手机”，那么横线上的词填“买”的概率就大很多了。</p>
<p>而这个在单向循环神经网络是无法建模的，因此我们需要双向循环神经网络，如下图所示：</p>
<p><img src="/2018/12/18/深度学习/深度学习（四）：循环神经网络/06.jpg" alt></p>
<p> 我们先考虑$y_2$的计算，从上图可以看出，双向卷积神经网络的隐藏层要保存两个值，一个A参与正向计算，另一个A′参与反向计算。最终的输出值$y_2$取决于$A_2$和$A_2’$，其计算方法为： </p>
<script type="math/tex; mode=display">
y_2=g(VA_2+V'A_2')</script><p>$A_2$和$A_2’$ 则分别计算 </p>
<script type="math/tex; mode=display">
A_2=f(WA_1+Ux_2)</script><script type="math/tex; mode=display">
A_2'=f(W'A_3'+U'x_2 )</script><p> 现在，我们已经可以看出一般的规律：正向计算时，隐藏层的值$s<em>t$与$s</em>{t−1}$有关；反向计算时，隐藏层的值$s<em>t′$与$s′</em>{t+1}$有关；最终的输出取决于正向和反向计算的加和。现在，我们仿照式1和式2，写出双向循环神经网络的计算方法： </p>
<script type="math/tex; mode=display">
o_t=g(Vs_t+V's_t')</script><script type="math/tex; mode=display">
s_t=f(Ux_t+Ws_{t-1 })</script><script type="math/tex; mode=display">
s_t'=f(U'x_t+W's_{t+1}')</script><p>从上面三个公式我们可以看到，正向计算和反向计算不共享权重，也就是说U和U′、W和W′、V和V′都是不同的权重矩阵。</p>
<h2 id="深度循环神经网络"><a href="#深度循环神经网络" class="headerlink" title="深度循环神经网络"></a>深度循环神经网络</h2><p>前面我们介绍的循环神经网络只有一个隐藏层，我们当然也可以堆叠两个以上的隐藏层，这样就得到了深度循环神经网络。如下图所示</p>
<p><img src="/2018/12/18/深度学习/深度学习（四）：循环神经网络/07.jpg" alt></p>
<h2 id="训练-RNN"><a href="#训练-RNN" class="headerlink" title="训练 RNN"></a>训练 RNN</h2><p>为了训练一个 RNN，诀窍是在时间上展开（就像我们刚刚做的那样），然后简单地使用常规反向传播（见图 14-5）。 这个策略被称为时间上的标准反向传播（BPTT）。另外可以<strong>采用截断式沿时间反向传播算法</strong>（BPTT）可以降低循环网络中每项参数更新的复杂度。简而言之，此种算法可以让我们以同样的运算能力更快地定型神经网络 。假设用长度为12个时间步的时间序列定型一个循环网络。我们需要进行12步的正向传递，计算误差（基于预测与实际值对比），再进行12个时间步的反向传递：</p>
<p><img src="/2018/12/18/深度学习/深度学习（四）：循环神经网络/08.png" alt></p>
<p>就像在正常的反向传播中一样，展开的网络（用虚线箭头表示）有第一个正向传递。然后使用损失函数评估输出序列$C(Y<em>{t</em>{min}},Y<em>{t</em>{min+1}},…,Y<em>{t</em>{max}})$。其中$t<em>{min}$ 和$t</em>{max}$ 是第一个和最后一个输出时间步长，不计算忽略的输出），并且该损失函数的梯度通过展开的网络向后传播（实线箭头）；最后使用在 BPTT 期间计算的梯度来更新模型参数。 请注意，梯度在损失函数所使用的所有输出中反向流动，而不仅仅通过最终输出（截断式传播，例如，在图 14-5 中，损失函数使用网络的最后三个输出Y(2)，Y(3)，和Y(4)，所以梯度流经这三个输出，但不通过Y(0)和Y(1)。而且，由于在每个时间步骤使用相同的参数<code>W</code>和<code>b</code>，所以反向传播将做正确的事情并且总结所有时间步骤。</p>
<p>具体BPTT的解析过程可以看这篇<a href="http://www.cnblogs.com/zhbzz2007/p/6339346.html" target="_blank" rel="noopener">戳我</a></p>
<h3 id="训练序列分类器"><a href="#训练序列分类器" class="headerlink" title="训练序列分类器"></a>训练序列分类器</h3><p>我们训练一个 RNN 来分类 MNIST 图像。 卷积神经网络将更适合于图像分类，但这是一个你已经熟悉的简单例子。 我们将把每个图像视为 28 行 28 像素的序列（因为每个MNIST图像是<code>28×28</code>像素）。 我们将使用 150 个循环神经元的单元，再加上一个全连接层，其中包含连接到上一个时间步的输出的 10 个神经元（每个类一个），然后是一个 softmax 层（见图）。</p>
<p><img src="/2018/12/18/深度学习/深度学习（四）：循环神经网络/10.png" alt></p>
<p> 建模阶段非常简单， 它和我们在之前中建立的 MNIST 分类器几乎是一样的，只是展开的 RNN 替换了隐层。 注意，全连接层连接到状态张量，其仅包含 RNN 的最终状态（即，第 28 个输出）。 另请注意，<code>y</code>是目标类的占位符。 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">n_steps = <span class="number">28</span></span><br><span class="line">n_inputs = <span class="number">28</span></span><br><span class="line">n_neurons = <span class="number">150</span></span><br><span class="line">n_outputs = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">learning_rate = <span class="number">0.001</span></span><br><span class="line"></span><br><span class="line">X = tf.placeholder(tf.float32, [<span class="literal">None</span>, n_steps, n_inputs])</span><br><span class="line">y = tf.placeholder(tf.int32, [<span class="literal">None</span>])</span><br><span class="line"></span><br><span class="line">basic_cell = tf.contrib.rnn.BasicRNNCell(num_units=n_neurons)</span><br><span class="line">outputs, states = tf.nn.dynamic_rnn(basic_cell, X, dtype=tf.float32)</span><br><span class="line"></span><br><span class="line">logits = tf.layers.dense(states, n_outputs)</span><br><span class="line">xentropy = tf.nn.sparse_softmax_cross_entropy_with_logits(labels=y,</span><br><span class="line">                                                          logits=logits)</span><br><span class="line">loss = tf.reduce_mean(xentropy)</span><br><span class="line">optimizer = tf.train.AdamOptimizer(learning_rate=learning_rate)</span><br><span class="line">training_op = optimizer.minimize(loss)</span><br><span class="line">correct = tf.nn.in_top_k(logits, y, <span class="number">1</span>)</span><br><span class="line">accuracy = tf.reduce_mean(tf.cast(correct, tf.float32))</span><br><span class="line"></span><br><span class="line">init = tf.global_variables_initializer()</span><br></pre></td></tr></table></figure>
<p>现在让我们加载 MNIST 数据，并按照网络的预期方式将测试数据重塑为<code>[batch_size, n_steps, n_inputs]</code>。 我们之后会关注训练数据的重塑。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.examples.tutorials.mnist <span class="keyword">import</span> input_data</span><br><span class="line">mnist = input_data.read_data_sets(<span class="string">"/tmp/data/"</span>)</span><br><span class="line">X_test = mnist.test.images.reshape((<span class="number">-1</span>, n_steps, n_inputs))</span><br><span class="line">y_test = mnist.test.labels</span><br></pre></td></tr></table></figure>
<p>现在我们准备训练 RNN 了。 执行阶段与第 10 章中 MNIST 分类器的执行阶段完全相同，不同之处在于我们在将每个训练的批量提供给网络之前要重新调整。</p>
<p>现在我们准备训练 RNN 了。 执行阶段与第 10 章中 MNIST 分类器的执行阶段完全相同，不同之处在于我们在将每个训练的批量提供给网络之前要重新调整。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">batch_size = <span class="number">150</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    init.run()</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> range(n_epochs):</span><br><span class="line">        <span class="keyword">for</span> iteration <span class="keyword">in</span> range(mnist.train.num_examples // batch_size):</span><br><span class="line">            X_batch, y_batch = mnist.train.next_batch(batch_size)</span><br><span class="line">            X_batch = X_batch.reshape((<span class="number">-1</span>, n_steps, n_inputs))</span><br><span class="line">            sess.run(training_op, feed_dict=&#123;X: X_batch, y: y_batch&#125;)</span><br><span class="line">        acc_train = accuracy.eval(feed_dict=&#123;X: X_batch, y: y_batch&#125;)</span><br><span class="line">        acc_test = accuracy.eval(feed_dict=&#123;X: X_test, y: y_test&#125;)</span><br><span class="line">        print(epoch, <span class="string">"Train accuracy:"</span>, acc_train, <span class="string">"Test accuracy:"</span>, acc_test)</span><br></pre></td></tr></table></figure>
<p>输出应该是这样的：</p>
<p><img src="/2018/12/18/深度学习/深度学习（四）：循环神经网络/11.png" alt></p>
<p>我们获得了超过 98% 的准确性 - 不错！ 另外，通过调整超参数，使用 He 初始化初始化 RNN 权重，更长时间训练或添加一些正则化（例如，droupout），你肯定会获得更好的结果。</p>
<p>你可以通过将其构造代码包装在一个变量作用域内（例如，使用<code>variable_scope(&quot;rnn&quot;, initializer = variance_scaling_initializer())</code>来使用 He 初始化）来为 RNN 指定初始化器。</p>
<h3 id="为预测时间序列而训练"><a href="#为预测时间序列而训练" class="headerlink" title="为预测时间序列而训练"></a>为预测时间序列而训练</h3><p>首先，我们来创建一个 RNN。 它将包含 100 个循环神经元，并且我们将在 20 个时间步骤上展开它，因为每个训练实例将是 20 个输入那么长。 每个输入将仅包含一个特征（在该时间的值）。 目标也是 20 个输入的序列，每个输入包含一个值。 代码与之前几乎相同：</p>
<p><img src="/2018/12/18/深度学习/深度学习（四）：循环神经网络/12.png" alt></p>
<p>一般来说，你将不只有一个输入功能。 例如，如果你试图预测股票价格，则你可能在每个时间步骤都会有许多其他输入功能，例如竞争股票的价格，分析师的评级或可能帮助系统进行预测的任何其他功能。</p>
<p>在每个时间步，我们现在有一个大小为 100 的输出向量。但是我们实际需要的是每个时间步的单个输出值。 最简单的解决方法是将单元包装在<code>OutputProjectionWrapper</code>中。 单元包装器就像一个普通的单元，代理每个方法调用一个底层单元，但是它也增加了一些功能。<code>Out putProjectionWrapper</code>在每个输出之上添加一个完全连接的线性神经元层（即没有任何激活函数）（但不影响单元状态）。 所有这些完全连接的层共享相同（可训练）的权重和偏差项。 结果 RNN 如图所示</p>
<p><img src="/2018/12/18/深度学习/深度学习（四）：循环神经网络/13.png" alt></p>
<p>装单元是相当容易的。 让我们通过将<code>BasicRNNCell</code>包装到<code>OutputProjectionWrapper</code>中来调整前面的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cell =tf.contrib.rnn.OutputProjectionWrapper(</span><br><span class="line">    tf.contrib.rnn.BasicRNNCell(num_units=n_neurons,activation=tf.nn.relu),</span><br><span class="line">    output_size=n_outputs)</span><br></pre></td></tr></table></figure>
<p>到现在为止还挺好。 现在我们需要定义损失函数。 我们将使用均方误差（MSE），就像我们在之前的回归任务中所做的那样。 接下来，我们将像往常一样创建一个 Adam 优化器，训练操作和变量初始化操作。（省略）</p>
<h3 id="生成-RNN"><a href="#生成-RNN" class="headerlink" title="生成 RNN"></a>生成 RNN</h3><p>到现在为止，我们已经训练了一个能够预测未来时刻样本值的模型，正如前文所述，可以用模型来生成新的序列。</p>
<p>为模型提供 长度为<code>n_steps</code>的种子序列, 比如全零序列，然后通过模型预测下一时刻的值；把该预测值添加到种子序列的末尾，用最后面 长度为<code>n_steps</code>的序列做为新的种子序列，做下一次预测，以此类推生成预测序列。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sequence = [<span class="number">0.</span>] * n_steps</span><br><span class="line"><span class="keyword">for</span> iteration <span class="keyword">in</span> range(<span class="number">300</span>):</span><br><span class="line">    X_batch = np.array(sequence[-n_steps:].reshape(<span class="number">1</span>, n_steps, <span class="number">1</span>)</span><br><span class="line">    y_pred = sess.run(outputs, feed_dict=&#123;X: X_batch&#125;</span><br><span class="line">    sequence.append(y_pred[<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h2 id="LSTM-单元"><a href="#LSTM-单元" class="headerlink" title="LSTM 单元"></a>LSTM 单元</h2><p><strong>在训练长序列的 RNN 模型时，那么就需要把 RNN 在时间维度上展开成很深的神经网络</strong>。正如任何深度神经网络一样，其面临着梯度消失/爆炸的问题，使训练无法终止或收敛。很多之前讨论过的缓解这种问题的技巧都可以应用在深度展开的 RNN 网络：好的参数初始化方式，非饱和的激活函数（如 ReLU），批量规范化（Batch Normalization）， 梯度截断（Gradient Clipping），更快的优化器。</p>
<p>即便如此， RNN 在处理适中的长序列（如 100 输入序列）也在训练时表现的很慢。最简单和常见的方法解决训练时长问题就是在训练阶段仅仅展开限定时间步长的 RNN 网络，一种称为截断时间反向传播的算法。</p>
<p><strong>在长的时间训练过程中，第二个要面临的问题时第一个输入的记忆会在长时间运行的 RNN 网络中逐渐淡去。 那么在一定时间后，第一个输入实际上会在 RNN 的状态中消失于无形</strong>。 为了解决其中的问题，各种能够携带长时记忆的神经单元的变体被提出。<strong>这些变体是有效的，往往基本形式的神经单元就不怎么被使用了。</strong></p>
<p>首先了解一下最流行的一种长时记忆神经单元：长短时记忆神经单元 LSTM。 可以看下面这篇文章</p>
<p><a href="https://www.yunaitong.cn/understanding-lstm-networks.html" target="_blank" rel="noopener">理解LSTM网络</a></p>
<blockquote>
<p>注：LSTM和GRU单元是近年来RNN成功背后的主要原因之一，特别实在自然语言的应用</p>
</blockquote>

          
        
      
    </div>
    
    
    
    
    
    
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/14/深度学习/深度学习（三）：卷积神经网络/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mosbyllc">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mosbyllc">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/14/深度学习/深度学习（三）：卷积神经网络/" itemprop="url">深度学习（三）：卷积神经网络</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-14T17:06:13+08:00">
                2018-12-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/深度学习/" itemprop="url" rel="index">
                    <span itemprop="name">深度学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3,836
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  14
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="认识卷积神经网络"><a href="#认识卷积神经网络" class="headerlink" title="认识卷积神经网络"></a>认识卷积神经网络</h2><p>全连接神经网络之所以不太适合图像识别任务，主要有三个方面的问题：</p>
<ul>
<li>参数数量太多，一个输入1000×1000像素的图片有100万个神经元（一个像素点代表一个神经元）</li>
<li>没有利用像素之间的位置信息</li>
<li>网络层数限制，网络层数越多，其表达能力越强，但是通过梯度下降方法训练深度全连接神经网络很困难，因为全连接神经网络的梯度很难传递超过三层。</li>
</ul>
<h3 id="局部感受野（local-receptive-fields）"><a href="#局部感受野（local-receptive-fields）" class="headerlink" title="局部感受野（local receptive fields）"></a>局部感受野（local receptive fields）</h3><p>在之前的全连接神经网络中，一个样例的输入被转换为一个一维向量。但在一个卷积网络中，把输入看作是一个按照28×28排列的正方形，或者当有颜色通道的时候，比如28x28x3，就是宽高都是28，且有3个颜色通道。比如下图就代表了一个输入</p>
<p><img src="/2018/12/14/深度学习/深度学习（三）：卷积神经网络/01.jpg" alt></p>
<p> 然后，我们通常把输入像素连接到一个隐藏层的神经元，但和全连接神经网络那样每个输入都连接一个隐藏层神经元不同的是，这里我们只是把输入图像进行局部的连接。 </p>
<p><img src="/2018/12/14/深度学习/深度学习（三）：卷积神经网络/02.jpg" alt></p>
<p>如此不断地重复，构建起第一个隐藏层。注意如果我们有一个28×28的输入图像，5×5的局部感受野，那么隐藏层中就会有24×24个神经元。这是因为在抵达抵达最右边或最底部的输入图像之前，我们只能把局部感受野向右或向下移动23个神经元。</p>
<p><img src="/2018/12/14/深度学习/深度学习（三）：卷积神经网络/03.jpg" alt></p>
<p>如上图所示，把图中间的那个看作是可以“滑动的窗口”，他的作用是和输入相应的“感受域”下的像素做运算得到新的值。这个运算就是“卷积”运算了。图上面有详细的运算过程。实际上就是每个相应元素的值相乘，然后把得到的都加起来。这个窗口的本质是其中的数字和一个偏置构成的，通常就把<strong>这个窗口(Convolution kernel)叫做滤波器或者卷积核（相当于是全连接层里面要求的隐藏权重，它代表识别某个特征）</strong>。 这个“窗口”是可以滑动的，每次的滑动步长可以人为指定 。</p>
<h3 id="池化-Pooling"><a href="#池化-Pooling" class="headerlink" title="池化(Pooling)"></a>池化(Pooling)</h3><p>它的作用是逐渐<strong>降低数据体的空间尺寸，这样的话就能减少网络中参数的数量，使得计算资源耗费变少，也能有效控制过拟合</strong>。最常见的形式是汇聚层使用尺寸2x2的滤波器，以步长为2来对每个深度切片进行降采样，将其中75%的激活信息都丢掉。每个MAX操作是从4个数字中取最大值（也就是在深度切片中某个2x2的区域）。深度保持不变。</p>
<p>Pooling的方法很多，最常用的是Max Pooling。 此外，还有平均池化（average pooling）和L2-norm池化。</p>
<p><img src="/2018/12/14/深度学习/深度学习（三）：卷积神经网络/04.jpg" alt></p>
<h2 id="卷积神经网络的层"><a href="#卷积神经网络的层" class="headerlink" title="卷积神经网络的层"></a>卷积神经网络的层</h2><p>首先，让我们对卷积神经网络有一个感性的认识，下图就是一个卷积神经网络的示意图：</p>
<p><img src="/2018/12/14/深度学习/深度学习（三）：卷积神经网络/05.jpg" alt></p>
<p> 如上图所示，一个神经网络由若干卷积层（CONV）、Pooling层（POOL）、全连接层（FC）组成。你可以构建各种不同的卷积神经网络，它的常用架构模式为： </p>
<script type="math/tex; mode=display">
INPUT\rightarrow\left[\left[CONV\right]\times N\rightarrow POOL\right]\times M\rightarrow\left[FC\right]\times K</script><p>也就是N个卷积层叠加，然后叠加一个Pooling层（可选），重复这个结构M次，最后叠加K个全连接层。</p>
<p>对于上图来说，该卷积神经网络的架构为：</p>
<script type="math/tex; mode=display">
INPUT\rightarrow\left[\left[CONV\right]\times 1\rightarrow POOL\right]\times 2\rightarrow\left[FC\right]\times 2</script><p>也就是N=1,M=2,K=2</p>
<p>我们看到输入层的宽度和高度对应于输入图像的宽度和高度，而他的深度为1。接着第一个卷积层对这幅图像进行了卷积操作，得到了三个Feature Map。<strong>实际上这个卷积层包含三个Filter（卷积核，是隐藏不显示图上的），也就是三套参数，每个Filter都可以把原始输入图像卷积得到一个Feature Map，三个Filter就可以得到三个Feature Map</strong>。<strong>至于一个卷积层可以有多少个Filter，那是可以自由设定的。也就是说，卷积层的Filter个数也是一个超参数</strong>。<strong>我们可以把Feature Map可以看做是通过卷积变换提取到的图像特征，三个Filter就对原始图像提取出三组不同的特征</strong>，也就是得到了三个Feature Map，也称做三个通道(channel)。</p>
<p>在第一个卷积层之后，Pooling层对三个Feature Map做了下采样，得到了三个更小的Feature Map。接着，<strong>是第二个卷积层，它有5个Filter</strong>。<strong>每个Fitler都把前面下采样之后的3个Feature Map卷积在一起（每个Fitlter与输入有相同的深度，然后对应相乘后总相加）</strong>，得到一个新的Feature Map。这样，5个Filter就得到了5个Feature Map。接着，是第二个Pooling，继续对5个Feature Map进行下采样，得到了5个更小的Feature Map。</p>
<p><strong>最后两层是全连接层。第一个全连接层的每个神经元，和上一层5个Feature Map中的每个神经元相连</strong>，第二个全连接层(也就是输出层)的每个神经元，则和第一个全连接层的每个神经元相连，这样得到了整个网络的输出。</p>
<p>至此，我们对卷积神经网络有了最基本的感性认识。接下来，我们将介绍卷积神经网络中各种层的计算和训练。</p>
<h3 id="卷积层"><a href="#卷积层" class="headerlink" title="卷积层"></a>卷积层</h3><p>卷积层的参数是一些可学习的滤波器（卷积核，隐藏不显示，相当于全连接层的隐藏权重）构成，<strong>滤波器的宽度和高度一般不大，深度与其输入数据保持一致</strong>。见下图：</p>
<p><img src="/2018/12/14/深度学习/深度学习（三）：卷积神经网络/06.jpg" alt></p>
<p><img src="/2018/12/14/深度学习/深度学习（三）：卷积神经网络/07.jpg" alt></p>
<p><img src="/2018/12/14/深度学习/深度学习（三）：卷积神经网络/08.jpg" alt></p>
<p><img src="/2018/12/14/深度学习/深度学习（三）：卷积神经网络/09.jpg" alt></p>
<p><strong>要点</strong>：卷积层有一个或多个滤波器（卷积核）构成，每个卷积核宽度和高度（这里为5×5）一般不大，深度（这里为3）与其输入数据保持一致。这里有6个不同的卷积核，得到的6个不同的activation map分别表示诸如边缘特征、形状特征等特征图，将这些activation map映射在深度方向上层叠起来就生成了输出数据。所以在用了6个过滤器（卷积层）之后，我们可以得到28×28×6的激活图。</p>
<h3 id="卷积层输出值的计算"><a href="#卷积层输出值的计算" class="headerlink" title="卷积层输出值的计算"></a>卷积层输出值的计算</h3><p>我们使用一个简单的例子来讲述如何计算卷积，然后，抽象出卷积层的一些重要概念和计算方法。</p>
<p>假设有一个5×5的图像，使用一个3×3的滤波器进行卷积，想得到3×3的Feature Map，如下所示：</p>
<p><img src="/2018/12/14/深度学习/深度学习（三）：卷积神经网络/10.jpg" alt></p>
<p> 为了清楚地描述卷积的计算过程，我们首先对图像的每个像素进行编号，用$x<em>{i,j}$表示图像的第i行第j列元素，对filter的每个权重进行编号，用$w</em>{m,n}$表示第m行第n列权重，用$w<em>b$表示filter的偏置项；对Feature Map的每个元素进行编号，用$a</em>{i,j}$表示Feature Map的第i行第j列元素；用f表示激活函数（此处使用Relu函数作为激活函数）。然后使用下列公式计算卷积： </p>
<script type="math/tex; mode=display">
a_{i,j}=f\left(\sum_{m=0}^2{\sum_{n=0}^2{w_{m,n}x_{m+i,n+j}}}+w_b\right)</script><p> 例如，对于Feature Map的左上角元素$a_{0,0}$来说，其卷积计算方法为：</p>
<script type="math/tex; mode=display">
a_{0,0}=f\left(\sum_{m=0}^2{\sum_{n=0}^2{w_{m,n}x_{m+0,n+0}}}+w_b\right)=Relu\left(4\right)=4</script><p> 按照这个公式可以依次计算出Feature Map中所有的值，下面的动画显示了整个Feature Map的计算过程： </p>
<p><img src="/2018/12/14/深度学习/深度学习（三）：卷积神经网络/11.gif" alt></p>
<h3 id="填充和步幅"><a href="#填充和步幅" class="headerlink" title="填充和步幅"></a>填充和步幅</h3><p>假设输入形状的$n_h\times n_w$，卷积核窗口形状是$k_h\times k_w$，那么输出的形状将会是</p>
<script type="math/tex; mode=display">
(n_h-k_h+1)\times (n_w-k_w+1)</script><p>所以卷积层的输出形状由输⼊形状和卷积核窗口形状决定。这里我们将介绍卷积层的两个超参数，填充和步幅。它们可以对给定形状的输⼊和卷积核改变输出形状。</p>
<p><strong>填充</strong>（padding）是指在输入和宽的两侧填充元素（通常是0元素）。下图表示在原输入高的宽的两侧分别添加了值为0的元素，使得高和宽从3变成了5，并导致输出的高和宽由2增加到4.</p>
<p><img src="/2018/12/14/深度学习/深度学习（三）：卷积神经网络/12.png" alt></p>
<p>卷积窗口从输⼊数组的最左上⽅开始，按从左往右、从上往下的顺序，依次在输⼊数组上滑动。我们将每次滑动的⾏数和列数称为<strong>步幅</strong>（stride）</p>
<p>上面的计算过程中，步幅（stride）为1。当然步幅可以设为大于1的数。例如，当步幅为2时，Feature Map计算如下：</p>
<p><img src="/2018/12/14/深度学习/深度学习（三）：卷积神经网络/13.jpg" alt></p>
<h3 id="多输入通道"><a href="#多输入通道" class="headerlink" title="多输入通道"></a>多输入通道</h3><p>到此我们讲了深度为1的卷积层的计算方法，如果深度大于1怎么计算呢？其实也是类似的。 下图展⽰了含2个输⼊通道的⼆维互相关计算的例⼦。在每个通道上，⼆维输⼊数组与⼆维核数组做互相关运算，再按通道相加即得到输出。图中阴影部分为第⼀个输出元及其计算所使⽤的输⼊和核数组元素：</p>
<script type="math/tex; mode=display">
(1×1+2×2+4×3+5×4)+(0×0+1×1+3×2+4×3)=56</script><p><img src="/2018/12/14/深度学习/深度学习（三）：卷积神经网络/14.png" alt></p>
<p> 动画演示 </p>
<p><img src="/2018/12/14/深度学习/深度学习（三）：卷积神经网络/15.gif" alt></p>
<h2 id="内存需求"><a href="#内存需求" class="headerlink" title="内存需求"></a>内存需求</h2><p>CNN 的另一个问题是卷积层需要大量的 RAM，特别是在训练期间，因为反向传播需要在正向传递期间计算的所有中间值。</p>
<p><strong>如果由于内存不足错误导致训练崩溃，则可以尝试减少小批量大小。 或者，您可以尝试使用步幅降低维度，或者删除几个图层。 或者你可以尝试使用 16 位浮点数而不是 32 位浮点数。 或者你可以在多个设备上分发 CNN。</strong></p>
<h2 id="CNN-架构"><a href="#CNN-架构" class="headerlink" title="CNN 架构"></a>CNN 架构</h2><p>典型的 CNN 体系结构有一些卷积层（每一个通常跟着一个 ReLU 层），然后是一个池化层，然后是另外几个卷积层（+ ReLU），然后是另一个池化层，等等。 随着网络的进展，图像变得越来越小，但是由于卷积层的缘故，图像通常也会越来越深（即更多的特征映射）。 在堆栈的顶部，添加由几个全连接层（+ ReLU）组成的常规前馈神经网络，并且最终层输出预测（例如，输出估计类别概率的 softmax 层）。</p>
<p><strong>一个常见的错误是使用太大的卷积核。 通常可以通过将两个3×3内核堆叠在一起来获得与9×9内核相同的效果，计算量更少。</strong></p>
<p>多年来，这种基础架构的变体已经被开发出来，导致了该领域的惊人进步。<strong>这里就不展开讲了，大家感兴趣可以去找相关的论文和资料深入了解这些流行的CNN架构。</strong></p>
<h3 id="LeNet-5"><a href="#LeNet-5" class="headerlink" title="LeNet-5"></a>LeNet-5</h3><p>LeNet-5 架构也许是最广为人知的 CNN 架构。 如前所述，它是由 Yann LeCun 于 1998 年创建的，广泛用于手写数字识别（MNIST）。</p>
<p><img src="/2018/12/14/深度学习/深度学习（三）：卷积神经网络/16.png" alt></p>
<h3 id="AlexNet"><a href="#AlexNet" class="headerlink" title="AlexNet"></a>AlexNet</h3><p>AlexNet CNN 架构赢得了 2012 年的 ImageNet ILSVRC 挑战赛：它达到了 17% 的 top-5 的错误率，而第二名错误率只有 26%！ 它由 Alex Krizhevsky（因此而得名），Ilya Sutskever 和 Geoffrey Hinton 开发。 它与 LeNet-5 非常相似，只是更大更深，它是第一个将卷积层直接堆叠在一起，而不是在每个卷积层顶部堆叠一个池化层。</p>
<p><img src="/2018/12/14/深度学习/深度学习（三）：卷积神经网络/17.png" alt></p>
<h3 id="VGG"><a href="#VGG" class="headerlink" title="VGG"></a>VGG</h3><p>它名字来源于论⽂作者所在的实验室Visual Geometry Group。VGG提出了可以通过重复使⽤简单的基础块来构建深度模型的思路.</p>
<p>VGG块的组成规律是：连续使⽤数个相同的填充为1、窗口形状为3 × 3的卷积层后接上⼀个步幅为2、窗口形状为2 × 2的最⼤池化层。卷积层保持输⼊的⾼和宽不变，而池化层则对其减半。VGG⽹络同Alex Net和Le Net⼀样，VGG⽹络由卷积层模块后接全连接层模块构成。。全连接模块则跟Alex Net中的⼀样。</p>
<h3 id="GoogLeNet"><a href="#GoogLeNet" class="headerlink" title="GoogLeNet"></a>GoogLeNet</h3><p>GoogLeNet 架构是由 Christian Szegedy 等人开发的。 来自 Google Research，通过低于 7% 的 top-5 错误率，赢得了 ILSVRC 2014 的挑战赛。 这个伟大的表现很大程度上因为它比以前的 CNN 网络更深。 <strong>这是通过称为初始模块（inception modules）的子网络实现的</strong>，这使得 GoogLeNet 比以前的架构更有效地使用参数：实际上，GoogLeNet 的参数比 AlexNet 少了 10 倍（约 600 万而不是 6000 万）。</p>
<p><img src="/2018/12/14/深度学习/深度学习（三）：卷积神经网络/18.png" alt></p>
<h3 id="ResNet"><a href="#ResNet" class="headerlink" title="ResNet"></a>ResNet</h3><p>最后是，2015 年 ILSVRC 挑战赛的赢家 Kaiming He 等人开发的 Residual Network（或 ResNet），该网络的 top-5 误率低到惊人的 3.6%，它使用了一个非常深的 CNN，由 152 层组成。 能够训练如此深的网络的关键是使用跳过连接（skip connection，也称为快捷连接）：一个层的输入信号也被添加到位于下一层的输出。 让我们看看为什么这是有用的。</p>
<p>当训练一个神经网络时，目标是使其模拟一个目标函数<code>h(x)</code>。 如果将输入x添加到网络的输出中（即添加跳过连接），那么网络将被迫模拟<code>f(x)= h(x) - x</code>而不是<code>h(x)</code>。 这被称为残留学习</p>
<p><img src="/2018/12/14/深度学习/深度学习（三）：卷积神经网络/19.png" alt></p>
<p>当你初始化一个普通的神经网络时，它的权重接近于零，所以网络只输出接近零的值。 如果添加跳过连接，则生成的网络只输出其输入的副本; 换句话说，它最初对身份函数进行建模。 如果目标函数与身份函数非常接近（常常是这种情况），这将大大加快训练速度。 由于跳过连接，信号可以很容易地通过整个网络。 深度剩余网络可以看作是一堆剩余单位，其中每个剩余单位是一个有跳过连接的小型神经网络。</p>
<p>现在让我们看看 ResNet 的架构（见下图）。 这实际上是令人惊讶的简单。 它的开始和结束与GoogLeNet完全一样（除了没有 dropout 层），而在两者之间只是一堆很简单的残余单位。 每个残差单元由两个卷积层组成，使用<code>3×3</code>的内核和保存空间维度（步幅 1，<code>SAME</code>填充），批量归一化（BN）和 ReLU 激活。</p>
<p><img src="/2018/12/14/深度学习/深度学习（三）：卷积神经网络/20.jpg" alt></p>
<p>正如你所看到的，这个领域正在迅速发展，每年都会有各种各样的架构出现。 一个明显的趋势是 CNN 越来越深入。 他们也越来越轻量，需要越来越少的参数。 目<strong>前，ResNet 架构既是最强大的，也是最简单的，所以它现在应该是你应该使用的</strong> 。</p>
<p>Res Net中的跨层连接设计引申出了数个后续⼯作，稠密连接⽹络（Dense Net）是其中一个，Dense Net的主要构建模块是稠密块（dense block）和过渡层（transition layer）。前者定义了输⼊和输出是如何连结的，后者则⽤来控制通道数，使之不过⼤。</p>
<p>还有其他一些架构可供您参考，特别是 VGGNet（2014 年 ILSVRC 挑战赛的亚军）和 Inception-v4（将 GooLeNet 和 ResNet 的思想融合在一起，实现了接近 3% 的 top-5 误差 ImageNet 分类率）。</p>

          
        
      
    </div>
    
    
    
    
    
    
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/11/深度学习/深度学习（二）：训练深层神经网络/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mosbyllc">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mosbyllc">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/11/深度学习/深度学习（二）：训练深层神经网络/" itemprop="url">深度学习（二）：训练深层神经网络</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-11T17:06:13+08:00">
                2018-12-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/深度学习/" itemprop="url" rel="index">
                    <span itemprop="name">深度学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  5,637
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  20
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前面介绍了人工神经网络，并训练了我们的第一个深度神经网络。 但它是一个非常浅的 DNN，只有两个隐藏层。 如果你需要解决非常复杂的问题，例如检测高分辨率图像中的数百种类型的对象，该怎么办？ 你可能需要训练更深的 DNN，也许有 10 层，每层包含数百个神经元，通过数十万个连接来连接。 这会相当困难</p>
<ul>
<li>首先，你将面临棘手的梯度消失问题（或相关的梯度爆炸问题），这会影响深度神经网络，并使较低层难以训练。</li>
<li>其次，对于如此庞大的网络，训练将非常缓慢。</li>
<li>第三，具有数百万参数的模型将会有严重的过拟合训练集的风险。</li>
</ul>
<p>在本章中，我们将从解释<strong>梯度消失</strong>问题开始，并探讨解决这个问题的一些最流行的解决方案。 接下来我们将看看<strong>各种优化器，它们可以加速大型模型的训练</strong>。 最后，我们将浏览一些流行的<strong>大型神经网络正则化技术</strong>。 使用这些工具，你将能够训练非常深的网络：欢迎来到深度学习的世界！</p>
<h2 id="梯度消失-爆炸问题"><a href="#梯度消失-爆炸问题" class="headerlink" title="梯度消失/爆炸问题"></a>梯度消失/爆炸问题</h2><p>反向传播算法的工作原理是从输出层到输入层，传播误差的梯度。 一旦该算法已经计算了网络中每个参数的损失函数的梯度，它就使用这些梯度来用梯度下降步骤来更新每个参数。</p>
<p>不幸的是，梯度往往变得越来越小，随着算法进展到较低层。 结果，梯度下降更新使得低层连接权重实际上保持不变，并且训练永远不会收敛到良好的解决方案。 这被称为梯度消失问题。 在某些情况下，可能会发生相反的情况：梯度可能变得越来越大，许多层得到了非常大的权重更新，算法发散。这是梯度爆炸的问题，在循环神经网络中最为常见 。</p>
<h3 id="Xavier初始化和-He-初始化"><a href="#Xavier初始化和-He-初始化" class="headerlink" title="Xavier初始化和 He 初始化"></a>Xavier初始化和 He 初始化</h3><p>虽然这种不幸的行为已经经过了相当长的一段时间的实验观察 但直到 2010 年左右，人们才有了明显的进步。 Xavier Glorot 和 Yoshua Bengio 发表的题为《Understanding the Difficulty of Training Deep Feedforward Neural Networks》的论文分析了一些疑问，包括流行的 sigmoid 激活函数和当时最受欢迎的<strong>默认权重参数初始化技术的组合，即随机初始化时使用平均值为 0，标准差为 1 的正态分布 。</strong></p>
<p>简而言之，他们表明，用这个激活函数和这个初始化方案，每层输出的方差远大于其输入的方差。网络正向，每层的方差持续增加，直到激活函数在顶层饱和。这实际上是因为logistic函数的平均值为 0.5 而不是 0（双曲正切函数的平均值为 0，表现略好于深层网络中的logistic函数） 。看一下logistic 激活函数，可以看到当输入变大（负或正）时，函数饱和在 0 或 1，导数非常接近 0。因此，当反向传播开始时， 它几乎没有梯度通过网络传播回来，而且由于反向传播通过顶层向下传递，所以存在的小梯度不断地被稀释，因此较低层确实没有任何东西可用。</p>
<p>Glorot 和 Bengio 在他们的论文中提出了一种显著缓解这个问题的方法。 我们需要信号在两个方向上正确地流动：在进行预测时是正向的，在反向传播梯度时是反向的。 我们不希望信号消失，也不希望它爆炸并饱和。 <strong>为了使信号正确流动，作者认为，我们需要每层输出的方差等于其输入的方差</strong>。</p>
<p>实际上不可能保证两者都是一样的，除非这个层具有相同数量的输入和输出连接，但是他们提出了一个很好的折衷办法，在实践中证明这个折中办法非常好<strong>：随机初始化连接权重必须如下面公式所描述的那样</strong>。其中<code>n_inputs</code>和<code>n_outputs</code>是权重正在被初始化的层（也称为扇入和扇出）的输入和输出连接的数量。 <strong>这种初始化策略通常被称为Xavier初始化（在作者的名字之后）</strong> 。很多初始化策略也都是为了保持每层的分布不变 ，这样利于传递信息 。</p>
<p><img src="/2018/12/11/深度学习/深度学习（二）：训练深层神经网络/01.png" alt></p>
<p> 使用 Xavier 初始化策略可以大大加快训练速度，这是导致深度学习目前取得成功的技巧之一。 最近的一些论文针对不同的激活函数提供了类似的策略，如下表所示。 ReLU 激活函数（及其变体，包括简称 ELU 激活）的初始化策略有时称为 He 初始化（在其作者的姓氏之后）。 </p>
<p><img src="/2018/12/11/深度学习/深度学习（二）：训练深层神经网络/02.png" alt></p>
<h3 id="非饱和激活函数"><a href="#非饱和激活函数" class="headerlink" title="非饱和激活函数"></a>非饱和激活函数</h3><p>激活函数在深度神经网络中表现得更好，特别是 ReLU 激活函数，主要是因为它对正值不会饱和（也因为它的计算速度很快）。</p>
<p>不幸的是，<strong>ReLU</strong>激活功能并不完美。 它有一个被称为 “ReLU 死区” 的问题：在训练过程中，一些神经元有效地死亡，意味着它们停止输出 0 以外的任何东西。在某些情况下，你可能会发现你网络的一半神经元已经死亡，特别是如果你使用大学习率。 在训练期间，如果神经元的权重得到更新，使得神经元输入的加权和为负，则它将开始输出 0 。当这种情况发生时，由于当输入为负时，ReLU函数的梯度为0，神经元不可能恢复生机。</p>
<p>为了解决这个问题，你可能需要使用 ReLU 函数的一个变体，比如 <strong>leaky ReLU</strong>。这个函数定义为<code>LeakyReLUα(z)= max(αz，z)</code> 。超参数<code>α</code>定义了函数“leaks”的程度：它是<code>z &lt; 0</code>时函数的斜率，通常设置为 0.01。这个小斜坡确保 leaky ReLU 永不死亡；他们可能会长期昏迷，但他们有机会最终醒来。 事实上，设定<code>α= 0.2</code>（巨大 leak）似乎导致比<code>α= 0.01</code>（小 leak）更好的性能。</p>
<p><img src="/2018/12/11/深度学习/深度学习（二）：训练深层神经网络/03.png" alt></p>
<p> 最后，Djork-Arné Clevert 等人在 2015 年的一篇论文中提出了一种称为指数线性单元（exponential linear unit，ELU）的新的激活函数，在他们的实验中表现优于所有的 ReLU 变体：训练时间减少，神经网络在测试集上表现的更好，如下所示。 </p>
<p><img src="/2018/12/11/深度学习/深度学习（二）：训练深层神经网络/04.png" alt></p>
<p>它看起来很像 ReLU 函数，但有一些区别，主要区别在于：</p>
<ul>
<li>首先它在<code>z &lt; 0</code>时取负值，这使得该单元的平均输出接近于 0。这有助于减轻梯度消失问题，如前所述。 超参数<code>α</code>定义为当<code>z</code>是一个大的负数时，ELU 函数接近的值。它通常设置为 1，但是如果你愿意，你可以像调整其他超参数一样调整它。</li>
<li>其次，它对<code>z &lt; 0</code>有一个非零的梯度，避免了神经元死亡的问题。</li>
<li>第三，函数在任何地方都是平滑的，包括<code>z = 0</code>左右，这有助于加速梯度下降，因为它不会弹回<code>z = 0</code>的左侧和右侧。</li>
</ul>
<p>ELU 激活函数的主要缺点是计算速度慢于 ReLU 及其变体（由于使用指数函数），但是在训练过程中，这是通过更快的收敛速度来补偿的。 然而，在测试时间，ELU 网络将比 ReLU 网络慢。</p>
<p>那么你应该使用哪个激活函数来处理深层神经网络的隐藏层？ 虽然你的里程会有所不同，一般 ELU &gt; leaky ReLU（及其变体）&gt; ReLU &gt; tanh &gt; sigmoid。 如果您关心运行时性能，那么您可能喜欢 leaky ReLU超过ELU。</p>
<h3 id="批量标准化"><a href="#批量标准化" class="headerlink" title="批量标准化"></a>批量标准化</h3><p>尽管使用 He初始化和 ELU（或任何 ReLU 变体）可以显著减少训练开始阶段的梯度消失/爆炸问题，但不保证在训练期间问题不会回来。</p>
<p>在 2015 年的一篇论文中，Sergey Ioffe 和 Christian Szegedy 提出了一种称为批量标准化（Batch Normalization，BN）的技术来解决梯度消失/爆炸问题，每层输入的分布在训练期间改变的问题，更普遍的问题是当前一层的参数改变，每层输入的分布会在训练过程中发生变化（他们称之为内部协变量偏移问题）。</p>
<p>该技术包括在每层的激活函数之前在模型中添加操作，简单地对输入进行zero-centering和规范化，然后每层使用两个新参数（一个用于尺度变换，另一个用于偏移）对结果进行尺度变换和偏移。 换句话说，这个操作可以让模型学习到每层输入值的最佳尺度,均值。为了对输入进行归零和归一化，算法需要估计输入的均值和标准差。 它通过评估当前小批量输入的均值和标准差（因此命名为“批量标准化”）来实现。</p>
<p><img src="/2018/12/11/深度学习/深度学习（二）：训练深层神经网络/05.jpg" alt></p>
<p>在测试时，没有小批量计算经验均值和标准差，所以您只需使用整个训练集的均值和标准差。 这些通常在训练期间使用移动平均值进行有效计算。 因此，总的来说，每个批次标准化的层次都学习了四个参数：<code>γ</code>（标度），<code>β</code>（偏移），<code>μ</code>（平均值）和<code>σ</code>（标准差）</p>
<p>作者证明，这项技术大大改善了他们试验的所有深度神经网络。梯度消失问题大大减少了，他们可以使用饱和激活函数，如 tanh 甚至 sigmoid 激活函数。网络对权重初始化也不那么敏感。他们能够使用更大的学习率，显著加快了学习过程。 由于每层所需的额外计算，神经网络的预测速度较慢。 所以，如果你需要预测闪电般快速，你可能想要检查普通ELU + He初始化执行之前如何执行批量标准化。您可能会发现，训练起初相当缓慢，而渐变下降正在寻找每层的最佳尺度和偏移量，但一旦找到合理的好值，它就会加速。</p>
<p>当然，如果你训练的时间越长，准确性就越好，但是由于这样一个浅的网络，批量范数和 ELU 不太可能产生非常积极的影响：它们大部分都是为了更深的网络而发光。</p>
<p>批量标准化和初始化权重参数的意义差不多，更深的理解可以看这篇 <a href="https://plushunter.github.io/2017/05/14/深度学习系列（9）：Batch Normalization/" target="_blank" rel="noopener">批量标准化</a></p>
<h3 id="梯度裁剪"><a href="#梯度裁剪" class="headerlink" title="梯度裁剪"></a>梯度裁剪</h3><p>减少梯度爆炸问题的一种常用技术是在反向传播过程中<strong>简单地剪切梯度，使它们不超过某个阈值</strong>（这对于递归神经网络是非常有用的）。 这就是所谓的梯度裁剪。一般来说，人们更喜欢批量标准化，但了解梯度裁剪以及如何实现它仍然是有用的。</p>
<h2 id="复用预训练层"><a href="#复用预训练层" class="headerlink" title="复用预训练层"></a>复用预训练层</h2><p>从零开始训练一个非常大的 DNN 通常不是一个好主意，相反，您应该总是尝试找到一个现有的神经网络来完成与您正在尝试解决的任务类似的任务，然后复用这个网络的较低层：这就是所谓的迁移学习。这不仅会大大加快训练速度，还将需要更少的训练数据。 一般包括三个步骤</p>
<p>1、冻结较低层：在训练过程中变量不会发生变化（通常称为冻结层）。</p>
<p>2、缓存冻结层：由于冻结层不会改变，因此可以为每个训练实例缓存最上面的冻结层的输出。 由于训练贯穿整个数据集很多次，这将给你一个巨大的速度提升</p>
<p>3、调整，删除或替换较高层：对于新任务来说最有用的高层特征可能与对原始任务最有用的高层特征明显不同。 你需要找到正确的层数来复用。 一般拥有的训练数据越多，您可以解冻的层数就越多。</p>
<h3 id="Model-Zoos"><a href="#Model-Zoos" class="headerlink" title="Model Zoos"></a>Model Zoos</h3><p>你在哪里可以找到一个类似于你想要解决的任务训练的神经网络？ 首先看看显然是在你自己的模型目录。 这是保存所有模型并组织它们的一个很好的理由，以便您以后可以轻松地检索它们。 另一个选择是在模型动物园中搜索。 许多人为了各种不同的任务而训练机器学习模型，并且善意地向公众发布预训练模型。</p>
<p>TensorFlow 在 <a href="https://github.com/tensorflow/models" target="_blank" rel="noopener">https://github.com/tensorflow/models</a> 中有自己的模型动物园。 特别是，它包含了大多数最先进的图像分类网络，如 VGG，Inception 和 ResNet（参见第 13 章，检查<code>model/slim</code>目录），包括代码，预训练模型和 工具来下载流行的图像数据集。</p>
<p>另一个流行的模型动物园是 Caffe 模型动物园。 它还包含许多在各种数据集（例如，ImageNet，Places 数据库，CIFAR10 等）上训练的计算机视觉模型（例如，LeNet，AlexNet，ZFNet，GoogLeNet，VGGNet，开始）。 Saumitro Dasgupta 写了一个转换器，可以在 <a href="https://github.com/ethereon/caffetensorflow。" target="_blank" rel="noopener">https://github.com/ethereon/caffetensorflow。</a></p>
<h2 id="更快的优化器"><a href="#更快的优化器" class="headerlink" title="更快的优化器"></a>更快的优化器</h2><p>练一个非常大的深度神经网络可能会非常缓慢。 到目前为止，我们已经看到了四种加速训练的方法（并且达到更好的解决方案）：对连接权重应用良好的初始化策略，使用良好的激活函数，使用批量规范化以及重用预训练网络的部分。 另一个巨大的速度提升来自使用比普通渐变下降优化器更快的优化器。 在本节中，我们将介绍最流行的：动量优化，Nesterov 加速梯度，AdaGrad，RMSProp，最后是 Adam 优化。</p>
<p>剧透：<strong>本节的结论是，您几乎总是应该使用<code>Adam_optimization</code></strong>，所以如果您不关心它是如何工作的，只需使用<code>AdamOptimizer</code>替换您的<code>GradientDescentOptimizer</code>，然后跳到下一节！ 只需要这么小的改动，训练通常会快几倍。 <strong>但是，Adam 优化确实有三个可以调整的超参数（加上学习率）。 默认值通常工作的不错，但如果您需要调整它们，知道他们怎么实现的可能会有帮助</strong>。</p>
<p>理解这些优化器可以看这篇 <a href="https://plushunter.github.io/2017/05/11/深度学习系列（7）：神经网络的优化方法/" target="_blank" rel="noopener">神经网络的优化方法</a></p>
<h3 id="训练稀疏模型"><a href="#训练稀疏模型" class="headerlink" title="训练稀疏模型"></a>训练稀疏模型</h3><p>上面所有刚刚提出的优化算法都会产生密集的模型，这意味着大多数参数都是非零的。 如果你在运行时需要一个非常快速的模型，或者如果你需要它占用较少的内存，你可能更喜欢用一个稀疏模型优化器来代替。</p>
<p>这时可以使用FTRL 优化器，一种由尤里·涅斯捷罗夫（Yurii Nesterov）提出的技术。 当与 l1 正则化一起使用时，这种技术通常导致非常稀疏的模型。</p>
<h2 id="学习率调整"><a href="#学习率调整" class="headerlink" title="学习率调整"></a>学习率调整</h2><p>自适应下降的学习速率会更好。有三种流行的方法：</p>
<ul>
<li>性能调度：每 N 步测量验证误差（就像提前停止一样），当误差下降时，将学习率降低一个因子<code>λ</code>。</li>
<li>指数调度：将学习率设置为<strong>迭代次数<code>t</code></strong>的函数$\eta(t)=\eta_0\cdot10^{-t/r}$： 这很好，但它需要调整初始速率<code>η0</code>和<strong>总迭代次数</strong><code>r</code>。 学习率将由每<code>r</code>步下降 10 倍。</li>
<li>幂调度：设学习率为$\eta(t)=\eta_0(1+t/r)^{-c}$。 超参数<code>c</code>通常被设置为 1。这与指数调度类似，但是学习率下降要慢得多。</li>
</ul>
<p>根据Andrew Senior 等2013年的论文。 比较了使用动量优化训练深度神经网络进行语音识别时一些最流行的学习率调整的性能。 作者得出结论：在这种情况下，性能调度和指数调度都表现良好，但他们更喜欢指数调度，因为它实现起来比较简单，容易调整，收敛速度略快于最佳解决方案 。</p>
<h2 id="通过正则化避免过拟合"><a href="#通过正则化避免过拟合" class="headerlink" title="通过正则化避免过拟合"></a>通过正则化避免过拟合</h2><p>1、早起停止法</p>
<p>2、L1和L2正则化：注意不需要对bias正则，只对权重</p>
<p>3、Dropout</p>
<p>深度神经网络最流行的正则化技术可以说是 dropout。 它由 GE Hinton 于 2012 年提出，并在 Nitish Srivastava 等人的论文中进一步详细描述，并且已被证明是非常成功的：即使是最先进的神经网络，仅仅通过增加丢失就可以提高1-2％的准确度。</p>
<p>是一个相当简单的算法：在每个训练步骤中，每个神经元（包括输入神经元，但不包括输出神经元）都有一个暂时“丢弃”的概率<code>p</code>，这意味着在这个训练步骤中它将被完全忽略， 在下一步可能会激活（见下图 ）。 超参数<code>p</code>称为丢失率，通常设为 50%。 训练后，神经元不会再下降。</p>
<p><img src="/2018/12/11/深度学习/深度学习（二）：训练深层神经网络/05.png" alt></p>
<p>如果观察到模型过拟合，则可以增加 dropout 率（即，减少<code>keep_prob</code>超参数）。 相反，如果模型欠拟合训练集，则应尝试降低 dropout 率（即增加<code>keep_prob</code>）。 它也可以帮助增加大层的 dropout 率，并减少小层的 dropout 率。</p>
<p>dropout 似乎减缓了收敛速度，但通常会在调整得当时使模型更好。 所以，这通常值得花费额外的时间和精力。</p>
<p>Dropconnect是dropout的变体，其中单个连接随机丢弃而不是整个神经元。 一般而言，dropout表现会更好。</p>
<h2 id="最大范数正则化"><a href="#最大范数正则化" class="headerlink" title="最大范数正则化"></a>最大范数正则化</h2><p>另一种在神经网络中非常流行的正则化技术被称为最大范数正则化：对于每个神经元，它约束输入连接的权重<code>w</code>，使得$\Vert w\Vert_2 \leq r$，其中<code>r</code>是最大范数超参数，$\Vert \cdot \Vert$是 L2 范数。</p>
<p>我们通常通过在每个训练步骤之后计算 $\Vert w\Vert_2$来实现这个约束，并且如果需要的话可以剪切<code>W</code> ，即$w\leftarrow w\frac{r}{\Vert w\Vert_2}$。</p>
<p>减少<code>r</code>增加了正则化的数量(经常剪切<code>W</code>)，并有助于减少过拟合。 最大范数正则化还可以帮助减轻梯度消失/爆炸问题（如果您不使用批量标准化）。</p>
<h2 id="数据增强"><a href="#数据增强" class="headerlink" title="数据增强"></a>数据增强</h2><p>最后一个正则化技术，数据增强，包括从现有的训练实例中产生新的训练实例，人为地增加了训练集的大小。 这将减少过拟合，使之成为正则化技术。 诀窍是生成逼真的训练实例;</p>
<p>例如，如果您的模型是为了分类蘑菇图片，您可以稍微移动，旋转和调整训练集中的每个图片的大小，并将结果图片添加到训练集。 这迫使模型更能容忍图片中蘑菇的位置，方向和大小。 如果您希望模型对光照条件更加宽容，则可以类似地生成具有各种对比度的许多图像。 假设蘑菇是对称的，你也可以水平翻转图片。 通过结合这些转换，可以大大增加训练集的大小。</p>
<h2 id="实践指南"><a href="#实践指南" class="headerlink" title="实践指南"></a>实践指南</h2><p>当然，如果你能找到解决类似问题的方法，你应该尝试重用预训练的神经网络的一部分。</p>
<p>这个默认配置可能需要调整：</p>
<ul>
<li>如果你找不到一个好的学习率（收敛速度太慢，所以你增加了训练速度，现在收敛速度很快，但是网络的准确性不是最理想的），那么你可以尝试添加一个学习率调整，如指数衰减。</li>
<li>如果你的训练集太小，你可以实现数据增强。</li>
<li>如果你需要一个稀疏的模型，你可以添加 l1 正则化混合（并可以选择在训练后将微小的权重归零）。 如果您需要更稀疏的模型，您可以尝试使用 FTRL 而不是 Adam 优化以及 l1 正则化。</li>
<li>如果在运行时需要快速模型，则可能需要删除批量标准化，并可能用 leakyReLU 替换 ELU 激活函数。 有一个稀疏的模型也将有所帮助。</li>
</ul>
<hr>
<ol>
<li>使用 He 初始化随机选择权重，是否可以将所有权重初始化为相同的值？</li>
</ol>
<p>答：不，所有的权值都应该独立采样;它们的初值不应该相同。如果任意一层的所有神经元都有相同的权值。这就像每层只有一个神经元，而且速度要慢得多。</p>
<ol>
<li>可以将偏置初始化为 0 吗？</li>
</ol>
<p>答：可以</p>
<ol>
<li>说出 ELU 激活功能与 ReLU 相比的三个优点。</li>
</ol>
<p>答：</p>
<ul>
<li>它可以取负值，所以任意一层神经元的<strong>平均输出</strong>通常比使用relu激活函数(从不输出负值)时<strong>更接近于0</strong>。这有助于缓解渐变消失的问题。</li>
<li>它总是有一个非零的导数，这避免了神经元死亡的问题。</li>
<li>处处平滑，而Relu的斜率在z = 0时突然从0跳到1。这样的骤减使梯度下降效果降低，因为它会在z =0附近反弹.</li>
</ul>
<ol>
<li>在哪些情况下，您想要使用以下每个激活函数：ELU，leaky ReLU（及其变体），ReLU，tanh，logistic 以及 softmax？</li>
</ol>
<p>答：ELU是一个不错的默认选择。如果想要训练速度更快一些可以采用 leaky ReLU（及其变体）</p>
<ol>
<li>dropout 是否会减慢训练？ 它是否会减慢推断（即预测新的实例）？</li>
</ol>
<p>答：dropout确实会减慢训练速度，总的来说大概是两倍。然而，它没有对推断（预测新的实例）的影响，因为它只在训练期间打开。</p>

          
        
      
    </div>
    
    
    
    
    
    
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/09/深度学习/深度学习（一）：神经网络与反向传播/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mosbyllc">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mosbyllc">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/09/深度学习/深度学习（一）：神经网络与反向传播/" itemprop="url">深度学习（一）：神经网络与反向传播</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-09T17:06:13+08:00">
                2018-12-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/深度学习/" itemprop="url" rel="index">
                    <span itemprop="name">深度学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  5,115
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  19
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="神经元"><a href="#神经元" class="headerlink" title="神经元"></a>神经元</h2><p>首先我们从最简单的神经网络——神经元讲起，以下即为一个神经元（Neuron）的图示：</p>
<p><img src="/2018/12/09/深度学习/深度学习（一）：神经网络与反向传播/01.jpg" alt></p>
<p>我们知道感知机的激活函数是阶跃函数；而当我们说神经元的时，激活函数往往选择sigmoid函数或tanh函数 ,<strong>还有Relu函数（效果较好）</strong>。如下图所示 </p>
<p><img src="/2018/12/09/深度学习/深度学习（一）：神经网络与反向传播/02.jpg" alt></p>
<p>可以看出，这个单一神经元的输入输出的映射关系其实就是一个逻辑回归（logistic regression）。</p>
<h2 id="神经网络模型"><a href="#神经网络模型" class="headerlink" title="神经网络模型"></a>神经网络模型</h2><h3 id="神经网络模型-1"><a href="#神经网络模型-1" class="headerlink" title="神经网络模型"></a>神经网络模型</h3><p>所谓神经网络就是将许多神经元联结在一起，这样，一个神经元的输出就可以是另一神经元的输入。例如，下图就是一个简单的神经网络：</p>
<p><img src="/2018/12/09/深度学习/深度学习（一）：神经网络与反向传播/03.jpg" alt></p>
<p>这样的神经网络也称之为多层感知机（MLP），MLP 由一个（通过）输入层、一个或多个称为隐藏层的 LTU （单层感知器）组成，一个最终层 LTU 称为输出层。除了输出层之外的每一层包括偏置神经元，并且全连接到下一层。当人工神经网络有两个或多个隐含层时，称为深度神经网络（DNN）。</p>
<h2 id="BP反向传播"><a href="#BP反向传播" class="headerlink" title="BP反向传播"></a>BP反向传播</h2><p>反向传播指的是计算神经⽹络参数梯度的⽅法。总的来说，反向传播依据微积分中的链式法则，沿着从输出层到输⼊层的顺序，依次计算并存储⽬标函数有关神经⽹络各层的中间变量以及参数的梯度。</p>
<p><img src="/2018/12/09/深度学习/深度学习（一）：神经网络与反向传播/04.png" alt></p>
<p><img src="/2018/12/09/深度学习/深度学习（一）：神经网络与反向传播/05.png" alt></p>
<p><img src="/2018/12/09/深度学习/深度学习（一）：神经网络与反向传播/06.png" alt></p>
<p><img src="/2018/12/09/深度学习/深度学习（一）：神经网络与反向传播/07.png" alt></p>
<p>上图依次为利用dE/dx6求出第一个dE/dw; 利用分量的点对点继续求dE/dw; 利用求和来下一个dE/dy2 ;(这里的所以x,y总输入输出都是知道的)</p>
<ul>
<li>dE/dw是有上下夹层dE/dx与上面一层的y求出的</li>
<li>dE/dy是由上面一层全连接的wij 与其连接的dE/dx求出的</li>
</ul>
<p><img src="/2018/12/09/深度学习/深度学习（一）：神经网络与反向传播/08.png" alt></p>
<p>dE/dy2 = dE/dx4, w24 和 dE/dx5, dw25的求和得到其中，y2=w24*x4,故有dx_j/dy_i = wij</p>
<h2 id="用-TensorFlow-高级-API-训练-MLP"><a href="#用-TensorFlow-高级-API-训练-MLP" class="headerlink" title="用 TensorFlow 高级 API 训练 MLP"></a>用 TensorFlow 高级 API 训练 MLP</h2><p>与 TensorFlow 一起训练 MLP 最简单的方法是使用高级 API TF.Learn，这与 sklearn 的 API 非常相似。<code>DNNClassifier</code>可以很容易训练具有任意数量隐层的深度神经网络，而 softmax 输出层输出估计的类概率。例如，下面的代码训练两个隐藏层的 DNN（一个具有 300 个神经元，另一个具有 100 个神经元）和一个具有 10 个神经元的 SOFTMax 输出层进行分类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">feature_columns = tf.contrib.learn.infer_real_valued_columns_from_input(X) </span><br><span class="line">dnn_clf = tf.contrib.learn.DNNClassifier(hidden_units=[<span class="number">300</span>, <span class="number">100</span>], n_classes=<span class="number">10</span>,</span><br><span class="line">                                         feature_columns=feature_columns) </span><br><span class="line">dnn_clf.fit(x=X, y=y, batch_size=<span class="number">50</span>, steps=<span class="number">40000</span>)</span><br></pre></td></tr></table></figure>
<p>如果你在 MNIST 数据集上运行这个代码（在缩放它之后，例如，通过使用 skLearn 的<code>StandardScaler</code>），你实际上可以得到一个在测试集上达到 98.1% 以上精度的模型！</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score &gt;&gt;&gt; y_pred = list(dnn_clf.predict(X_test)) &gt;&gt;&gt; accuracy_score(y_test, y_pred) <span class="number">0.98180000000000001</span></span><br></pre></td></tr></table></figure>
<p>TF.Learn 学习库也为评估模型提供了一些方便的功能：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dnn_clf.evaluate(X_test, y_test) &#123;<span class="string">'accuracy'</span>: <span class="number">0.98180002</span>, <span class="string">'global_step'</span>: <span class="number">40000</span>, <span class="string">'loss'</span>: <span class="number">0.073678359</span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用普通-TensorFlow-训练-DNN"><a href="#使用普通-TensorFlow-训练-DNN" class="headerlink" title="使用普通 TensorFlow 训练 DNN"></a>使用普通 TensorFlow 训练 DNN</h2><p>如果您想要更好地控制网络架构，您可能更喜欢使用 TensorFlow 的较低级别的 Python API。 在本节中，我们将使用与之前的 API 相同的模型，我们将实施 Minibatch 梯度下降来在 MNIST 数据集上进行训练。 第一步是建设阶段，构建 TensorFlow 图。 第二步是执行阶段，您实际运行计算图谱来训练模型。</p>
<h3 id="构造阶段"><a href="#构造阶段" class="headerlink" title="构造阶段"></a>构造阶段</h3><p>开始吧。 首先我们需要导入<code>tensorflow</code>库。 然后我们必须指定输入和输出的数量，并设置每个层中隐藏的神经元数量：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tfn_inputs = <span class="number">28</span>*<span class="number">28</span> <span class="comment"># MNISTn_hidden1 = 300n_hidden2 = 100n_outputs = 10</span></span><br></pre></td></tr></table></figure>
<p>接下来，可以使用占位符节点来表示训练数据和目标。<code>X</code>的形状仅有部分被定义。 我们知道它将是一个 2D 张量（即一个矩阵），沿着第一个维度的实例和第二个维度的特征，我们知道特征的数量将是<code>28×28</code>（每像素一个特征） <strong>但是我们不知道每个训练批次将包含多少个实例。 所以<code>X</code>的形状是<code>(None, n_inputs)</code></strong>。 <strong>同样，我们知道<code>y</code>将是一个 1D 张量，每个实例有一个入口，但是我们再次不知道在这一点上训练批次的大小，所以形状<code>(None)</code></strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X = tf.placeholder(tf.float32, shape=(<span class="literal">None</span>, n_inputs), name=<span class="string">"X"</span>)y = tf.placeholder(tf.int64, shape=(<span class="literal">None</span>), name=<span class="string">"y"</span>)</span><br></pre></td></tr></table></figure>
<p>现在让我们创建一个实际的神经网络。 占位符<code>X</code>将作为输入层; 在执行阶段，它将一次更换一个训练批次（注意训练批中的所有实例将由神经网络同时处理）。 现在您需要创建两个隐藏层和输出层。 两个隐藏的层几乎相同：它们只是它们所连接的输入和它们包含的神经元的数量不同。 <strong>输出层也非常相似，但它使用 softmax 激活函数而不是 ReLU 激活函数</strong>。 <strong>所以让我们创建一个<code>neuron_layer()</code>函数，我们将一次创建一个图层。 它将需要参数来指定输入，神经元数量，激活函数和图层的名称：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">neuron_layer</span><span class="params">(X, n_neurons, name, activation=None)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> tf.name_scope(name):</span><br><span class="line">        n_inputs = int(X.get_shape()[<span class="number">1</span>])</span><br><span class="line">        stddev = <span class="number">2</span> / np.sqrt(n_inputs)</span><br><span class="line">        init = tf.truncated_normal((n_inputs, n_neurons), stddev=stddev)</span><br><span class="line">        W = tf.Variable(init, name=<span class="string">"weights"</span>) <span class="comment"># 使用满足分布概率来更好第初始化W权重</span></span><br><span class="line">        b = tf.Variable(tf.zeros([n_neurons]), name=<span class="string">"biases"</span>)</span><br><span class="line">        <span class="comment"># multiply这个函数实现的是元素级别的相乘，也就是两个相乘的数元素各自相乘，而不是矩阵乘法</span></span><br><span class="line">        <span class="comment"># tf.matmul才算矩阵乘法，注意区别</span></span><br><span class="line">        z = tf.matmul(X, W) + b </span><br><span class="line">        <span class="keyword">if</span> activation == <span class="string">"relu"</span>:</span><br><span class="line">            <span class="keyword">return</span> tf.nn.relu(z)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> z</span><br></pre></td></tr></table></figure>
<p>我们逐行浏览这个代码：</p>
<ol>
<li>首先，我们使用名称范围来创建每层的名称：它将包含该神经元层的所有计算节点。 <strong>这是可选的</strong>，但如果节点组织良好，则 TensorBoard 图形将会更加出色。</li>
<li>接下来，我们通过查找输入矩阵的形状并获得第二个维度的大小来获得输入数量（<strong>第一个维度用于实例数量</strong>）。</li>
<li>接下来的三行创建一个保存权重矩阵的<code>W</code>变量。 它将是包含每个输入和每个神经元之间的所有连接权重的2D张量；因此，<strong>它的形状将是<code>(n_inputs, n_neurons)</code></strong>。<strong>它将被随机初始化，使用具有标准差为<code>2/√n</code>的截断的正态（高斯）分布</strong>(使用截断的正态分布而不是常规正态分布确保不会有任何大的权重，这可能会减慢训练。).<strong>使用这个特定的标准差有助于算法的收敛速度更快</strong>（我们将在后面进一步讨论这一点），这是对神经网络的微小调整之一，对它们的效率产生了巨大的影响）。 重要的是为所有隐藏层随机初始化连接权重，以避免梯度下降算法无法中断的任何对称性。（例如，如果将所有权重设置为 0，则所有神经元将输出 0，并且给定隐藏层中的所有神经元的误差梯度将相同。 然后，梯度下降步骤将在每个层中以相同的方式更新所有权重，因此它们将保持相等。 换句话说，尽管每层有数百个神经元，你的模型就像每层只有一个神经元一样。）</li>
<li>下一行创建一个偏差的<code>b</code>变量，初始化为 0（在这种情况下无对称问题），每个神经元有一个偏置参数。</li>
<li>然后我们创建一个子图来计算<code>z = X·W + b</code>。 该向量化实现将有效地计算输入的加权和加上层中每个神经元的偏置，对于批次中的所有实例，仅需一次.</li>
<li>最后，如果激活参数设置为<code>relu</code>，则代码返回<code>relu(z)</code>（即<code>max(0,z)</code>），否则它只返回<code>z</code>。</li>
</ol>
<p>好了，现在你有一个很好的函数来创建一个神经元层。 让我们用它来创建深层神经网络！ 第一个隐藏层以<code>X</code>为输入。 第二个将第一个隐藏层的输出作为其输入。 最后，输出层将第二个隐藏层的输出作为其输入。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.name_scope(<span class="string">"dnn"</span>):</span><br><span class="line">        hidden1 = neuron_layer(X, n_hidden1, <span class="string">"hidden1"</span>, activation=<span class="string">"relu"</span>)</span><br><span class="line">    hidden2 = neuron_layer(hidden1, n_hidden2, <span class="string">"hidden2"</span>, activation=<span class="string">"relu"</span>)</span><br><span class="line">    logits = neuron_layer(hidden2, n_outputs, <span class="string">"outputs"</span>)</span><br></pre></td></tr></table></figure>
<p>要注意，<strong>logit 是在通过 softmax 激活函数之前神经网络的输出</strong>：为了优化，我们稍后将处理 softmax 计算。</p>
<p><strong>正如你所期望的，TensorFlow 有许多方便的功能来创建标准的神经网络层，所以通常不需要像我们刚才那样定义你自己的<code>neuron_layer()</code>函数</strong>。 例如，TensorFlow 的<code>tf.layers.dense()</code>函数创建一个完全连接的层，其中所有输入都连接到图层中的所有神经元。 <strong>它使用正确的初始化策略来负责创建权重和偏置变量，并且默认情况下不使用激活函数（我们可以使用<code>activate_fn</code>参数来更改它）</strong>。 它还支持正则化和归一化参数。 我们来调整上面的代码来使用<code>tf.layers.dense()</code>函数，而不是我们的<code>neuron_layer()</code>函数。 只需导入该功能，并使用以下代码替换之前所有 dnn 构建部分：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.name_scope(<span class="string">"dnn"</span>):</span><br><span class="line">    hidden1 = tf.layers.dense(X, n_hidden1, name=<span class="string">"hidden1"</span>,</span><br><span class="line">                              activation=tf.nn.relu)</span><br><span class="line">    hidden2 = tf.layers.dense(hidden1, n_hidden2, name=<span class="string">"hidden2"</span>,</span><br><span class="line">                              activation=tf.nn.relu)</span><br><span class="line">    logits = tf.layers.dense(hidden2, n_outputs, name=<span class="string">"outputs"</span>)</span><br></pre></td></tr></table></figure>
<h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p>现在我们已经有了神经网络模型，我们需要定义我们用来训练的损失函数。 正如我们在之前对 Softmax 回归所做的那样，我们将使用交叉熵。 我们将使用<code>sparse_softmax_cross_entropy_with_logits()</code>：它根据“logit”计算交叉熵（即，在通过 softmax 激活函数之前的网络输出），并且期望以 0 到 -1 数量的整数形式的标签（在我们的例子中，从 0 到 9）。 <strong>这将给我们一个包含每个实例的交叉熵的 1D 张量</strong>。 <strong>然后，我们可以使用 TensorFlow 的<code>reduce_mean()</code>函数来计算所有实例的平均交叉熵。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.name_scope(<span class="string">"loss"</span>):</span><br><span class="line">    xentropy = tf.nn.sparse_softmax_cross_entropy_with_logits(labels=y, logits=logits)</span><br><span class="line">    loss = tf.reduce_mean(xentropy, name=<span class="string">"loss"</span>)</span><br></pre></td></tr></table></figure>
<p>该<code>sparse_softmax_cross_entropy_with_logits()</code>函数等同于应用 SOFTMAX 激活函数，然后计算交叉熵，但它更高效，它妥善照顾的边界情况下，比如 logits 等于 0，这就是为什么我们没有较早的应用 SOFTMAX 激活函数。 还有称为<code>softmax_cross_entropy_with_logits()</code>的另一个函数，该函数在标签单热载体的形式（而不是整数 0 至类的数目减 1）。</p>
<h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><p>我们有神经网络模型，我们有损失函数，现在我们需要定义一个<code>GradientDescentOptimizer</code>来调整模型参数以最小化损失函数。没什么新鲜的; 就像我们之前中所做的那样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">learning_rate = <span class="number">0.01</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.name_scope(<span class="string">"train"</span>):</span><br><span class="line">    optimizer = tf.train.GradientDescentOptimizer(learning_rate)</span><br><span class="line">    training_op = optimizer.minimize(loss)</span><br></pre></td></tr></table></figure>
<h3 id="评估模型性能"><a href="#评估模型性能" class="headerlink" title="评估模型性能"></a>评估模型性能</h3><p>建模阶段的最后一个重要步骤是指定如何评估模型。 我们将简单地将精度用作我们的绩效指标。 首先，对于每个实例，通过检查最高 logit 是否对应于目标类别来确定神经网络的预测是否正确。 为此，您可以使用<code>in_top_k()</code>函数。 这返回一个充满布尔值的 1D 张量，因此我们需要将这些布尔值转换为浮点数，然后计算平均值。 这将给我们网络的整体准确性.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.name_scope(<span class="string">"eval"</span>):</span><br><span class="line">    correct = tf.nn.in_top_k(logits, y, <span class="number">1</span>)</span><br><span class="line">    accuracy = tf.reduce_mean(tf.cast(correct, tf.float32))</span><br></pre></td></tr></table></figure>
<p>而且，像往常一样，我们需要创建一个初始化所有变量的节点，我们还将创建一个<code>Saver</code>来将我们训练有素的模型参数保存到磁盘中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">init = tf.global_variables_initializer()</span><br><span class="line">saver = tf.train.Saver()</span><br></pre></td></tr></table></figure>
<p>建模阶段结束。 这是不到 40 行代码，但相当激烈：我们为输入和目标创建占位符，我们创建了一个构建神经元层的函数，我们用它来创建 DNN，我们定义了损失函数，我们 创建了一个优化器，最后定义了性能指标。 现在到执行阶段。</p>
<h3 id="执行阶段"><a href="#执行阶段" class="headerlink" title="执行阶段"></a>执行阶段</h3><p>首先，我们加载 MNIST。 我们可以像之前的章节那样使用 ScikitLearn，但是 TensorFlow 提供了自己的助手来获取数据，将其缩放（0 到 1 之间），将它洗牌，并提供一个简单的功能来一次加载一个小批量：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.examples.tutorials.mnist <span class="keyword">import</span> input_data</span><br><span class="line">mnist = input_data.read_data_sets(<span class="string">"/tmp/data/"</span>)</span><br><span class="line">n_epochs = <span class="number">10001</span>  <span class="comment"># 迭代次数</span></span><br><span class="line">batch_size = <span class="number">50</span>   <span class="comment"># 小批量大小</span></span><br></pre></td></tr></table></figure>
<p>现在我们去训练模型:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    init.run()</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> range(n_epochs):</span><br><span class="line">        <span class="keyword">for</span> iteration <span class="keyword">in</span> range(mnist.train.num_examples // batch_size): <span class="comment"># 每批量一次</span></span><br><span class="line">            X_batch, y_batch = mnist.train.next_batch(batch_size)</span><br><span class="line">            sess.run(training_op, feed_dict=&#123;X: X_batch, y: y_batch&#125;) <span class="comment"># 运行计算程序</span></span><br><span class="line">        acc_train = accuracy.eval(feed_dict=&#123;X: X_batch, y: y_batch&#125;)</span><br><span class="line">        acc_test = accuracy.eval(feed_dict=&#123;X: mnist.test.images, y: mnist.test.labels&#125;)</span><br><span class="line">        print(epoch, <span class="string">"Train accuracy:"</span>, acc_train, <span class="string">"Test accuracy:"</span>, acc_test)</span><br><span class="line"></span><br><span class="line">    save_path = saver.save(sess, <span class="string">"./my_model_final.ckpt"</span>)</span><br></pre></td></tr></table></figure>
<p>该代码打开一个 TensorFlow 会话，并运行初始化所有变量的<code>init</code>节点。 然后它运行的主要训练循环：在每个时期，通过一些小批次的对应于训练集的大小的代码进行迭代。 <strong>每个小批量通过<code>next_batch()</code>方法获取，然后代码简单地运行训练操作</strong>，为当前的小批量输入数据和目标提供。 接下来，在每个时期结束时，代码评估最后一个小批量和完整训练集上的模型，并打印出结果。 最后，模型参数保存到磁盘。</p>
<h3 id="使用神经网络进行预测"><a href="#使用神经网络进行预测" class="headerlink" title="使用神经网络进行预测"></a>使用神经网络进行预测</h3><p>现在神经网络被训练了，你可以用它进行预测。 为此，您可以重复使用相同的建模阶段，但是更改执行阶段，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    saver.restore(sess, <span class="string">"./my_model_final.ckpt"</span>) <span class="comment"># or better, use save_path</span></span><br><span class="line">    X_new_scaled = mnist.test.images[:<span class="number">20</span>]</span><br><span class="line">    Z = logits.eval(feed_dict=&#123;X: X_new_scaled&#125;)</span><br><span class="line">    y_pred = np.argmax(Z, axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>首先，代码从磁盘加载模型参数。 然后加载一些您想要分类的新图像。 记住应用与训练数据相同的特征缩放（在这种情况下，将其从 0 缩放到 1）。 然后代码评估对数点节点。 如果您想知道所有估计的类概率，则需要将<code>softmax()</code>函数应用于对数，但如果您只想预测一个类，则可以简单地选择具有最高 logit 值的类（使用<code>argmax()</code>函数做的伎俩）。</p>
<h2 id="微调神经网络超参数"><a href="#微调神经网络超参数" class="headerlink" title="微调神经网络超参数"></a>微调神经网络超参数</h2><p>神经网络的灵活性也是其主要缺点之一：有很多超参数要进行调整。 不仅可以使用任何可想象的网络拓扑（如何神经元互连），而且即使在简单的 MLP 中，您可以更改层数，每层神经元数，每层使用的激活函数类型，权重初始化逻辑等等。 你怎么知道什么组合的超参数是最适合你的任务？</p>
<p>可以使用具有交叉验证的网格搜索来查找正确的超参数 ，但是由于要调整许多超参数，并且由于在大型数据集上训练神经网络需要很多时间 。像之前讨论过的，使用随机搜索要好得多 ，另一个选择是使用诸如 Oscar 之类的工具，它可以实现更复杂的算法，以帮助您快速找到一组好的超参数.</p>
<h3 id="隐藏层数量"><a href="#隐藏层数量" class="headerlink" title="隐藏层数量"></a>隐藏层数量</h3><p>实际上已经表明，只有一个隐藏层的 MLP 可以建模甚至最复杂的功能，只要它具有足够的神经元。 但是他们忽略了这样一个事实：深层网络具有比浅层网络更高的参数效率：他们可以使用比浅网格更少的神经元来建模复杂的函数，使得训练更快。</p>
<p>总而言之，对于许多问题，您可以从一个或两个隐藏层开始。(MNIST 数据集上容易达到 97% 以上的准确度使用两个具有相同总神经元数量的隐藏层 )；对于更复杂的问题，您可以逐渐增加隐藏层的数量，直到您开始覆盖训练集。 <strong>但是，我们很少从头开始训练这样的网络：重用预先训练的最先进的网络执行类似任务的部分更为常见</strong>。训练将会更快，需要更少的数据 。</p>
<h3 id="每层隐藏层的神经元数量"><a href="#每层隐藏层的神经元数量" class="headerlink" title="每层隐藏层的神经元数量"></a>每层隐藏层的神经元数量</h3><p>不幸的是，正如你所看到的，找到完美的神经元数量仍然是黑色的艺术.</p>
<p><strong>一个更简单的方法是选择一个具有比实际需要的更多层次和神经元的模型</strong>，然后使用早期停止来防止它过度拟合（以及其他正则化技术，特别是 drop out，我们将在后面）。 这被称为“拉伸裤”的方法：而不是浪费时间寻找完美匹配您的大小的裤子，只需使用大型伸缩裤，缩小到合适的尺寸。</p>
<h3 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h3><p>在大多数情况下，您可以在隐藏层中使用 ReLU 激活函数（或其中一个变体 ）</p>
<p>对于输出层，softmax 激活函数通常是分类任务的良好选择（当这些类是互斥的时）。 对于回归任务，您完全可以不使用激活函数。</p>
<hr>
<ol>
<li>为什么通常使用逻辑斯蒂回归分类器而不是经典感知器（即使用感知器训练算法训练单层的线性阈值单元）？你如何调整感知器使之等同于逻辑回归分类器？</li>
</ol>
<p>答：经典感知器只有在数据集是线性可分的情况下才会收敛。相比之下，逻辑回归分类器将收敛于一个很好的解决方案，即使数据集不是线性可分的，它会输出类的概率。如果你将感知器的激活函数改为逻辑激活函数(或如果有多个神经元，则为softmax激活函数)，，则等价于逻辑回归分类器。</p>
<ol>
<li>为什么激活函数是训练第一个 MLP 的关键因素？</li>
</ol>
<p>答：logistic激活函数是训练第一批MLP的关键因素，因为它是一个复杂的过程导数总是不为零的，所以梯度下降总是可以沿着斜率向下滚动。当激活函数是阶跃函数，梯度下降无法移动，因为根本没有斜率。</p>
<ol>
<li>假设有一个 MLP 有一个 10 个神经元组成的输入层，接着是一个 50 个神经元的隐藏层，最后一个 3 个神经元输出层。所有人工神经元使用 Relu 激活函数。</li>
</ol>
<ul>
<li>输入矩阵<code>X</code>的形状是什么？ ——   -m × 10，其中m为batch size.</li>
<li>隐藏层的权重向量的形状以及它的偏置向量的形状如何？ ——W_h=50 × 10，b_h = 50（一维长度）</li>
<li>输出层的权重向量和它的偏置向量的形状是什么？ ——W_o=50 × 3，b_o=3</li>
<li>网络的输出矩阵<code>Y</code>是什么形状？ ——Y=m × 3</li>
<li>写出计算网络输出矩阵的方程 —$-Y=(X\cdot W_h+b_h)\cdot W_o+b_o$</li>
</ul>
<ol>
<li>如果你想把电子邮件分类成垃圾邮件或正常邮件，你需要在输出层中有多少个神经元？在输出层中应该使用什么样的激活函数？如果你想解决 MNIST 问题，你需要多少神经元在输出层，使用什么激活函数？</li>
</ol>
<p>答：只需要神经系统在输出层中的一个神经元，通常在估计概率时，使用输出层的logistic激活函数。如果你想处理mnist，你需要输出层的10个神经元，你必须替换<br>logistic函数与softmax激活函数，它可以处理多个分裂，每个类输出一个概率。如果现在想让你的神经网络预测房屋价格，则需要一个输出神经元，不使用任何激活函数<br>输出层。</p>

          
        
      
    </div>
    
    
    
    
    
    
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/14/数据挖掘概念与技术/数据挖掘概念与技术笔记（8）：聚类（2）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mosbyllc">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mosbyllc">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/14/数据挖掘概念与技术/数据挖掘概念与技术笔记（8）：聚类（2）/" itemprop="url">数据挖掘概念与技术笔记（8）：聚类（2）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-14T17:06:14+08:00">
                2018-11-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据挖掘/" itemprop="url" rel="index">
                    <span itemprop="name">数据挖掘</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3,563
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  13
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="基于密度的聚类"><a href="#基于密度的聚类" class="headerlink" title="基于密度的聚类"></a>基于密度的聚类</h2><p>密度聚类方法的指导思想是，只要样本点的密度大于某阈值，则将该样本添加到最近的簇中。这类算法能克服基于距离的算法只能发现“类圆”（凸）的聚类的缺点，可发现任意形状的聚类，且对噪声数据不敏感。但计算密度单元的计算复杂度大，需要建立空间索引来降低计算量。</p>
<h3 id="DBSCAN：一种基于高密度连通区域的密度聚类"><a href="#DBSCAN：一种基于高密度连通区域的密度聚类" class="headerlink" title="DBSCAN：一种基于高密度连通区域的密度聚类"></a>DBSCAN：一种基于高密度连通区域的密度聚类</h3><p>DBCSAN（Density-Based Spatial Clustering of Applications with Noise）是一个比较有代表性的基于密度的聚类算法。与划分和层次聚类方法不同，它将簇定义为密度相连的点的最大集合，能够把具有足够高密度的区域划分为簇，并可在有“噪声”的数据中发现任意形状的聚类。</p>
<p>基础概念</p>
<ul>
<li>对象的ϵ−领域：给定对象在半径ϵϵ内的区域</li>
<li>核心对象：对于给定的数目m，如果一个对象的ϵ−领域至少包含m个对象，则称该对象为核心对象。</li>
<li>直接密度可达：给定一个对象集合D，如果p是在q的ϵ−领域内，而q是一个核心对象，我们说对象p从对象q出发时直接密度可达的。</li>
</ul>
<p>如图ϵ=1 ，m=5， q是一个核心对象，从对象q出发到对象p是直接密度可达的。</p>
<p><img src="/2018/11/14/数据挖掘概念与技术/数据挖掘概念与技术笔记（8）：聚类（2）/01.jpg" alt></p>
<ul>
<li>密度可达：如果存在一个对象链$p<em>1,p_2,⋅⋅⋅,p_n$，使得$p_1=q$，$p_n=p$，并且对$p_i (1≤i≤n)∈D$，有$p</em>{i+1}$是从$p_i$关于ϵ和m直接密度可达的，则p是从q密度可达的(也就是中间连接了多个直接密度可达)。注意密度可达不是等价关系，因为它不是对称的。如果$o_1$和$o_2$都是核心对象，则都是密度可达；如果$o_2$是核心对象$o_1$不是，则$o_1$可能是从$o_2$密度可达，反过来就不可以。（需要从核心出发到不核心）</li>
</ul>
<p><img src="/2018/11/14/数据挖掘概念与技术/数据挖掘概念与技术笔记（8）：聚类（2）/02.jpg" alt></p>
<p> 密度相连：如果对象集合D中存在一个对象o，使得对p和q是从o关于ϵ和m密度可达的，那么对象p和q是关于ϵ和m密度相连的。 (存在中间点o，分别到q和p两条路线都是密度可达，则q和p密度相连)。不像密度可达，密度相连是等价的。 </p>
<p><img src="/2018/11/14/数据挖掘概念与技术/数据挖掘概念与技术笔记（8）：聚类（2）/03.jpg" alt></p>
<p>算法步骤：</p>
<p>下面这张图来自WIKI，图上有若干个点，其中标出了A、B、C、N这四个点，据此来说明这个算法的步骤：</p>
<p><img src="/2018/11/14/数据挖掘概念与技术/数据挖掘概念与技术笔记（8）：聚类（2）/04.jpg" alt></p>
<ul>
<li>1、首先随机选择A点为算法实施的切入点，我们将ϵϵ设置为图中圆的半径，对象密度个数$m（minPts）$设定为4。这里我们看到，A点的ϵϵ领域包含4个对象（自己也包含在内），大于等于$m(minPts)$，则创建A作为核心对象的新簇，簇内其他点都（暂时）标记为边缘点。</li>
<li>2、然后在标记的边缘点中选取一个重复上一步，寻找并合并核心对象直接密度可达的对象。对暂时标记为边缘点反复递归上述算法，直至没有新的点可以更新簇时，算法结束。这样就形成了一个以A为起始的一个聚类，为图中红色的中心点和黄色的边缘点（黄红点都形成簇）</li>
<li>3、如果还有Points未处理，再次新产生一个类别来重新启动这个算法过程。遍历所有数据，如果有点既不是边缘点也不是中心点，将其标记为噪音。</li>
</ul>
<p><img src="/2018/11/14/数据挖掘概念与技术/数据挖掘概念与技术笔记（8）：聚类（2）/05.webp" alt></p>
<p>初始，给定数据集D中的所有对象都标记为”unvisited”。DBSCAN随机地选择一个未访问的对象p，标记p为”visited”，并检查p是否为核心对象。如果不是，标记p为噪点，否则为p创建一个新的簇C，并且将领域内所有对象都放到候选集合N中（这个集合会慢慢加大）。<strong>DBSCAN迭代地把N中不属于其他簇的对象添加C中</strong>。在此过程中，对于N中标记为”unvisited”的对象p’ ，标记为”visited”，如果它是核心对象，则将它的领域节点都添加到N中。DBSCAN继续从候选集N中添加到C，直到N的集合为空。此时，簇C完全生成，于是被输出。</p>
<p>从上述算法可知：</p>
<ul>
<li>每个簇至少包含一个核心对象；</li>
<li>非核心对象可以是簇的一部分，构成了簇的边缘（edge）；</li>
<li>包含过少对象的簇被认为是噪声；</li>
</ul>
<p>DBSCAN的主要优点有：</p>
<p>　　1） 可以对任意形状的稠密数据集进行聚类，相对的，K-Means之类的聚类算法一般只适用于凸数据集。</p>
<p>　　2） 可以在聚类的同时发现异常点，对数据集中的异常点不敏感。</p>
<p>　　3） 聚类结果没有偏倚，相对的，K-Means之类的聚类算法初始值对聚类结果有很大影响。</p>
<p>DBSCAN的主要缺点有：</p>
<p>　　1）如果样本集的密度不均匀、聚类间距差相差很大时，聚类质量较差，这时用DBSCAN聚类一般不适合。</p>
<p>　　2） 如果样本集较大时，聚类收敛时间较长，此时可以对搜索最近邻时建立的KD树或者球树进行规模限制来改进。</p>
<p>　　3） 调参相对于传统的K-Means之类的聚类算法稍复杂，主要需要对距离阈值ϵ，邻域样本数阈值$m(MinPts)$联合调参，不同的参数组合对最后的聚类效果有较大影响。</p>
<h3 id="OPTICS-通过点排序识别聚类结构"><a href="#OPTICS-通过点排序识别聚类结构" class="headerlink" title="OPTICS:通过点排序识别聚类结构"></a>OPTICS:通过点排序识别聚类结构</h3><p>在前面介绍的DBSCAN算法中，有两个初始参数Eps（邻域半径）和minPts(Eps邻域最小点数)需要手动设置，并且聚类的结果对这两个参数的取值非常敏感，不同的取值将产生不同的聚类结果。为了克服DBSCAN算法这一缺点，提出了OPTICS算法（Ordering Points to identify the clustering structure），翻译过来就是，对点排序以此来确定簇结构。</p>
<p>OPTICS是对DBSCAN的一个扩展算法。该算法可以让算法对半径Eps不再敏感。只要确定minPts的值，半径Eps的轻微变化，并不会影响聚类结果 。OPTICS并不显示的产生结果类簇，而是为聚类分析生成一个增广的簇排序，从这个排序中可以得到基于任何参数Eps和minPts的DBSCAN算法的聚类结果。</p>
<h4 id="核心距离与可达距离"><a href="#核心距离与可达距离" class="headerlink" title="核心距离与可达距离"></a>核心距离与可达距离</h4><p>要搞清楚OPTICS算法，需要搞清楚2个新的定义：<strong>核心距离和可达距离</strong>。</p>
<ul>
<li>核心距离：一个对象p的核心距离是<strong>使得其成为核心对象的最小半径</strong>，如果p不是核心点，其可达距离没有定义 。</li>
<li>可达距离：从q到p的可达距离是$\max {core-distance(q), dist(p,q)}$。如果q不是核心点，其从q到p的可达距离没有定义。另外对象p关于不同的核心对象，p可能有多个可达距离。p的最小可达距离代表离一个稠密簇的距离越短，越处于核心密集地段。</li>
</ul>
<p>举例，下图中假设minPts=3，半径是ϵϵ。那么P点的核心距离是d(1,P)，点2的可达距离是d(1,P)，点3的可达距离也是d(1,P)，点4的可达距离则是d(4,P)的距离。</p>
<p><img src="/2018/11/14/数据挖掘概念与技术/数据挖掘概念与技术笔记（8）：聚类（2）/06.png" alt></p>
<h4 id="OPTICS算法描述"><a href="#OPTICS算法描述" class="headerlink" title="OPTICS算法描述"></a>OPTICS算法描述</h4><p>输入：样本集D, 邻域半径ϵϵ, 给定点在ϵϵ领域内成为核心对象的最小领域点数MinPts</p>
<p>输出：具有可达距离信息的样本点输出排序</p>
<p>首先创建两个队列，有序队列和结果队列。（有序队列用来存储核心对象及其该核心对象的直接可达对象，并按可达距离升序排列；结果队列用来存储样本点的输出次序。你可以把有序队列里面放的理解为待处理的数据，而结果队列里放的是已经处理完的数据）。</p>
<p>步骤：</p>
<ul>
<li>D: 待聚类的集合</li>
<li>Q: 有序队列，元素按照可达距离排序，可达距离最小的在队首</li>
<li>O: 结果队列，最后输出结果的点集的有序队列</li>
</ul>
<p>首先从D中取出一个核心对象p，首先p要先标记加入结果队列，它的领域则加入有序队列。从有序队列取队首q，先把队首q标记且加入结果队列，若q不为核心对象则继续从Q队列中取队首处理；否则若为核心队列则将q的领域加入到有序队列并重新排列顺序。加入新元素后再取有序队列队首依次循环处理。算法结束，输出结果队列中的有序样本点。</p>
<p><img src="/2018/11/14/数据挖掘概念与技术/数据挖掘概念与技术笔记（8）：聚类（2）/07.png" alt></p>
<p>得到结果队列后，使用如下算法得到最终的聚类结果：</p>
<ul>
<li>从结果队列中按顺序取出点，如果该点的<strong>可达距离</strong>不大于给定半径ϵϵ，则该点属于当前类别，否则至步骤2</li>
<li>如果该点的<strong>核心距离</strong>大于给定半径ϵ，则该点为噪声，可以忽略，否则该点属于新的聚类，跳至步骤1</li>
<li>结果队列遍历结束，则算法结束</li>
</ul>
<p><img src="/2018/11/14/数据挖掘概念与技术/数据挖掘概念与技术笔记（8）：聚类（2）/08.png" alt></p>
<p> 上面的算法处理完后，我们得到了输出结果序列，每个节点的可达距离和核心距离。我们以可达距离为纵轴，样本点输出次序为横轴进行可视化： </p>
<p><img src="/2018/11/14/数据挖掘概念与技术/数据挖掘概念与技术笔记（8）：聚类（2）/09.png" alt></p>
<p>其中：</p>
<ul>
<li>X轴代表OPTICS算法处理点的顺序，Y轴代表可达距离。</li>
<li>簇在坐标轴中表述为山谷，并且山谷越深，簇越紧密</li>
<li>黄色代表的是噪声，它们不形成任何凹陷。</li>
</ul>
<p>当你需要提取聚集的时候，参考Y轴和图像，自己设定一个阀值就可以提取聚集了。再来一张凹陷明显的：</p>
<p><img src="/2018/11/14/数据挖掘概念与技术/数据挖掘概念与技术笔记（8）：聚类（2）/10.png" alt></p>
<p>OPTICS的核心思想：</p>
<ul>
<li>较稠密簇中的对象在簇排序中相互靠近</li>
<li>一个对象的最小可达距离给出了一个对象连接到一个稠密簇的最短路径</li>
</ul>
<h3 id="DPCA算法"><a href="#DPCA算法" class="headerlink" title="DPCA算法"></a>DPCA算法</h3><p>2014年6月，Alex Rodriguez和Alessandro Laio在ScienceScience上发表了一篇名为《Clustering by fast search and find of density peaks》的文章，提供了一种简洁而优美的聚类算法，是一种基于密度的聚类方法，可以识别各种形状的类簇，并且参数很容易确定。它克服了DBSCAN中不同类的密度差别大、邻域范围难以设定的问题，鲁棒性强。 在文章中提出的聚类方法DPCA算法（Desity Peaks Clustering Algorithm）基于这样一种假设：对于一个数据集，聚类中心被一些低局部密度的数据点包围，而且这些低局部密度点距离其他有高局部密度的点的距离都比较大。</p>
<h4 id="一些概念："><a href="#一些概念：" class="headerlink" title="一些概念："></a>一些概念：</h4><ul>
<li>局部密度$p_i$ ：即到对象i的距离小于$d_c$的对象个数。</li>
<li>高局部密度点距离（顾名思义，密度是特别局部的），其定义为：</li>
</ul>
<script type="math/tex; mode=display">
\delta_i=\min\limits_{j:p_j>p_i}d_{ij}</script><p> 即在局部密度高于对象i的所有对象中，到对象i最近的距离。 而极端地，对于局部密度最大的那个对象(它没有比它更大的了)，我们设置$\delta=max(d_{ij})$，即它与离它最远的点的距离； 只有那些密度是局部或者全局最大的点（即稀疏的点）才会有远大于正常值的高局部密度点距离。 </p>
<h4 id="聚类过程"><a href="#聚类过程" class="headerlink" title="聚类过程"></a>聚类过程</h4><p>这个聚类实例摘自作者的PPT讲演，在一个二维空间中对数据进行聚类，具体步骤如下：</p>
<p>1、首先计算每一个点的局部密度ρiρi，如图中，$ρ<em>1=7,ρ_8=5,ρ</em>{10}=4$</p>
<p><img src="/2018/11/14/数据挖掘概念与技术/数据挖掘概念与技术笔记（8）：聚类（2）/11.jpg" alt></p>
<p> 2、然后对于每一个点i计算在局部密度高于对象i的所有对象中，到对象i最近的距离，即$ \delta_i $</p>
<p><img src="/2018/11/14/数据挖掘概念与技术/数据挖掘概念与技术笔记（8）：聚类（2）/12.jpg" alt></p>
<p> 3、对每一个点，绘制出局部密度与高局部密度点距离的关系散点图 </p>
<p><img src="/2018/11/14/数据挖掘概念与技术/数据挖掘概念与技术笔记（8）：聚类（2）/13.jpg" alt></p>
<p> 4、<strong>图上的异常点即为簇中心</strong>。如图所示，1和10两点的局部密度和高局部密度距离都很大，将其作为簇中心。 </p>
<p><img src="/2018/11/14/数据挖掘概念与技术/数据挖掘概念与技术笔记（8）：聚类（2）/14.jpg" alt></p>
<p>5、将其他的点分配给距离其最近的有着更高的局部密度的簇。</p>
<p><img src="/2018/11/14/数据挖掘概念与技术/数据挖掘概念与技术笔记（8）：聚类（2）/15.jpg" alt></p>
<p> 左图是所有点在二维空间的分布，右图是以ρρ为横坐标，以δδ为纵坐标绘制的决策图。容<strong>易发现，1和10两个点的$ρ_i$和$ \delta_i $都比较大，作为簇的中心点</strong>。<strong>26、27、28三个点的δδ也比较大，但是ρ比较小，所以是异常点</strong>。 </p>
<h4 id="簇中心的识别"><a href="#簇中心的识别" class="headerlink" title="簇中心的识别"></a>簇中心的识别</h4><p>那些有着比较大的局部密度ρiρi和很大的高局部密度δiδi的点被认为是簇的中心； 而高局部密度距离δiδi较大但局部密度ρiρi较小的点是异常点； 确定簇中心之后，其他点按照距离已知簇的中心最近进行分类，也可以按照密度可达的方法进行分类。</p>
<p>但是，这里我们在确定聚类中心时，没有定量地分析，而是通过肉眼观察，包含很多的主观因素。因此，作者在文中给出了一种确定聚类中心个数的提醒：计算一个将ρ值和$ \delta$值综合考虑的量</p>
<script type="math/tex; mode=display">
\gamma_i=\rho_i\delta_i</script><p>显然γ值越大，越有可能是聚类中心。因此，只需对其降序排列，然后从前往后截取若干个数据点作为聚类中心就可以了。</p>
<p>领域阈值$d_c$的选择：一种推荐做法是选择$d_c$，使得平均每个点的邻居数为所有点的1%~2%。</p>
<h2 id="基于网格的聚类"><a href="#基于网格的聚类" class="headerlink" title="基于网格的聚类"></a>基于网格的聚类</h2><p>基于格子的参考这篇文章吧，感觉很少用啊，主要是STING统计信息网格算法和CLIQUE子空间聚类算法。</p>
<p><a href="https://cloud.tencent.com/developer/article/1005263" target="_blank" rel="noopener">戳我</a></p>
<h2 id="谱聚类"><a href="#谱聚类" class="headerlink" title="谱聚类"></a>谱聚类</h2><p>谱聚类似乎也应用较广，这篇博客写的很清晰了</p>
<p><a href="https://blog.csdn.net/google19890102/article/details/45697695" target="_blank" rel="noopener">戳我</a></p>

          
        
      
    </div>
    
    
    
    
    
    
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/12/数据挖掘概念与技术/数据挖掘概念与技术笔记（7）：聚类（1）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mosbyllc">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mosbyllc">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/12/数据挖掘概念与技术/数据挖掘概念与技术笔记（7）：聚类（1）/" itemprop="url">数据挖掘概念与技术笔记（7）：聚类（1）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-12T17:06:14+08:00">
                2018-11-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据挖掘/" itemprop="url" rel="index">
                    <span itemprop="name">数据挖掘</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  4,792
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  17
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p> 下图简单地总结了一些聚类方法的简单划分 </p>
<p><img src="/2018/11/12/数据挖掘概念与技术/数据挖掘概念与技术笔记（7）：聚类（1）/01.png" alt></p>
<h2 id="基于划分的聚类"><a href="#基于划分的聚类" class="headerlink" title="基于划分的聚类"></a>基于划分的聚类</h2><p>聚类分析最简单、最基本的版本是基于划分的聚类，它把对象组织成多个互斥的组或簇。为了使得问题说明简洁，我们假定簇个数作为背景知识给定，这个参数是划分方法的起点。</p>
<h3 id="k-均值（k-mean）-：一种基于形心的技术"><a href="#k-均值（k-mean）-：一种基于形心的技术" class="headerlink" title="k-均值（k-mean） ：一种基于形心的技术"></a>k-均值（k-mean） ：一种基于形心的技术</h3><p><strong>k均值算法非常简单，它用簇$C_i$的形心代表该簇。每次确定K个类别中心，然后将各个结点归属到与之距离最近的中心点所在的Cluster，然后将类别中心更新为属于各Cluster的所有样本的均值</strong>，反复迭代，直至类别中心不再发生变化或变化小于某阈值。 下面给出该算法的伪代码</p>
<p><img src="/2018/11/12/数据挖掘概念与技术/数据挖掘概念与技术笔记（7）：聚类（1）/02.png" alt></p>
<ul>
<li>优点：<ul>
<li>是解决聚类问题的一种经典算法，简单、快速</li>
<li>对处理大数据集，该算法保持可伸缩性和高效率</li>
</ul>
</li>
<li>缺点：<ul>
<li>必须事先给出K，而且对初值敏感，对于不同的初始值，结果可能不同</li>
<li>只能发现球状Cluster，不适合于发现非凸形状的簇或者大小差别很大的簇</li>
<li>对噪声和孤立点数据敏感，如簇中含有异常点，将导致均值偏离严重</li>
</ul>
</li>
</ul>
<p>如何确定k类</p>
<p><a href="https://www.cnblogs.com/yan2015/p/5239970.html" target="_blank" rel="noopener">https://www.cnblogs.com/yan2015/p/5239970.html</a></p>
<h3 id="k-中心点（k-mediods）：一种基于代表对象的技术"><a href="#k-中心点（k-mediods）：一种基于代表对象的技术" class="headerlink" title="k-中心点（k-mediods）：一种基于代表对象的技术"></a>k-中心点（k-mediods）：一种基于代表对象的技术</h3><p>k-均值算法对离群点敏感，因为这种对象远离大多数数据，因此分配到一个簇时，它们可能严重地扭曲簇的均值。因此，提出了k-中心点算法，<strong>它挑选实际对象代表簇，每个簇使用一个代表对象。这个代表对象选择的规则是：选择簇内一个点到其他点的距离之和的最小代价值，作为新的中心点</strong>。</p>
<p>K-中心聚类算法计算的是某点到其它所有点的距离之和最小的点，通过距离之和最短的计算方式可以减少某些孤立数据对聚类过程的影响 。下面给出算法的伪代码</p>
<p><img src="/2018/11/12/数据挖掘概念与技术/数据挖掘概念与技术笔记（7）：聚类（1）/03.png" alt></p>
<h2 id="基于层次的聚类"><a href="#基于层次的聚类" class="headerlink" title="基于层次的聚类"></a>基于层次的聚类</h2><p>尽管基于划分的聚类算法能够实现把数据集划分成指定数量的簇，但是在某些情况下，需要把数据集划分成不同层上的簇。<strong>层次聚类方法将数据组成层次结构或簇的”树”</strong></p>
<p><strong>基于层次的聚类算法（Hierarchical Clustering）可以</strong>是凝聚的（Agglomerative）或者分裂的（Divisive），取决于层次的划分是“自底向上”还是“自顶向下”。</p>
<ul>
<li>自顶向下： 它把所有对象至于一个簇中开始，该簇是层次结构的根。然后，它把根上的簇划分为多个较小的子簇，并且递归地把这次簇划分成更小的簇，直到满足终止条件。常见的自顶向下的算法有K-means层次聚类算法。</li>
<li>自底向上：把数据集中的每个对象最为一个簇开始，迭代地把簇合并成为更大的簇，直到最终形成一个大簇，或者满足某个终止条件。基于自底向上算法有凝聚算法、BIRCH算法、CURE算法、变色龙算法等。</li>
</ul>
<h3 id="自顶向下算法"><a href="#自顶向下算法" class="headerlink" title="自顶向下算法"></a>自顶向下算法</h3><h4 id="Hierarchical-K-means算法"><a href="#Hierarchical-K-means算法" class="headerlink" title="Hierarchical K-means算法"></a>Hierarchical K-means算法</h4><p>Hierarchical K-means算法是“自顶向下”的层次聚类算法，用到了基于划分的聚类算法那K-means，算法思路如下：</p>
<ol>
<li>首先，把原始数据集放到一个簇C，这个簇形成了层次结构的最顶层；</li>
<li>使用K-means算法把簇C划分成指定的K个子簇$C_i，i=1,2,…,k$，形成一个新的层；</li>
<li>对于步骤2所生成的K个簇，递归使用K-means算法划分成更小的子簇，直到每个簇不能再划分（只包含一个数据对象）或者满足设定的终止条件。</li>
</ol>
<p>如下图，展示了一组数据进行了二次K-means算法的过程</p>
<p><img src="/2018/11/12/数据挖掘概念与技术/数据挖掘概念与技术笔记（7）：聚类（1）/04.png" alt></p>
<p> Hierarchical K-means算法一个很大的问题是，一旦两个点在最开始被划分到了不同的簇，即使这两个点距离很近，在后面的过程中也不会被聚类到一起。 </p>
<p><img src="/2018/11/12/数据挖掘概念与技术/数据挖掘概念与技术笔记（7）：聚类（1）/05.png" alt></p>
<p>对于以上的例子，红色椭圆框中的对象聚类成一个簇可能是更优的聚类结果，但是由于橙色对象和绿色对象在第一次K-means就被划分到不同的簇，之后也不再可能被聚类到同一个簇。</p>
<h3 id="自底向上算法"><a href="#自底向上算法" class="headerlink" title="自底向上算法"></a>自底向上算法</h3><h4 id="Agglomerative-Clustering算法"><a href="#Agglomerative-Clustering算法" class="headerlink" title="Agglomerative Clustering算法"></a>Agglomerative Clustering算法</h4><p>相比于Hierarchical K-means算法存在的问题，Agglomerative Clustering算法能够保证距离近的对象能够被聚类到一个簇中，该算法采用的“自底向上”聚类的思路。</p>
<p> 算法思路，对于数据集$D，D=x_1,x_2,…,x_n$：</p>
<ol>
<li>将数据集中的每个对象生成一个簇，得到簇列表$C，C=c_1,c_2,…,c_n$<ul>
<li>a) 每个簇只包含一个数据对象：$c_i=x_i$；</li>
</ul>
</li>
<li>重复如下步骤，直到C中只有一个簇：<ul>
<li>a) 从C中的簇中找到两个“距离”最近的两个簇：$\min D(ci,cj)$；</li>
<li>b) 合并簇$c<em>i$和$c_j$，形成新的簇$c</em>{ij}；</li>
<li>c) 从C中删除簇$c<em>i%和$c_j$，添加簇$c</em>{ij}</li>
</ul>
</li>
</ol>
<h5 id="簇间距离计算"><a href="#簇间距离计算" class="headerlink" title="簇间距离计算"></a>簇间距离计算</h5><p>在上面描述的算法中涉及到计算两个簇之间的距离，对于簇$C_1$和$C_2$，计算$minD(C1,C2)$，有以下几种计算方式：</p>
<p> <strong>最小距离：</strong> </p>
<script type="math/tex; mode=display">
\min\ dist_{min}(C_i,C_j)=\min \mathop{\min} \limits_{p\in C_i,q\in C_j}\{|p-q|\}</script><p><img src="/2018/11/12/数据挖掘概念与技术/数据挖掘概念与技术笔记（7）：聚类（1）/06.png" alt></p>
<p>两个簇之间最近的两个点的距离作为簇之间的距离，该方式的缺陷是受噪点影响大，容易产生长条状的簇。</p>
<p><strong>最大距离：</strong></p>
<script type="math/tex; mode=display">
\min\ dist_{max}(C_i,C_j)=\min \mathop{\max} \limits_{p\in C_i,q\in C_j}\{|p-q|\}</script><p><img src="/2018/11/12/数据挖掘概念与技术/数据挖掘概念与技术笔记（7）：聚类（1）/07.png" alt></p>
<p>两个簇之间最远的两个点的距离作为簇之间的距离，采用该距离计算方式得到的聚类比较紧凑。</p>
<p><strong>均值距离：</strong> $m_i$和$m_j$为簇内所有点的均值坐标</p>
<script type="math/tex; mode=display">
\min\ dist_{mean}(C_i,C_j)=\min |m_i-m_j|</script><p> <strong>平均距离：</strong> </p>
<script type="math/tex; mode=display">
\min\ dist_{avg}(C_i,C_j)=\min\ \frac{1}{n_in_j}\mathop{\sum}\limits_{p\in C_i,q\in C_j}\{|p-q|\}</script><h5 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h5><p><img src="/2018/11/12/数据挖掘概念与技术/数据挖掘概念与技术笔记（7）：聚类（1）/09.png" alt></p>
<p>Agglomerative聚类算法的优点是能够根据需要在不同的尺度上展示对应的聚类结果，缺点同Hierarchical K-means算法一样，一旦两个距离相近的点被划分到不同的簇，之后也不再可能被聚类到同一个簇，即无法撤销先前步骤的工作。另外，Agglomerative性能较低，并且因为聚类层次信息需要存储在内存中，内存消耗大，不适用于大量级的数据聚类，下面介绍一种针对大数据量级的聚类算法BIRCH。</p>
<h4 id="BIRCH算法：使用聚类特征树"><a href="#BIRCH算法：使用聚类特征树" class="headerlink" title="BIRCH算法：使用聚类特征树"></a>BIRCH算法：使用聚类特征树</h4><p><strong>BIRCH算法利用了一个树结构来帮助实现快速的聚类，这个数结构类似于平衡B+树，一般将它称之为聚类特征树(Clustering Feature Tree，简称CF Tree)。</strong>这颗树的<strong>每一个节点是由若干个聚类特征(Clustering Feature，简称CF)组成</strong>。从下图可以看看聚类特征树是什么样子的：<strong>每个节点包括叶子节点都有若干个CF，而内部节点的CF有指向孩子节点的指针，所有的叶子节点用一个双向链表链接起来</strong>。</p>
<p><img src="/2018/11/12/数据挖掘概念与技术/数据挖掘概念与技术笔记（7）：聚类（1）/10.png" alt></p>
<p> <strong>在聚类特征树中，一个聚类特征CF是这样定义的：</strong>每一个CF是一个三元组，可以用（N，LS，SS）表示，其中<strong>N代表了这个CF中拥有的样本点的数量；LS代表了这个CF中拥有的样本点各特征维度的和向量，SS代表了这个CF中拥有的样本点各特征维度的平方和</strong>。 聚类特征本质上是定簇的统计汇总。使用聚类特征，我们可以很容易地推导出簇的许多有用的统计量，例如簇的形心$x_0$、半径R和直径D分别是 </p>
<script type="math/tex; mode=display">
x_0=\frac{\sum_{i=1}^nx_i}{n}=\frac{LS}{n}</script><script type="math/tex; mode=display">
R=\sqrt{\frac{\sum_{i=1}^n(x_i-x_0)^2}{n}}</script><script type="math/tex; mode=display">
D=\sqrt{\frac{\sum_{i=1}^n\sum_{j=1}^n(x_i-x_j)^2}{n(n-1)}}=\sqrt{\frac{2nSS-2LS^2}{n(n-1)}}</script><p>其中，R是成员对象到形心的平均距离，D是簇中逐对对象的平均距离。<strong>R和D都反映了形心周围簇的紧凑程度</strong>。</p>
<p>此外，<strong>聚类特征是可加的</strong>，也就是说，对于两个不相交的簇$C_1$和$C_2$，其聚类特征分别是$CF_1[n_1,LS_1,SS_1]$和$CF_2 [n_2,LS_2,SS_2]，合并后的簇的聚类特征是 </p>
<script type="math/tex; mode=display">
CF_1+CF_2=[n_1+n_2,LS_1+LS_2,SS_1+SS_2]</script><p>对于CF Tree，一般有几个重要参数，<strong>第一个参数是每个内部节点的最大CF数B</strong>，<strong>第二个参数是每个叶子节点的最大CF数L</strong>，<strong>第三个参数是针对叶子节点中某个CF中的样本点来说的，它是叶节点每个CF的最大样本半径阈值T</strong>，也就是说，在<strong>这个CF中的所有样本点一定要在半径小于T的一个超球体内</strong>。对于图中的CF Tree，<strong>限定了B=7， L=5， 也就是说内部节点最多有7个CF，而叶子节点最多有5个CF</strong>。</p>
<p><strong>将所有的训练集样本建立了CF Tree，一个基本的BIRCH算法就完成了，对应的输出就是若干个CF节点，每个节点里的样本点就是一个聚类的簇。也就是说BIRCH算法的主要过程，就是建立CF Tree的过程。</strong></p>
<h5 id="聚类特征树CF-Tree的生成"><a href="#聚类特征树CF-Tree的生成" class="headerlink" title="聚类特征树CF Tree的生成"></a>聚类特征树CF Tree的生成</h5><p>下面看看怎么生成CF Tree。<strong>先定义好CF Tree的参数： 即内部节点的最大CF数B， 叶子节点的最大CF数L， 叶节点每个CF的最大样本半径阈值T。</strong></p>
<p><strong>开始时CF Tree是空的，</strong>没有任何样本，我们<strong>从训练集读入第一个样本点，将它放入一个新的CF三元组A</strong>，这个三元组的N=1，将这个新的CF放入根节点，<strong>此时的CF Tree如下图：</strong></p>
<p><img src="/2018/11/12/数据挖掘概念与技术/数据挖掘概念与技术笔记（7）：聚类（1）/11.png" alt></p>
<p> <strong>现在继续读入第二个样本点，发现这个样本点和第一个样本点A在半径为T的超球体范围内，即他们属于一个CF，将第二个点也加入CF A,此时需要更新A的三元组的值。</strong>此时A的三元组中N=2。此时的CF Tree如下图： </p>
<p><img src="/2018/11/12/数据挖掘概念与技术/数据挖掘概念与技术笔记（7）：聚类（1）/12.png" alt></p>
<p> <strong>此时读取第三个节点，结果发现这个节点不能融入刚才前面的节点形成的超球体内，</strong>也就是说，<strong>需要一个新的CF三元组B来容纳这个新的值。此时根节点有两个CF三元组A和B</strong>，此时的CF Tree如下图： </p>
<p><img src="/2018/11/12/数据挖掘概念与技术/数据挖掘概念与技术笔记（7）：聚类（1）/13.png" alt></p>
<p> <strong>当来到第四个样本点时，发现和B在半径小于T的超球体，这样更新后的CF Tree如下图：</strong> </p>
<p><img src="/2018/11/12/数据挖掘概念与技术/数据挖掘概念与技术笔记（7）：聚类（1）/14.png" alt></p>
<p>那个什么时候CF Tree的节点需要分裂呢？假设现在的CF Tree 如下图， 叶子节点LN1有三个CF， LN2和LN3各有两个CF。<strong>叶子节点的最大CF数L=3</strong>。此时一个新的样本点来了，发现它离LN1节点最近，因此开始判断它是否在sc1,sc2,sc3这3个CF对应的超球体之内，但是很不幸，它不在，因此它需要建立一个新的CF，即sc8来容纳它。<strong>问题是我们的L=3，也就是说LN1的CF个数已经达到最大值了，不能再创建新的CF了，怎么办？此时就要将LN1叶子节点一分为二了</strong>。</p>
<p><strong>将LN1里所有CF元组中，找到两个最远的CF做这两个新叶子节点的种子CF，然后将LN1节点里所有CF sc1, sc2, sc3，以及新样本点的新元组sc8划分到两个新的叶子节点上。</strong>将LN1节点划分后的CF Tree如下图：</p>
<p><img src="/2018/11/12/数据挖掘概念与技术/数据挖掘概念与技术笔记（7）：聚类（1）/15.png" alt></p>
<p> <strong>如果内部节点的最大CF数B=3，则此时叶子节点一分为二会导致根节点的最大CF数超了，也就是说，根节点现在也要分裂</strong>，分裂的方法和叶子节点分裂一样，分裂后的CF Tree如下图： </p>
<p><img src="/2018/11/12/数据挖掘概念与技术/数据挖掘概念与技术笔记（7）：聚类（1）/16.png" alt></p>
<p><strong>有了上面这一系列的图，相信大家对于CF Tree的插入就没有什么问题了，总结下CF Tree的插入：</strong></p>
<ul>
<li>1、<strong>从根节点向下寻找</strong>和新样本距离最近的叶子节点和叶子节点里最近的CF节点（判断新节点与NLN1和NLN2谁近一些，然后继续往下）</li>
<li>2、如果新样本加入后，这个CF节点对应的超球体半径仍然满足小于阈值T，则更新路径上所有的CF三元组，插入结束。否则转入3.</li>
<li>3、如果当前叶子节点的CF节点个数小于阈值L，则创建一个新的CF节点，放入新样本，将新的CF节点放入这个叶子节点，更新路径上所有的CF三元组，插入结束。否则转入4。</li>
<li>4、将当前叶子节点划分为两个新叶子节点，选择旧叶子节点中所有CF元组里超球体距离最远的两个CF元组，分布作为两个新叶子节点的第一个CF节点。将其他元组和新样本元组按照距离远近原则放入对应的叶子节点。依次向上检查父节点是否也要分裂，如果需要按和叶子节点分裂方式相同。</li>
</ul>
<p>当然，真实的BIRCH算法除了建立CF Tree来聚类，其实还有一些可选的算法步骤的，<strong>现在我们就来看看 BIRCH算法的流程。</strong></p>
<ul>
<li>1） 将所有的样本依次读入，在内存中建立一颗CF Tree, 建立的方法参考上一节。</li>
<li>2）（可选）将第一步建立的CF Tree进行筛选，去除一些异常CF节点，这些节点一般里面的样本点很少。对于一些超球体距离非常近的元组进行合并</li>
<li>3）（可选）利用其它的一些聚类算法比如K-Means对所有的CF元组进行聚类，得到一颗比较好的CF Tree.这一步的主要目的是消除由于样本读入顺序导致的不合理的树结构，以及一些由于节点CF个数限制导致的树结构分裂。</li>
<li>4）（可选）利用第三步生成的CF Tree的所有CF节点的质心，作为初始质心点，对所有的样本点按距离远近进行聚类。这样进一步减少了由于CF Tree的一些限制导致的聚类不合理的情况。</li>
</ul>
<p><strong>从上面可以看出，BIRCH算法的关键就是步骤1，也就是CF Tree的生成，其他步骤都是为了优化最后的聚类结果。</strong></p>
<p><strong>优点</strong></p>
<ul>
<li>1) 节约内存，所有的样本都在磁盘上，CF Tree仅仅存了CF节点和对应的指针。</li>
<li>2) 聚类速度快，只需要一遍扫描训练集就可以建立CF Tree，CF Tree的增删改都很快。</li>
<li>3) 可以识别噪音点，还可以对数据集进行初步分类的预处理</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>1) 由于CF Tree对每个节点的CF个数有限制，导致聚类的结果可能和真实的类别分布不同.</li>
<li>2) 对高维特征的数据聚类效果不好。此时可以选择Mini Batch K-Means</li>
<li>3) 如果数据集的分布簇不是类似于超球体，或者说不是凸的，则聚类效果不好。</li>
</ul>
<h4 id="CURE算法"><a href="#CURE算法" class="headerlink" title="CURE算法"></a>CURE算法</h4><p>CURE（Clustering Using Representatives）是一种针对大型数据库的高效的聚类算法。基于划分的传统的聚类算法得到的是球状的，相等大小的聚类，对异常数据比较脆弱。CURE采用了用多个点代表一个簇的方法，可以较好的处理以上问题。并且在处理大数据量的时候采用了随机取样，分区的方法，来提高其效率，使得其可以高效的处理大量数据。</p>
<p>我们先看一下基于划分聚类算法的缺陷：</p>
<p><img src="/2018/11/12/数据挖掘概念与技术/数据挖掘概念与技术笔记（7）：聚类（1）/17.png" alt></p>
<p>如上图所示，基于划分的聚类算法比如Hierarchical K-means聚类算法，不能够很好地区分尺寸差距大的簇，原因是K-means算法基于“质心”加一定“半径”对数据进行划分，导致最后聚类的簇近似“圆形”。</p>
<p><strong>CURE算法核心的思想是使用一定数量的“分散的”点（scattered points）来代表一个簇（cluster）</strong>，而不像是其他层次聚类算法中，只使用一个点，使得CURE算法有如下优势：</p>
<ul>
<li>准确地识别任意形状的簇；</li>
<li>准确地识别尺寸差距大的簇；</li>
<li>很好地处理“噪点”</li>
</ul>
<p>所以，CURE算法很好地解决了上面提到的聚类结果的缺陷，CURE算法主流程如下：</p>
<p><strong>Pass 1</strong></p>
<ul>
<li>1、从总数据中随机选取一个样本；</li>
<li>2、利用层次聚类算法把这个样本聚类，形成最初的簇$C_i,(i=1,2,…,k)$；</li>
<li>3、选取“代表点”（representative pionts）;</li>
</ul>
<p>①对于每个簇，选取代表点（比如4个），这些点尽量分散;</p>
<p>②按照固定的比例α（比如20%），把每个样本点向簇的“质心”收缩，生成代表点</p>
<script type="math/tex; mode=display">
\{p'_{i1},p'_{i2},p'_{i3},p'_{i4}\}</script><p><strong>Pass 2</strong></p>
<ul>
<li>重新扫描所有的数据， 对于点p，找到距离p最近的簇，把它放到 “最近的簇”。简单来讲，<strong>是点p到簇$C_i$的距离为点p到簇$C_i$的四个“代表点 中最近的点之间的距离</strong>。</li>
</ul>
<p>收缩系数α的取值不同，聚类结果也相应不同。当α趋于0时，所有的“代表点”都汇聚到质心，算法退化为基于“质心”的聚类；当α趋于1时，“代表点”完全没有收缩，算法退化为基于“全连接”的聚类，因此α值需要要根据数据特征灵活选取，才能得到更好的聚类结果</p>
<h4 id="Chameleon变色龙算法：使用动态建模"><a href="#Chameleon变色龙算法：使用动态建模" class="headerlink" title="Chameleon变色龙算法：使用动态建模"></a>Chameleon变色龙算法：使用动态建模</h4><p>Chameleon（变色龙）是一种层次聚类算法，它采用动态建模来确定一对簇之间的相似度。在Chameleon中，簇的相似性依据以下两点评估：1）簇中对象的连接情况 ；2）簇的邻近性。也就是说，如果两个簇的互连性都很高并且它们之间又靠得很近就将其合并。</p>
<p><img src="/2018/11/12/数据挖掘概念与技术/数据挖掘概念与技术笔记（7）：聚类（1）/18.png" alt></p>
<p>整体算法流程：</p>
<p>1、创建KNN图，每个节点将其最相似的k个节点用一条边连接起来；</p>
<p>2、使用最大流算法或者最小割算法，将kNN图分隔成小图； 也就是说簇C被划分为子簇CiCi和$C_j$，使得把C二分成$C_i$和$C_j$而被切断的边的权重之和最小。</p>
<p>3、将小簇进行和并，找对最大的度量值$RC*RI^\alpha$的两个簇，合并条件是$RC*RI^\alpha$大于某个阈值，否则结束合并。RC和RI的一个基本思想是，点之间的链接越多，这些点越可能连接成一个簇，C表示一个簇，是点的集合，|C|是集合的大小，即点的个数, $EC(A,B)$表示两个簇之间的边的数量。</p>
<p><strong>相似互连度</strong>$RI(C_i,C_j)$</p>
<script type="math/tex; mode=display">
RI(C_i,C_j)=\frac{|EC_{\{C_i,C_j\}}|}{\frac{1}{2}(|EC_{C_i}|+|EC_{C_j}|)}</script><p> 相对接近度$RC(C_i,C_j)$</p>
<script type="math/tex; mode=display">
RC(C_i,C_j)=\frac{\overline S_{EC_{\{C_i,C_j\}}}}{\frac{|C_i|}{|C_i|+|C_j|} \overline S_{EC_{C_i}}+ \frac{|C_i|}{|C_i|+|C_j|} \overline S_{EC_{C_j}}  }</script><p> 其中，分子是连接$C_i$顶点和$C_j$顶点的边的平均权重，分母SECC是最小二分簇$C_i$（或$C_j$）的边的平均权重。 </p>

          
        
      
    </div>
    
    
    
    
    
    
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/09/数据挖掘概念与技术/数据挖掘概念与技术笔记（6）：高级分类方法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mosbyllc">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mosbyllc">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/09/数据挖掘概念与技术/数据挖掘概念与技术笔记（6）：高级分类方法/" itemprop="url">数据挖掘概念与技术笔记（6）：高级分类方法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-09T17:06:14+08:00">
                2018-11-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据挖掘/" itemprop="url" rel="index">
                    <span itemprop="name">数据挖掘</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2,247
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  8
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="贝叶斯信念网络"><a href="#贝叶斯信念网络" class="headerlink" title="贝叶斯信念网络"></a>贝叶斯信念网络</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>朴素贝叶斯分类有一个限制条件，就是特征属性<strong>必须有条件独立或基本独立</strong>（实际上在现实应用中几乎不可能做到完全独立）。当这个条件成立时，朴素贝叶斯分类法的准确率是最高的，但不幸的是，现实中各个特征属性间往往并不条件独立，而是具有<strong>较强的相关性</strong>，这样就限制了朴素贝叶斯分类的能力。 解决这个问题的一种算法叫<strong>贝叶斯网络（又称贝叶斯信念网络或信念网络）</strong>。</p>
<p>贝叶斯网络由两个成分定义：1）有向无环图（DAG）; 2)条件概率表的集合(Conditional Probability Table，CPT)</p>
<p><img src="/2018/11/09/数据挖掘概念与技术/数据挖掘概念与技术笔记（6）：高级分类方法/01.png" alt></p>
<p>上图给出了一个布尔变量的简单贝叶斯信念网络，图中的弧可看做因果知识。<strong>换言之，一旦我们知道变量LungCanner的结果，那么变量FamilyHistory和Smoker就不再提供关于PostiveXRay的任何附近信息</strong>。</p>
<p>DAG中每一个节点表示一个随机变量，可以是可直接观测变量或隐藏变量，而有向边表示随机变量间的条件依赖；<strong>条件概率表中的每一个元素对应DAG中唯一的节点，存储此节点对于其所有直接前驱节点的联合条件概率</strong>。贝叶斯网络有一条极为重要的性质，就是我们<strong>断言每一个节点在其直接前驱节点的值制定后，这个节点条件独立于其所有非直接前驱前辈节点</strong>。这条特性的<strong>重要意义</strong>在于明确了贝叶斯网络可以方便计算联合概率分布。 一般情况先，多变量非独立联合条件概率分布有如下求取公式：</p>
<script type="math/tex; mode=display">
P(x_1,x_2,..,x_n)=P(x_1)P(x_2|x_1)P(x_3|x_1,x_2)...P(x_n|x_1,x_2,...,x_{n-1})</script><p> 而在贝叶斯网络中，由于存在前述性质，任意随机变量组合的联合条件概率分布被化简成 </p>
<script type="math/tex; mode=display">
P(x_1,x_2,...,x_n)=\prod_{i=1}^nP(x_i|Parents(x_i))</script><p> 其中，$P(x_1,…,x_n)$是X的值的特定组合的概率，Parents表示xi的直接前驱节点的<strong>联合</strong> ，而$P(x_i|Parents(x_i))$的值对应于CPT概率表的值。 </p>
<p><img src="/2018/11/09/数据挖掘概念与技术/数据挖掘概念与技术笔记（6）：高级分类方法/02.png" alt></p>
<p>上图是一个有向无环图（DAG） ，不过仅有这个图的话，只能<strong>定性</strong>给出随机变量间的关系，如果要定量，还需要一些数据，这些数据就是每个节点对其直接前驱节点的条件概率（也就是CPT表的概率），而没有前驱节点的节点则使用先验概率表示。</p>
<p>没有前驱的节点用先验概率表示；以及CPT条件概率，例如P(H=0|R=0)=0.9（真实账号为假，头像也为假的概率）</p>
<p><img src="/2018/11/09/数据挖掘概念与技术/数据挖掘概念与技术笔记（6）：高级分类方法/03.png" alt></p>
<p> <strong>有了这些数据，不但能顺向推断，还能通过贝叶斯定理进行逆向推断</strong>。例如，现随机抽取一个账户，已知其头像为假，求其账号也为假的概率： </p>
<p><img src="/2018/11/09/数据挖掘概念与技术/数据挖掘概念与技术笔记（6）：高级分类方法/04.png" alt></p>
<p><strong>如果给出所有节点的条件概率表，则可以在观察值不完备的情况下对任意随机变量进行统计推断</strong>。上述方法就是使用了贝叶斯网络。</p>
<h3 id="训练贝叶斯网络"><a href="#训练贝叶斯网络" class="headerlink" title="训练贝叶斯网络"></a>训练贝叶斯网络</h3><p>构造与训练贝叶斯网络分为以下两步：</p>
<ul>
<li>1、确定随机变量间的拓扑关系，形成DAG。<strong>这一步通常需要领域专家完成</strong>，而想要建立一个好的拓扑结构，通常需要不断迭代和改进才可以。</li>
<li>2、训练贝叶斯网络。如果不训练的，我们只能知道定性的网络，而不能定量。<strong>实际上这一步也就是要完成条件概率表(CPT表)的构造</strong>，如果每个随机变量的值都是可以直接观察的，像我们上面的例子，那么这一步的训练是直观的，方法类似于朴素贝叶斯分类。<strong>但是通常贝叶斯网络的中存在隐藏变量节点，那么训练方法就是比较复杂，例如使用梯度下降法</strong>。</li>
</ul>
<h3 id="性能如何"><a href="#性能如何" class="headerlink" title="性能如何"></a>性能如何</h3><p>贝叶斯网络已经广泛于临床，生物，征信等领域。其强大之处在于两点</p>
<ul>
<li>1.贝叶斯网络最强大之处在于从每个阶段结果所获得的概率都是数学与科学的反映，换句话说，假设我们了解了足够多的信息，根据这些信息获继而得统计知识，网络就会告诉我们合理的推断。</li>
<li>2.贝叶斯网络最很容易扩展(或减少,简化),以<strong>适应不断变化的需求和变化的知识</strong>。</li>
</ul>
<h2 id="使用频繁模式分类"><a href="#使用频繁模式分类" class="headerlink" title="使用频繁模式分类"></a>使用频繁模式分类</h2><h3 id="关联分类"><a href="#关联分类" class="headerlink" title="关联分类"></a>关联分类</h3><p>回顾一下之前的关联规则，显示了规则的置信度和支持度</p>
<script type="math/tex; mode=display">
age=youth \land credit=ok \Rightarrow buys\_computer=yes \\ [support =20\%，confidence=93\%]</script><p>从分类角度，置信度类似于规则的准准确度。例如，93%的置信度意味着D中身为年轻人并且信誉度为OK的顾客中，93%属于类buysconputer=yes。支持度20%意味着D中20%的顾客是青年，信誉为OK，并且属于类buyscomputer=yes</p>
<p>一般而言，关联规则的分类包括以下步骤：</p>
<ul>
<li>1、挖掘数据，找出频繁项集，即找出数据经常出现的属性-值对</li>
<li>2、分析频繁项集，产生每个类的关联规则，它们满足置信度和支持度标准</li>
<li>3、组织规则，形成基于规则的分类器</li>
</ul>
<p>这里，我们考察以下三种分类方法1）CBA ; 2) CMAR ; 3)CPAR</p>
<h4 id="CBA"><a href="#CBA" class="headerlink" title="CBA"></a>CBA</h4><p>最早、最简单的关联分类算法是CBA。CBA使用迭代的方法挖掘频繁项集，类似于Apriori算法。CBA使用了一种启发式方法构造分类器，其中<strong>规则按照它们的置信度和支持度递减优先级排序</strong>，如果当中一组规则具有相同的前件，则选取具有最高置信度的规则代表该集合。<strong>在对新元组分类是，使用满足该元组第一个规则对它进行分类</strong>。分类器还包含一个默认规则，具有最低优先级。</p>
<h4 id="CMAR"><a href="#CMAR" class="headerlink" title="CMAR"></a>CMAR</h4><p>CMAR和CBA在频繁项集挖掘和构建分类器都不同，<strong>CMAR采用FP-growth算法的变形来发现满足最小支持的最小置信度的规则完全集</strong>。构造分类器时，如果新元组X只匹配一个规则，则简单地把规则的类标号给这个元组。如果多个规则满足X，把这些规则形成一个集合S。CBA将集合S中最大置信度的规则的类标号指派给X，而CMAR考虑多个规则。<strong>它根据S的类标号将规则分类，不同组中的规则具有不同的类标号</strong>，然后CMAR使用X2X2卡方度量，根据组中规则的统计相关联找出相关性“最强的”规则组，再把该类标号指派个X元组。这样，<strong>它就考虑了多个规则，不是像CBA一样只考虑一个规则</strong>。CMAR在准确率和复杂的都比CBA更有效一点。</p>
<h4 id="CPAR"><a href="#CPAR" class="headerlink" title="CPAR"></a>CPAR</h4><p>CPAR和CMAR相差不多，<strong>它通过FOIL算法而不是FP-growth来挖掘规</strong>则。同样也将集合S的规则按类分组。然而，CPAR根据期望准确率，使用每组中最好的k个规则预测X元组的类标号，<strong>通过考虑组中最好的k个规则而不是所有规则</strong>。在大数据集上，CPAR和CMAR准确率差不多，但产生的规则要比CMAR少的多。</p>
<h3 id="基于有区别力的频繁模式分类"><a href="#基于有区别力的频繁模式分类" class="headerlink" title="基于有区别力的频繁模式分类"></a>基于有区别力的频繁模式分类</h3><p>如果我们把所有频繁模式都添加到特征空间，可能许多模式是冗余，还可能因特征太多而过分拟合，导致准确率降低。因此，一种好的做法是使用特征选择，删除区别能力较弱的特征，其一般框架步骤(两步法)如下：</p>
<ul>
<li>特征产生：频繁模式的集合F形成候选特征</li>
<li>特征选择： 通过信息增等度量对F进行特征选择，得到选择后的频繁模式FsFs，数据集DD变换成D′D′</li>
<li>学习分类模型：在数据集D′D′建立分类器</li>
</ul>
<p><img src="/2018/11/09/数据挖掘概念与技术/数据挖掘概念与技术笔记（6）：高级分类方法/05.png" alt></p>
<p>为了提高两步法的效率，考虑将步骤1和步骤2合并为一步。即有可能只挖掘具有高度区别能力的频繁模式的集合，而不是完全集。DDPMine算法采用这种方法，它首先把训练数据变换到一个称频繁模式树或FP树的紧凑树结构，然后再该树种搜索有区别能力的模式。</p>
<p>在准确率和效率两个方面，DDPMine都优于最先进的关联分类方法。</p>
<h2 id="k-近邻分类"><a href="#k-近邻分类" class="headerlink" title="k-近邻分类"></a>k-近邻分类</h2><p><strong>对于，k-近邻分类算法，位置元组每次都被指派到它的k个最近邻（距离度量）的多数类</strong>。</p>

          
        
      
    </div>
    
    
    
    
    
    
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Mosbyllc">
            
              <p class="site-author-name" itemprop="name">Mosbyllc</p>
              <p class="site-description motion-element" itemprop="description">Sometimes thing have to fall apart to make way for better things.</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">62</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">74</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/kugua233" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:1499913789@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Recommended reading
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://wulc.me/" title="Wulc" target="_blank">Wulc</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://blog.csdn.net/qq_15262671/article/details/78481922" title="Pinard" target="_blank">Pinard</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://donche.github.io/" title="Donche" target="_blank">Donche</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://xtf615.com/" title="XFT" target="_blank">XFT</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://seawaylee.github.io/" title="Seawaylee" target="_blank">Seawaylee</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-star"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mosbyllc</span>

  
</div>











        







        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  


  

  

</body>
</html>
