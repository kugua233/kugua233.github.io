<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="Mosbyllc" type="application/atom+xml">






<meta name="description" content="Sometimes thing have to fall apart to make way for better things.">
<meta property="og:type" content="website">
<meta property="og:title" content="Mosbyllc">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="Mosbyllc">
<meta property="og:description" content="Sometimes thing have to fall apart to make way for better things.">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Mosbyllc">
<meta name="twitter:description" content="Sometimes thing have to fall apart to make way for better things.">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"right","display":"always","offset":12,"b2t":true,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/3/">





  <title>Mosbyllc</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Mosbyllc</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>

<link href="https://cdn.bootcss.com/KaTeX/0.7.1/katex.min.css" rel="stylesheet">



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/11/数据结构与算法/经典排序总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mosbyllc">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mosbyllc">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/11/数据结构与算法/经典排序总结/" itemprop="url">经典排序总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-11T17:06:11+08:00">
                2018-09-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构与算法/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构与算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  4,486
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  18
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>先看一个排序算法可视化大概了解一下经典的排序算法。</p>
<p><a href="http://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html" target="_blank" rel="noopener">排序算法可视化</a></p>
<h2 id="冒泡排序-BubbleSort"><a href="#冒泡排序-BubbleSort" class="headerlink" title="冒泡排序 BubbleSort"></a>冒泡排序 BubbleSort</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>冒泡排序(bubble sort)：每个回合都从第一个元素开始和它后面的元素比较，如果比它后面的元素更大的话就交换，一直重复，直到这个元素到了它能到达的位置。每次遍历都将剩下的元素中最大的那个放到了序列的“最后”(除去了前面已经排好的那些元素)。注意检测是否已经完成了排序，如果已完成就可以退出了。</p>
<p><img src="/2018/09/11/数据结构与算法/经典排序总结/01.jpg" alt></p>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对第0个到第n-1个数据做同样的工作。这时，最大的数就“浮”到了数组最后的位置上。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ol>
<h3 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h3><p><strong>Python源代码（错误版本）：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(arry)</span>:</span></span><br><span class="line">    n = len(arry)                   <span class="comment">#获得数组的长度</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span>  arry[i] &gt; arry[j] :       <span class="comment">#如果前者比后者大</span></span><br><span class="line">                arry[i],arry[j] = arry[j],arry[i]      <span class="comment">#则交换两者</span></span><br><span class="line">    <span class="keyword">return</span> arry</span><br></pre></td></tr></table></figure>
<blockquote>
<p> 注：上述代码是没有问题的，但是实现却不是冒泡排序，而是选择排序（原理见选择排序），注意冒泡排序的本质是“相邻元素”的顺序交换，而非每次完成一个最小数字的选定。 </p>
</blockquote>
<p> <strong>Python源代码（正确版本）：</strong> </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(arry)</span>:</span></span><br><span class="line">    n = len(arry)                   <span class="comment">#获得数组的长度</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">    <span class="comment"># 这里n-i有可能是最后的下标，如果用j和j+1会超过数组限制，所以应该用j-1和j，把 range改为（1，n-i）</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n-i):     <span class="comment"># 每轮找到最大数值，n-i因为前面已经确定i个最大值，只需比较剩下n-i个</span></span><br><span class="line">            <span class="keyword">if</span>  arry[j<span class="number">-1</span>] &gt; arry[j] :       <span class="comment">#如果前者比后者大</span></span><br><span class="line">                arry[j<span class="number">-1</span>],arry[j] = arry[j],arry[j<span class="number">-1</span>]      <span class="comment">#则交换两者</span></span><br><span class="line">    <span class="keyword">return</span> arry</span><br></pre></td></tr></table></figure>
<p><strong>优化1：</strong></p>
<p>某一趟遍历如果没有数据交换，则说明已经排好序了，因此不用再进行迭代了。用一个标记记录这个状态即可。</p>
<p><strong>Python源代码：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort2</span><span class="params">(ary)</span>:</span></span><br><span class="line">    n = len(ary)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        flag = <span class="literal">False</span>    <span class="comment"># 标记</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n - i):</span><br><span class="line">            <span class="keyword">if</span> ary[j] &lt; ary[j<span class="number">-1</span>]:</span><br><span class="line">                ary[j], ary[j<span class="number">-1</span>] = ary[j<span class="number">-1</span>], ary[j]</span><br><span class="line">                flag = <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 某一趟遍历如果没有数据交换，则说明已经排好序了，因此不用再进行迭代了</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> flag:    </span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> ary</span><br></pre></td></tr></table></figure>
<h2 id="选择排序-SelectionSort"><a href="#选择排序-SelectionSort" class="headerlink" title="选择排序 SelectionSort"></a>选择排序 SelectionSort</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>每个回合都选择出剩下的元素中最大的那个，选择的方法是首先默认第一元素是最大的，如果后面的元素比它大的话，那就更新剩下的最大的元素值，找到剩下元素中最大的之后将它放入到合适的位置就行了。和冒泡排序类似，只是找剩下的元素中最大的方式不同而已。</p>
<p><img src="/2018/09/11/数据结构与算法/经典排序总结/02.jpg" alt></p>
<h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</li>
<li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li>
<li>以此类推，直到所有元素均排序完毕。</li>
</ol>
<h3 id="源代码-1"><a href="#源代码-1" class="headerlink" title="源代码"></a>源代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_sort</span><span class="params">(ary)</span>:</span></span><br><span class="line">    n = len(ary)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,n):</span><br><span class="line">        min = i                             <span class="comment"># 最小元素下标标记，这句是最重要的</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">if</span> ary[j] &lt; ary[min] :</span><br><span class="line">                min = j                     <span class="comment"># 找到最小值的下标</span></span><br><span class="line">        ary[min],ary[i] = ary[i],ary[min]   <span class="comment"># 交换两者</span></span><br><span class="line">    <span class="keyword">return</span> ary</span><br></pre></td></tr></table></figure>
<h2 id="插入排序-Insertion-Sort"><a href="#插入排序-Insertion-Sort" class="headerlink" title="插入排序 Insertion Sort"></a>插入排序 Insertion Sort</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p>插入排序的工作原理是，<strong>对于每个未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入</strong>。 对具有nn个数据元素的序列进行排序时，插入排序需要进行n−1n−1趟插入。进行第j(1≥j≥n−1)j(1≥j≥n−1)趟插入时，前面已经有jj个元素排好序了，第jj趟将aj+1aj+1插入到已经排好序的序列中，这样既可使前面的j+1j+1个数据排好序。</p>
<p><img src="/2018/09/11/数据结构与算法/经典排序总结/03.gif" alt></p>
<h3 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>从第一个元素开始，该元素可以认为已经被排序</li>
<li>取出下一个元素，<strong>在已经排序的元素序列中从后向前扫描</strong></li>
<li><strong>如果被扫描的元素（已排序）大于新元素，将该元素后移一位</strong></li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li>
<li>将新元素插入到该位置后</li>
<li>重复步骤2~5</li>
</ol>
<h3 id="源代码-2"><a href="#源代码-2" class="headerlink" title="源代码"></a>源代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span><span class="params">(ary)</span>:</span></span><br><span class="line">    n = len(ary)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">        pre_key = i - <span class="number">1</span> <span class="comment"># 往前的下标</span></span><br><span class="line">        mark = ary[i] <span class="comment"># 记录当前元素 这两句很重要</span></span><br><span class="line">        <span class="keyword">while</span> pre_key &gt;= <span class="number">0</span> <span class="keyword">and</span> ary[pre_key] &gt; mark:  <span class="comment"># 找到第一个比mark的小的元素或到头时结束</span></span><br><span class="line">            ary[pre_key+<span class="number">1</span>] = ary[pre_key]  <span class="comment"># 往后移一位</span></span><br><span class="line">            pre_key -= <span class="number">1</span></span><br><span class="line">        ary[pre_key+<span class="number">1</span>] = mark   <span class="comment"># 找到并插入（想象一个简单的例子）</span></span><br><span class="line">    <span class="keyword">return</span> ary</span><br></pre></td></tr></table></figure>
<h2 id="希尔排序-ShellSort"><a href="#希尔排序-ShellSort" class="headerlink" title="希尔排序 ShellSort"></a>希尔排序 ShellSort</h2><h3 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h3><p>希尔排序，也称递减增量排序算法，实质是<strong>分组插入排序</strong>。由 Donald Shell 于1959年提出。希尔排序是非稳定排序算法。</p>
<p>希尔排序的基本思想是：先将整个待排元素序列分割成若干个子序列（由相隔某个“增量”的元素组成的）<strong>分别进行直接插入排序</strong>，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。因为直接插入排序在元素基本有序的情况下（接近最好情况），效率是很高的，因此希尔排序在时间效率上比前两种方法有较大提高。</p>
<p>n=10的一个数组49, 38, 65, 97, 26, 13, 27, 49, 55, 4为例</p>
<p><strong>第一次 gap = 10/2 = 5</strong></p>
<p>49 38 65 97 26 13 27 49 55 4</p>
<p>1A 1B 2A 2B 3A 3B 4A 4B 5A 5B</p>
<blockquote>
<p> 1A, 1B, 2A, 2B等为分组标记，数字相同的表示在同一组，同组进行直接插入排序 </p>
</blockquote>
<p><strong>第二次 gap = 5 / 2 = 2</strong>，排序后</p>
<p>13 27 49 55 4 49 38 65 97 26</p>
<p>1A 1B 1C 1D 1E 2A 2B 2C 2D 2E</p>
<p><strong>第三次 gap = 2 / 2 = 1</strong></p>
<p>4 26 13 27 38 49 49 55 97 65</p>
<p>1A 1B 1C 1D 1E 1F 1G 1H 1I 1J</p>
<p><strong>第四次 gap = 1 / 2 = 0</strong> 排序完成得到数组：</p>
<p>4 13 26 27 38 49 49 55 65 97</p>
<h3 id="源代码-3"><a href="#源代码-3" class="headerlink" title="源代码"></a>源代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shell_sort</span><span class="params">(ary)</span>:</span></span><br><span class="line">        count = len(ary)</span><br><span class="line">        gap = round(count/<span class="number">2</span>)   <span class="comment"># round精度不够可以考虑用math.floor()  </span></span><br><span class="line">        <span class="comment"># 双杠用于整除（向下取整），在python直接用 “/” 得到的永远是浮点数，用round()得到四舍五入值</span></span><br><span class="line">        <span class="keyword">while</span> gap &gt;= <span class="number">1</span>: <span class="comment"># 不要忘了这句</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(gap, count): <span class="comment"># 前面的gap间隔数组视为已排好序，每次插入到排好序数组中</span></span><br><span class="line">                cur = ary[i] </span><br><span class="line">                preindex = i -gap <span class="comment"># 往前的下标</span></span><br><span class="line">                <span class="keyword">while</span> preindex &gt;= <span class="number">0</span> <span class="keyword">and</span> ary[preindex] &gt; cur:  <span class="comment"># 到这里与插入排序一样了</span></span><br><span class="line">                    ary[preindex+gap] = ary[preindex]  <span class="comment"># 往后移</span></span><br><span class="line">                    preindex -= gap</span><br><span class="line">                ary[preindex+gap] = cur  <span class="comment"># 插入</span></span><br><span class="line">            gap = round(gap/<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> ary</span><br></pre></td></tr></table></figure>
<h2 id="归并排序-Merge-Sort"><a href="#归并排序-Merge-Sort" class="headerlink" title="归并排序 Merge Sort"></a>归并排序 Merge Sort</h2><h3 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h3><p>归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。</p>
<p>首先考虑下如何将将二个有序数列合并。这个非常简单，只要从比较二个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可。</p>
<p><img src="/2018/09/11/数据结构与算法/经典排序总结/04.gif" alt></p>
<h3 id="源代码-4"><a href="#源代码-4" class="headerlink" title="源代码"></a>源代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 归并排序</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(self, ary)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> len(ary) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> ary</span><br><span class="line"></span><br><span class="line">        median = int(len(ary)/<span class="number">2</span>)    <span class="comment"># 二分分解</span></span><br><span class="line">        left = self.merge_sort(ary[:median]) <span class="comment"># 先自调用，最里一层只有一个单元素</span></span><br><span class="line">        right = self.merge_sort(ary[median:])</span><br><span class="line">        <span class="keyword">return</span> self.merge(left, right)    <span class="comment"># 合并成有序数组</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, left, right)</span>:</span></span><br><span class="line">     <span class="string">'''合并操作，将两个有序数组left[]和right[]合并成一个大的有序数组'''</span></span><br><span class="line">        res = []</span><br><span class="line">        i = j = k = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; len(left) <span class="keyword">and</span> j &lt; len(right)):</span><br><span class="line">            <span class="keyword">if</span> left[i] &lt; right[j]:</span><br><span class="line">                res.append(left[i])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(right[j])</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        res = res + left[i:] + right[j:]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h2 id="快速排序-QuickSort"><a href="#快速排序-QuickSort" class="headerlink" title="快速排序 QuickSort"></a>快速排序 QuickSort</h2><h3 id="介绍-5"><a href="#介绍-5" class="headerlink" title="介绍"></a>介绍</h3><p>快速排序是图灵奖得主C.R.A Hoare于1960年提出的一种划分交换排序。它采用了一种分治的策略，通常称其为分治法。分治法的基本思想是：将原问题分解为若干个规模更小但结构与原问题相似的子问题。递归地解这些子问题，然后将这些子问题组合为原问题的解。</p>
<p><img src="/2018/09/11/数据结构与算法/经典排序总结/05.gif" alt></p>
<p><img src="/2018/09/11/数据结构与算法/经典排序总结/06.gif" alt></p>
<p>以一个数组作为示例，取区间第一个数为基准数。</p>
<blockquote>
<p>0 1 2 3 4 5 6 7 8 9</p>
<p>72 6 57 88 60 42 83 73 48 85</p>
</blockquote>
<p>初始时，i = 0; j = 9; X = a[i] = 72</p>
<p>由于已经将a[0]中的数保存到X中，可以理解成在数组a[0]上挖了个坑，可以将其它数据填充到这来。</p>
<p>从j开始向前找一个比X小或等于X的数。当j=8，符合条件，将a[8]挖出再填到上一个坑a[0]中。a[0]=a[8]; i++; 这样一个坑a[0]就被搞定了，但又形成了一个新坑a[8]，这怎么办了？简单，再找数字来填a[8]这个坑。这次从i开始向后找一个大于X的数，当i=3，符合条件，将a[3]挖出再填到上一个坑中a[8]=a[3]; j–;</p>
<p>数组变为：</p>
<blockquote>
<p>0 1 2 3 4 5 6 7 8 9</p>
<p>48 6 57 88 60 42 83 73 88 85</p>
</blockquote>
<p>i = 3; j = 7; X=72</p>
<p>再重复上面的步骤，<strong>先从后向前找，再从前向后找。</strong></p>
<h3 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤"></a>步骤</h3><p>利用分治法可将快速排序分为三步：</p>
<ol>
<li>从数列中挑出一个元素作为“基准”（pivot）。</li>
<li>分区过程，将比基准数大的放到右边，小于或等于它的数都放到左边。这个操作称为“分区操作”，分区操作结束后，基准元素所处的位置就是最终排序后它的位置</li>
<li>再对“基准”左右两边的子集不断重复第一步和第二步，直到所有子集只剩下一个元素为止。</li>
</ol>
<h3 id="源代码-5"><a href="#源代码-5" class="headerlink" title="源代码"></a>源代码</h3><h4 id="版本一"><a href="#版本一" class="headerlink" title="版本一"></a>版本一</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(self, ary)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> qsort(ary, <span class="number">0</span>, len(ary)<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">qsort</span><span class="params">(self, ary, start, end)</span>:</span>  <span class="comment"># ary为原数组，其他为下标</span></span><br><span class="line">    <span class="keyword">if</span> start &lt; end: <span class="comment"># 这句不能忘！！！</span></span><br><span class="line">        left = start</span><br><span class="line">        right = end</span><br><span class="line">        key = ary[start]</span><br><span class="line">        <span class="keyword">while</span> left &lt; right: <span class="comment"># 这里都没有等号，left=right是最后key赋值</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> ary[right] &gt;= key: <span class="comment"># 核心</span></span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> left &lt; right:    <span class="comment">#说明打破while循环的原因是ary[right] &lt;= key</span></span><br><span class="line">                ary[left] = ary[right] <span class="comment"># 填坑</span></span><br><span class="line">                left += <span class="number">1</span> <span class="comment"># 换位继续</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> ary[left] &lt; key:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> left &lt; right:    <span class="comment">#说明打破while循环的原因是ary[left] &gt;= key</span></span><br><span class="line">                ary[right] = ary[left]</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">        ary[left] = key    <span class="comment">#此时，left=right，用key来填坑</span></span><br><span class="line">        self.qsort(ary, start, left<span class="number">-1</span>)  <span class="comment"># 注意这里的下标顺序</span></span><br><span class="line">        self.qsort(ary, left+<span class="number">1</span>, end)</span><br><span class="line">    <span class="keyword">return</span> ary</span><br></pre></td></tr></table></figure>
<h4 id="版本二"><a href="#版本二" class="headerlink" title="版本二"></a>版本二</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quickSort</span><span class="params">(array)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(array)&lt;<span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> array</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        base = array[<span class="number">0</span>] <span class="comment"># 元素，return时要变为列表</span></span><br><span class="line">        <span class="comment">#小于等于基准值的元素组成的数组</span></span><br><span class="line">        less = [i <span class="keyword">for</span> i <span class="keyword">in</span> array[<span class="number">1</span>:] <span class="keyword">if</span> i&lt;=base]</span><br><span class="line">        <span class="comment">#大于基准值的元素组成的数组</span></span><br><span class="line">        greater = [i <span class="keyword">for</span> i <span class="keyword">in</span> array[<span class="number">1</span>:] <span class="keyword">if</span> i&gt; base]</span><br><span class="line">        <span class="comment">#将数组串起来</span></span><br><span class="line">        <span class="keyword">return</span> quickSort(less)+[base]+quickSort(greater)</span><br><span class="line"></span><br><span class="line">print(quickSort([<span class="number">45</span>, <span class="number">26</span>, <span class="number">34</span>, <span class="number">2</span>, <span class="number">888</span>, <span class="number">54</span>, <span class="number">23</span>, <span class="number">45</span>, <span class="number">76</span>, <span class="number">2</span>]))</span><br></pre></td></tr></table></figure>
<h2 id="堆排序-HeapSort"><a href="#堆排序-HeapSort" class="headerlink" title="堆排序 HeapSort"></a>堆排序 HeapSort</h2><h3 id="介绍-6"><a href="#介绍-6" class="headerlink" title="介绍"></a>介绍</h3><p>堆排序在 top K 问题中使用比较频繁。堆排序是采用二叉堆的数据结构来实现的，虽然实质上还是一维数组。堆（二叉堆）可以视为一棵完全的二叉树，完全二叉树的一个“优秀”的性质是，除了最底层之外，每一层都是满的，这使得堆可以利用数组来表示（普通的一般的二叉树通常用链表作为基本容器表示），每一个结点对应数组中的一个元素。</p>
<p>如下图，是一个堆和数组的相互关系，<strong>可看做堆的初始化</strong></p>
<p><img src="/2018/09/11/数据结构与算法/经典排序总结/07.jpg" alt></p>
<p>对于给定的某个结点的下标 i，可以很容易的计算出这个结点的父结点、孩子结点的下标：</p>
<ul>
<li>Parent(i) = floor(i/2)，i 的父节点下标</li>
<li>Left(i) = 2i，i 的左子节点下标</li>
<li>Right(i) = 2i + 1，i 的右子节点下标</li>
</ul>
<p><img src="/2018/09/11/数据结构与算法/经典排序总结/08.jpg" alt></p>
<p>二叉堆具有以下性质：</p>
<ol>
<li>父节点的键值总是大于或等于（小于或等于）任何一个子节点的键值。</li>
<li>每个节点的左右子树都是一个二叉堆（都是最大堆或最小堆）。</li>
</ol>
<p><img src="/2018/09/11/数据结构与算法/经典排序总结/09.gif" alt></p>
<p><img src="/2018/09/11/数据结构与算法/经典排序总结/10.gif" alt></p>
<h3 id="步骤-4"><a href="#步骤-4" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>构造最大堆（Build_Max_Heap）<strong>自底向上</strong>：若数组下标范围为0~n，<strong>考虑到单独一个元素是大根堆，则从下标n/2开始的元素均为大根堆</strong>。<strong>于是只要从n/2-1开始(最后一个非叶子节点开始)</strong>，<strong>分别与左孩子和右孩子比较大小，如果最大，则不用调整，否则和孩子中的值最大的一个交换位置，若交换之后还比此节点的孩子要小，继续向下交换（这里是自顶向下）</strong> 。并向前依次构造大根堆，这样就能保证，构造到某个节点时，它的左右子树都已经是大根堆。</li>
<li>堆排序（HeapSort）：由于堆是用数组模拟的。<strong>得到一个最大根堆后</strong>，数组内部并不是有序的。因此需要将堆化数组有序化。<strong>思想是总是移除根节点（用最后一个元素来填补空缺）</strong>，并做最大堆调整的递归运算。<strong>第一次将heap[0]与heap[n-1]交换，再对heap[0…n-2]做最大堆调整</strong>。第二次将heap[0]与heap[n-2]交换，再对heap[0…n-3]做最大堆调整。重复该操作直至heap[0]和heap[1]交换。由于每次都是将最大的数并入到后面的有序区间，故操作完后整个数组就是有序的了。</li>
<li>最大堆调整（Max_Heapify）：该方法是提供给上述两个过程调用的。目的是将堆的末端子节点作调整，使得子节点永远小于父节点 。</li>
</ol>
<p><strong>构造最大堆：</strong>先自底向上，再自顶向下</p>
<p><img src="/2018/09/11/数据结构与算法/经典排序总结/11.png" alt></p>
<p> <strong>调整最大堆</strong>：交换之后，被交换的节点从顶向下调整，调完继续交换，依次递归。 </p>
<p><img src="/2018/09/11/数据结构与算法/经典排序总结/12.png" alt></p>
<h3 id="源代码-6"><a href="#源代码-6" class="headerlink" title="源代码"></a>源代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_sort</span><span class="params">(ary)</span>:</span></span><br><span class="line">    n = len(ary)</span><br><span class="line">    first = int(n/<span class="number">2</span><span class="number">-1</span>)    <span class="comment">#最后一个非叶子节点</span></span><br><span class="line">    <span class="keyword">for</span> start <span class="keyword">in</span> range(first,<span class="number">-1</span>,<span class="number">-1</span>):    <span class="comment">#构建最大堆</span></span><br><span class="line">        max_heapify(ary,start,n<span class="number">-1</span>)</span><br><span class="line">    <span class="comment"># range(n-1,0,-1)因为0时不用和顶点自己交换</span></span><br><span class="line">    <span class="keyword">for</span> end <span class="keyword">in</span> range(n<span class="number">-1</span>,<span class="number">0</span>,<span class="number">-1</span>): <span class="comment">#堆排，将最大跟堆转换成有序数组，</span></span><br><span class="line">        ary[end],ary[<span class="number">0</span>] = ary[<span class="number">0</span>], ary[end]    <span class="comment">#将根节点元素与最后叶子节点进行互换，取出最大根节点元素，对剩余节点重新构建最大堆</span></span><br><span class="line">        max_heapify(ary,<span class="number">0</span>,end<span class="number">-1</span>)    <span class="comment">#因为end上面取的是n-1，故而这里直接放end-1，相当于忽略了最后最大根节点元素ary[n-1]</span></span><br><span class="line">    <span class="keyword">return</span> ary</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#最大堆调整：将堆的末端子节点作调整，使得子节点永远小于父节点</span></span><br><span class="line"><span class="comment">#start为当前需要调整最大堆的位置，end为调整边界</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max_heapify</span><span class="params">(ary,start,end)</span>:</span></span><br><span class="line">    root = start</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:  <span class="comment"># 记住这一句</span></span><br><span class="line">        child = root * <span class="number">2</span> + <span class="number">1</span>    <span class="comment">#调整节点的子节点,这里要注意数值下标从0开始，左节点为root * 2 + 1，这里都是下标表示</span></span><br><span class="line">        <span class="keyword">if</span> child &gt; end: <span class="comment"># 左子树超过边界，右子树肯定也超了</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> child + <span class="number">1</span> &lt;= end <span class="keyword">and</span> ary[child] &lt; ary[child+<span class="number">1</span>]: <span class="comment">#两个都没超，选数值大的下标</span></span><br><span class="line">            child = child + <span class="number">1</span>   <span class="comment">#取较大的子节点</span></span><br><span class="line">        <span class="comment"># 满足父节点比子节点小才叫交换</span></span><br><span class="line">        <span class="keyword">if</span> ary[root] &lt; ary[child]:    <span class="comment"># 子节点成为父节点；child为左子树或上一步较大的子节点</span></span><br><span class="line">            ary[root], ary[child] = ary[child], ary[root]    <span class="comment">#交换</span></span><br><span class="line">            root = child <span class="comment"># 调整时候要自顶向下继续调整，不要忘了这一句</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<h2 id="时空复杂度总结"><a href="#时空复杂度总结" class="headerlink" title="时空复杂度总结"></a>时空复杂度总结</h2><p><img src="/2018/09/11/数据结构与算法/经典排序总结/13.png" alt></p>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><blockquote>
<p>＂快些以O(nlog2n)O(nlog2n)的速度归队＂</p>
</blockquote>
<p>即快，希，归，堆都是O(nlog2n)O(nlog2n)，其他都是O(n2)O(n2)，基数排序例外，是O(d(n+rd))O(d(n+rd))</p>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><ul>
<li>快排O(log2n)O(log2n)</li>
<li>归并O(n)O(n)</li>
<li>基数O(rd)O(rd)</li>
<li>其他O(1)O(1)</li>
</ul>
<h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><blockquote>
<p>＂心情不稳定，快些找一堆朋友聊天吧＂</p>
</blockquote>
<p>即不稳定的有：快，希，堆</p>
<h3 id="其他性质"><a href="#其他性质" class="headerlink" title="其他性质"></a>其他性质</h3><ul>
<li>直接插入排序，初始基本有序情况下，是O(n)O(n)</li>
<li>冒泡排序，初始基本有序情况下，是O(n)O(n)</li>
<li>快排在初始状态越差的情况下算法效果越好．</li>
<li>堆排序适合记录数量比较大的时候，从n个记录中选择k个记录．</li>
<li>经过一趟排序，元素可以在它最终的位置的有：交换类的（冒泡，快排），选择类的（简单选择，堆）</li>
<li>比较次数与初始序列无关的是：简单选择与折半插入</li>
<li>排序趟数与原始序列有关的是：交换类的（冒泡和快排）</li>
</ul>

          
        
      
    </div>
    
    
    
    
    
    
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/07/数据结构与算法/剑指offer解题_Python版/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mosbyllc">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mosbyllc">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/07/数据结构与算法/剑指offer解题_Python版/" itemprop="url">剑指offer解题_Python版</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-07T17:06:11+08:00">
                2018-09-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构与算法/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构与算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  14,568
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  67
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-二维数组中的查找"><a href="#1-二维数组中的查找" class="headerlink" title="1.二维数组中的查找"></a>1.二维数组中的查找</h3><p><strong>题目：</strong> 在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p><strong>思路：</strong>遍历每一行，查找该元素是否在该行之中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># array 二维列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Find</span><span class="params">(self, target, array)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> array:</span><br><span class="line">            <span class="keyword">if</span> target <span class="keyword">in</span> i:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h3 id="2-替换空格"><a href="#2-替换空格" class="headerlink" title="2.替换空格"></a>2.替换空格</h3><p><strong>题目：</strong> 请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
<p><strong>思路：</strong>利用字符串中的replace直接替换即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># s 源字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replaceSpace</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> s.replace(<span class="string">' '</span>,<span class="string">'%20'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="3-从尾到头打印链表"><a href="#3-从尾到头打印链表" class="headerlink" title="3.从尾到头打印链表"></a>3.从尾到头打印链表</h3><p><strong>题目：</strong>输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。</p>
<p><strong>思路：</strong>将链表中的值记录到list之中，然后进行翻转list。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回从尾部到头部的列表值序列，例如[1,2,3]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printListFromTailToHead</span><span class="params">(self, listNode)</span>:</span></span><br><span class="line">        l = list()</span><br><span class="line">        <span class="keyword">while</span> listNode:</span><br><span class="line">            l.append(listNode.val)</span><br><span class="line">            listNode=listNode.next</span><br><span class="line">        <span class="keyword">return</span> l[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="4-重建二叉树-flag"><a href="#4-重建二叉树-flag" class="headerlink" title="4.重建二叉树(flag)"></a>4.重建二叉树(flag)</h3><p><strong>题目：</strong>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>
<p><strong>题解：</strong>首先前序遍历的第一个元素为二叉树的根结点，<strong>那么便能够在中序遍历之中找到根节点，那么在根结点左侧则是左子树；在根结点右侧，便是右子树</strong>。然后在递归遍历左子树和右子树。这里要注意一点，<strong>pre的左右子树分割长度与中序的左右子树分割长度一致</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回构造的TreeNode根节点</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reConstructBinaryTree</span><span class="params">(self, pre, tin)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(pre)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> len(pre)==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> TreeNode(pre[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            flag = TreeNode(pre[<span class="number">0</span>])</span><br><span class="line">            <span class="comment">#pre的左右子树分割长度与中序的左右子树分割长度一致。</span></span><br><span class="line">            flag.left = self.reConstructBinaryTree(pre[<span class="number">1</span>:tin.index(pre[<span class="number">0</span>])+<span class="number">1</span>],tin[:tin.index(pre[<span class="number">0</span>])])  </span><br><span class="line">            flag.right = self.reConstructBinaryTree(pre[tin.index(pre[<span class="number">0</span>])+<span class="number">1</span>:],tin[tin.index(pre[<span class="number">0</span>])+<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">return</span> flag</span><br></pre></td></tr></table></figure>
<h3 id="5-用两个栈实现队列-flag"><a href="#5-用两个栈实现队列-flag" class="headerlink" title="5.用两个栈实现队列(flag)"></a>5.用两个栈实现队列(flag)</h3><p><strong>题目：</strong>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p>
<p><strong>题解：</strong>申请两个栈Stack1和Stack2，Stack1当作输入，Stack2当作pop。<strong>当Stack2空的时候</strong>，将Stack1进行反转，并且输入到Stack2。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.Stack1=[]</span><br><span class="line">        self.Stack2=[]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        self.Stack1.append(node)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># return xx</span></span><br><span class="line">        <span class="keyword">if</span> self.Stack2==[]:</span><br><span class="line">            <span class="keyword">while</span> self.Stack1:</span><br><span class="line">                self.Stack2.append(self.Stack1.pop())</span><br><span class="line">            <span class="keyword">return</span> self.Stack2.pop()</span><br><span class="line">        <span class="keyword">return</span> self.Stack2.pop()</span><br></pre></td></tr></table></figure>
<h3 id="6-旋转数组的最小数字"><a href="#6-旋转数组的最小数字" class="headerlink" title="6.旋转数组的最小数字"></a>6.旋转数组的最小数字</h3><p><strong>题目：</strong>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumberInRotateArray</span><span class="params">(self, rotateArray)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> rotateArray:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            <span class="keyword">return</span> min(rotateArray)</span><br></pre></td></tr></table></figure>
<h3 id="7-斐波那契数列-flag"><a href="#7-斐波那契数列-flag" class="headerlink" title="7.斐波那契数列(flag)"></a>7.斐波那契数列(flag)</h3><p><strong>题目：</strong>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。n&lt;=39。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Fibonacci</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">1</span> <span class="keyword">or</span> n==<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        a,b=<span class="number">1</span>,<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-2</span>):</span><br><span class="line">            a,b=b,a+b</span><br><span class="line">        <span class="keyword">return</span> b</span><br></pre></td></tr></table></figure>
<h3 id="8-跳台阶"><a href="#8-跳台阶" class="headerlink" title="8.跳台阶"></a>8.跳台阶</h3><p><strong>题目：</strong>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p>
<p><strong>题解：</strong>ans[n]=ans[n-1]+ans[n-2]</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jumpFloor</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> number:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> number==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> number==<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        a,b=<span class="number">1</span>,<span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(number<span class="number">-2</span>):</span><br><span class="line">            a,b=b,a+b</span><br><span class="line">        <span class="keyword">return</span> b</span><br></pre></td></tr></table></figure>
<h3 id="9-变态跳台阶"><a href="#9-变态跳台阶" class="headerlink" title="9.变态跳台阶"></a>9.变态跳台阶</h3><p><strong>题目：</strong>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
<p><strong>题解：</strong>ans[n]=ans[n-1]+ans[n-2]+ans[n-3]+…+ans[n-n]，ans[n-1]=ans[n-2]+ans[n-3]+…+ans[n-n]，ans[n]=2*ans[n-1]。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jumpFloorII</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> number:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> number==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> number==<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>**(number<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>
<h3 id="10-矩形覆盖"><a href="#10-矩形覆盖" class="headerlink" title="10.矩形覆盖"></a>10.矩形覆盖</h3><p><strong>题目：</strong>我们可以用2<em>1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2</em>1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p>
<p><strong>题解：</strong>新增加的小矩阵竖着放，则方法与n-1时相同，新增加的小矩阵横着放，则方法与n-2时相同，于是f(n)=f(n-1)+f(n-2)。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rectCover</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> number:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> number==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> number==<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        a,b=<span class="number">1</span>,<span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(number<span class="number">-2</span>):</span><br><span class="line">            a,b=b,a+b</span><br><span class="line">        <span class="keyword">return</span> b</span><br></pre></td></tr></table></figure>
<h3 id="11-二进制中1的个数-flag"><a href="#11-二进制中1的个数-flag" class="headerlink" title="11.二进制中1的个数(flag)"></a>11.二进制中1的个数(flag)</h3><p><strong>题目：</strong>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p>
<p><strong>题解：</strong>每次进行右移一位，然后与1进行相与，如果是1则进行加1。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 向右移1位可以看成除以2，向左移一位可以看成乘以2。移动n位可以看成乘以或者除以2的n次方。</span></span><br><span class="line"><span class="comment"># 负数原码（int整型用32位表示）所有位取反码然后+1得到补码；正数的补码为其自身</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>  <span class="comment">#转为字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">NumberOf1</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n&gt;<span class="number">0</span>:</span><br><span class="line">            a=bin(n).count(<span class="string">'1'</span>)</span><br><span class="line">            <span class="keyword">return</span> a</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            a=bin(<span class="number">2</span>**<span class="number">32</span>+n).count(<span class="string">'1'</span>)</span><br><span class="line">            <span class="keyword">return</span> a</span><br><span class="line">            </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span> <span class="comment">#每次移一位，看此为是否为1，负数的表示内部已经是补码了</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">NumberOf1</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">            count += (n &gt;&gt; i) &amp; <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>
<h3 id="12-数值的整次方"><a href="#12-数值的整次方" class="headerlink" title="12.数值的整次方"></a>12.数值的整次方</h3><p><strong>题目：</strong>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Power</span><span class="params">(self, base, exponent)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        ans=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,abs(exponent)):</span><br><span class="line">            ans=ans*base</span><br><span class="line">        <span class="keyword">if</span> exponent&gt;<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>/ans</span><br></pre></td></tr></table></figure>
<h3 id="13-调整数组顺序使奇数位于偶数前面"><a href="#13-调整数组顺序使奇数位于偶数前面" class="headerlink" title="13.调整数组顺序使奇数位于偶数前面"></a>13.调整数组顺序使奇数位于偶数前面</h3><p><strong>题目：</strong>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>
<p><strong>题解：</strong>申请奇数数组和偶数数组，分别存放奇数值和偶数值，数组相加便为结果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reOrderArray</span><span class="params">(self, array)</span>:</span></span><br><span class="line">        array=list(array)</span><br><span class="line">        a=[]</span><br><span class="line">        b=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> array:</span><br><span class="line">            <span class="keyword">if</span> i%<span class="number">2</span>==<span class="number">1</span>:</span><br><span class="line">                a.append(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                b.append(i)</span><br><span class="line">        <span class="keyword">return</span> a+b</span><br></pre></td></tr></table></figure>
<h3 id="14-链表中倒数第K个节点"><a href="#14-链表中倒数第K个节点" class="headerlink" title="14.链表中倒数第K个节点"></a>14.链表中倒数第K个节点</h3><p><strong>题目：</strong>输入一个链表，输出该链表中倒数第k个结点。</p>
<p><strong>题解：</strong>快慢指针。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindKthToTail</span><span class="params">(self, head, k)</span>:</span></span><br><span class="line">        l=[]</span><br><span class="line">        count=<span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        a1=head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> a1:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                a1=a1.next</span><br><span class="line">        a2=head</span><br><span class="line">        <span class="keyword">while</span> a1:</span><br><span class="line">            a1=a1.next</span><br><span class="line">            a2=a2.next</span><br><span class="line">        <span class="keyword">return</span> a2</span><br></pre></td></tr></table></figure>
<h3 id="15-反转链表-flag"><a href="#15-反转链表-flag" class="headerlink" title="15.反转链表(flag)"></a>15.反转链表(flag)</h3><p><strong>题目：</strong>输入一个链表，反转链表后，输出新链表的表头。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回ListNode</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ReverseList</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead.next:</span><br><span class="line">            <span class="keyword">return</span> pHead</span><br><span class="line">        Pre=<span class="literal">None</span></span><br><span class="line">        Next=<span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> pHead:</span><br><span class="line">            Next=pHead.next <span class="comment"># 暂存当前节点的下一个节点信息</span></span><br><span class="line">            pHead.next=Pre  <span class="comment"># 断开链表, 反转节点, 这两句都是为了保护链表断开不丢失next的指向</span></span><br><span class="line">            Pre=pHead</span><br><span class="line">            pHead=Next</span><br><span class="line">        <span class="keyword">return</span> Pre</span><br></pre></td></tr></table></figure>
<h3 id="16-合并两个排序的列表"><a href="#16-合并两个排序的列表" class="headerlink" title="16.合并两个排序的列表"></a>16.合并两个排序的列表</h3><p><strong>题目：</strong>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回合并后列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Merge</span><span class="params">(self, pHead1, pHead2)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead1 <span class="keyword">and</span> <span class="keyword">not</span> pHead2:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead1 <span class="keyword">or</span> <span class="keyword">not</span> pHead2:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> pHead1:</span><br><span class="line">                <span class="keyword">return</span> pHead2</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> pHead1</span><br><span class="line">        merge=ListNode(<span class="number">0</span>)<span class="comment"># 新一个头结点数值为x的链表</span></span><br><span class="line">        p=merge    <span class="comment">#返回时的指向头结点的指针</span></span><br><span class="line">        <span class="keyword">while</span> pHead1 <span class="keyword">and</span> pHead2:</span><br><span class="line">            <span class="keyword">if</span> pHead1.val&lt;=pHead2.val:</span><br><span class="line">                merge.next=pHead1</span><br><span class="line">                pHead1=pHead1.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                merge.next=pHead2</span><br><span class="line">                pHead2=pHead2.next</span><br><span class="line">            merge=merge.next</span><br><span class="line">        <span class="keyword">while</span> pHead1:</span><br><span class="line">            merge.next=pHead1</span><br><span class="line">            pHead1=pHead1.next</span><br><span class="line">            merge=merge.next</span><br><span class="line">        <span class="keyword">while</span> pHead2:</span><br><span class="line">            merge.next=pHead2</span><br><span class="line">            pHead2=pHead2.next</span><br><span class="line">            merge=merge.next</span><br><span class="line">        <span class="keyword">return</span> p.next</span><br></pre></td></tr></table></figure>
<h3 id="17-树的子结构-flag"><a href="#17-树的子结构-flag" class="headerlink" title="17.树的子结构(flag)"></a>17.树的子结构(flag)</h3><p><strong>题目：</strong>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）。</p>
<p><strong>题解：</strong>递归；或者将树转变为中序序列，然后转变为str类型，最后判断是否包含。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">HasSubtree</span><span class="params">(self, pRoot1, pRoot2)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot1 <span class="keyword">or</span> <span class="keyword">not</span> pRoot2:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        root1 = pRoot1</span><br><span class="line">        root2 = pRoot2</span><br><span class="line">        result = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> root1.val==root2.val:  <span class="comment"># HasSubtree条件出口，满足根节点相同才继续判断子树结构</span></span><br><span class="line">            result = self.hastree(root1,root2)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> result:</span><br><span class="line">            result = self.HasSubtree(root1.left,root2)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> result:</span><br><span class="line">            result = self.HasSubtree(root1.right,root2)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hastree</span><span class="params">(self,root1,root2)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root2==<span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> root1==<span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> root1.val==root2.val:</span><br><span class="line">            <span class="keyword">return</span> self.hastree(root1.left,root2.left) <span class="keyword">and</span> self.hastree(root1.right,root2.right)</span><br><span class="line">        <span class="keyword">if</span> root1.val!=root2.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h3 id="18-二叉树的镜像"><a href="#18-二叉树的镜像" class="headerlink" title="18.二叉树的镜像"></a>18.二叉树的镜像</h3><p><strong>题目：</strong> 操作给定的二叉树，将其变换为源二叉树的镜像。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回镜像树的根节点</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Mirror</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            root.left,root.right=root.right,root.left</span><br><span class="line">            self.Mirror(root.left)</span><br><span class="line">            self.Mirror(root.right)</span><br></pre></td></tr></table></figure>
<h3 id="19-顺时针打印矩阵-flag"><a href="#19-顺时针打印矩阵-flag" class="headerlink" title="19.顺时针打印矩阵(flag)"></a>19.顺时针打印矩阵(flag)</h3><p><strong>题目:</strong> 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># matrix类型为二维列表，需要返回列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printMatrix</span><span class="params">(self, matrix)</span>:</span></span><br><span class="line">        rows=len(matrix)</span><br><span class="line">        cols=len(matrix[<span class="number">0</span>])</span><br><span class="line">        l=[]</span><br><span class="line">        <span class="keyword">if</span> rows==<span class="number">1</span> <span class="keyword">and</span> cols==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> [matrix[<span class="number">0</span>][<span class="number">0</span>]]</span><br><span class="line">        left,right, up, down = <span class="number">0</span>,cols<span class="number">-1</span>,<span class="number">0</span>,rows<span class="number">-1</span>  <span class="comment">#这个是数组下标</span></span><br><span class="line">        <span class="keyword">while</span> left&lt;=right <span class="keyword">and</span> up&lt;=down:    </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(left,right+<span class="number">1</span>):     <span class="comment">#range函数接收参数从小到大，大的数值不计入</span></span><br><span class="line">                l.append(matrix[up][i])</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(up+<span class="number">1</span>,down+<span class="number">1</span>):</span><br><span class="line">                l.append(matrix[j][right])</span><br><span class="line">            <span class="keyword">if</span> down-up&gt;=<span class="number">1</span>:   <span class="comment">#相等时为剩余单行</span></span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(left,right)[::<span class="number">-1</span>]:   <span class="comment">#这里注意逆序的数组下标</span></span><br><span class="line">                    l.append(matrix[down][k])</span><br><span class="line">            <span class="keyword">if</span> right-left&gt;=<span class="number">1</span>:   <span class="comment">#相等时为剩余单列</span></span><br><span class="line">                <span class="keyword">for</span> p <span class="keyword">in</span> range(up+<span class="number">1</span>,down)[::<span class="number">-1</span>]:</span><br><span class="line">                    l.append(matrix[p][left])</span><br><span class="line">            up=up+<span class="number">1</span></span><br><span class="line">            down=down<span class="number">-1</span></span><br><span class="line">            left=left+<span class="number">1</span></span><br><span class="line">            right=right<span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> l</span><br></pre></td></tr></table></figure>
<h3 id="20-包含Min函数的栈-flag"><a href="#20-包含Min函数的栈-flag" class="headerlink" title="20.包含Min函数的栈(flag)"></a>20.包含Min函数的栈(flag)</h3><p><strong>题目：</strong>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.stack=[]</span><br><span class="line">        self.minstack=[]      <span class="comment">#pop()删除列表的最后一个元素,[-1]获取最后一个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, node)</span>:</span>     <span class="comment">#最小栈存储 整个原栈的最小元素，若最小元素在原栈删除，则也要删除最小栈</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.minstack <span class="keyword">or</span> node&lt;self.minstack[<span class="number">-1</span>]:   </span><br><span class="line">            self.minstack.append(node)</span><br><span class="line">        self.stack.append(node)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.stack:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">elif</span> self.stack[<span class="number">-1</span>]==self.minstack[<span class="number">-1</span>]:</span><br><span class="line">            self.minstack.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.stack.pop()</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.stack[<span class="number">-1</span>]</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">min</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.minstack[<span class="number">-1</span>]</span><br><span class="line">        <span class="comment"># write code here</span></span><br></pre></td></tr></table></figure>
<h3 id="21-栈的压入弹出序列-flag"><a href="#21-栈的压入弹出序列-flag" class="headerlink" title="21.栈的压入弹出序列(flag)"></a>21.栈的压入弹出序列(flag)</h3><p><strong>题目：</strong>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）。</p>
<p><strong>题解：</strong>构建压入和活动栈，只有处于压入栈栈顶或者活动栈内才可弹出；或者新构建一个中间栈，来模拟栈的输入和栈的输出，比对输入结果和输出结果是否相等。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">IsPopOrder</span><span class="params">(self, pushV, popV)</span>:</span>  </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pushV:   </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        fixed=[]   <span class="comment">#压下去的辅助栈，处于栈顶可以出栈</span></span><br><span class="line">        left=pushV[:]   <span class="comment">#剩余的可活动栈，p元素位置之前的都要压入辅助栈</span></span><br><span class="line">        flag=<span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> popV:</span><br><span class="line">            <span class="keyword">if</span> p <span class="keyword">not</span> <span class="keyword">in</span> pushV:   <span class="comment">#还要判断pushV和popV元素不同的情况</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> p <span class="keyword">in</span> left:</span><br><span class="line">                k=left.index(p)</span><br><span class="line">                fixed=fixed+left[:k+<span class="number">1</span>]</span><br><span class="line">                left=left[k+<span class="number">1</span>:]</span><br><span class="line">                fixed.pop()</span><br><span class="line">            <span class="keyword">elif</span> fixed:  <span class="comment">#避免fixed[-1]越界</span></span><br><span class="line">                <span class="keyword">if</span> p!=fixed[<span class="number">-1</span>]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">else</span>:fixed.pop()</span><br><span class="line">        <span class="keyword">return</span> flag</span><br></pre></td></tr></table></figure>
<h3 id="22-从上往下打印二叉树"><a href="#22-从上往下打印二叉树" class="headerlink" title="22.从上往下打印二叉树"></a>22.从上往下打印二叉树</h3><p><strong>题目：</strong>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p>
<p><strong>思路：</strong>层次遍历，用队列。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回从上到下每个节点值列表，例：[1,2,3]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">PrintFromTopToBottom</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        res=[]</span><br><span class="line">        value=[]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []  <span class="comment">#返回空列表，而不是None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res.append(root)</span><br><span class="line">            value.append(root.val)</span><br><span class="line">        <span class="keyword">while</span> res:</span><br><span class="line">            p=res.pop(<span class="number">0</span>)   <span class="comment"># pop(0)才是第一个元素</span></span><br><span class="line">            <span class="keyword">if</span> p.left:</span><br><span class="line">                res.append(p.left)</span><br><span class="line">                value.append(p.left.val)</span><br><span class="line">            <span class="keyword">if</span> p.right:</span><br><span class="line">                res.append(p.right)</span><br><span class="line">                value.append(p.right.val)</span><br><span class="line">        <span class="keyword">return</span> value</span><br></pre></td></tr></table></figure>
<h3 id="23-二叉树的后续遍历序列-flag"><a href="#23-二叉树的后续遍历序列-flag" class="headerlink" title="23.二叉树的后续遍历序列(flag)"></a>23.二叉树的后续遍历序列(flag)</h3><p><strong>题目：</strong>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p>
<p><strong>思路：</strong>二叉搜索树的特性是所有左子树值都小于中节点，所有右子树的值都大于中节点，递归遍历左子树和右子树的值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># 后续遍历要满足 去除序列最后一个元素（根）后，将小于和大于这个元素直接分成两段，递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">VerifySquenceOfBST</span><span class="params">(self, sequence)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> sequence:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> len(sequence)==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        front=[]</span><br><span class="line">        back=[]</span><br><span class="line">        flag=<span class="number">0</span>  <span class="comment"># 辅助与分段的标记，第一个大于p元素之后的都放在back断</span></span><br><span class="line">        p=sequence.pop()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> sequence:</span><br><span class="line">            <span class="keyword">if</span> i&lt;=p <span class="keyword">and</span> flag==<span class="number">0</span>:</span><br><span class="line">                front.append(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                flag=<span class="number">1</span></span><br><span class="line">                back.append(i)</span><br><span class="line">        <span class="keyword">if</span> front <span class="keyword">and</span> max(front)&gt;p:  <span class="comment">#front要满足所有元素都小于p</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> back <span class="keyword">and</span> min(back)&lt;p: <span class="comment">#back要满足所有元素都大于p</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        LEFT=<span class="literal">True</span>  <span class="comment">#递归出口</span></span><br><span class="line">        RIGHT=<span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> front:</span><br><span class="line">            LEFT=self.VerifySquenceOfBST(front)</span><br><span class="line">        <span class="keyword">if</span> back:</span><br><span class="line">            RIGHT=self.VerifySquenceOfBST(back)</span><br><span class="line">        <span class="keyword">return</span> LEFT <span class="keyword">and</span> RIGHT</span><br></pre></td></tr></table></figure>
<h3 id="24-二叉树中和为某一值的路径-flag"><a href="#24-二叉树中和为某一值的路径-flag" class="headerlink" title="24.二叉树中和为某一值的路径(flag)"></a>24.二叉树中和为某一值的路径(flag)</h3><p><strong>题目：</strong>输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回二维列表，内部每个列表表示找到的路径</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindPath</span><span class="params">(self, root, expectNumber)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment"># 这题不太会，记一下</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="comment">#即是一开始条件语句，也是递归出口，若叶子节点不满足条件，left或者right返回空</span></span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">and</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right <span class="keyword">and</span> root.val == expectNumber:</span><br><span class="line">            <span class="keyword">return</span> [[root.val]]  <span class="comment">#递归出口，即叶子节点满足条件，不会执行以下任何语句；</span></span><br><span class="line">                                 </span><br><span class="line">        res = [] <span class="comment">#每次清空</span></span><br><span class="line">        <span class="comment"># 先会一直先递归left，相当于深度优先搜索</span></span><br><span class="line">        left = self.FindPath(root.left, expectNumber-root.val) <span class="comment">#left_left1_left11_right11_...right1</span></span><br><span class="line">        right = self.FindPath(root.right, expectNumber-root.val)</span><br><span class="line">        <span class="comment"># 遍历后的操作</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> left+right:  <span class="comment">#是指里面的元素，[[root.val]]得到的元素是[root.val]</span></span><br><span class="line">            res.append([root.val]+i)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">   <span class="comment">#      6        左图所示，left返回[[3]],right返回的res为[].append([2]+[1])=[[2,1]]</span></span><br><span class="line">    <span class="comment">#   3   2      最后一层返回[[6,3],[6,2,1]]</span></span><br><span class="line">     <span class="comment">#     1</span></span><br></pre></td></tr></table></figure>
<h3 id="25-复杂链表的复制-flag"><a href="#25-复杂链表的复制-flag" class="headerlink" title="25.复杂链表的复制(flag)"></a>25.复杂链表的复制(flag)</h3><p><strong>题目：</strong>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）。</p>
<p><strong>思路：</strong></p>
<p>1、遍历链表，复制每个结点，如复制结点A得到A1，将结点A1插到结点A后面（暂不处理随机节点）；</p>
<p>2、重新遍历链表，复制老结点的随机指针给新结点，如A1.random = A.random.next;</p>
<p>3、拆分链表，将链表拆分为原链表和复制后的链表</p>
<p><img src="/2018/09/07/数据结构与算法/剑指offer解题_Python版/01.png" alt></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.label = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line">        self.random = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回 RandomListNode</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Clone</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        pCur = pHead</span><br><span class="line">        <span class="keyword">while</span> pCur:</span><br><span class="line">            node = RandomListNode(pCur.label)</span><br><span class="line">            node.next = pCur.next</span><br><span class="line">            pCur.next = node</span><br><span class="line">            pCur = node.next</span><br><span class="line">        pCur = pHead</span><br><span class="line">        <span class="keyword">while</span> pCur:</span><br><span class="line">            <span class="keyword">if</span> pCur.random:</span><br><span class="line">                pCur.next.random = pCur.random</span><br><span class="line">            pCur = pCur.next.next</span><br><span class="line">        pCur = pHead</span><br><span class="line">        cur = pHead.next</span><br><span class="line">        h = cur</span><br><span class="line">        <span class="keyword">while</span> cur:  <span class="comment">#拆分</span></span><br><span class="line">            pCur.next = cur.next</span><br><span class="line">            <span class="keyword">if</span> pCur.next:</span><br><span class="line">                cur.next = pCur.next.next</span><br><span class="line">            pCur = pCur.next</span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="keyword">return</span> h</span><br></pre></td></tr></table></figure>
<h3 id="26-二叉搜索树与双向列表"><a href="#26-二叉搜索树与双向列表" class="headerlink" title="26.二叉搜索树与双向列表"></a>26.二叉搜索树与双向列表</h3><p><strong>题目：</strong>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p>
<p><strong>思路：</strong>中序遍历，然后添加一个pre指针</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.a=[]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Convert</span><span class="params">(self, pRootOfTree)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">         </span><br><span class="line">        <span class="keyword">if</span> pRootOfTree==<span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        self.Convert(pRootOfTree.left)</span><br><span class="line">        self.a.append(pRootOfTree)</span><br><span class="line">        self.Convert(pRootOfTree.right)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(self.a)<span class="number">-1</span>):</span><br><span class="line">            self.a[i].right=self.a[i+<span class="number">1</span>]</span><br><span class="line">            self.a[i+<span class="number">1</span>].left=self.a[i]</span><br><span class="line">        <span class="keyword">return</span> self.a[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h3 id="27-字符串的排列-flag"><a href="#27-字符串的排列-flag" class="headerlink" title="27.字符串的排列(flag)"></a>27.字符串的排列(flag)</h3><p><strong>题目：</strong>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p>
<p><strong>输入：</strong>输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。</p>
<p><strong>思路：</strong>用itertools.permutations;或者通过将固定每一位的字符，然后进行和后面的每个字符进行交换，得到所有结果集。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Permutation</span><span class="params">(self, ss)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> ss:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">return</span> sorted(list(set(map(<span class="string">''</span>.join, itertools.permutations(ss)))))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#  abc</span></span><br><span class="line">    <span class="comment">#  itertools.permutations(ss)输出('a','b','c') ('a','c','b')...等</span></span><br><span class="line">    <span class="comment">#  map函数后为abc acb..</span></span><br></pre></td></tr></table></figure>
<h3 id="28-数组中出现次数超过一般的数字"><a href="#28-数组中出现次数超过一般的数字" class="headerlink" title="28.数组中出现次数超过一般的数字"></a>28.数组中出现次数超过一般的数字</h3><p><strong>题目：</strong>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0</p>
<p><strong>题解：</strong>判断是否有超过一半的元素，如果有则在数组中间的元素</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(self, numbers)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> numbers:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(numbers)==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> numbers[<span class="number">0</span>]</span><br><span class="line">        l=len(numbers)//<span class="number">2</span></span><br><span class="line">        k=sorted(list(numbers))  <span class="comment">#排序，满足条件处于中间位置的为最多元素</span></span><br><span class="line">        count=<span class="number">0</span>                  <span class="comment">#不满足条件则遍历判断 此元素maxcount是否超过一半</span></span><br><span class="line">        maxcount=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(k)<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> k[i]==k[i+<span class="number">1</span>]:</span><br><span class="line">                count=count+<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> count&gt;maxcount:</span><br><span class="line">                    maxcount=count</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count=<span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> maxcount&gt;=l:</span><br><span class="line">            <span class="keyword">return</span> k[l]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h3 id="29-最小的K个数"><a href="#29-最小的K个数" class="headerlink" title="29.最小的K个数"></a>29.最小的K个数</h3><p><strong>题目：</strong>输入n个整数，找出其中最小的K个数，例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetLeastNumbers_Solution</span><span class="params">(self, tinput, k)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> len(tinput)&lt;k:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res=sorted(tinput)</span><br><span class="line">        <span class="keyword">return</span> res[:k]</span><br></pre></td></tr></table></figure>
<h3 id="30-连续子数组的最大和-flag"><a href="#30-连续子数组的最大和-flag" class="headerlink" title="30.连续子数组的最大和(flag)"></a>30.连续子数组的最大和(flag)</h3><p><strong>题目：</strong>HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。你会不会被他忽悠住？(子向量的长度至少是1)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(self, array)</span>:</span></span><br><span class="line">        <span class="comment"># write code here  只需要返回最大数，下标不管</span></span><br><span class="line">        <span class="comment"># 思路：创建一个列表储存要加入的元素，当累积和小于0则清空前面一段</span></span><br><span class="line">        <span class="comment"># 另外一个更简单的思路PART2</span></span><br><span class="line">        <span class="keyword">if</span> len(array)==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> array[<span class="number">0</span>]  </span><br><span class="line">        <span class="keyword">if</span> max(array)&lt;=<span class="number">0</span>:  <span class="comment">#全是负数</span></span><br><span class="line">            <span class="keyword">return</span> max(array)</span><br><span class="line">        <span class="keyword">if</span> min(array)&gt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> sum(array)</span><br><span class="line">        cum_max=<span class="number">0</span></span><br><span class="line">        maxnum=<span class="number">0</span></span><br><span class="line">        res=[]</span><br><span class="line">        <span class="keyword">for</span>  k, i <span class="keyword">in</span> enumerate(array):  </span><br><span class="line">            <span class="keyword">if</span> cum_max+i&gt;=<span class="number">0</span> <span class="keyword">and</span> max(array[k:])&gt;<span class="number">0</span>: <span class="comment"># 注意一点，当前数组后面全是负数，不能再加了</span></span><br><span class="line">                res.append(i)</span><br><span class="line">                cum_max=cum_max+i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment">#curmax=0  #此时可以记下标，这里不要求</span></span><br><span class="line">                cum_max=<span class="number">0</span></span><br><span class="line">                <span class="keyword">if</span> sum(res)&gt;maxnum:</span><br><span class="line">                    maxnum=sum(res)</span><br><span class="line">                res=[]</span><br><span class="line">        <span class="keyword">return</span> max(maxnum,sum(res))    <span class="comment">#sum(res)是最后数组res一直加入元素而没有更新maxnum </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># ======================part2：==========================</span></span><br><span class="line">    <span class="comment"># class Solution:</span></span><br><span class="line">    <span class="comment">#    def FindGreatestSumOfSubArray(self, array):</span></span><br><span class="line">    <span class="comment">#        maxnum= float(-inf)</span></span><br><span class="line">    <span class="comment">#        cum_max= 0</span></span><br><span class="line">    <span class="comment">#        for i in array:</span></span><br><span class="line">    <span class="comment">#            if cum_max+i&lt;0:</span></span><br><span class="line">    <span class="comment">#                cum_max=i        #这一句是精华，什么都不作处理，下一个值当做cum_max</span></span><br><span class="line">    <span class="comment">#            else:</span></span><br><span class="line">    <span class="comment">#                cum_max=cum_max+i</span></span><br><span class="line">    <span class="comment">#            if cum_max&gt;maxnum:</span></span><br><span class="line">    <span class="comment">#                maxnum=cum_max</span></span><br><span class="line">    <span class="comment">#            return maxnum</span></span><br></pre></td></tr></table></figure>
<h3 id="31-整数中1出现的次数"><a href="#31-整数中1出现的次数" class="headerlink" title="31.整数中1出现的次数"></a>31.整数中1出现的次数</h3><p><strong>题目：</strong>求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        count=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>+n):</span><br><span class="line">            count=count+str(i).count(<span class="string">'1'</span>)</span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>
<h3 id="32-把数组排成最小的数-flag"><a href="#32-把数组排成最小的数-flag" class="headerlink" title="32.把数组排成最小的数(flag)"></a>32.把数组排成最小的数(flag)</h3><p><strong>题目：</strong>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p>
<p><strong>思路：</strong>将数组转换成字符串之后，进行两两比较字符串的大小，比如3,32的大小由332和323确定，即3+32和32+3确定。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">PrintMinNumber</span><span class="params">(self, numbers)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> numbers:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">        cmp_def = <span class="keyword">lambda</span> x1,x2: int(str(x1)+str(x2))-int(str(x2)+str(x1))</span><br><span class="line">        a=sorted(numbers,cmp=cmp_def)  <span class="comment">#sortef创建副本，sort原地</span></span><br><span class="line">        b=list(map(<span class="keyword">lambda</span> x:str(x),a)) <span class="comment">#列表数字转字符串</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(b)  <span class="comment">#jion反馈一个字符串</span></span><br></pre></td></tr></table></figure>
<h3 id="33-丑数-flag"><a href="#33-丑数-flag" class="headerlink" title="33.丑数(flag)"></a>33.丑数(flag)</h3><p><strong>题目：</strong>把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p>
<p><strong>思路：</strong>每一个丑数必然是由之前的某个丑数与2，3或5的乘积得到的，这样下一个丑数就用之前的丑数分别乘以2，3，5，找出这三这种最小的并且大于当前最大丑数的值，即为下一个要求的丑数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        <span class="comment"># write code herei</span></span><br><span class="line">        <span class="comment"># 思路，创建一个数组存储丑数；创建三个丑数数组独立下标对应乘以235，最小为当前丑数</span></span><br><span class="line">        <span class="keyword">if</span> index==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> index==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        uglyarr=[<span class="number">1</span>]</span><br><span class="line">        a2,a3,a5=<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(index<span class="number">-1</span>):</span><br><span class="line">            n1,n2,n3=uglyarr[a2]*<span class="number">2</span>,uglyarr[a3]*<span class="number">3</span>,uglyarr[a5]*<span class="number">5</span>        </span><br><span class="line">            min_num=min(n1,n2,n3)</span><br><span class="line">            uglyarr.append(min_num)</span><br><span class="line">            <span class="keyword">if</span> min_num==n1:</span><br><span class="line">                a2=a2+<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> min_num==n2:</span><br><span class="line">                a3=a3+<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> min_num==n3:</span><br><span class="line">                a5=a5+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> uglyarr[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="34-第一个只出现一次的字符"><a href="#34-第一个只出现一次的字符" class="headerlink" title="34.第一个只出现一次的字符"></a>34.第一个只出现一次的字符</h3><p><strong>题目：</strong>在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        ss=list(s)</span><br><span class="line">        <span class="keyword">for</span> i,e <span class="keyword">in</span> enumerate(ss):</span><br><span class="line">            <span class="keyword">if</span> s.count(e)==<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h3 id="35-数组中的逆序对-Flag"><a href="#35-数组中的逆序对-Flag" class="headerlink" title="35.数组中的逆序对(Flag)"></a>35.数组中的逆序对(Flag)</h3><p><strong>题目描述：</strong>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007。</p>
<p><strong>输入描述：</strong>题目保证输入的数组中没有的相同的数字。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">/*</span></span><br><span class="line"><span class="string">归并排序的改进，把数据分成前后两个数组(递归分到每个数组仅有一个数据项)，合并数组，合并时，出现前面的数组值array[i]大于后面数组值array[j]时；则前面数组array[i]~array[mid]都是大于array[j]的，</span></span><br><span class="line"><span class="string">count += mid+1 - i参考剑指Offer，但是感觉剑指Offer归并过程少了一步拷贝过程。还有就是测试用例输出结果比较大，对每次返回的count mod(1000000007)求余</span></span><br><span class="line"><span class="string">*/</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">InversePairs</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> self.inverseCount(data[:], <span class="number">0</span>, len(data)<span class="number">-1</span>, data[:])%<span class="number">1000000007</span></span><br><span class="line">       </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inverseCount</span><span class="params">(self, tmp, start, end, data)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> end-start &lt;<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> end - start == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> data[start]&lt;=data[end]:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        mid = (start+end)//<span class="number">2</span></span><br><span class="line">        cnt = self.inverseCount(data, start, mid, tmp) + self.inverseCount(data, mid+<span class="number">1</span>, end, tmp)</span><br><span class="line">        <span class="comment"># print(start, mid, end, cnt, data)</span></span><br><span class="line">        i = start</span><br><span class="line">        j = mid + <span class="number">1</span></span><br><span class="line">        ind = start  <span class="comment"># 用于tmp的下标</span></span><br><span class="line">           </span><br><span class="line">        <span class="keyword">while</span>(i &lt;= mid <span class="keyword">and</span> j &lt;= end): <span class="comment"># tmp排序</span></span><br><span class="line">            <span class="keyword">if</span> data[i] &lt;= data[j]:</span><br><span class="line">                tmp[ind] = data[i]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tmp[ind] = data[j]</span><br><span class="line">                cnt += mid - i + <span class="number">1</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            ind += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid):</span><br><span class="line">            tmp[ind] = data[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            ind += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span>(j&lt;=end):</span><br><span class="line">            tmp[ind] = data[j]</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">            ind += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> cnt</span><br></pre></td></tr></table></figure>
<h3 id="36-两个链表的第一个公共节点"><a href="#36-两个链表的第一个公共节点" class="headerlink" title="36.两个链表的第一个公共节点"></a>36.两个链表的第一个公共节点</h3><p><strong>题目：</strong>输入两个链表，找出它们的第一个公共结点。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#有些题的输入指针，没有val属性，只有next</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindFirstCommonNode</span><span class="params">(self, pHead1, pHead2)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead1 <span class="keyword">or</span> <span class="keyword">not</span> pHead2:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> pHead1:</span><br><span class="line">            p2=pHead2  </span><br><span class="line">            <span class="keyword">while</span> p2:</span><br><span class="line">                <span class="keyword">if</span> pHead1==p2:</span><br><span class="line">                    <span class="keyword">return</span> pHead1</span><br><span class="line">                p2=p2.next</span><br><span class="line">            pHead1=pHead1.next</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<h3 id="37-数字在排序数组中出现的次数"><a href="#37-数字在排序数组中出现的次数" class="headerlink" title="37.数字在排序数组中出现的次数"></a>37.数字在排序数组中出现的次数</h3><p><strong>题目：</strong>统计一个数字在排序数组中出现的次数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetNumberOfK</span><span class="params">(self, data, k)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        count=<span class="number">0</span></span><br><span class="line">        flag=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> data:</span><br><span class="line">            <span class="keyword">if</span> i==k:</span><br><span class="line">                count=count+<span class="number">1</span></span><br><span class="line">                flag=<span class="number">1</span>  <span class="comment">#设置处在相同阶段的标志</span></span><br><span class="line">            <span class="keyword">if</span> count&gt;<span class="number">0</span> <span class="keyword">and</span> flag!=<span class="number">1</span>: <span class="comment">#不在相同阶段就break </span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>
<h3 id="38-二叉树的深度-flag"><a href="#38-二叉树的深度-flag" class="headerlink" title="38.二叉树的深度(flag)"></a>38.二叉树的深度(flag)</h3><p><strong>题目：</strong>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">TreeDepth</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left=self.TreeDepth(pRoot.left)  <span class="comment">#操作放在后面，想象后序遍历</span></span><br><span class="line">        right=self.TreeDepth(pRoot.right)</span><br><span class="line">        <span class="keyword">return</span> max(left,right)+<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="39-平衡二叉树-flag"><a href="#39-平衡二叉树-flag" class="headerlink" title="39.平衡二叉树(flag)"></a>39.平衡二叉树(flag)</h3><p><strong>题目：</strong>输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p>
<p><strong>题解：</strong>平衡二叉树是左右子数的距离不能大于1，因此递归左右子树，判断子树距离是否大于1。用Maxdeep递归求深度</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">IsBalanced_Solution</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment"># 递归且有一个实现求深度的递归函数</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> abs(self.Maxdeep(pRoot.left)-self.Maxdeep(pRoot.right))&gt;<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> self.IsBalanced_Solution(pRoot.left) <span class="keyword">and</span> self.IsBalanced_Solution(pRoot.right)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Maxdeep</span><span class="params">(self,pRoot)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left = self.Maxdeep(pRoot.left)</span><br><span class="line">        right = self.Maxdeep(pRoot.right)</span><br><span class="line">        <span class="keyword">return</span> max(left,right)+<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="40-数组中只出现一次的数字"><a href="#40-数组中只出现一次的数字" class="headerlink" title="40.数组中只出现一次的数字"></a>40.数组中只出现一次的数字</h3><p><strong>题目：</strong>一个整型数组里除了两个数字之外，其他的数字都出现了偶数次。请写程序找出这两个只出现一次的数字。</p>
<p><strong>题解：</strong>转为字符串；或者将数组中数转到set之中，然后利用dict存储每个数字出现的次数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回[a,b] 其中ab是出现一次的两个数字</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindNumsAppearOnce</span><span class="params">(self, array)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> array:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> len(array)==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> array[<span class="number">0</span>]</span><br><span class="line">        l=[]</span><br><span class="line">        arr_str_list=list(map(<span class="keyword">lambda</span> x:str(x),array))</span><br><span class="line">        arr_str=<span class="string">''</span>.join(arr_str_list) <span class="comment">#输入要为字符列表</span></span><br><span class="line">        <span class="keyword">for</span> i,e <span class="keyword">in</span> enumerate(arr_str_list):</span><br><span class="line">            <span class="keyword">if</span> arr_str.count(e)==<span class="number">1</span>:</span><br><span class="line">                l.append(i)</span><br><span class="line">        ll=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> l:</span><br><span class="line">            ll.append(array[i])</span><br><span class="line">        <span class="keyword">return</span> ll</span><br><span class="line"><span class="comment"># ====================================</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回[a,b] 其中ab是出现一次的两个数字</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindNumsAppearOnce</span><span class="params">(self, array)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        arrayset=set(array)</span><br><span class="line">        dict=&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> arrayset:</span><br><span class="line">            dict[num]=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(array)):</span><br><span class="line">            dict[array[i]]=dict[array[i]]+<span class="number">1</span></span><br><span class="line">        ans=[]</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> arrayset:</span><br><span class="line">            <span class="keyword">if</span> dict[num]==<span class="number">1</span>:</span><br><span class="line">                ans.append(num)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="41-和为S的连续正整数序列"><a href="#41-和为S的连续正整数序列" class="headerlink" title="41.和为S的连续正整数序列"></a>41.和为S的连续正整数序列</h3><p><strong>题目：</strong>小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!</p>
<p><strong>输出描述：</strong>输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindContinuousSequence</span><span class="params">(self, tsum)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment">#若是100,只需要从1：50找就可以了，+2是考虑到下标0开始，让搜索范围大一些</span></span><br><span class="line">        bitsum=tsum//<span class="number">2</span>+<span class="number">2</span> </span><br><span class="line">        ori=list(range(<span class="number">1</span>,bitsum)) </span><br><span class="line">        res=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,bitsum):</span><br><span class="line">            l=[]</span><br><span class="line">            summ=i <span class="comment">#累积总和</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,bitsum):</span><br><span class="line">                summ=summ+j</span><br><span class="line">                <span class="keyword">if</span> summ==tsum:</span><br><span class="line">                    l=ori[i<span class="number">-1</span>:j] <span class="comment">#i,j看做下标返回满足条件的数组</span></span><br><span class="line">                <span class="keyword">if</span> summ&gt;tsum:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> l:</span><br><span class="line">                res.append(l)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="42-和为S的两个数字-flag"><a href="#42-和为S的两个数字-flag" class="headerlink" title="42.和为S的两个数字(flag)"></a>42.和为S的两个数字(flag)</h3><p><strong>题目：</strong>输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。</p>
<p><strong>输出描述：</strong>对应每个测试案例，输出两个数，小的先输出</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindNumbersWithSum</span><span class="params">(self, array, tsum)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment"># 返回列表类型的，若不满足条件则[]</span></span><br><span class="line">        <span class="keyword">if</span> len(array)&lt;=<span class="number">1</span> <span class="keyword">or</span> min(array)&gt;tsum:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(array)):  <span class="comment"># 都是索引下标循环</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,len(array)): </span><br><span class="line">                <span class="keyword">if</span> array[i]+array[j]==tsum:</span><br><span class="line">                    <span class="comment"># 从头开始搜索这时候得到的应该是乘积最小的，可以直接退出外层循环</span></span><br><span class="line">                    res.append(array[i])</span><br><span class="line">                    res.append(array[j])</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> array[j]&gt;tsum:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment"># 上面循环正常结束才会执行，若上面循环执行break则这条语句不执行</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">if</span> res:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>
<h3 id="43-左旋字符子串"><a href="#43-左旋字符子串" class="headerlink" title="43.左旋字符子串"></a>43.左旋字符子串</h3><p><strong>题目：</strong>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">LeftRotateString</span><span class="params">(self, s, n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> len(s)&lt;n <span class="keyword">or</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        <span class="keyword">return</span> s[n:]+s[:n]</span><br></pre></td></tr></table></figure>
<h3 id="44-反转单词顺序-flag"><a href="#44-反转单词顺序-flag" class="headerlink" title="44.反转单词顺序(flag)"></a>44.反转单词顺序(flag)</h3><p><strong>题目：</strong>牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ReverseSentence</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        ss=s.split(<span class="string">' '</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">' '</span>.join(ss[::<span class="number">-1</span>])</span><br></pre></td></tr></table></figure>
<h3 id="45-扑克牌顺序"><a href="#45-扑克牌顺序" class="headerlink" title="45.扑克牌顺序"></a>45.扑克牌顺序</h3><p><strong>题目：</strong>LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\小王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">IsContinuous</span><span class="params">(self, numbers)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment"># 只需要判断没有0的数组里数值是唯一且max-min&lt;5即可</span></span><br><span class="line">        <span class="keyword">if</span> len(numbers)&lt;<span class="number">5</span> <span class="keyword">and</span> <span class="keyword">not</span> numbers:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        grost_num=<span class="number">0</span></span><br><span class="line">        without_gro=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> numbers:</span><br><span class="line">            <span class="keyword">if</span> i==<span class="number">0</span>:</span><br><span class="line">                grost_num+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> i <span class="keyword">in</span> without_gro <span class="keyword">and</span> i!=<span class="number">0</span>: <span class="comment">#唯一</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                without_gro.append(i)</span><br><span class="line">        <span class="keyword">if</span> max(without_gro)-min(without_gro)&lt;<span class="number">5</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h3 id="46-孩子们的圈圈-圈圈中最后剩下的数-flag"><a href="#46-孩子们的圈圈-圈圈中最后剩下的数-flag" class="headerlink" title="46.孩子们的圈圈(圈圈中最后剩下的数)(flag)"></a>46.孩子们的圈圈(圈圈中最后剩下的数)(flag)</h3><p><strong>题目：</strong>每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">LastRemaining_Solution</span><span class="params">(self, n, m)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment"># flag=0</span></span><br><span class="line">        <span class="comment"># 把index想象为连续拼接数组</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n <span class="keyword">or</span> <span class="keyword">not</span> m:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        num = list(range(n))</span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> len(num)&gt;<span class="number">1</span>: <span class="comment"># 剩余两个都要继续执行</span></span><br><span class="line">            index=(index+m<span class="number">-1</span>)%len(num) <span class="comment">#index为上一次停的地方，加上m-1为重新第m-1个出列</span></span><br><span class="line">            num.pop(index)</span><br><span class="line">        <span class="keyword">return</span> num[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h3 id="47-求1-2-3-…-n"><a href="#47-求1-2-3-…-n" class="headerlink" title="47.求1+2+3+…+n"></a>47.求1+2+3+…+n</h3><p><strong>题目：</strong>求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Sum_Solution</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> n+self.Sum_Solution(n<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>
<h3 id="48-不用加减乘除做加法"><a href="#48-不用加减乘除做加法" class="headerlink" title="48.不用加减乘除做加法"></a>48.不用加减乘除做加法</h3><p><strong>题目：</strong>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。</p>
<p><strong>思路：</strong>二进制异或进位。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Add</span><span class="params">(self, num1, num2)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment"># 位操作不懂</span></span><br><span class="line">        <span class="keyword">return</span> sum([num1,num2])</span><br><span class="line">        </span><br><span class="line"><span class="comment"># ============================</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">首先看十进制是如何做的： 5+7=12，三步走</span></span><br><span class="line"><span class="string">第一步：相加各位的值，不算进位，得到2。</span></span><br><span class="line"><span class="string">第二步：计算进位值，得到10. 如果这一步的进位值为0，那么第一步得到的值就是最终结果。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">第三步：重复上述两步，只是相加的值变成上述两步的得到的结果2和10，得到12。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">同样我们可以用三步走的方式计算二进制值相加： 5-101，7-111 第一步：相加各位的值，不算进位，得到010，二进制每位相加就相当于各位做异或操作，101^111。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">第二步：计算进位值，得到1010，相当于各位做与操作得到101，再向左移一位得到1010，(101&amp;111)&lt;&lt;1。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">第三步重复上述两步， 各位相加 010^1010=1000，进位值为100=(010&amp;1010)&lt;&lt;1。</span></span><br><span class="line"><span class="string">     继续重复上述两步：1000^100 = 1100，进位值为0，跳出循环，1100为最终结果。</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Add</span><span class="params">(self, num1, num2)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">while</span> num2!=<span class="number">0</span>:</span><br><span class="line">            sum=num1^num2</span><br><span class="line">            carry=(num1&amp;num2)&lt;&lt;<span class="number">1</span></span><br><span class="line">            num1=sum</span><br><span class="line">            num2=carry</span><br><span class="line">        <span class="keyword">return</span> num1</span><br></pre></td></tr></table></figure>
<h3 id="49-把字符串转换成整数"><a href="#49-把字符串转换成整数" class="headerlink" title="49.把字符串转换成整数"></a>49.把字符串转换成整数</h3><p><strong>题目：</strong>将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。</p>
<p><strong>输入描述：</strong>输入一个字符串,包括数字字母符号,可以为空输出描述:如果是合法的数值表达则返回该数字，否则返回0。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">StrToInt</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        l=[s]</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            num=list(map(eval,l))  </span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> num[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h3 id="50-数组中重复的数字"><a href="#50-数组中重复的数字" class="headerlink" title="50.数组中重复的数字"></a>50.数组中重复的数字</h3><p><strong>题目：</strong>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p>
<p><strong>思路：</strong>利用dict计算重复数字。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 这里要特别注意~找到任意重复的一个值并赋值到duplication[0]</span></span><br><span class="line">    <span class="comment"># 函数返回True/False</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">duplicate</span><span class="params">(self, numbers, duplication)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> numbers:</span><br><span class="line">            <span class="keyword">if</span> numbers.count(i)&gt;<span class="number">1</span>:</span><br><span class="line">                duplication[<span class="number">0</span>]=i</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h3 id="51-构建乘积数组"><a href="#51-构建乘积数组" class="headerlink" title="51.构建乘积数组"></a>51.构建乘积数组</h3><p><strong>题目</strong>:给定数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1];其中B中的元素B[i]=A[0]<em>A[1]…A[i-1]</em>A[i+1]…A[n-1]。不能使用除法。</p>
<p><strong>注意</strong>：没有A[i]</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">multiply</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> A:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> len(A)==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        B=[<span class="literal">None</span>]*len(A)</span><br><span class="line">        <span class="keyword">for</span> i,e <span class="keyword">in</span> enumerate(A):</span><br><span class="line">            cumpower=<span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> ii,ee <span class="keyword">in</span> enumerate(A):</span><br><span class="line">                <span class="keyword">if</span> ii!=i:</span><br><span class="line">                    cumpower=cumpower*ee</span><br><span class="line">            B[i]=cumpower</span><br><span class="line">        <span class="keyword">return</span> B</span><br></pre></td></tr></table></figure>
<h3 id="52-正则表达式匹配-flag"><a href="#52-正则表达式匹配-flag" class="headerlink" title="52.正则表达式匹配(flag)"></a>52.正则表达式匹配(flag)</h3><p><strong>题目：</strong>请实现一个函数用来匹配包括’ , ‘和’ * ‘的正则表达式。模式中的字符’ , ‘表示任意一个字符，而’ * ‘表示它前面的字符可以出现任意次（包含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但是与”aa.a”和”ab*a”均不匹配。</p>
<p> 思路: </p>
<blockquote>
<p>当模式中的第二个字符不是 *时：</p>
<ul>
<li>如果字符串第一个字符和模式中的第一个字符相匹配，那么字符串和模式都后移一个字符，然后匹配剩余的。</li>
<li>如果字符串第一个字符和模式中的第一个字符相不匹配，直接返回false。</li>
</ul>
<p>当模式中的第二个字符是 *时：</p>
<ul>
<li>如果字符串第一个字符跟模式第一个字符不匹配，则模式后移2个字符，继续匹配。</li>
<li>如果字符串第一个字符跟模式第一个字符匹配，可以有3种匹配方式。<ul>
<li>模式后移2字符，相当于 x<em>被忽略。即模式串中</em>与他前面的字符和字符串匹配0次。</li>
<li>字符串后移1字符，模式后移2字符。即模式串中*与他前面的字符和字符串匹配1次。</li>
<li>字符串后移1字符，模式不变，即继续匹配字符下一位，因为 <em>可以匹配多位。即模式串中</em>与他前面的字符和字符串匹配多次。</li>
</ul>
</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># s, pattern都是字符串</span></span><br><span class="line">    <span class="comment"># flag=0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">match</span><span class="params">(self, s, pattern)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> (len(s) == <span class="number">0</span> <span class="keyword">and</span> len(pattern) == <span class="number">0</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> (len(s) &gt; <span class="number">0</span> <span class="keyword">and</span> len(pattern) == <span class="number">0</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> (len(pattern) &gt; <span class="number">1</span> <span class="keyword">and</span> pattern[<span class="number">1</span>] == <span class="string">'*'</span>):</span><br><span class="line">            <span class="keyword">if</span> (len(s) &gt; <span class="number">0</span> <span class="keyword">and</span> (s[<span class="number">0</span>] == pattern[<span class="number">0</span>] <span class="keyword">or</span> pattern[<span class="number">0</span>] == <span class="string">'.'</span>)):</span><br><span class="line">                <span class="keyword">return</span> (self.match(s, pattern[<span class="number">2</span>:]) <span class="keyword">or</span> self.match(s[<span class="number">1</span>:], pattern[<span class="number">2</span>:]) <span class="keyword">or</span> self.match(s[<span class="number">1</span>:], pattern))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> self.match(s, pattern[<span class="number">2</span>:])</span><br><span class="line">        <span class="keyword">if</span> (len(s) &gt; <span class="number">0</span> <span class="keyword">and</span> (pattern[<span class="number">0</span>] == <span class="string">'.'</span> <span class="keyword">or</span> pattern[<span class="number">0</span>] == s[<span class="number">0</span>])):</span><br><span class="line">            <span class="keyword">return</span> self.match(s[<span class="number">1</span>:], pattern[<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h3 id="53-表示数值的字符串"><a href="#53-表示数值的字符串" class="headerlink" title="53.表示数值的字符串"></a>53.表示数值的字符串</h3><p><strong>题目：</strong>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># s字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isNumeric</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        l=[s]</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            b=float(s)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h3 id="54-字符流中第一个不重复的字符-flag"><a href="#54-字符流中第一个不重复的字符-flag" class="headerlink" title="54.字符流中第一个不重复的字符(flag)"></a>54.字符流中第一个不重复的字符(flag)</h3><p><strong>题目：</strong>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。</p>
<p><strong>输出描述：</strong>如果当前字符流没有存在出现一次的字符，返回#字符。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># flag=0</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回对应char</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.s=<span class="string">''</span></span><br><span class="line">        self.dict=&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FirstAppearingOnce</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> self.s:</span><br><span class="line">            <span class="keyword">if</span> self.dict[i]==<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'#'</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Insert</span><span class="params">(self, char)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        self.s+=char</span><br><span class="line">        <span class="keyword">if</span> char <span class="keyword">in</span> self.dict:</span><br><span class="line">            self.dict[char]+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.dict[char]=<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="55-链表中环的入口节点-flag"><a href="#55-链表中环的入口节点-flag" class="headerlink" title="55.链表中环的入口节点(flag)"></a>55.链表中环的入口节点(flag)</h3><p><strong>题目：</strong>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。</p>
<p><strong>思路：</strong>第一步，找环中相汇点。分别用p1，p2指向链表头部，p1每次走一步，p2每次走二步，直到p1==p2找到在环中的相汇点。第二步，找环的入口。接上步，当p1==p2时，p2所经过节点数为2x,p1所经过节点数为x,设环中有n个节点,p2比p1多走一圈有2x=n+x;n=x;可以看出p1实际走了一个环的步数，再让p2指向链表头部，p1位置不变，p1,p2每次走一步直到p1==p2; 此时p1指向环的入口：直线+小段环=整环，故p1再走整环-小段环到达起点。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">EntryNodeOfLoop</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        fast,slow=pHead,pHead</span><br><span class="line">        <span class="keyword">if</span> fast <span class="keyword">and</span> fast.next: </span><br><span class="line">            fast=fast.next.next</span><br><span class="line">            slow=slow.next</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.next <span class="keyword">and</span> fast!=slow:</span><br><span class="line">            fast=fast.next.next</span><br><span class="line">            slow=slow.next</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> fast.next: </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        fast=pHead</span><br><span class="line">        <span class="keyword">while</span> fast!=slow:</span><br><span class="line">            fast=fast.next</span><br><span class="line">            slow=slow.next</span><br><span class="line">        <span class="keyword">return</span> fast</span><br></pre></td></tr></table></figure>
<h3 id="56-删除链表中重复的节点-flag"><a href="#56-删除链表中重复的节点-flag" class="headerlink" title="56.删除链表中重复的节点(flag)"></a>56.删除链表中重复的节点(flag)</h3><p><strong>题目：</strong>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留(全部删除)，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplication</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        result = ListNode(<span class="number">0</span>)</span><br><span class="line">        res = result</span><br><span class="line">        tmp = pHead</span><br><span class="line">        <span class="keyword">while</span> tmp <span class="keyword">and</span> tmp.next:</span><br><span class="line">            <span class="keyword">if</span> tmp.val == tmp.next.val:</span><br><span class="line">                <span class="keyword">while</span> tmp.next <span class="keyword">and</span> tmp.val == tmp.next.val:</span><br><span class="line">                    tmp = tmp.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.next = tmp  <span class="comment">#把整个tmp之后的链表都接上去了</span></span><br><span class="line">                res = res.next</span><br><span class="line">            tmp = tmp.next</span><br><span class="line">        res.next = tmp</span><br><span class="line">        <span class="keyword">return</span> result.next</span><br><span class="line">            </span><br><span class="line"><span class="comment"># 一开始res为&#123;-1&#125;，1和2不同，res.next = tmp得到&#123;-1，1,2,3,3,4,4,5&#125;，res和tmp指针往下</span></span><br><span class="line"><span class="comment"># 第二次2和3不同，res.next = tmp得到&#123;-1，1，+，2,3,3,4,4,5&#125;，+号前为res指针位置</span></span><br><span class="line"><span class="comment"># 第三次3和3相同，tmp指针到4的位置，下一次res.next=tmp得到&#123;-1,1,2，+，4,4,5&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="57-二叉树中的下一个节点"><a href="#57-二叉树中的下一个节点" class="headerlink" title="57. 二叉树中的下一个节点"></a>57. 二叉树中的下一个节点</h3><p><strong>题目：</strong>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p>
<p><strong>思路：</strong>分析二叉树的下一个节点，一共有以下情况：1.二叉树为空，则返回空；2.节点右孩子存在，则设置一个指针从该节点的右孩子出发，一直沿着指向左子结点的指针找到的叶子节点即为下一个节点；3.节点不是根节点。如果该节点是其父节点的左孩子，则返回父节点；否则继续向上遍历其父节点的父节点，重复之前的判断，返回结果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeLinkNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetNext</span><span class="params">(self, pNode)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pNode:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> pNode.right:</span><br><span class="line">            pNode=pNode.right</span><br><span class="line">            <span class="keyword">while</span> pNode.left:</span><br><span class="line">                pNode=pNode.left</span><br><span class="line">            <span class="keyword">return</span> pNode</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>: <span class="comment">#存在该节点在父节点右边，且一直递归，这时要找爷爷节点 型如"\"</span></span><br><span class="line">            <span class="keyword">while</span> pNode.next:</span><br><span class="line">                <span class="keyword">if</span> pNode.next.left==pNode:</span><br><span class="line">                    <span class="keyword">return</span> pNode.next</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    pNode=pNode.next</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<h3 id="58-对称的二叉树-flag"><a href="#58-对称的二叉树-flag" class="headerlink" title="58.对称的二叉树(flag)"></a>58.对称的二叉树(flag)</h3><p><strong>题目：</strong>请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p>
<p><strong>思路：</strong>采用递归的方法来判断两数是否相同。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"><span class="comment">#  设计一个递归求issame的函数,issame(root1.left,root2.right)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetrical</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot.left <span class="keyword">and</span> <span class="keyword">not</span> pRoot.right:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> pRoot.left <span class="keyword">and</span> pRoot.right:</span><br><span class="line">            <span class="keyword">return</span> self.issame(pRoot.left,pRoot.right)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">issame</span><span class="params">(self, root1, root2)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root1 <span class="keyword">and</span> <span class="keyword">not</span> root2:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> root1 <span class="keyword">and</span> root2:</span><br><span class="line">            <span class="keyword">if</span> root1.val==root2.val:</span><br><span class="line">                <span class="keyword">return</span> self.issame(root1.left,root2.right) <span class="keyword">and</span> self.issame(root2.left,root1.right)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h3 id="59-按之字形顺序打印二叉树-flag"><a href="#59-按之字形顺序打印二叉树-flag" class="headerlink" title="59.按之字形顺序打印二叉树(flag)"></a>59.按之字形顺序打印二叉树(flag)</h3><p><strong>题目：</strong>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Print</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        res=[]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        level=[pRoot]</span><br><span class="line">        reverseflag=<span class="literal">False</span></span><br><span class="line">        <span class="keyword">while</span> level:</span><br><span class="line">            levelvalue=[]</span><br><span class="line">            nextlevel=[]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> level:</span><br><span class="line">                levelvalue.append(i.val)</span><br><span class="line">                <span class="keyword">if</span> i.left:</span><br><span class="line">                    nextlevel.append(i.left)</span><br><span class="line">                <span class="keyword">if</span> i.right:</span><br><span class="line">                    nextlevel.append(i.right)</span><br><span class="line">            <span class="keyword">if</span> reverseflag:</span><br><span class="line">                levelvalue.reverse()</span><br><span class="line">            <span class="keyword">if</span> levelvalue:</span><br><span class="line">                res.append(levelvalue)</span><br><span class="line">                <span class="comment"># for j in levelvalue:</span></span><br><span class="line">                <span class="comment">#     res.append(j) </span></span><br><span class="line">            reverseflag = <span class="keyword">not</span> reverseflag</span><br><span class="line">            level=nextlevel</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="60-把二叉树打印成多行"><a href="#60-把二叉树打印成多行" class="headerlink" title="60.把二叉树打印成多行"></a>60.把二叉树打印成多行</h3><p><strong>题目：</strong>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回二维列表[[1,2],[4,5]]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Print</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res=[]</span><br><span class="line">        level = [pRoot]</span><br><span class="line">        <span class="keyword">while</span> level:</span><br><span class="line">            levelvalue=[]</span><br><span class="line">            nextlevel=[]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> level:</span><br><span class="line">                levelvalue.append(i.val)</span><br><span class="line">                <span class="keyword">if</span> i.left:</span><br><span class="line">                    nextlevel.append(i.left)</span><br><span class="line">                <span class="keyword">if</span> i.right:</span><br><span class="line">                    nextlevel.append(i.right)</span><br><span class="line">            <span class="keyword">if</span> levelvalue:</span><br><span class="line">                res.append(levelvalue)</span><br><span class="line">            level = nextlevel</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="61-序列化二叉树-flag"><a href="#61-序列化二叉树-flag" class="headerlink" title="61.序列化二叉树(flag)"></a>61.序列化二叉树(flag)</h3><p><strong>题目：</strong>请实现两个函数，分别用来序列化和反序列化二叉树。</p>
<p><strong>思路：</strong>转变成前序遍历，空元素利用”#”代替，然后进行解序列。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"><span class="comment">#序列化指的是遍历二叉树为字符串；所谓反序列化指的是依据字符串重新构造成二叉树。</span></span><br><span class="line"><span class="comment">#当在遍历二叉树时碰到Null指针时，这些Null指针被序列化为一个特殊的字符“#”,结点之间的数值用逗号隔开。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Serialize</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">Pre_Order</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> root:</span><br><span class="line">                result.append(str(root.val))</span><br><span class="line">                Pre_Order(root.left)</span><br><span class="line">                Pre_Order(root.right)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result.append(<span class="string">'#'</span>)</span><br><span class="line">        result = []</span><br><span class="line">        Pre_Order(root)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">','</span>.join(result)</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Deserialize</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        s = s.split(<span class="string">','</span>)</span><br><span class="line">         </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">Change</span><span class="params">(num)</span>:</span></span><br><span class="line">            num[<span class="number">0</span>] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> num[<span class="number">0</span>] &lt; len(s):</span><br><span class="line">                <span class="keyword">if</span> s[num[<span class="number">0</span>]] == <span class="string">'#'</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">                root = TreeNode(int(s[num[<span class="number">0</span>]]))</span><br><span class="line">                root.left = Change(num)</span><br><span class="line">                root.right = Change(num)</span><br><span class="line">                <span class="keyword">return</span> root</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        num = [<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> Change(num)</span><br></pre></td></tr></table></figure>
<h3 id="62-二叉搜索树中的第K个节点"><a href="#62-二叉搜索树中的第K个节点" class="headerlink" title="62.二叉搜索树中的第K个节点"></a>62.二叉搜索树中的第K个节点</h3><p><strong>题目：</strong>给定一棵二叉搜索树，请找出其中的第k小的结点。例如（5，3，7，2，4，6，8）中，按结点数值大小顺序第三小结点的值为4。</p>
<p><strong>思路：</strong>中序遍历后，返回第K个节点值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回对应节点TreeNode</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.res = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">KthNode</span><span class="params">(self, pRoot, k)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment">#pnode=pRoot  # 为啥要加这一句呢？</span></span><br><span class="line">        self.sorttree(pRoot)</span><br><span class="line">        <span class="keyword">if</span> len(self.res)&lt;k <span class="keyword">or</span> k&lt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.res[k<span class="number">-1</span>]</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sorttree</span><span class="params">(self,pRoot)</span>:</span> <span class="comment"># 中序排序</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        left = self.sorttree(pRoot.left)</span><br><span class="line">        self.res.append(pRoot)</span><br><span class="line">        right = self.sorttree(pRoot.right)</span><br></pre></td></tr></table></figure>
<h3 id="63-数据流中的中位数"><a href="#63-数据流中的中位数" class="headerlink" title="63.数据流中的中位数"></a>63.数据流中的中位数</h3><p><strong>题目：</strong>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.arr=[]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Insert</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        self.arr.append(num)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetMedian</span><span class="params">(self,arr)</span>:</span> <span class="comment">#为啥这里要加 arr 作为输入,换为其他参数也行，必须要占位？</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        res=sorted(self.arr)</span><br><span class="line">        <span class="keyword">if</span> len(res)%<span class="number">2</span>==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> (res[len(res)//<span class="number">2</span><span class="number">-1</span>]+res[len(res)//<span class="number">2</span>])/<span class="number">2.0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> res[len(res)//<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<h3 id="64-滑动窗口的最大值"><a href="#64-滑动窗口的最大值" class="headerlink" title="64.滑动窗口的最大值"></a>64.滑动窗口的最大值</h3><p><strong>题目：</strong>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}，{2,3,4,2,6,[2,5,1]}。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxInWindows</span><span class="params">(self, num, size)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> size&lt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">if</span> size==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> num</span><br><span class="line">        res=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(num)-size+<span class="number">1</span>):</span><br><span class="line">            res.append(max(num[i:i+size]))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="65-矩阵中的路径-flag"><a href="#65-矩阵中的路径-flag" class="headerlink" title="65.矩阵中的路径(flag)"></a>65.矩阵中的路径(flag)</h3><p><strong>题目：</strong>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。例如 a b c e s f c s a d e e 这样的3 X 4 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</p>
<p><strong>思路：</strong>当起点第一个字符相同时，开始进行递归搜索，设计搜索函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPath</span><span class="params">(self, matrix, rows, cols, path)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(rows):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(cols):</span><br><span class="line">                <span class="keyword">if</span> matrix[i*cols+j]==path[<span class="number">0</span>]:</span><br><span class="line">                    <span class="keyword">if</span> self.findpath(list(matrix),rows,cols,path[<span class="number">1</span>:],i,j):</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findpath</span><span class="params">(self, matrix, rows, cols, path ,i ,j)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> path:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        matrix[i*cols+j]=<span class="string">'0'</span></span><br><span class="line">        <span class="keyword">if</span> j+<span class="number">1</span>&lt;cols <span class="keyword">and</span> matrix[i*cols+j+<span class="number">1</span>]==path[<span class="number">0</span>]:  <span class="comment">#j+1&lt;cols 这里是下标，不能等于</span></span><br><span class="line">            <span class="keyword">return</span> self.findpath(matrix, rows, cols, path[<span class="number">1</span>:],i,j+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">elif</span> j<span class="number">-1</span>&gt;=<span class="number">0</span> <span class="keyword">and</span> matrix[i*cols+j<span class="number">-1</span>]==path[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> self.findpath(matrix, rows, cols, path[<span class="number">1</span>:],i,j<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">elif</span> i+<span class="number">1</span>&lt;rows <span class="keyword">and</span> matrix[(i+<span class="number">1</span>)*cols+j]==path[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> self.findpath(matrix, rows, cols, path[<span class="number">1</span>:],i+<span class="number">1</span>,j)</span><br><span class="line">        <span class="keyword">elif</span> i<span class="number">-1</span>&gt;=<span class="number">0</span> <span class="keyword">and</span> matrix[(i<span class="number">-1</span>)*cols+j]==path[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> self.findpath(matrix, rows, cols, path[<span class="number">1</span>:],i<span class="number">-1</span>,j)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h3 id="66-机器人的运动范围"><a href="#66-机器人的运动范围" class="headerlink" title="66.机器人的运动范围"></a>66.机器人的运动范围</h3><p><strong>题目：</strong>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">movingCount</span><span class="params">(self, threshold, rows, cols)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment"># 回溯的出口 ： 所有self.findgrid回溯出口的不满足if条件就停止</span></span><br><span class="line">        matrix = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(cols)] <span class="keyword">for</span> j <span class="keyword">in</span> range(rows)]</span><br><span class="line">        count = self.findgrid(threshold,rows,cols,matrix,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findgrid</span><span class="params">(self,threshold,rows,cols,matrix,i,j)</span>:</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span>&lt;=i&lt;rows <span class="keyword">and</span> <span class="number">0</span>&lt;=j&lt;cols <span class="keyword">and</span> (sum(map(int, str(i) + str(j))) &lt;= threshold) <span class="keyword">and</span> matrix[i][j]==<span class="number">0</span>:</span><br><span class="line">            matrix[i][j] = <span class="number">1</span></span><br><span class="line">            count = <span class="number">1</span> + self.findgrid(threshold,rows,cols,matrix,i,j<span class="number">-1</span>)\</span><br><span class="line">            + self.findgrid(threshold,rows,cols,matrix,i,j+<span class="number">1</span>)\</span><br><span class="line">            + self.findgrid(threshold,rows,cols,matrix,i+<span class="number">1</span>,j)\</span><br><span class="line">            + self.findgrid(threshold,rows,cols,matrix,i<span class="number">-1</span>,j)</span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    
    
    
    
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/28/机器学习专题/朴素贝叶斯/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mosbyllc">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mosbyllc">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/28/机器学习专题/朴素贝叶斯/" itemprop="url">朴素贝叶斯</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-28T12:37:38+08:00">
                2018-08-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/机器学习专题/" itemprop="url" rel="index">
                    <span itemprop="name">机器学习专题</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3,056
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  13
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>注：这篇文章原文出处放在了下面的连接，原文已经写得非常清晰明了，这里有适当的修改和增加内容，写在这里是为了更好地查阅巩固。</p>
</blockquote>
<p><a href="https://plushunter.github.io/2017/02/15/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%EF%BC%8810%EF%BC%89%EF%BC%9A%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/" target="_blank" rel="noopener">戳我原文</a></p>
<p>朴素贝叶斯（Naive Bayes）是基于贝叶斯定理与特征条件假设的分类方法。</p>
<p>对于给定的训练数据集，首先基于特征条件独立假设学习输入、输出的联合分布；然后基于此模型，对给定的输入x，利用贝叶斯定理求出后验概率最大的输出y。</p>
<p>朴素贝叶斯实现简单，学习与预测的效率都很高，是一种常用的方法。</p>
<h1 id="朴素贝叶斯的学习与分类"><a href="#朴素贝叶斯的学习与分类" class="headerlink" title="朴素贝叶斯的学习与分类"></a>朴素贝叶斯的学习与分类</h1><h2 id="贝叶斯定理"><a href="#贝叶斯定理" class="headerlink" title="贝叶斯定理"></a>贝叶斯定理</h2><p>先看什么是条件概率</p>
<p>P(A|B)表示事件B已经发生的前提下，事件A发生的概率，叫做事件B发生下事件A的条件概率。其基本求解公式为</p>
<script type="math/tex; mode=display">
P\left(A|B\right)=\frac{P\left(AB\right)}{P\left(B\right)}</script><p>贝叶斯定理便是基于条件概率，通过P(A|B)来求P(B|A)：</p>
<script type="math/tex; mode=display">
P\left(B|A\right)=\frac{P\left(A|B\right)·P\left(B\right)}{P\left(A\right)}</script><p>顺便提一下，<strong>上式中的分母，可以根据全概率公式分解为</strong>：</p>
<script type="math/tex; mode=display">
P\left(A\right)=\sum_{i=1}^n{P\left(B_i\right)P\left(A|B_i\right)}</script><h2 id="特征条件独立假设"><a href="#特征条件独立假设" class="headerlink" title="特征条件独立假设"></a>特征条件独立假设</h2><p>这一部分开始朴素贝叶斯的理论推导，从中你会深刻地理解什么是特征条件独立假设。</p>
<p>给定训练数据集(X,Y)，其中每个样本X都包括nn维特征，即$x=(x_1,x_2,···,x_n)$，类标记集合含有K种类别，即$y=(y_1,y_2,···,y_k)$ </p>
<p>如果现在来了一个新样本x我们要怎么判断它的类别?从概率的角度来看，这个问题就是给定x，它属于哪个类别的概率更大。<strong>那么问题就转化为求解$P(y_1|x),P(y_2|x),P(y_k|x)$中最大的那个，即求后验概率最大的输出</strong>：$arg\underset{y_k}{\max}P\left(y_k|x\right)$ 。那$P(y_k|x)$怎么求解？答案就是贝叶斯定理</p>
<script type="math/tex; mode=display">
P\left(y_k|x\right)=\frac{P\left(x|y_k\right)·P\left(y_k\right)}{P\left(x\right)}</script><p>根据全概率公式，可以进一步分解上式中的分母：</p>
<script type="math/tex; mode=display">
P\left(y_k|x\right)=\frac{P\left(x|y_k\right)·P\left(y_k\right)}{\sum_{i=1}^n{P\left(x|y_k\right)P\left(y_k\right)}}
（公式1）</script><p><strong>先不管分母，分子中的$P(y_k)$是先验概率，根据训练集就可以简单地计算出来</strong>，而条件概率$P(x|y<em>k)=P(x_1,x_2,···,x_n|y_k)$它的参数规模是指数数量级别的，假设第$i$维特征$x_i$可取值的个数有$S_i$个，类别取值个数为k个，那么参数个数为$k\prod</em>{j=1}^n{S_j}$ </p>
<p>这显然是不可行的。针对这个问题，<strong>朴素贝叶斯算法对条件概率分布做了独立性的假设，通俗地讲就是说假设各个维度的特征 $x_1,x_2,···,x_n$互相独立，由于这是一个较强的假设</strong>，朴素贝叶斯算法也因此得名。在这个假设的前提上，条件概率可以转化为：</p>
<script type="math/tex; mode=display">
P\left(x|y_i\right)=P\left(x_1,x_2,···,x_n|y_i\right)=\prod_{i=1}^n{P\left(x_i|y_i\right)}
    （公式2）</script><p>这样参数规模就降到了$\sum_{i=1}^n{S_ik}$</p>
<p>以上就是针对条件概率所作出的特征条件独立性假设，至此，先验概率$P(y_k)$和条件概率$P(x|y_k)$的求解问题就都解决了，那么我们是不是可以求解我们所需要的后验概率$P(y_k|x)$了？</p>
<p>答案是肯定的。我们继续上面关于$P(y_k|x)$的推导，将公式2代入公式1中得到：</p>
<script type="math/tex; mode=display">
P\left(y_k|x\right)=\frac{P\left(y_k\right)\prod_{i=1}^n{P\left(x_i|y_k\right)}}{\sum_k{P\left(y_k\right)\prod_{i=1}^n{P\left(x_i|y_k\right)}}}</script><p>于是朴素贝叶斯分类器可表示为：</p>
<script type="math/tex; mode=display">
f\left(x\right)=arg\underset{y_k}{\max}P\left(y_k|x\right)=arg\underset{y_k}{\max}\frac{P\left(y_k\right)\prod_{i=1}^n{P\left(x_i|y_k\right)}}{\sum_k{P\left(y_k\right)\prod_{i=1}^n{P\left(x_i|y_k\right)}}}</script><p>因为对于所有的$y_k$，上式中的分母的值都是一样的（为什么？注意到全加符号就容易理解了），<strong>所以可以忽略分母部分，朴素贝叶斯分裂期最终表示为：</strong></p>
<script type="math/tex; mode=display">
f\left(x\right)=arg\underset{y_k}{\max}P\left(y_k\right)\prod_{i=1}^n{P\left(x_i|y_k\right)}</script><h1 id="朴素贝叶斯法的参数估计"><a href="#朴素贝叶斯法的参数估计" class="headerlink" title="朴素贝叶斯法的参数估计"></a>朴素贝叶斯法的参数估计</h1><h2 id="极大似然估计"><a href="#极大似然估计" class="headerlink" title="极大似然估计"></a>极大似然估计</h2><p>根据上述，可知朴素贝叶斯要学习的东西就是$P(Y=c<em>k)$和$P(X^{j}=a</em>{jl}|Y=c_k)$可以应用极大似然估计法估计相应的概率（简单讲，就是用样本来推断模型的参数，或者说是使得似然函数最大的参数）</p>
<p><strong>先验概率$P(Y=c_k)$的极大似然估计是</strong></p>
<script type="math/tex; mode=display">
P\left(Y=c_k\right)=\frac{\sum_{i=1}^N{I\left(y_i=c_k\right)}}{N},\,\,k=1,2,···,K</script><p><strong>也就是用样本中$c_k$的出现次数除以样本容量</strong>。</p>
<p>设第$j$个特征$x^{(j)}$可能取值的集合为${a<em>{j1},a</em>{j2},···,a<em>{jl}}$，**条件概率 $P(X^{j}=a</em>{jl}|Y=c_k)$的极大似然估计是**：</p>
<script type="math/tex; mode=display">
P\left(X^{\left(j\right)}=a_{jl}|Y=c_k\right)=\frac{\sum_{i=1}^N{I\left(x_{i}^{\left(j\right)}=a_{jl},y_{i=}c_k\right)}}{\sum_{i=1}^N{I\left(y_i=c_k\right)}}</script><p>式中，$x_i^j$是第$i$个样本的第$j$个特征。</p>
<h1 id="一个例题"><a href="#一个例题" class="headerlink" title="一个例题"></a>一个例题</h1><p>例题如下</p>
<p><img src="/2018/08/28/机器学习专题/朴素贝叶斯/01.png" alt></p>
<p><img src="/2018/08/28/机器学习专题/朴素贝叶斯/02.png" alt></p>
<h2 id="贝叶斯估计"><a href="#贝叶斯估计" class="headerlink" title="贝叶斯估计"></a>贝叶斯估计</h2><p>极大似然估计有一个隐患，假设训练数据中没有出现某种参数与类别的组合怎么办？比如上例中当Y=1对应的$X^{(1)}$的取值只有1和2。这样可能会出现所要估计的概率值为0的情况，但是这不代表真实数据中就没有这样的组合。这时会影响到后验概率的计算结果，使分类产生偏差。解决办法是贝叶斯估计。</p>
<p><strong>条件概率的贝叶斯估计</strong>：</p>
<script type="math/tex; mode=display">
P_{\lambda}\left(X^{\left(j\right)}=a_{jl}\parallel Y=c_k\right)=\frac{\sum_{i=1}^N{I\left(x_{i}^{\left(j\right)}=a_{jl},y_{i=}c_k\right)}+\lambda}{\sum_{i=1}^N{I\left(y_i=c_k\right)}+S_j\lambda}</script><p>其中$\lambda≥0$，<strong>$S_j$表示第$x_j$个特征可能取值的个数</strong>。<strong>分子和分母分别比极大似然估计多了一点东西</strong>，其意义为在随机变量各个取值的频数上赋予一个正数$λ≥0$。<strong>当$λ=0$时就是极大似然估计。常取$λ=1$，这时称为拉普拉斯平滑。</strong></p>
<p>先验概率的贝叶斯估计：（K为类别个数）</p>
<script type="math/tex; mode=display">
P_{\lambda}\left(Y=c_k\right)=\frac{\sum_{i=1}^N{I\left(y_i=c_k\right)}+\lambda}{N+K\lambda}</script><p>例题如下：套入公式计算即可</p>
<p><img src="/2018/08/28/机器学习专题/朴素贝叶斯/03.png" alt></p>
<p>上诉说的是$X<em>j$为普通离散型的情况。<strong>如果$X_j$是稀疏的离散值，即各个特征的出现概率很低</strong>，那么可以假设$X_j$服从伯努利分布，即特征$X_j$出现记为1，不出现记为0。**即我们只关注$X_j$是否出现，不关注$X_j$出现的次数，这样得到的$P\left(X^{\left(j\right)}=a</em>{jl}|Y=c<em>k\right)$是在是在样本类别$c_k$中$a</em>{jl}$出现的频率**，公式如下所示。其中$a_{jl}$取值为0和1。</p>
<script type="math/tex; mode=display">
P(X_j=a_{jl}|Y=C_k)=P(X_j|Y=C_k)a_{jl}+(1-P(X_j|Y=C_k))(1-a_{jl})</script><p><strong>如果$X_j$是连续值</strong>，那么假设$X<em>j$的先验概率为高斯分布(正态分布)，这样假设$P\left(X^{\left(j\right)}=a</em>{jl}|Y=c<em>k\right)$的概率分布公式如下所示。其**中$\mu_k$和$\sigma</em>{k}^2$是正态分布的期望和方差**，$\mu<em>k$为样本类别$C_k$中，所有$X_j$的平均值，$\sigma</em>{k}^2$为样本类别$C<em>k$中，所有$X_j$的方差，$\mu_k$和$\sigma</em>{k}^2$可以通过极大似然估计求得。</p>
<script type="math/tex; mode=display">
P(X_j=a_{jl}|Y=C_k)=\frac{1}{\sqrt{2 \pi \sigma^2}}exp(-\frac{(a_{jl}- \mu_k)^2}{2\sigma_{k}^{2}})</script><h1 id="python代码实现"><a href="#python代码实现" class="headerlink" title="python代码实现"></a>python代码实现</h1><h2 id="朴素贝叶斯文档分类"><a href="#朴素贝叶斯文档分类" class="headerlink" title="朴素贝叶斯文档分类"></a>朴素贝叶斯文档分类</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Created on 下午5:28 22 03 2017</span></span><br><span class="line"><span class="string">bayes algorithm: classify a words as good or bad   [text classify]</span></span><br><span class="line"><span class="string">@author: plushunter</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Naive_Bayes</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._creteria = <span class="string">"NB"</span></span><br><span class="line">    <span class="comment">#创建不重复词集</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_creatVocabList</span><span class="params">(self,dataSet)</span>:</span></span><br><span class="line">        vocabSet = set([])  <span class="comment"># 创建一个空的SET</span></span><br><span class="line">        <span class="keyword">for</span> document <span class="keyword">in</span> dataSet:</span><br><span class="line">            vocabSet = vocabSet | set(document)  <span class="comment"># 并集</span></span><br><span class="line">        <span class="keyword">return</span> list(vocabSet)  <span class="comment"># 返回不重复词表（SET的特性）</span></span><br><span class="line">    <span class="comment">#文档词集向量模型</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_setOfWordToVec</span><span class="params">(self,vocabList, inputSet)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        功能:给定一行词向量inputSet，将其映射至词库向量vocabList，出现则标记为1，否则标记为0.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        returnVec = [<span class="number">0</span>] * len(vocabList)</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> inputSet:</span><br><span class="line">            <span class="keyword">if</span> word <span class="keyword">in</span> vocabList:</span><br><span class="line">                returnVec[vocabList.index(word)] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> returnVec</span><br><span class="line">    <span class="comment">#文档词袋模型</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_bagOfsetOfWordToVec</span><span class="params">(self,vocabList, inputSet)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        功能：对每行词使用第二种统计策略，统计单个词的个数，然后映射到此库中</span></span><br><span class="line"><span class="string">        输出：一个n维向量，n为词库的长度，每个取值为单词出现的次数</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        returnVec = [<span class="number">0</span>] * len(vocabList)</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> inputSet:</span><br><span class="line">            <span class="keyword">if</span> word <span class="keyword">in</span> vocabList:</span><br><span class="line">                returnVec[vocabList.index(word)] += <span class="number">1</span> <span class="comment">#更新此处代码</span></span><br><span class="line">        <span class="keyword">return</span> returnVec</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_trainNB0</span><span class="params">(self,trainMatrix, trainCategory)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        输入：训练词矩阵trainMatrix与类别标签trainCategory,格式为Numpy矩阵格式</span></span><br><span class="line"><span class="string">        功能：计算条件概率p0Vect、p1Vect和类标签概率pAbusive</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        numTrainDocs = len(trainMatrix)<span class="comment">#样本个数</span></span><br><span class="line">        numWords = len(trainMatrix[<span class="number">0</span>])<span class="comment">#特征个数，此处为词库长度</span></span><br><span class="line">        pAbusive = sum(trainCategory) / float(numTrainDocs)<span class="comment">#计算负样本出现概率（先验概率）</span></span><br><span class="line">        p0Num = ones(numWords)<span class="comment">#初始词的出现次数为1，以防条件概率为0，影响结果</span></span><br><span class="line">        p1Num = ones(numWords)<span class="comment">#同上</span></span><br><span class="line">        p0Denom = <span class="number">2.0</span><span class="comment">#类标记为2，使用拉普拉斯平滑法,</span></span><br><span class="line">        p1Denom = <span class="number">2.0</span></span><br><span class="line">        <span class="comment">#按类标记进行聚合各个词向量</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(numTrainDocs):</span><br><span class="line">            <span class="keyword">if</span> trainCategory[i] == <span class="number">0</span>:</span><br><span class="line">                p0Num += trainMatrix[i]</span><br><span class="line">                p0Denom += sum(trainMatrix[i])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p1Num += trainMatrix[i]</span><br><span class="line">                p1Denom += sum(trainMatrix[i])</span><br><span class="line">        p1Vect = log(p1Num / p1Denom)<span class="comment">#计算给定类标记下，词库中出现某个单词的概率</span></span><br><span class="line">        p0Vect = log(p0Num / p0Denom)<span class="comment">#取log对数，防止条件概率乘积过小而发生下溢</span></span><br><span class="line">        <span class="keyword">return</span> p0Vect, p1Vect, pAbusive</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_classifyNB</span><span class="params">(self,vec2Classify, p0Vec, p1Vec, pClass1)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        该算法包含四个输入:</span></span><br><span class="line"><span class="string">        vec2Classify表示待分类的样本在词库中的映射集合，</span></span><br><span class="line"><span class="string">        p0Vec表示条件概率P(wi|c=0)P(wi|c=0)，</span></span><br><span class="line"><span class="string">        p1Vec表示条件概率P(wi|c=1)P(wi|c=1)，</span></span><br><span class="line"><span class="string">        pClass1表示类标签为1时的概率P(c=1)P(c=1)。</span></span><br><span class="line"><span class="string">        p1=ln[p(w1|c=1)p(w2|c=1)…p(wn|c=1)p(c=1)]</span></span><br><span class="line"><span class="string">        p0=ln[p(w1|c=0)p(w2|c=0)…p(wn|c=0)p(c=0)]</span></span><br><span class="line"><span class="string">        log取对数为防止向下溢出</span></span><br><span class="line"><span class="string">        功能:使用朴素贝叶斯进行分类,返回结果为0/1</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        p1 = sum(vec2Classify * p1Vec) + log(pClass1)</span><br><span class="line">        p0 = sum(vec2Classify * p0Vec) + log(<span class="number">1</span> - pClass1)</span><br><span class="line">        <span class="keyword">if</span> p1 &gt; p0:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="comment">#test</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">testingNB</span><span class="params">(self,testSample)</span>:</span></span><br><span class="line">        <span class="string">"step1：加载数据集与类标号"</span></span><br><span class="line">        listOPosts, listClasses = loadDataSet()</span><br><span class="line">        <span class="string">"step2：创建词库"</span></span><br><span class="line">        vocabList = self._creatVocabList(listOPosts)</span><br><span class="line">        <span class="string">"step3：计算每个样本在词库中出现的情况"</span></span><br><span class="line">        trainMat = []</span><br><span class="line">        <span class="keyword">for</span> postinDoc <span class="keyword">in</span> listOPosts:</span><br><span class="line">            trainMat.append(self._bagOfsetOfWordToVec(vocabList, postinDoc))</span><br><span class="line">        p0V, p1V, pAb = self._trainNB0(trainMat, listClasses)</span><br><span class="line">        <span class="string">"step4：测试"</span></span><br><span class="line">        thisDoc = array(self._bagOfsetOfWordToVec(vocabList, testSample))</span><br><span class="line">        result=self._classifyNB(thisDoc, p0V, p1V, pAb)</span><br><span class="line">        <span class="keyword">print</span> testSample, <span class="string">'classified as:'</span>, result</span><br><span class="line">        <span class="comment"># return result</span></span><br><span class="line"><span class="comment">###</span></span><br><span class="line"><span class="comment"># 加载数据集</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loadDataSet</span><span class="params">()</span>:</span></span><br><span class="line">    postingList = [[<span class="string">'my'</span>, <span class="string">'dog'</span>, <span class="string">'has'</span>, <span class="string">'flea'</span>, <span class="string">'problems'</span>, <span class="string">'help'</span>, <span class="string">'please'</span>],</span><br><span class="line">                   [<span class="string">'maybe'</span>, <span class="string">'not'</span>, <span class="string">'take'</span>, <span class="string">'him'</span>, <span class="string">'to'</span>, <span class="string">'dog'</span>, <span class="string">'park'</span>, <span class="string">'stupid'</span>],</span><br><span class="line">                   [<span class="string">'my'</span>, <span class="string">'dalmation'</span>, <span class="string">'is'</span>, <span class="string">'so'</span>, <span class="string">'cute'</span>, <span class="string">'I'</span>, <span class="string">'love'</span>, <span class="string">'him'</span>],</span><br><span class="line">                   [<span class="string">'stop'</span>, <span class="string">'posting'</span>, <span class="string">'stupid'</span>, <span class="string">'worthless'</span>, <span class="string">'garbage'</span>],</span><br><span class="line">                   [<span class="string">'mr'</span>, <span class="string">'licks'</span>, <span class="string">'ate'</span>, <span class="string">'my'</span>, <span class="string">'steak'</span>, <span class="string">'how'</span>, <span class="string">'to'</span>, <span class="string">'stop'</span>, <span class="string">'him'</span>],</span><br><span class="line">                   [<span class="string">'quit'</span>, <span class="string">'buying'</span>, <span class="string">'worthless'</span>, <span class="string">'dog'</span>, <span class="string">'food'</span>, <span class="string">'stupid'</span>]]</span><br><span class="line">    classVec = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]  <span class="comment"># 1 is abusive, 0 not</span></span><br><span class="line">    <span class="keyword">return</span> postingList, classVec</span><br><span class="line"><span class="comment">#测试</span></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    clf = Naive_Bayes()</span><br><span class="line">    testEntry = [[<span class="string">'love'</span>, <span class="string">'my'</span>, <span class="string">'girl'</span>, <span class="string">'friend'</span>],</span><br><span class="line">                 [<span class="string">'stupid'</span>, <span class="string">'garbage'</span>],</span><br><span class="line">                 [<span class="string">'Haha'</span>, <span class="string">'I'</span>, <span class="string">'really'</span>, <span class="string">"Love"</span>, <span class="string">"You"</span>],</span><br><span class="line">                 [<span class="string">'This'</span>, <span class="string">'is'</span>, <span class="string">"my"</span>, <span class="string">"dog"</span>],</span><br><span class="line">                 [<span class="string">'maybe'</span>,<span class="string">'stupid'</span>,<span class="string">'worthless'</span>]]</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> testEntry:</span><br><span class="line">        clf.testingNB(item)</span><br></pre></td></tr></table></figure>
<h2 id="使用朴素贝叶斯过滤垃圾邮件"><a href="#使用朴素贝叶斯过滤垃圾邮件" class="headerlink" title="使用朴素贝叶斯过滤垃圾邮件"></a>使用朴素贝叶斯过滤垃圾邮件</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Created on 下午8:47 22 03 2017</span></span><br><span class="line"><span class="string">Email_Classify </span></span><br><span class="line"><span class="string">@author: plushunter </span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> Bayes</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># mysent='This book is the best book on Python or M.L I have ever laid eyes upon.'</span></span><br><span class="line"><span class="comment"># regEx = re.compile('\\W*')</span></span><br><span class="line"><span class="comment"># listOfTokens=regEx.split(mysent)</span></span><br><span class="line"><span class="comment"># tok=[tok.upper() for tok in listOfTokens if len(tok)&gt;0]</span></span><br><span class="line"><span class="comment"># print tok</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># emailText=open('email/ham/6.txt').read()</span></span><br><span class="line"><span class="comment"># listOfTokens=regEx.split(emailText)</span></span><br><span class="line"><span class="comment"># print listOfTokens</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">textParse</span><span class="params">(bigString)</span>:</span></span><br><span class="line">    <span class="keyword">import</span> re</span><br><span class="line">    listOfTokens=re.split(<span class="string">r'\w*'</span>,bigString)</span><br><span class="line">    <span class="keyword">return</span> [tok.lower() <span class="keyword">for</span> tok <span class="keyword">in</span> listOfTokens <span class="keyword">if</span> len(tok)&gt;<span class="number">2</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spamTest</span><span class="params">()</span>:</span></span><br><span class="line">    clf = Bayes.Naive_Bayes()</span><br><span class="line">    docList=[]</span><br><span class="line">    classList=[]</span><br><span class="line">    fullText=[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">26</span>):</span><br><span class="line">        wordList=textParse(open(<span class="string">'email/spam/%d.txt'</span>%i).read())</span><br><span class="line">        docList.append(wordList)</span><br><span class="line">        fullText.extend(wordList)</span><br><span class="line">        classList.append(<span class="number">1</span>)</span><br><span class="line">        wordList=textParse(open(<span class="string">'email/ham/%i.txt'</span>%i).read())</span><br><span class="line">        docList.append(wordList)</span><br><span class="line">        fullText.extend(wordList)</span><br><span class="line">        classList.append(<span class="number">0</span>)</span><br><span class="line">    vocabList=clf._creatVocabList(docList)</span><br><span class="line">    trainingSet=range(<span class="number">50</span>);testSet=[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        randIndex=int(random.uniform(<span class="number">0</span>,len(trainingSet)))</span><br><span class="line">        testSet.append(trainingSet[randIndex])</span><br><span class="line">        <span class="keyword">del</span>(trainingSet[randIndex])</span><br><span class="line">    trainMatix=[];trainClasses=[]</span><br><span class="line">    <span class="keyword">for</span> docIndex <span class="keyword">in</span> trainingSet:</span><br><span class="line">        trainMatix.append(clf._bagOfsetOfWordToVec(vocabList,docList[docIndex]))</span><br><span class="line">        trainClasses.append(classList[docIndex])</span><br><span class="line">    p0V,p1V,pSpam=clf._trainNB0(array(trainMatix),array(trainClasses))</span><br><span class="line">    errorCount = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> docIndex <span class="keyword">in</span> testSet:</span><br><span class="line">        wordVector = clf._bagOfsetOfWordToVec(vocabList,docList[docIndex])</span><br><span class="line">        <span class="keyword">if</span> clf._classifyNB(array(wordVector), p0V, p1V, pSpam)!=classList[docIndex]:</span><br><span class="line">            errorCount+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'the error rate is :'</span>,float(errorCount)/len(testSet)</span><br></pre></td></tr></table></figure>
<h1 id="朴素贝叶斯优缺点"><a href="#朴素贝叶斯优缺点" class="headerlink" title="朴素贝叶斯优缺点"></a>朴素贝叶斯优缺点</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li>具有稳定的分类效率。</li>
<li>对缺失数据不敏感，算法也比较简单。</li>
<li>对小规模数据表现良好，能处理多分类任务，适合增量式训练。尤其是数据量超出内存后，我们可以一批批的去增量训练。</li>
</ul>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li>对输入数据的表达形式比较敏感，需针对不同类型数据采用不同模型。</li>
<li>由于我们是使用数据加先验概率预测后验概率，所以分类决策存在一定的错误率。</li>
<li>假设各特征之间相互独立，但实际生活中往往不成立，因此对特征个数比较多或特征之间相关性比较大的数据来说，分类效果可能不是太好。</li>
</ul>

          
        
      
    </div>
    
    
    
    
    
    
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/27/机器学习专题/最大期望算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mosbyllc">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mosbyllc">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/27/机器学习专题/最大期望算法/" itemprop="url">最大期望算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-27T21:38:20+08:00">
                2018-08-27
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/机器学习专题/" itemprop="url" rel="index">
                    <span itemprop="name">机器学习专题</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3,253
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  13
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>注：这篇文章原文出处放在了下面的连接，有适当的修改和增加内容，写在这里是为了更好地查阅巩固。</p>
</blockquote>
<p><a href="https://weizhixiaoyi.com/2018/05/09/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%9C%80%E5%A4%A7%E6%9C%9F%E6%9C%9B-EM-%E7%AE%97%E6%B3%95/" target="_blank" rel="noopener">戳我原文</a></p>
<h1 id="EM算法简介"><a href="#EM算法简介" class="headerlink" title="EM算法简介"></a>EM算法简介</h1><p>最大期望算法（Expectation Maximization，简称EM算法）是在<strong>概率模型中寻找参数最大似然估计</strong>或者最大后验估计的算法，<strong>其中概率模型依赖于无法观测的隐藏变量</strong>。其主要思想就是通过迭代来建立完整数据的对数似然函数的期望界限，然后最大化不完整数据的对数似然函数。最大期望算法是一种迭代优化算法，其计算方法是每次迭代分为期望(E)步和最大(M)步。</p>
<h1 id="EM算法实例"><a href="#EM算法实例" class="headerlink" title="EM算法实例"></a>EM算法实例</h1><p>假如现在我们有两枚硬币1和2，随机抛掷后面朝上概率分别为P1，P2。为了估计两硬币概率，我们做如下实验，每次取一枚硬币，连掷5次后得到如下结果。</p>
<p><img src="/2018/08/27/机器学习专题/最大期望算法/01.jpg" alt></p>
<p>我们可以很方便的估计出硬币1概率P1=0.4，硬币2概率P2=0.5。</p>
<script type="math/tex; mode=display">
P1=\frac{3+1+2}{15}=0.4</script><script type="math/tex; mode=display">
P2=\frac{2+3}{10}=0.5</script><p>下面我们增加问题难度。如果并不知道每次投掷时所使用的硬币标记，那么如何估计P1和P2呢?</p>
<p><img src="/2018/08/27/机器学习专题/最大期望算法/02.jpg" alt></p>
<p>此时我们加入<strong>隐含变量z</strong>，可以把它认为是一个5维的向量(z1,z2,z3,z4,z5)，代表每次投掷时所使用的硬币。比如z1就代表第一轮投掷时所使用的是硬币1还是2，<strong>我们必须先估计出z，然后才能进一步估计P1和P2</strong></p>
<p><strong>我们先随机初始化一个P1和P2，用它来估计z，然后基于z按照最大似然概率方法去估计新的P1和P2.</strong>例如假设P1=0.2和P2=0.7，然后我们看看第一轮投掷的最可能是哪个硬币。如果是硬币1，得出3正2反的概率为0.2×0.2×0.2×0.8×0.8=0.00512，如果是硬币2，得出3正2反的概率为0.7×0.7×0.7×0.3×0.3=0.03087。然后依次求出其他4轮中的相应概率，接下来便可根据最大似然方法得到每轮中最有可能的硬币。</p>
<p><img src="/2018/08/27/机器学习专题/最大期望算法/03.jpg" alt></p>
<p>我们把上面的值作为z的估计值(2,1,1,2,1)，然后按照最大似然概率方法来估计新的P1和P2。得到</p>
<script type="math/tex; mode=display">
P1=\frac{2+1+2}{15}=0.33</script><script type="math/tex; mode=display">
P2=\frac{3+3}{10}=0.6</script><p>可以预估，我们继续按照上面思路，用估计出的P1和P2再来估计z，再用z来估计新的P1和P2，反复迭代下去，可以最终得到P1=0.4，P2=0.5。然后无论怎样迭代，P1和P2的值都会保持0.4和0.5不变，于是我们就找到P1和P2的最大似然估计。</p>
<p>上面我们用最大似然方法估计出z值，然后再用z值按照最大似然概率方法估计新的P1和P2。也就是说，我们使用了最有可能的z值，而不是所有的z值。如果考虑所有可能的z值，对每一个z值都估计出新的P1和P2，将每一个z值概率大小作为权重，将所有新的P1和P2分别加权相加，这样估计出的P1和P2是否会更优呢?</p>
<p>但所有的z值共有2^5=32种，我们是否进行32次估计呢？<strong>当然不是，我们利用期望来简化运算</strong>。</p>
<p><img src="/2018/08/27/机器学习专题/最大期望算法/04.jpg" alt></p>
<p>利用上面表格，我们可以算出每轮投掷种使用硬币1或者使用硬币2的概率。比如第一轮使用硬币1的概率</p>
<script type="math/tex; mode=display">
z_1=\frac{0.00512}{0.00512+0.03087}=0.14</script><p>相应的算出其他4轮的概率。</p>
<p><img src="/2018/08/27/机器学习专题/最大期望算法/05.jpg" alt></p>
<p><strong>上表中表示期望值</strong>，例如0.86表示此轮中使用硬币2的概率是0.86。前面方法我们按照最大似然概率直接将第一轮估计为硬币2，此时我们更加严谨，只说有0.14的概率是硬币1，有0.86的概率是硬币2。<strong>这样我们在估计P1或者P2时，就可以用上全部的数据，而不是部分的数据。此步我们实际上是估计出z的概率分布，称为E步。</strong></p>
<p>按照期望最大似然概率的法则来<strong>估计出新的P1和P2</strong>。以P1估计为例，第一轮的3正2反相当于有0.14×3=0.42的概率为正，有0.14×2的概率为反。然后依次计算出其他四轮。那么我们可以得到P1概率，可以看到改变了z的估计方法后，<strong>新估计出的P1要更加接近0.4，原因是我们使用了所有抛掷的数据，而不是部分的数据。此步中我们根据E步中求出z的概率分布，依据最大似然概率法则去估计P1和P2，称为M步</strong>。</p>
<p><img src="/2018/08/27/机器学习专题/最大期望算法/06.jpg" alt></p>
<script type="math/tex; mode=display">
P1=\frac{4.22}{4.22+7.98}=0.35</script><p>上面我们是通过迭代来得到P1和P2，结果更接近真实的P1和P2。</p>
<h1 id="EM算法推导"><a href="#EM算法推导" class="headerlink" title="EM算法推导"></a>EM算法推导</h1><h2 id="Jensen不等式"><a href="#Jensen不等式" class="headerlink" title="Jensen不等式"></a>Jensen不等式</h2><p>Jensen不等式表述如下：</p>
<p>如果f是凸函数，x是随机变量，那么：$E[f(x)]\geq f(E[x])$ ,特别地，如果f是严格凸函数，那么当且仅当$P(x=E[x])=1$(也就是说x是常量)，$E[f(x)]=f(E[x])$ </p>
<p>通过下面这张图，我们可以加深理解：</p>
<p><img src="/2018/08/27/机器学习专题/最大期望算法/07.jpg" alt></p>
<p>上图中，函数f是凸函数，X是随机变量，有0.5的概率为a，有0.5的概率是b（就像抛硬币一样）。X的期望值就是a和b的中值了，图中可以看到$E[f(x)]\geq f(E[x])$成立.</p>
<h2 id="极大似然估计"><a href="#极大似然估计" class="headerlink" title="极大似然估计"></a>极大似然估计</h2><p>EM算法推导过程中，会使用到极大似然估计参数。</p>
<p>极大似然估计是一种概率论在统计学的应用。<strong>已知某个随机样本满足某种概率分布，但是其中具体的参数不清楚，参数估计就是通过若干次试验，观察结果，利用结果推出参数的大概值</strong>。极大似然估计建立在这样的思想上：已知某个参数能使这个样本出现的概率最大，我们当然不会再去选择其他小概率的样本，所以干脆就把这个参数作为估计的真实值。</p>
<p>这里再给出求极大似然估计值的一般步骤：</p>
<ul>
<li>1）写出似然函数；</li>
<li>2）对似然函数取对数，并整理；</li>
<li>3）求导数，令导数为0，得到似然方程；</li>
<li>4）解似然方程，得到的参数即为所求；</li>
</ul>
<h2 id="EM算法推导-1"><a href="#EM算法推导-1" class="headerlink" title="EM算法推导"></a>EM算法推导</h2><p>对于m个样本观察数据$x=(x^{(1)},x^{(2)},x^{(3)},…,x^{(m)})$，找出样本的模型参数θ，极大化模型分布的对数似然函数如下所示</p>
<script type="math/tex; mode=display">
\theta =\arg \max_{\theta} \sum _{i=1}^{m}logP(x^{(i)};\theta)</script><p>如果我们得到的观察数据有未观察到的隐含数据$z=(z^{(1)},z^{(2)},z^{(3)},…,z^{(m)})$，此时我们极大化模型分布的对数似然函数如下</p>
<script type="math/tex; mode=display">
\theta =\arg \max_{\theta} \sum _{i=1}^{m}logP(x^{(i)};\theta) \\ \\ \\ =\arg \max_{\theta} \sum _{i=1}^{m}log\sum _{z^{(i)}}P(x^{(i)},z^{(i)};\theta)</script><p>上面方程是无法直接求出θ的，因此需要一些特殊技巧，在此我们引入<strong>Jensen不等式</strong>。</p>
<p>我们再回到上述推导过程，得到如下方程式。</p>
<script type="math/tex; mode=display">
\sum _{i=1}^{m}log\sum _{z^{(i)}}P(x^{(i)},z^{(i)};\theta) \\ \\ \\ =\sum _{i=1}^{m}log\sum _{z^{(i)}}Q_i(z^{(i)})\frac{P(x^{(i)},z^{(i)};\theta) }{Q_i(z^{(i)})}\ \ \ \ \ \ \ (1) \\ \\ \\ \ge \sum _{i=1}^{m}\sum _{z^{(i)}}Q_i(z^{(i)})log\frac{P(x^{(i)},z^{(i)};\theta) }{Q_i(z^{(i)})} \ \ \ \ \ \ \ (2)</script><p>我们来解释下怎样得到的方程式(1)和方程式(2)，上面(1)式中引入一个未知的新的分布$Q_i(z^{(i)})$，第二式用到Jensen不等式。</p>
<p>首先log函数是凹函数，那么E[f(X)]≤f(E[X])，也就是f(E(X))≥E(f(X))。其中$\sum <em>{z^{(i)}}Q_i(z^{(i)})\frac{P(x^{(i)},z^{(i)};\theta) }{Q_i(z^{(i)})}$ 是$\frac{P(x^{(i)},z^{(i);\theta})}{Q_i(z^{(i)})}$的数学期望，那么$log\sum </em>{z^{(i)}}Q<em>i(z^{(i)})\frac{P(x^{(i)},z^{(i)};\theta) }{Q_i(z^{(i)})}$ 便相当于f(E(X))，同时$\sum </em>{z^{(i)}}Q_i(z^{(i)})log\frac{P(x^{(i)},z^{(i)};\theta) }{Q_i(z^{(i)})}$相当于E(f(X))，因此我们便得到上述方程式(1)(2)。</p>
<p>如果要满足Jensen不等式的等号，那么需要满足X为常量，即为</p>
<script type="math/tex; mode=display">
\frac{P(x^{(i)},z^{(i)};\theta)}{Q_i(z^{(i)})}=c,\ c为常量</script><p>那么稍加改变能够得到</p>
<script type="math/tex; mode=display">
c Q_i(z^{(i)})=P(x^{(i)},z^{(i)};\theta)\ ,c为常量</script><script type="math/tex; mode=display">
\sum_z c\  Q_i(z^{(i)})= \sum _z P(x^{(i)},z^{(i)};\theta)= c</script><p>因此得到下列方程，<strong>其中方程(3)利用到条件概率公式</strong>。</p>
<script type="math/tex; mode=display">
Q_i(z^{(i)})=\frac{P(x^{(i)},z^{(i)};\theta)}{c}=\frac{P(x^{(i)},z^{(i)};\theta)}{\sum _z P(x^{(i)},z^{(i)};\theta)}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \</script><script type="math/tex; mode=display">
=\frac{P(x^{(i)},z^{(i)};\theta)}{ P(x^{(i)};\theta)}=P(z^{(i)}|x^{(i)};\theta)  \ \ \ \ \ \ \ \  \ \ \ \ \ \   (3)</script><p>如果$Q_i(z^{(i)})=P(z^{(i)}|x^{(i)};\theta)$ 那么第(2)式就是我们隐藏数据的对数似然的下界。<strong>如果我们能极大化方程式(2)的下界，则也在尝试极大化我们的方程式(1)</strong>。即我们需要最大化下式</p>
<script type="math/tex; mode=display">
\arg \max _{\theta} \sum _{i=1}^{m}\sum _{z^{(i)}}Q_i(z^{(i)})log\frac{P(x^{(i)},z^{(i)};\theta) }{Q_i(z^{(i)})}</script><p>去掉上式中常数部分，则我们需要极大化的对数似然下界为</p>
<script type="math/tex; mode=display">
\arg \max _{\theta} \sum _{i=1}^{m}\sum _{z^{(i)}}Q_i(z^{(i)})[log P(x^{(i)},z^{(i)};\theta)-log {Q_i(z^{(i)})}]</script><script type="math/tex; mode=display">
=\arg \max _{\theta} \sum _{i=1}^{m}\sum _{z^{(i)}}Q_i(z^{(i)})log P(x^{(i)},z^{(i)};\theta)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (4)</script><p>注意到上式中$Q<em>i(z^{(i)})$ 是一个分布，因此$\sum </em>{z^{(i)}}Q_i(z^{(i)})log P(x^{(i)},z^{(i)};\theta)$ 可以理解为$logP(x^{(i)},z^{(i)};\theta)$ 基于条件概率分布$Q_i(z^{(i)})$的期望，也就是我们EM算法中<strong>E步</strong>。极大化方程式(4)也就是我们EM算法中的<strong>M步</strong>。</p>
<p>到这里，<strong>我们推出了在固定参数θ后，使下界拉升的Q(z)的计算公式就是后验概率（条件概率），解决了Q(z)如何选择的问题。此步就是EM算法的E步，目的是建立L(θ)的下界。接下来的M步，目的是在给定Q(z)后，调整θ，从而极大化L(θ)的下界J（在固定Q(z)后，下界还可以调整的更大）</strong>。那么一般的EM算法的步骤如下：</p>
<ul>
<li><p>第一步：初始化分布参数θ；</p>
</li>
<li><p>第二步：重复E步和M步直到收敛：</p>
<p>E步：根据参数的初始值或上一次迭代的模型参数来计算出的因变量的后验概率（条件概率），其实就是隐变量的期望值，来作为隐变量的当前估计值：</p>
<script type="math/tex; mode=display">
 Q_i\left(z^{\left(i\right)}\right)=p\left(z^{\left(i\right)}|x^{\left(i\right)};\theta\right)</script><p>M步：最大化似然函数从而获得新的参数值：</p>
<script type="math/tex; mode=display">
\theta :=arg\underset{\theta}{\max}\sum_i{\sum_{z^{\left(i\right)}}{Q_i\left(z^{\left(i\right)}\right)\log\frac{p\left(x^{\left(i\right)},z^{\left(i\right)};\theta\right)}{Q_i\left(z^{\left(i\right)}\right)}}}</script></li>
</ul>
<p>EM算法可以保证收敛到一个稳定点，但是却不能保证收敛到全局的极大值点，因此它是局部最优的算法。当然，如果我们的优化目标L(θ,θj)是凸的，则EM算法可以保证收敛到全局最大值，这点和梯度下降法中迭代算法相同。</p>
<h1 id="Sklearn实现EM算法"><a href="#Sklearn实现EM算法" class="headerlink" title="Sklearn实现EM算法"></a>Sklearn实现EM算法</h1><p>高斯混合模型(GMM)使用高斯分布作为参数模型，利用期望最大(EM)算法进行训练，有兴趣了解高斯混合模型的同学可以去<a href="https://mp.weixin.qq.com/s?src=11&amp;timestamp=1525932817&amp;ver=867&amp;signature=U4UxviydVELD71Ju*bRWvh0ziFU57aNoPTZkVu5ShBEH7lxe1PLqxQnZ-xVSFgXdw5GcsWcYF5W1llR4dQ2yrsj0t2syeXgEggjm*budZlpZdMQMLOcXB-FnvKKlkV2H&amp;new=1" target="_blank" rel="noopener">这儿</a>。下列代码来自于<a href="http://scikit-learn.org/stable/auto_examples/mixture/plot_gmm_covariances.html#sphx-glr-auto-examples-mixture-plot-gmm-covariances-py" target="_blank" rel="noopener">Sklearn官网GMM模块</a>，利用高斯混合模型确定iris聚类。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib <span class="keyword">as</span> mpl</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">from</span> sklearn.mixture <span class="keyword">import</span> GaussianMixture</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> StratifiedKFold</span><br><span class="line"></span><br><span class="line">colors = [<span class="string">'navy'</span>, <span class="string">'turquoise'</span>, <span class="string">'darkorange'</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_ellipses</span><span class="params">(gmm, ax)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> n, color <span class="keyword">in</span> enumerate(colors):</span><br><span class="line">        <span class="keyword">if</span> gmm.covariance_type == <span class="string">'full'</span>:</span><br><span class="line">            covariances = gmm.covariances_[n][:<span class="number">2</span>, :<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">elif</span> gmm.covariance_type == <span class="string">'tied'</span>:</span><br><span class="line">            covariances = gmm.covariances_[:<span class="number">2</span>, :<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">elif</span> gmm.covariance_type == <span class="string">'diag'</span>:</span><br><span class="line">            covariances = np.diag(gmm.covariances_[n][:<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">elif</span> gmm.covariance_type == <span class="string">'spherical'</span>:</span><br><span class="line">            covariances = np.eye(gmm.means_.shape[<span class="number">1</span>]) * gmm.covariances_[n]</span><br><span class="line">        v, w = np.linalg.eigh(covariances)</span><br><span class="line">        u = w[<span class="number">0</span>] / np.linalg.norm(w[<span class="number">0</span>])</span><br><span class="line">        angle = np.arctan2(u[<span class="number">1</span>], u[<span class="number">0</span>])</span><br><span class="line">        angle = <span class="number">180</span> * angle / np.pi  <span class="comment"># convert to degrees</span></span><br><span class="line">        v = <span class="number">2.</span> * np.sqrt(<span class="number">2.</span>) * np.sqrt(v)</span><br><span class="line">        ell = mpl.patches.Ellipse(gmm.means_[n, :<span class="number">2</span>], v[<span class="number">0</span>], v[<span class="number">1</span>],</span><br><span class="line">                                  <span class="number">180</span> + angle, color=color)</span><br><span class="line">        ell.set_clip_box(ax.bbox)</span><br><span class="line">        ell.set_alpha(<span class="number">0.5</span>)</span><br><span class="line">        ax.add_artist(ell)</span><br><span class="line"></span><br><span class="line">iris = datasets.load_iris()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Break up the dataset into non-overlapping training (75%)</span></span><br><span class="line"><span class="comment"># and testing (25%) sets.</span></span><br><span class="line">skf = StratifiedKFold(n_splits=<span class="number">4</span>)</span><br><span class="line"><span class="comment"># Only take the first fold.</span></span><br><span class="line">train_index, test_index = next(iter(skf.split(iris.data, iris.target)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">X_train = iris.data[train_index]</span><br><span class="line">y_train = iris.target[train_index]</span><br><span class="line">X_test = iris.data[test_index]</span><br><span class="line">y_test = iris.target[test_index]</span><br><span class="line"></span><br><span class="line">n_classes = len(np.unique(y_train))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Try GMMs using different types of covariances.</span></span><br><span class="line">estimators = dict((cov_type, GaussianMixture(n_components=n_classes,</span><br><span class="line">                   covariance_type=cov_type, max_iter=<span class="number">20</span>, random_state=<span class="number">0</span>))</span><br><span class="line">                  <span class="keyword">for</span> cov_type <span class="keyword">in</span> [<span class="string">'spherical'</span>, <span class="string">'diag'</span>, <span class="string">'tied'</span>, <span class="string">'full'</span>])</span><br><span class="line"></span><br><span class="line">n_estimators = len(estimators)</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">3</span> * n_estimators // <span class="number">2</span>, <span class="number">6</span>))</span><br><span class="line">plt.subplots_adjust(bottom=<span class="number">.01</span>, top=<span class="number">0.95</span>, hspace=<span class="number">.15</span>, wspace=<span class="number">.05</span>,</span><br><span class="line">                    left=<span class="number">.01</span>, right=<span class="number">.99</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index, (name, estimator) <span class="keyword">in</span> enumerate(estimators.items()):</span><br><span class="line">    <span class="comment"># Since we have class labels for the training data, we can</span></span><br><span class="line">    <span class="comment"># initialize the GMM parameters in a supervised manner.</span></span><br><span class="line">    estimator.means_init = np.array([X_train[y_train == i].mean(axis=<span class="number">0</span>)</span><br><span class="line">                                    <span class="keyword">for</span> i <span class="keyword">in</span> range(n_classes)])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Train the other parameters using the EM algorithm.</span></span><br><span class="line">    estimator.fit(X_train)</span><br><span class="line"></span><br><span class="line">    h = plt.subplot(<span class="number">2</span>, n_estimators // <span class="number">2</span>, index + <span class="number">1</span>)</span><br><span class="line">    make_ellipses(estimator, h)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> n, color <span class="keyword">in</span> enumerate(colors):</span><br><span class="line">        data = iris.data[iris.target == n]</span><br><span class="line">        plt.scatter(data[:, <span class="number">0</span>], data[:, <span class="number">1</span>], s=<span class="number">0.8</span>, color=color,</span><br><span class="line">                    label=iris.target_names[n])</span><br><span class="line">    <span class="comment"># Plot the test data with crosses</span></span><br><span class="line">    <span class="keyword">for</span> n, color <span class="keyword">in</span> enumerate(colors):</span><br><span class="line">        data = X_test[y_test == n]</span><br><span class="line">        plt.scatter(data[:, <span class="number">0</span>], data[:, <span class="number">1</span>], marker=<span class="string">'x'</span>, color=color)</span><br><span class="line"></span><br><span class="line">    y_train_pred = estimator.predict(X_train)</span><br><span class="line">    train_accuracy = np.mean(y_train_pred.ravel() == y_train.ravel()) * <span class="number">100</span></span><br><span class="line">    plt.text(<span class="number">0.05</span>, <span class="number">0.9</span>, <span class="string">'Train accuracy: %.1f'</span> % train_accuracy,</span><br><span class="line">             transform=h.transAxes)</span><br><span class="line"></span><br><span class="line">    y_test_pred = estimator.predict(X_test)</span><br><span class="line">    test_accuracy = np.mean(y_test_pred.ravel() == y_test.ravel()) * <span class="number">100</span></span><br><span class="line">    plt.text(<span class="number">0.05</span>, <span class="number">0.8</span>, <span class="string">'Test accuracy: %.1f'</span> % test_accuracy,</span><br><span class="line">             transform=h.transAxes)</span><br><span class="line"></span><br><span class="line">    plt.xticks(())</span><br><span class="line">    plt.yticks(())</span><br><span class="line">    plt.title(name)</span><br><span class="line"></span><br><span class="line">plt.legend(scatterpoints=<span class="number">1</span>, loc=<span class="string">'lower right'</span>, prop=dict(size=<span class="number">12</span>))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2018/08/27/机器学习专题/最大期望算法/08.jpg" alt></p>
<h1 id="EM算法优缺点"><a href="#EM算法优缺点" class="headerlink" title="EM算法优缺点"></a>EM算法优缺点</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li>聚类。</li>
<li>算法计算结果稳定、准确。</li>
<li>EM算法自收敛，既不需要事先设定类别，也不需要数据间的两两比较合并等操作。</li>
</ul>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li>对初始化数据敏感。</li>
<li>EM算法计算复杂，收敛较慢，不适于大规模数据集和高维数据。</li>
<li>当所要优化的函数不是凸函数时，EM算法容易给出局部最优解，而不是全局最优解。</li>
</ul>

          
        
      
    </div>
    
    
    
    
    
    
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/20/浴室沉思/浴室沉思（二）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mosbyllc">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mosbyllc">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/20/浴室沉思/浴室沉思（二）/" itemprop="url">浴室沉思（二）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-20T09:59:22+08:00">
                2018-08-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/浴室沉思/" itemprop="url" rel="index">
                    <span itemprop="name">浴室沉思</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  208
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>1.</p>
<blockquote>
<p>地球那么大，为什么月亮的倒影能够准确地投映在我家院子里的一口井里？ </p>
</blockquote>
<p>2.</p>
<blockquote>
<p>你可以通过逃跑解决肥胖问题。</p>
</blockquote>
<p>3.</p>
<blockquote>
<p>你看不见你的脖子，你也离不开它。</p>
</blockquote>
<p>4.</p>
<blockquote>
<p>现金是电子支付的离线缓存。</p>
</blockquote>
<p>5.</p>
<blockquote>
<p>给水果剥皮，就像是拆来自大地的礼物。</p>
</blockquote>
<p>6.</p>
<blockquote>
<p>酒店房间里收费的饮品就像是手机应用的内购。</p>
</blockquote>
<p>7.</p>
<blockquote>
<p>你不能想象一种不存在的颜色。</p>
</blockquote>
<p>8.</p>
<blockquote>
<p>火山：睡上一万年，生起床气，到处乱丢东西，再睡上一万年。</p>
</blockquote>
<p>9.</p>
<blockquote>
<p>如果你每天“带薪拉屎”十分钟，一年下来就能相当于休了个一周的“带薪拉屎假”。</p>
</blockquote>
<p>10.</p>
<blockquote>
<p>如果你的手臂可以拆卸，你也没办法自己把它们互换位置。。</p>
</blockquote>

          
        
      
    </div>
    
    
    
    
    
    
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/20/浴室沉思/浴室沉思（一）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mosbyllc">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mosbyllc">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/20/浴室沉思/浴室沉思（一）/" itemprop="url">浴室沉思（一）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-20T09:17:20+08:00">
                2018-08-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/浴室沉思/" itemprop="url" rel="index">
                    <span itemprop="name">浴室沉思</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  207
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>1.</p>
<blockquote>
<p> 总有一天，你会完全忘记你读到过这句话。</p>
</blockquote>
<p>2.</p>
<blockquote>
<p>音乐是颤抖的风。</p>
</blockquote>
<p>3.</p>
<blockquote>
<p>狗狗可能并不喜欢叼球回来，只是不想看到东西弄丢了。</p>
</blockquote>
<p>4.</p>
<blockquote>
<p>根据美国的法律，在合法地饮用第一杯酒之前，你要先绕太阳飞行21圈。</p>
</blockquote>
<p>5.</p>
<blockquote>
<p>人类殖民火星，就像是通过空气传播的病毒。</p>
</blockquote>
<p>6.</p>
<blockquote>
<p>因为脑海里的声音不需要换气，脑海里可以一直在尖叫。</p>
</blockquote>
<p>7.</p>
<blockquote>
<p>同义词没有同义词，但是反义词的反义词是同义词。</p>
</blockquote>
<p>8.</p>
<blockquote>
<p>闪电是有人躲在云里偷拍我们，但忘了关闪光灯。</p>
</blockquote>
<p>9.</p>
<blockquote>
<p>氧气有最严重的戒断症状。</p>
</blockquote>
<p>10.</p>
<blockquote>
<p>火车是一种在三维世界中建立在二维平面上只能一维移动的物体。</p>
</blockquote>

          
        
      
    </div>
    
    
    
    
    
    
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/19/浴室沉思/浴室沉思101/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mosbyllc">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mosbyllc">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/19/浴室沉思/浴室沉思101/" itemprop="url">浴室沉思101</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-19T13:20:19+08:00">
                2018-08-19
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/浴室沉思/" itemprop="url" rel="index">
                    <span itemprop="name">浴室沉思</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,066
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  4
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原帖地址：<a href="https://www.reddit.com/r/Showerthoughts/comments/7xde4g/what_is_a_showerthought/" target="_blank" rel="noopener">戳我</a></p>
<p>欢迎来到r/showerthoughts, 我们很高兴在这里见到你，并且希望你玩得开心。这个帖子是一个关于showerthoughts 是什么/不是什么的简介。</p>
<blockquote>
<p>什么是Showerthoughts?</p>
</blockquote>
<p>简单来说，Showerthoughts 就是那些让庸常生活充满趣味的想法。这些想法往往是“另一个角度看待日常生活”的结果，而”另一个角度看待日常生活“往往又会让大家看到新的细节。这些想法可能十分可笑，也可能有些苦涩，可能会给你带来思想上的启迪，或者仅仅就是傻乎乎的而已。但他总应该是让人感到“啊，我怎么就没发现呢。“</p>
<p>Showerthoughts, 这个词指的是我们在日常生活中做无脑无聊时候事情时候产生的想法，并不一定要发生在浴室，也可以是在通勤中，在开车，或者是在等客服接你的电话的时候。</p>
<p>这里有一些Showerthoughts的例子：</p>
<ul>
<li>“你的胃觉得所有的土豆都是土豆泥。”</li>
<li>“当人们提到穿越回过去的时候，总是担心会导致改变今天的世界；但是他们却没有觉得，今天做的一切都会改变未来的世界。“</li>
<li>”如果你够蠢，所有的飞行物都是不明飞行物。”</li>
<li>“C3PO的确是卢克天行者的哥哥。”</li>
<li>“天鹅是一种聒噪，暴力，有进攻性的恐怖生物，同时也是爱情的象征。”</li>
</ul>
<blockquote>
<p>什么不是Showerthoughts？</p>
</blockquote>
<p>就像上面说的那样，Showerthoughts 应该让人从一个新的角度看待已经存在的现象或者事物。它不应该是一个个人意见或者观点，或者是一种产品的改进建议，或者是某些能快速通过Google 解决的问题。Showerthoughts 应该是一个命题，而不是一个假设。 R/showerthoughts 里面的内容应该文字流畅，内容新颖。如果某个post 过于泛滥，或者说文字水平太低，抑或者太过粗鲁，管理员将会将其移出。<br>这些例子里的内容不是Showerthoughts：</p>
<ul>
<li>“淦！我要买些肥皂了！”</li>
</ul>
<p>（这是一条浴室观察，不是一条浴室沉思）</p>
<ul>
<li>“我讨厌开车的时候被别人加塞，但是看着别人被加塞还蛮开心的。“</li>
</ul>
<p>（这是个人观点）</p>
<ul>
<li>“有人试过珠穆朗玛峰顶的味道嘛？“</li>
</ul>
<p>（这已经很接近showerthoughts 了，但是这是一个疑问句，应该改写成一个陈述句。）</p>
<ul>
<li>“地球每一天都再心的地方”</li>
</ul>
<p>（文字不流畅，而且还有错别字）</p>
<ul>
<li>“有没有可能有一群蜜蜂真的有蜂群思维呢？“</li>
</ul>
<p>（这是个假设，而且还是个文字游戏）</p>
<p>很多时候，我们很难找到一个完全原创，文字流畅，充满洞见的想法，不过这才让showerthoughts 变得好玩：它让你发现在你无意识的时候，你也是在思考的；而且这些想法也让你的无聊日常变得有趣起来。</p>
<blockquote>
<p>为什么要把Showerthoughts加入到自己的博客当中？</p>
</blockquote>
<p>Showerthoughts是我在Reddit里面最喜欢的一个版块，也是个人很喜欢的一种文化。看似简单的句子里蕴藏了许多奇思妙想，看待事物的角度时常让人耳目一新。看过许多有趣的Showerthoughts之后，偶尔也会自己进行创作，虽然质量不高，但都会发在饭否上面记录。但由于没有统一地方记录这些Showerthoughts，许多之前写的Showerthoughts已经很难找到了。所以，打算在博客里专门创建一个Showerthoughts的Tag，记录收藏有趣的Showerthoughts。</p>
<p>这些Showerthoughts绝大多数会在Reddit上面的r/showerthoughts版块中找到完整的原句，自己只搬运翻译一些感兴趣的Showerthoughts；另外还会摘录一些关注的饭友写的showerthoughts；最后也会自己偶尔写一些较低质量的Showerthoughts。</p>
<p>希望大家在码完代码疲惫之后，可以看到一些有趣的Showerthoughts，消除倦意，继续战斗。</p>
<p>注：微博上也有相关的Showerthoughts搬运博主，偶尔会转发一些网友有趣的Showerthoughts：<a href="https://weibo.com/u/2964236717?topnav=1&amp;wvr=6&amp;topsug=1&amp;is_all=1" target="_blank" rel="noopener">浴室沉思</a></p>

          
        
      
    </div>
    
    
    
    
    
    
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/19/算法比赛/kaggle_house_prices/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mosbyllc">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mosbyllc">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/19/算法比赛/kaggle_house_prices/" itemprop="url">浴室沉思101</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-19T13:20:19+08:00">
                2018-08-19
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/浴室沉思/" itemprop="url" rel="index">
                    <span itemprop="name">浴室沉思</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  14
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>思路</p>
<p>1、拆分数据集 ，验证集，测试集</p>

          
        
      
    </div>
    
    
    
    
    
    
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/07/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（七）：降维/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mosbyllc">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mosbyllc">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/07/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（七）：降维/" itemprop="url">Sklearn 与 TensorFlow 机器学习实用指南（七）：降维</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-07T10:03:06+08:00">
                2018-08-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Sklearn-与-TensorFlow-机器学习实用指南/" itemprop="url" rel="index">
                    <span itemprop="name">Sklearn 与 TensorFlow 机器学习实用指南</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  9,685
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  35
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>先来了解一张降维汇总图，降维的算法比较多，这里就只简单说MDS，PCA以及流行学习的Isomap和LLE。</p>
<p><img src="/2018/08/07/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（七）：降维/01.png" alt></p>
<hr>
<h1 id="多维缩放MDS：Multiple-Dimensional-Scaling"><a href="#多维缩放MDS：Multiple-Dimensional-Scaling" class="headerlink" title="多维缩放MDS：Multiple Dimensional Scaling"></a>多维缩放MDS：Multiple Dimensional Scaling</h1><p>低维嵌入：在很多时候， 人们观测或收集到的数据样本虽是高维的，但与学习任务密切相关的也许仅是某个低维分布，即高维空间中的一个低维”嵌入” (embedding) . 图 10.2 给出 了 一个直观的例子. 原始高维空间中的样本点，在这个低维嵌入子空间中更容易进行学习。</p>
<p><img src="/2018/08/07/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（七）：降维/02.png" alt></p>
<p>MDS的目标是在降维的过程中将数据的dissimilarity(差异性)保持下来，也可以理解降维让高维空间中的距离关系与低维空间中距离关系保持不变。这里的距离用矩阵表示，<strong>N个样本的两两距离用矩阵D的每一项$dist_{ij}$ 表示</strong>，并且假设在低维空间中的距离是欧式距离。<strong>而降维后的数据表示为$Z_i$</strong>,那么就有</p>
<script type="math/tex; mode=display">
dist_{ij}^2 = \left | \mathbf{z_i-z_j} \right |^2 = \left | \mathbf{z_i} \right |^2 + \left | \mathbf{z_j} \right |^2 - 2\mathbf{z_i}\mathbf{z_j}^T</script><p>令$B=ZZ^T$ ,右边的三项统一用<strong>内积矩阵B</strong>来表示$b_{ij}=z_iz_j^T$ ,所以有</p>
<script type="math/tex; mode=display">
dist_{ij}^2=b_{ii}+b_{jj}-2b_{ij} \quad(1)</script><p><strong>这时只要求出内积矩阵B即可求出降为后的矩阵Z（思路D-B-Z）</strong>。<strong>距离矩阵D去中心化之后(减去均值)，內积矩阵B的每一行每一列之和都是0</strong>，可以推导得出</p>
<p><img src="/2018/08/07/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（七）：降维/03.png" alt></p>
<p>其中 tr(.) 表示矩阵的迹(trace),$tr(E)=\sum<em>{i=1}^m\Vert z_i \Vert^2=\sum</em>{i=1}^mb_{ii}$,令</p>
<p><img src="/2018/08/07/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（七）：降维/04.png" alt></p>
<p>联立上(1)-(7),消除$b<em>{ii},b</em>{jj}$后，可以得到</p>
<script type="math/tex; mode=display">
b_{ij} = -\frac{1}{2}(dist_{ij}^2-dist_{i\cdot} - dist_{\cdot j}-dist_{\cdot\cdot}^2)</script><p>​i⋅与⋅j是指某列或者某列总和，从而建立了距离矩阵D与内积矩阵B之间的关系.由此即可通过降维前后保持不变的距离矩阵 D 求取内积矩阵 B。对矩阵 B 做特征值分解(eigenvalue decomposition)，$B=VAV^T$，其中$A=diag(λ<em>1,λ_2,…λ_d)$为特征值构成的对角矩阵,$λ_1\geq λ_2\geq …\geq λ_d$，V 为特征向量矩阵.假定其中有d* 个非零特征值，它们构成对角矩阵$A*=diag(λ_1,λ_2,…λ</em>{d<em>})$,令 V\</em>表示相应的特征向量矩阵，联立之前的$B=ZZ^T$,则最后Z可表达为</p>
<script type="math/tex; mode=display">
Z=A_*^{1/2}V_*^T</script><p>在现实应用中为了有效降维，往往仅需降维后的距离与原始空间中的距离尽可能接近?而不必严格相等.此时可取 d’&lt;&lt; d 个最大特征值构成对角矩阵。</p>
<p><img src="/2018/08/07/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（七）：降维/05.png" alt></p>
<h1 id="主成分分析PCA-Principal-Component-Analysis"><a href="#主成分分析PCA-Principal-Component-Analysis" class="headerlink" title="主成分分析PCA: Principal Component Analysis"></a>主成分分析PCA: Principal Component Analysis</h1><h2 id="向量內积"><a href="#向量內积" class="headerlink" title="向量內积"></a>向量內积</h2><p>由$A⋅B=|A||B|cos(a)$, A与B的内积等于A到B的投影长度乘以B的模。再进一步，如果我们假设B的模为1，则A与B的内积值等于A向B所在直线投影的矢量长度！</p>
<p><img src="/2018/08/07/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（七）：降维/06.png" alt></p>
<h2 id="基"><a href="#基" class="headerlink" title="基"></a>基</h2><p>向量(x,y)实际上表示线性组合，$x(1,0)^T+y(0,1)^T$,不难证明所有二维向量都可以表示为这样的线性组合。此处（1，0）和（0，1）叫做二维空间中的一组基。但实际上任何两个线性无关的二维向量都可以成为一组基，所谓线性无关在二维平面内可以直观认为是两个不在一条直线上的向量.例如，(1,1)和(−1,1)也可以成为一组基。一般来说，我们希望基的模是1,实际上，对应任何一个向量我们总可以找到其同方向上模为1的向量，只要让两个分量分别除以模就好了。例如，上面的基可以变为$(\frac{1}{\sqrt{2}},\frac{1}{\sqrt{2}})$和$(-\frac{1}{\sqrt{2}},\frac{1}{\sqrt{2}})$ </p>
<h2 id="基变换的矩阵表示："><a href="#基变换的矩阵表示：" class="headerlink" title="基变换的矩阵表示："></a>基变换的矩阵表示：</h2><p>下面我们找一种简便的方式来表示基变换。还是拿上面的例子，想一下，将(3,2)变换为新基上的坐标，就是用(3,2)与第一个基做内积运算，作为第一个新的坐标分量，然后用(3,2)与第二个基做内积运算，作为第二个新坐标的分量。实际上，我们可以用矩阵相乘的形式简洁的表示这个变换，其中矩阵的两行分别为两个基，乘以原向量，其结果刚好为新基的坐标：</p>
<p><img src="/2018/08/07/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（七）：降维/07.png" alt></p>
<h2 id="协方差矩阵及优化目标"><a href="#协方差矩阵及优化目标" class="headerlink" title="协方差矩阵及优化目标"></a>协方差矩阵及优化目标</h2><p>面我们讨论了选择不同的基可以对同样一组数据给出不同的表示，而且如果基的数量少于向量本身的维数，则可以达到降维的效果。但是我们还没有回答一个最最关键的问题：如何选择基才是最优的。或者说，如果我们有一组N维向量，现在要将其降到K维（K小于N），那么我们应该如何选择K个基才能最大程度保留原有的信息？</p>
<p><img src="/2018/08/07/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（七）：降维/08.png" alt></p>
<p>现在问题来了：如果我们必须使用一维来表示上面这些数据，又希望尽量保留原始的信息，你要如何选择？</p>
<p>通过上一节对基变换的讨论我们知道，这个问题实际上是要在二维平面中选择一个方向，将所有数据都投影到这个方向所在直线上，用投影值表示原始记录。这是一个实际的二维降到一维的问题。</p>
<p>那么如何选择这个方向（或者说基）才能尽量保留最多的原始信息呢？一种直观的看法是：希望投影后的投影值尽可能分散。</p>
<p>我们希望投影后投影值尽可能分散，而这种分散程度，可以用数学上的方差来表述。此处，一个字段的方差可以看做是每个元素与字段均值的差的平方和的均值，即：</p>
<script type="math/tex; mode=display">
Var(a)=\frac{1}{m}\sum^m_{i=1}(a_i-\mu)^2</script><p>通过去中心化（字段所有数值减去字段均值），将每个字段的均值都化为0了，因此方差可以直接用每个元素的平方和除以元素个数表示：</p>
<script type="math/tex; mode=display">
Var(a)=\frac{1}{m}\sum^m_{i=1}a_i^2</script><p>于是上面的问题被形式化表述为：寻找一个一维基，使得所有数据变换为这个基上的坐标表示后，方差值最大.</p>
<h2 id="协方差"><a href="#协方差" class="headerlink" title="协方差"></a>协方差</h2><p>对于上面二维降成一维的问题来说，找到那个使得方差最大的方向就可以了。不过对于更高维，还有一个问题需要解决。考虑三维降到二维问题。与之前相同，首先我们希望找到一个方向使得投影后方差最大，这样就完成了第一个方向的选择，继而我们选择第二个投影方向。</p>
<p>如果我们还是单纯只选择方差最大的方向，很明显，这个方向与第一个方向应该是“几乎重合在一起”，显然这样的维度是没有用的，因此，应该有其他约束条件。从直观上说，让两个字段尽可能表示更多的原始信息，我们是不希望它们之间存在（线性）相关性的，因为相关性意味着两个字段不是完全独立，必然存在重复表示的信息。</p>
<p>数学上可以用两个字段的协方差表示其相关性，由于已经让每个字段均值为0，则：</p>
<script type="math/tex; mode=display">
Cov(a,b) = \frac{1}{m}\sum_{i=1}^ma_ib_i</script><p>可以看到，在字段均值为0的情况下，两个字段的协方差简洁的表示为其内积除以元素数m。</p>
<p>当协方差为0时，表示两个字段完全独立。为了让协方差为0，我们选择第二个基时只能在与第一个基正交的方向上选择。因此最终选择的两个方向一定是正交的。</p>
<p>至此，我们得到了降维问题的优化目标：将一组N维向量降为K维（K大于0，小于N），其目标是选择K个单位（模为1）正交基，使得原始数据变换到这组基上后，<strong>各字段两两间协方差为0，而字段的方差则尽可能大</strong>（在正交的约束下，取最大的K个方差）。</p>
<h2 id="协方差矩阵"><a href="#协方差矩阵" class="headerlink" title="协方差矩阵"></a>协方差矩阵</h2><p>我们看到，最终要达到的目的与字段内方差及字段间协方差有密切关系。因此我们希望能将两者统一表示，仔细观察发现，两者均可以表示为内积的形式，而内积又与矩阵相乘密切相关。</p>
<p>假设我们只有a和b两个字段，那么我们将它们按行组成矩阵X：</p>
<p><img src="/2018/08/07/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（七）：降维/09.png" alt></p>
<p>然后我们用X乘以X的转置，并乘上系数1/m：</p>
<p><img src="/2018/08/07/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（七）：降维/10.png" alt></p>
<p>奇迹出现了！这个对角线上的两个元素分别是两个字段的方差，而其它元素是a和b的协方差。两者被统一到了一个矩阵的。</p>
<p>根据矩阵相乘的运算法则，这个结论很容易被推广到一般情况：设我们有m个n维数据记录，将其按列排成n乘m的矩阵X，设$C=\frac{1}{m}XX^𝖳$ ，则C是一个对称矩阵，其对角线分别个各个字段的方差，而第i行j列和j行i列元素相同，表示i和j两个字段的协方差。</p>
<h2 id="协方差矩阵对角化"><a href="#协方差矩阵对角化" class="headerlink" title="协方差矩阵对角化"></a>协方差矩阵对角化</h2><p>根据上述推导，我们发现要达到优化条件，等价于将协方差对角化：即除对角线外的其它元素化为0，并且在对角线上将元素按大小从上到下排列，这样我们就达到了优化目的。这样说可能还不是很明晰，我们进一步看下原矩阵与基变换后矩阵协方差矩阵的关系：</p>
<p>设<strong>原始数据矩阵X</strong>对应的<strong>协方差矩阵为C</strong>，而P是一组基按行组成的矩阵，设$Y=PX$，则<strong>Y为X对P做基变换后的数据</strong>。设<strong>Y的协方差矩阵为D</strong>，我们推导一下D与C的关系：</p>
<script type="math/tex; mode=display">
D = \frac{1}{m}YY^T\\ \quad =\frac{1}{m}(PX)(PX)^T\\ =\frac{1}{m}PXX^TP\\=PCP^T</script><p><strong>现在事情很明白了，我们要找的P不是别的，而是能让原始协方差矩阵对角化的P</strong>。换句话说，优化目标变成了寻找一个矩阵P，满足$PCP^T$是一个对角矩阵，并且对角元素按从小到大依次排列，那么<strong>P的前K行就是要寻找的基</strong>，<strong>用P的前K行组成的矩阵乘以X</strong>就使得X从N维降到了K维并满足上述优化条件。</p>
<p>现在所有焦点都聚焦在了协方差矩阵对角化问题上，由上文知道，<strong>协方差矩阵C是一个是对称矩阵</strong>，在线性代数上，实对称矩阵有一系列非常好的性质：</p>
<ul>
<li>1）实对称矩阵不同特征值对应的特征向量必然正交。</li>
<li>2）设特征向量λ重数为r，则必然存在r个线性无关的特征向量对应于λ，因此可以将这r个特征向量单位正交化。</li>
</ul>
<p>由上面两条可知，一个n行n列的实对称矩阵一定可以找到n个单位正交特征向量，设这n个特征向量为$e_1,e_2,⋯,e_n$，我们将其按列组成矩阵：</p>
<script type="math/tex; mode=display">
E = (e_1\ e_2 \ ··· \ e_n)</script><p>则对协方差矩阵C有如下结论：</p>
<script type="math/tex; mode=display">
E^TCE =
\varLambda\ =\left[\begin{matrix}
    \lambda_1&        &        &        \\
    &        \lambda_2&        &        \\
    &        &        ···&        \\
    &        &        &        \lambda_n\\
\end{matrix}\right]</script><p>其中Λ为对角矩阵，其对角元素为各特征向量对应的特征值（可能有重复）。以上结论不再给出严格的数学证明，对证明感兴趣的朋友可以参考线性代数书籍关于“实对称矩阵对角化”的内容。</p>
<p>到这里，我们发现我们已经找到了需要的矩阵P：P是协方差矩阵的特征向量单位化后按行排列出的矩阵，其中每一行都是C的一个特征向量。如果设P按照Λ中特征值的从大到小，将特征向量从上到下排列，则用P的前K行组成的矩阵乘以原始数据矩阵X，就得到了我们需要的降维后的数据矩阵Y</p>
<p>于是，只需对协方差矩阵$XX^T$进行特征值分解，将求得的特征值排序:$λ_1\geq λ_2\geq …\geq λ_d$,再再取前 d’ 个特征值对应的特征向量构成 $W=(w_1,w_2,..,w_d’)$.这就是主成分分析的解.要注意降维后低维空间的维数 d’ 通常是由用户事先指定。</p>
<p>简单回顾一下：给定原始数据矩阵X，其协方差矩阵$C=\frac{1}{M}XX^T$对角元素代表了方差，其余元素代表相关性。假定降维后的数据矩阵为Y，其协方差D会满足对角元素最大，其余元素为0，这样才会代表降维后的要求。设Y=PX，P代表要与矩阵相乘的基，有$D=PCP^T$的关系。这个等式的形式与实对称矩阵对角化一样，这时候只要找出C的特征值对应的特征向量，组合起来即为我们需要求得P。最后Y=PX得到降维后的数据矩阵。</p>
<p><img src="/2018/08/07/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（七）：降维/11.png" alt></p>
<p>PCA 仅需保留 W 与 样本 的均值向 量即可通过简单的向量减法和矩阵”向量乘法将新样本投影至低维空间中 . 显然，低维空间与原始高维空间必有不同，因为对应于最小的d-d’个特征值的特征 向量被舍弃了，这是降维导致的结果.但舍弃这部分信息往往是必要的- 一方面舍弃这部分信息之后能使样本的采样密度增大，这正是降维 的重要动机; 另一方面，当数据受到 噪声影响时， 最小的特征值所对应的特征 向量往往与噪声有关?将它们舍弃能在一定程度上起到去噪的效果.</p>
<h1 id="流行学习算法Isomap：等度量映射"><a href="#流行学习算法Isomap：等度量映射" class="headerlink" title="流行学习算法Isomap：等度量映射"></a>流行学习算法Isomap：等度量映射</h1><p>等度量映射(Isometric Mapping，简称 Isomap) 的基本 出发点，是认为低维流Î~嵌入到 高维空 间之后，直接在高维空间 中计算直线距离具有误导性，因为高维空间中的直线距离在低维嵌入流形上是不可达的.如图 所示，低维嵌入流形上两点间的距离是”测地线” (geodesic)距离。</p>
<p><img src="/2018/08/07/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（七）：降维/12.png" alt></p>
<p>那么，如何计算测地线距离呢?这时我们可利用流形在局部上与 欧氏空间同胚这个性质，对每个点基于欧 氏距离找出其近邻点，然后就能建立一个近邻连接图，图中近邻点之间存在连接，而非近邻点之间不存在连接， 于是，计算两点之间测地线距离的问题就转变为计算近邻连接图上两点之间的最短路径问题.</p>
<p>在近邻连接图上计算两点间的最短路径?可采用著名的Dijkstra算法或Floyd算法，在得到任意两点的距离之后，就可通过MDS 方法来获得样本点在低维空间中的坐标。</p>
<p><img src="/2018/08/07/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（七）：降维/13.png" alt></p>
<h1 id="流行学习算法LLE：局部线性嵌入"><a href="#流行学习算法LLE：局部线性嵌入" class="headerlink" title="流行学习算法LLE：局部线性嵌入"></a>流行学习算法LLE：局部线性嵌入</h1><p>LLE首先假设数据在较小的局部是线性的，也就是说，某一个数据可以由它邻域中的几个样本来线性表示。比如我们有一个样本x1,我们在它的原始高维邻域里用K-近邻思想找到和它最近的三个样本x2,x3,x4. 然后我们假设x1可以由x2,x3,x4线性表示，即</p>
<script type="math/tex; mode=display">
x_1 = w_{12}x_2 + w_{13}x_3 +w_{14}x_4</script><p>其中，w12，w13，w14为权重系数。在我们通过LLE降维后，我们希望x1在低维空间对应的投影x′1和x2,x3,x4对应的投影x′2,x′3,x′4也尽量保持同样的线性关系，即</p>
<script type="math/tex; mode=display">
x_1' \approx w_{12}x_2' + w_{13}x_3' +w_{14}x_4'</script><p>也就是说，投影前后线性关系的权重系数w12，w13，w14是尽量不变或者最小改变的。</p>
<p>从上面可以看出，线性关系只在样本的附近起作用，离样本远的样本对局部的线性关系没有影响，因此降维的复杂度降低了很多。</p>
<p>对于LLE算法，我们首先要确定邻域大小的选择，即我们需要多少个邻域样本来线性表示某个样本。假设这个值为k。我们可以通过和KNN一样的思想通过距离度量比如欧式距离来选择某样本的k个最近邻。</p>
<p>在寻找到某个样本的xi的k个最近邻之后我们就需要找到找到xi和这k个最近邻之间的线性关系，也就是要找到线性关系的权重系数。找线性关系，这显然是一个回归问题。假设我们有m个n维样本{x1,x2,…,xm},我们可以用均方差作为回归问题的损失函数：即：</p>
<script type="math/tex; mode=display">
J(w) = \sum\limits_{i=1}^{m}||x_i-\sum\limits_{j=1}^{k}w_{ij}x_j||_2^2</script><p>一般我们也会对权重系数$w_{ij}$做归一化的限制，即权重系数需要满足</p>
<script type="math/tex; mode=display">
\sum\limits_{j=1}^{k}w_{ij} = 1</script><p>对于不在样本$x<em>i$邻域内的样本$x_j$，我们令对应的$w</em>{ij}=0$.也就是我们需要通过上面两个式子求出我们的权重系数。一般我们可以通过矩阵和拉格朗日子乘法来求解这个最优化问题。(这个推导就不写了）</p>
<p>最后得到</p>
<script type="math/tex; mode=display">
W_i = \frac{Z_i^{-1}1_k}{1_k^TZ_i^{-1}1_k}</script><p>其中$W<em>i=(w</em>{i1},w<em>{i2},…w</em>{ik})^T$ ,矩阵$Z_i=(x_i−x_j)^T(x_i−x_j)$,其中$1_k$ 为k维全1向量。</p>
<p>在我们得到了高维的权重系数，那么我们希望这些权重系数对应的线性关系在降维后的低维一样得到保持。假设我们的n维样本集{x1,x2,…,xm}在低维的d维度对应投影为{y1,y2,…,ym}, 则我们希望保持线性关系，也就是希望对应的均方差损失函数最小，即最小化损失函数J(Y)如下：</p>
<script type="math/tex; mode=display">
J(y) = \sum\limits_{i=1}^{m}||y_i-\sum\limits_{j=1}^{k}w_{ij}y_j||_2^2</script><p>这个优化目标与之前的同形，唯一的区别是之前需要确定权重系数$w_i$，而现在是知道权重系数，需要确定的是$x_i$对应的低维空间坐标$y_i$。</p>
<p>令$M=(I-W)^T(I-W)$ ,则优化函数转变为最小化下式：$J(Y) = tr(Y^TMY)$,tr为迹函数。约束函数矩阵化为：$Y^TY=mI$ </p>
<p>上式可通过特征值分解求解:M 最小的 d’ 个特征值对应的特征向量组成的矩阵即为 $Z^T$.<br>算法流程：</p>
<p><img src="/2018/08/07/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（七）：降维/14.png" alt></p>
<p>从图中可以看出，LLE算法主要分为三步，第一步是求K近邻的过程，这个过程使用了和KNN算法一样的求最近邻的方法。第二步，就是对每个样本求它在邻域里的K个近邻的线性关系，得到线性关系权重系数W，第三步就是利用权重系数来在低维里重构样本数据。</p>
<p><img src="/2018/08/07/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（七）：降维/15.png" alt></p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>我们将会展示两种主要的降维方法：投影（projection）和流形学习（Manifold Learning），同时我们还会介绍三种流行的降维技术：主成分分析（PCA），核主成分分析（Kernel PCA）和局部线性嵌入（LLE）。</p>
<h2 id="主成分分析（PCA）"><a href="#主成分分析（PCA）" class="headerlink" title="主成分分析（PCA）"></a>主成分分析（PCA）</h2><p>主成分分析（Principal Component Analysis）是目前为止最流行的降维算法。首先它找到接近数据集分布的超平面，然后将所有的数据都投影到这个超平面上。</p>
<h3 id="保留（最大）方差"><a href="#保留（最大）方差" class="headerlink" title="保留（最大）方差"></a>保留（最大）方差</h3><p>在将训练集投影到较低维超平面之前，您首先需要选择正确的超平面。例如图左侧是一个简单的二维数据集，以及三个不同的轴（即一维超平面）。图右边是将数据集投影到每个轴上的结果。正如你所看到的，投影到实线上保留了最大方差，而在点线上的投影只保留了非常小的方差，投影到虚线上保留的方差则处于上述两者之间。</p>
<p><img src="/2018/08/07/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（七）：降维/16.png" alt></p>
<p><strong>选择保持最大方差的轴看起来是合理的，因为它很可能比其他投影损失更少的信息。证明这种选择的另一种方法是，选择这个轴使得将原始数据集投影到该轴上的均方距离最小。这是就 PCA 背后的思想，相当简单</strong>。</p>
<h3 id="主成分（Principle-Componets）"><a href="#主成分（Principle-Componets）" class="headerlink" title="主成分（Principle Componets）"></a>主成分（Principle Componets）</h3><p>PCA 寻找训练集中可获得最大方差的轴。在上图中，它是一条实线。<strong>它还发现了一个与第一个轴正交的第二个轴，选择它可以获得最大的残差</strong>。在这个 2D 例子中，没有选择：就只有这条点线。但如果在一个更高维的数据集中，PCA 也可以找到与前两个轴正交的第三个轴，以及与数据集中维数相同的第四个轴，第五个轴等。 定义第i个轴的单位矢量被称为第i个主成分（PC）。在图中，第一个 PC 是c1，第二个 PC 是c2。在投影图中，前两个 PC 用平面中的正交箭头表示，第三个 PC 与上述 PC 形成的平面正交（指向上或下）</p>
<blockquote>
<p>概述： 主成分的方向不稳定：如果您稍微打乱一下训练集并再次运行 PCA，则某些新 PC 可能会指向与原始 PC 方向相反。但是，它们通常仍位于同一轴线上。在某些情况下，一对 PC 甚至可能会旋转或交换，但它们定义的平面通常保持不变。</p>
</blockquote>
<p>那么如何找到训练集的主成分呢？幸运的是，<strong>有一种称为奇异值分解（SVD）的标准矩阵分解技术</strong>，可以将训练集矩阵X分解为三个矩阵$U·Σ·V^T$的点积，其中$V^T$$包含我们想要的所有主成分，如下所示。</p>
<p><img src="/2018/08/07/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（七）：降维/17.png" alt></p>
<p>下面的 Python 代码使用了 Numpy 提供的svd()函数获得训练集的所有主成分，然后提取前两个 PC:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X_centered=X-X.mean(axis=<span class="number">0</span>)    <span class="comment"># 中心化</span></span><br><span class="line">U,s,V=np.linalg.svd(X_centered)</span><br><span class="line">c1=V.T[:,<span class="number">0</span>]</span><br><span class="line">c2=V.T[:,<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>警告：PCA 假定数据集以原点为中心。正如我们将看到的，Scikit-Learn 的PCA类负责为您的数据集中心化处理。但是，如果您自己实现 PCA（如前面的示例所示），或者如果您使用其他库，不要忘记首先要先对数据做中心化处理。</p>
</blockquote>
<p><strong>投影到d维空间：</strong><br>一旦确定了所有的主成分，你就可以通过将数据集投影到由前d个主成分构成的超平面上，从而将数据集的维数降至d维。选择这个超平面可以确保投影将保留尽可能多的方差。</p>
<p><strong>为了将训练集投影到超平面上，可以简单地通过计算训练集矩阵X和Wd的点积，Wd定义为包含前d个主成分的矩阵（即由V^T的前d列组成的矩阵）</strong></p>
<p>将训练集投影到d维空间的公式：</p>
<script type="math/tex; mode=display">X_{d-proj} = X \cdot W_d</script><p>下面的 Python 代码将训练集投影到由前两个主成分定义的超平面上：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">W2=V.T[:,:<span class="number">2</span>]    <span class="comment"># 降为2维</span></span><br><span class="line">X2D=X_centered.dot(W2)</span><br></pre></td></tr></table></figure>
<p><strong>使用 Scikit-Learn</strong><br>Scikit-Learn 的 PCA 类使用 SVD 分解来实现，就像我们之前做的那样。以下代码应用 PCA 将数据集的维度降至两维（请注意，它会自动处理数据的中心化）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA</span><br><span class="line"></span><br><span class="line">pca=PCA(n_components=<span class="number">2</span>)</span><br><span class="line">X2D=pca.fit_transform(X)</span><br></pre></td></tr></table></figure>
<p>将 PCA 转化器应用于数据集后，可以使用components_访问每一个主成分（注意，它返回以 PC 作为水平向量的矩阵，因此，如果我们想要获得第一个主成分则可以写成pca.components_.T[:,0]）。</p>
<h3 id="方差解释率（Explained-Variance-Ratio）"><a href="#方差解释率（Explained-Variance-Ratio）" class="headerlink" title="方差解释率（Explained Variance Ratio）"></a>方差解释率（Explained Variance Ratio）</h3><p><strong>另一个非常有用的信息是每个主成分的方差解释率，可通过explained<em>variance_ratio</em>变量获得。它表示位于每个主成分轴上的数据集方差的比例</strong>。例如，让我们看下图中表示的三维数据集前两个分量的方差解释率：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(pca.explained_variance_ratio_)</span><br><span class="line">array([<span class="number">0.84248607</span>, <span class="number">0.14631839</span>])</span><br></pre></td></tr></table></figure>
<p>这表明，84.2% 的数据集方差位于第一轴，14.6% 的方差位于第二轴。第三轴的这一比例不到1.2％，因此可以认为它可能没有包含什么信息</p>
<p><strong>选择正确的维度</strong><br><strong>通常我们倾向于选择加起来到方差解释率能够达到足够占比（例如 95%）的维度的数量，而不是任意选择要降低到的维度数量。</strong>当然，除非您正在为数据可视化而降低维度 — 在这种情况下，您通常希望将维度降低到 2 或 3。</p>
<p>下面的代码在不降维的情况下进行 PCA，然后计算出保留训练集方差 95% 所需的最小维数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pca=PCA()</span><br><span class="line">pac.fit(X)</span><br><span class="line">cumsum=np.cumsum(pca.explained_variance_ratio_)</span><br><span class="line">d=np.argmax(cumsum&gt;=<span class="number">0.95</span>)+<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>你可以设置n_components = d并再次运行 PCA。但是，<strong>有一个更好的选择：不指定你想要保留的主成分个数，而是将n_components设置为 0.0 到 1.0 之间的浮点数，表明您希望保留的方差比率：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pca=PCA(n_components=<span class="number">0.95</span>)</span><br><span class="line">X_reduced=pca.fit_transform(X)</span><br></pre></td></tr></table></figure>
<p>另一种选择是画出方差解释率关于维数的函数（简单地绘制cumsum）。曲线中通常会有一个肘部，方差解释率停止快速增长。您可以将其视为数据集的真正的维度。在这种情况下，您可以看到将维度降低到大约100个维度不会失去太多的可解释方差。</p>
<h3 id="PCA-压缩"><a href="#PCA-压缩" class="headerlink" title="PCA 压缩"></a>PCA 压缩</h3><p>显然，在降维之后，训练集占用的空间要少得多。例如，尝试将 PCA 应用于 MNIST 数据集，同时保留 95% 的方差。你应该发现每个实例只有 150 多个特征，而不是原来的 784 个特征。因此，尽管大部分方差都保留下来，但数据集现在还不到其原始大小的 20%！这是一个合理的压缩比率，您可以看到这可以如何极大地加快分类算法（如 SVM 分类器）的速度。</p>
<p><strong>通过应用 PCA 投影的逆变换，也可以将缩小的数据集解压缩回 784 维。当然这并不会返回给你最原始的数据，因为投影丢失了一些信息（在5％的方差内），但它可能非常接近原始数据</strong>。原始数据和重构数据之间的均方距离（压缩然后解压缩）被称为重构误差（reconstruction error）。例如，下面的代码将 MNIST 数据集压缩到 154 维，然<strong>后使用inverse_transform()方法将其解压缩回 784 维</strong>。图 8-9 显示了原始训练集（左侧）的几位数字在压缩并解压缩后（右侧）的对应数字。您可以看到有轻微的图像质量降低，但数字仍然大部分完好无损。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pca=PCA(n_components=<span class="number">154</span>)</span><br><span class="line">X_mnist_reduced=pca.fit_transform(X_mnist)</span><br><span class="line">X_mnist_recovered=pca.inverse_transform(X_mnist_reduced)</span><br></pre></td></tr></table></figure>
<p><img src="/2018/08/07/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（七）：降维/19.png" alt></p>
<p>PCA逆变换公式，回退到原来的数据维度</p>
<script type="math/tex; mode=display">
X_{recovered} = X_{d-proj} \cdot W_d^T</script><h3 id="增量-PCA（Incremental-PCA）"><a href="#增量-PCA（Incremental-PCA）" class="headerlink" title="增量 PCA（Incremental PCA）"></a>增量 PCA（Incremental PCA）</h3><p><strong>先前 PCA 实现的一个问题是它需要在内存中处理整个训练集以便 SVD 算法运行。幸运的是，我们已经开发了增量 PCA（IPCA）算法：您可以将训练集分批，并一次只对一个批量使用 IPCA 算法。这对大型训练集非常有用</strong>，并且可以在线应用 PCA（即在新实例到达时即时运行）。</p>
<p><strong>下面的代码将 MNIST 数据集分成 100 个小批量（使用 NumPy 的array_split()函数），并将它们提供给 Scikit-Learn 的IncrementalPCA类，以将 MNIST 数据集的维度降低到 154 维（就像以前一样）。请注意，您必须对每个最小批次调用partial_fit()方法，而不是对整个训练集使用fit()方法</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> IncrementalPCA</span><br><span class="line"></span><br><span class="line">n_batches=<span class="number">100</span></span><br><span class="line">inc_pca=IncrementalPCA(n_components=<span class="number">154</span>)</span><br><span class="line"><span class="keyword">for</span> X_batch <span class="keyword">in</span> np.array_spplit(X_mnist,n_batches): <span class="comment">#分100批次数据</span></span><br><span class="line">    inc_pca.partial_fit(X_batch)    <span class="comment"># 必须批次调用partial_fit()方法</span></span><br><span class="line">X_mnist_reduced=inc_pca.transform(X_mnist)</span><br></pre></td></tr></table></figure>
<p>或者，您可以使用 NumPy 的memmap类，它允许您操作存储在磁盘上二进制文件中的大型数组，就好像它完全在内存中；该类仅在需要时加载内存中所需的数据。由于增量 PCA 类在任何时间内仅使用数组的一小部分，因此内存使用量仍受到控制。这可以调用通常的fit()方法，如下面的代码所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X_mm=np.memmap(filename,dtype=<span class="string">'float32'</span>,mode=<span class="string">'readonly'</span>,shape=(m,n))</span><br><span class="line">batch_size=m//n_batches</span><br><span class="line">inc_pca=IncrementalPCA(n_components=<span class="number">154</span>,batch_size=batch_size)</span><br><span class="line">inc_pca.fit(X_mm)</span><br></pre></td></tr></table></figure>
<h3 id="随机-PCA（Randomized-PCA）"><a href="#随机-PCA（Randomized-PCA）" class="headerlink" title="随机 PCA（Randomized PCA）"></a>随机 PCA（Randomized PCA）</h3><p>Scikit-Learn 提供了另一种执行 PCA 的选择，称为随机 PCA。这是一种随机算法，可以快速找到前d个主成分的近似值。它的计算复杂度是O(m × d^2) + O(d^3)，而不是O(m × n^2) + O(n^3)，所以当d远小于n时，<strong>它比之前的算法快得多。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rnd_pca=PCA(n_components=<span class="number">154</span>,svd_solver=<span class="string">'randomized'</span>)</span><br><span class="line">X_reduced=rnd_pca.fit_transform(X_mnist)</span><br></pre></td></tr></table></figure>
<h2 id="核-PCA（Kernel-PCA）"><a href="#核-PCA（Kernel-PCA）" class="headerlink" title="核 PCA（Kernel PCA）"></a>核 PCA（Kernel PCA）</h2><p>例如，下面的代码使用 Scikit-Learn 的KernelPCA类来执行带有 RBF 核的 kPCA</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> KernelPCA</span><br><span class="line"></span><br><span class="line">rbf_pca=KernelPCA(n_components=<span class="number">2</span>,kernel=<span class="string">'rbf'</span>,gamma=<span class="number">0.04</span>)</span><br><span class="line">X_reduced=rbf_pca.fit_transform(X)</span><br></pre></td></tr></table></figure>
<p><img src="/2018/08/07/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（七）：降维/20.png" alt></p>
<p><strong>选择一种核并调整超参数</strong><br><strong>由于 kPCA 是无监督学习算法，因此没有明显的性能指标可以帮助您选择最佳的核方法和超参数值。但是，降维通常是监督学习任务（例如分类）的准备步骤，因此您可以简单地使用网格搜索来选择可以让该任务达到最佳表现的核方法和超参数</strong>。例如，下面的代码创建了一个两步的流水线，首先使用 kPCA 将维度降至两维，然后应用 Logistic 回归进行分类。然后它<strong>使用Grid SearchCV为 kPCA 找到最佳的核和gamma值</strong>，以便在最后获得最佳的分类准确性：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> GridSearchCV <span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression <span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> Pipeline</span><br><span class="line">clf = Pipeline([</span><br><span class="line">        (<span class="string">"kpca"</span>, KernelPCA(n_components=<span class="number">2</span>)),</span><br><span class="line">        (<span class="string">"log_reg"</span>, LogisticRegression())</span><br><span class="line">])</span><br><span class="line">param_grid = [&#123;</span><br><span class="line">        <span class="string">"kpca__gamma"</span>: np.linspace(<span class="number">0.03</span>, <span class="number">0.05</span>, <span class="number">10</span>),</span><br><span class="line">        <span class="string">"kpca__kernel"</span>: [<span class="string">"rbf"</span>, <span class="string">"sigmoid"</span>]</span><br><span class="line">    &#125;]</span><br><span class="line">grid_search = GridSearchCV(clf, param_grid, cv=<span class="number">3</span>)</span><br><span class="line">grid_search.fit(X, y)</span><br></pre></td></tr></table></figure>
<p>你可以通过调用best<em>params</em>变量来查看使模型效果最好的核和超参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(grid_search.best_params_)</span><br><span class="line">&#123;<span class="string">'kpca__gamma'</span>: <span class="number">0.043333333333333335</span>, <span class="string">'kpca__kernel'</span>: <span class="string">'rbf'</span>&#125;</span><br></pre></td></tr></table></figure>
<p><strong>另一种完全为非监督的方法，是选择产生最低重建误差的核和超参数</strong>。但是，重建并不像线性 PCA 那样容易。这里是原因：图 8-11 显示了原始瑞士卷 3D 数据集（左上角），并且使用 RBF 核应用 kPCA 后生成的二维数据集（右上角）。由于核技巧，这在数学上等同于使用特征映射φ将训练集映射到无限维特征空间（右下），然后使用线性 PCA 将变换的训练集投影到 2D。请注意，如果我们可以在缩减空间中对给定实例实现反向线性 PCA 步骤，则重构点将位于特征空间中，而不是位于原始空间中（例如，如图中由x表示的那样）。由于特征空间是无限维的，我们不能找出重建点，因此我们无法计算真实的重建误差。<strong>幸运的是，可以在原始空间中找到一个贴近重建点的点。这被称为重建前图像（reconstruction pre-image）。一旦你有这个前图像，你就可以测量其与原始实例的平方距离。然后，您可以选择最小化重建前图像错误的核和超参数。</strong></p>
<p><img src="/2018/08/07/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（七）：降维/21.png" alt></p>
<p><strong>您可能想知道如何进行这种重建。一种解决方案是训练一个监督回归模型，将预计实例作为训练集，并将原始实例作为训练目标</strong>。如果您设置了fit_inverse_transform = True，Scikit-Learn 将自动执行此操作，代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rbf_pca = KernelPCA(n_components = <span class="number">2</span>, kernel=<span class="string">"rbf"</span>, gamma=<span class="number">0.0433</span>,fit_inverse_transform=<span class="literal">True</span>)</span><br><span class="line">X_reduced = rbf_pca.fit_transform(X)</span><br><span class="line">X_preimage = rbf_pca.inverse_transform(X_reduced)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>概述：默认条件下，fit_inverse_transform = False并且KernelPCA没有inverse_tranfrom()方法。这种方法仅仅当fit_inverse_transform = True的情况下才会创建。</p>
</blockquote>
<p>你可以计算重建前图像误差：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> mean_squared_error</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mean_squared_error(X, X_preimage) <span class="number">32.786308795766132</span></span><br></pre></td></tr></table></figure>
<p>现在你可以使用交叉验证的方格搜索来寻找可以最小化重建前图像误差的核方法和超参数。</p>
<h2 id="局部线性嵌入LLE"><a href="#局部线性嵌入LLE" class="headerlink" title="局部线性嵌入LLE"></a>局部线性嵌入LLE</h2><p>局部线性嵌入（Locally Linear Embedding）是另一种非常有效的非线性降维（NLDR）方法。这是一种流形学习技术，不依赖于像以前算法那样的投影。简而言之，LLE 首先测量每个训练实例与其最近邻（c.n.）之间的线性关系，然后寻找能最好地保留这些局部关系的训练集的低维表示（稍后会详细介绍） 。这使得它特别擅长展开扭曲的流形，尤其是在没有太多噪音的情况下。</p>
<p>例如，以下代码使用 Scikit-Learn 的LocallyLinearEmbedding类来展开瑞士卷。得到的二维数据集如图所示。正如您所看到的，瑞士卷被完全展开，实例之间的距离保存得很好。<strong>但是，距离不能在较大范围内保留的很好：展开的瑞士卷的左侧被挤压，而右侧的部分被拉长</strong>。尽管如此，LLE 在对流形建模方面做得非常好。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.manifold <span class="keyword">import</span> LocallyLinearEmbedding</span><br><span class="line"></span><br><span class="line">lle=LocallyLinearEmbedding(n_components=<span class="number">2</span>,n_neighbors=<span class="number">10</span>)</span><br><span class="line">X_reduced=lle.fit_transform(X)</span><br></pre></td></tr></table></figure>
<p><img src="/2018/08/07/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（七）：降维/22.png" alt></p>
<h2 id="其他降维方法"><a href="#其他降维方法" class="headerlink" title="其他降维方法"></a>其他降维方法</h2><p>多维缩放（MDS）在尝试保持实例之间距离的同时降低了维度</p>
<p>Isomap 通过将每个实例连接到最近的邻居来创建图形，然后在尝试保持实例之间的测地距离时降低维度。</p>
<p>t-分布随机邻域嵌入（t-Distributed Stochastic Neighbor Embedding，t-SNE）可以用于降低维​​度，同时试图保持相似的实例临近并将不相似的实例分开。它主要用于可视化，尤其是用于可视化高维空间中的实例（例如，可以将MNIST图像降维到 2D 可视化）。</p>
<p>线性判别分析（Linear Discriminant Analysis，LDA）实际上是一种分类算法，但在训练过程中，它会学习类之间最有区别的轴，然后使用这些轴来定义用于投影数据的超平面。LDA 的好处是投影会尽可能地保持各个类之间距离，所以在运行另一种分类算法（如 SVM 分类器）之前，LDA 是很好的降维技术。</p>
<p><img src="/2018/08/07/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（七）：降维/23.png" alt></p>
<h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><ol>
<li>减少数据集维度的主要动机是什么？主要缺点是什么？</li>
<li>什么是维度爆炸？</li>
<li>一旦对某数据集降维，我们可能恢复它吗？如果可以，怎样做才能恢复？如果不可以，为什么？</li>
<li>PCA 可以用于降低一个高度非线性对数据集吗？</li>
<li>假设你对一个 1000 维的数据集应用 PCA，同时设置方差解释率为 95%，你的最终数据集将会有多少维？</li>
<li>在什么情况下你会使用普通的 PCA，增量 PCA，随机 PCA 和核 PCA？</li>
<li>你该如何评价你的降维算法在你数据集上的表现？</li>
<li>将两个不同的降维算法串联使用有意义吗？</li>
</ol>
<hr>
<p>1、动机：为了加速后续训练算法（在某些情况下，它甚至可以消除噪声和冗余特征，使训练算法表现更好）； 通过可视化数据深入了解最重要的特征； 节省空间（压缩）。缺点：某些信息丢失，可能会降低后续训练算法的性能； 计算密集； 为机器学习管道增加了一些复杂性；转换后的功能通常难以解释。</p>
<p>2、在机器学习中，一个常见的表现是随机采样的高维向量通常非常稀疏，增加了过拟合的风险，并且在没有足够的训练数据的情况下很难识别数据中的模式。</p>
<p>3、一旦使用我们讨论过的算法减少了数据集的维数，几乎总是不可能完全逆转操作，因为在降维期间某些信息会丢失。 此外，虽然一些算法（例如PCA）具有可以重建与原始数据相对类似的数据集的简单反向变换过程，但是其他算法（例如T-SNE）则不然。</p>
<p>4、PCA可用于显着降低大多数数据集的维度，即使它们是高度非线性的，因为它至少可以消除无用的维度。 但是，如果没有无用的维度 - 例如，瑞士卷 - 那么使用PCA降低维数将失去太多信息。 你想要展开瑞士卷，而不是挤压它。</p>
<p>5、这是一个棘手的问题：它取决于数据集。 让我们看看两个极端的例子。 首先，假设数据集由几乎完全对齐的点组成。 在这种情况下，PCA可以将数据集减少到一维，同时仍然保留95％的方差。 现在想象一下，数据集由完全随机的点组成，分散在1000个维度周围。 在这种情况下，需要所有1,000个维度来保持95％的方差。 所以答案是，它取决于数据集，它可以是1到1,000之间的任何数字。 将解释的方差绘制为维数的函数是一种粗略了解数据集内在维度的方法。</p>
<p>6、常规PCA是默认值，但仅当数据集有足够内存时才有效。 当您需要在每次新实例到达时动态应用PCA，增量PCA对于在线任务很有用。 当您想要显着降低维度并且有足够内存时，随机PCA非常有用; 在这种情况下，它比普通PCA快得多。 最后，Kernel PCA对非线性数据集非常有用。</p>
<p>7、直观地说，如果从数据集中消除了大量维度而不会丢失太多信息，则降维算法表现良好。 衡量这种情况的一种方法是应用反向变换并测量重建误差。 但是，并非所有降维算法都提供逆向变换。</p>
<p>8、链接两个不同的降维算法绝对有意义。 一个常见的例子是使用PCA快速摆脱大量无用的维度，然后应用另一个慢得多的降维算法，如LLE。 这种两步法可能会产生与仅使用LLE相同的性能，但只需要很短的时间。</p>

          
        
      
    </div>
    
    
    
    
    
    
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/04/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（六）：集成学习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mosbyllc">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mosbyllc">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/04/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（六）：集成学习/" itemprop="url">Sklearn 与 TensorFlow 机器学习实用指南（六）：集成学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-04T16:05:54+08:00">
                2018-08-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Sklearn-与-TensorFlow-机器学习实用指南/" itemprop="url" rel="index">
                    <span itemprop="name">Sklearn 与 TensorFlow 机器学习实用指南</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  11,685
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  43
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>集成学习(ensemble learning)通过构建并结合多个学习器来完成学习任务，<strong>比单一学习器获得显著优越的泛化性能</strong>。想要获得好的集成，个体学习器应”<strong>好而不同</strong>“，要保证准确性和多样性。要产生好而不同的个体学习器，恰是集成学习研究的核心</p>
<p><strong>目前集成学习可分为两大类，即个体学习器之间有依赖关系，必须串行生成的序列化方法；以及个体学习器不存在强依赖关系，可同时生成的并行化方法。前者的代表是Boosting，最著名的是代表有Adaboost, GBDT和XGBOOST;后者的代表是Bagging和随机森林。对于学习器的结合策略有三大类：投票法（分类），平均法（连续数值），学习法（Stacking）</strong></p>
<h1 id="Boosting"><a href="#Boosting" class="headerlink" title="Boosting"></a>Boosting</h1><h2 id="Adaboost"><a href="#Adaboost" class="headerlink" title="Adaboost"></a>Adaboost</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>Adaboost提升方法是改变训练数据的概率分布（训练数据的权值分布），针对不同的训练数据分布调用弱学习算法学习一系列弱分类器。AdaBoost的做法是，<strong>提高那些被前一轮弱分类器错误分类样本的权值，而降低那些被正确分类样本的权值</strong>。这样一来，那些没有得到正确分类的数据，由于其权值的加大而受到后一轮的弱分类器的更大关注，于是，分类问题就被一系列的弱分类器“分而治之”。另外，对于弱分类器的组合，AdaBoost采取加权多数表决的方法。具体地，<strong>加大分类误差率小的弱分类器的权值，使其在表决中起较大的作用，减小分类误差率较大的弱分类器的权值，使其在表决中起较小的作用。</strong>(两个权重，一个是样本权重，另外一个是分类器的权重)</p>
<p>AdaboostBoost的算法的框架如下图所示</p>
<p><img src="/2018/08/04/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（六）：集成学习/01.png" alt></p>
<h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><p>具体算法流程如下图所示：</p>
<p><img src="/2018/08/04/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（六）：集成学习/02.png" alt></p>
<ul>
<li>step2. 预期迭代T轮</li>
<li>step4. 计算分类器$h_t$的误差率$\epsilon_t$ </li>
</ul>
<script type="math/tex; mode=display">
\epsilon_t=P\left(h_t\left(x\right)\ne y_i\right)=\frac{\sum_{i=1}^m{w_{ki}I\left(h_t\left(x_i\right)\ne y_i\right)}}{\sum_{i=1}^m{w_{ki}}}=\sum_{i=1}^m{w_{ki}I\left(G_m\left(x_i\right)\ne y_i\right)}</script><p>这里$w<em>{ki}$表示第k轮（第k个分类器）中第i个实例的权重，$\sum</em>{i=1}^m{w_{ki}=1}$，I表示指示函数，代表满足条件的样本。这表明，误差率是被$h_t$分类错误的样本的权重之和。（这些样本的权重会在后面归一化）</p>
<ul>
<li>step5. 分类器比随机分类效果还差则停止</li>
<li>step6. 根据误差率计算分类器的权重，表示最终分类器的重要程度。由表达式可知，当误差率小于等于1/2时，$\alpha_k$大于等于0。并且$\alpha_k$随着误差率的减小而增大，意味着误差越小的分类器最后的重要程度越大。</li>
<li>step7. 更新样本权重，$Z_k$为归一化因子，把最后的全部样本权重求和即可。</li>
</ul>
<script type="math/tex; mode=display">
w_{k+1,i}=\frac{w_{ki}}{Z_k}exp(-\alpha_k y_i G_k(x_i))</script><h3 id="Adaboost算法优缺点"><a href="#Adaboost算法优缺点" class="headerlink" title="Adaboost算法优缺点"></a>Adaboost算法优缺点</h3><h4 id="Adaboost优点"><a href="#Adaboost优点" class="headerlink" title="Adaboost优点"></a>Adaboost优点</h4><ul>
<li>不容易发生过拟合。</li>
<li>Adaboost是一种有很高精度的分类器。</li>
<li>当使用简单分类器时，计算出的结果是可理解的。</li>
<li>可以使用各种方法构建子分类器，Adaboost算法提供的是框架。</li>
</ul>
<h4 id="Adaboost缺点"><a href="#Adaboost缺点" class="headerlink" title="Adaboost缺点"></a>Adaboost缺点</h4><ul>
<li>训练时间过长。</li>
<li>执行效果依赖于弱分类器的选择。</li>
<li>对样本敏感，异常样本在迭代中可能会获得较高的权重，影响最终的强学习器的预测准确性。</li>
</ul>
<h2 id="GBTD"><a href="#GBTD" class="headerlink" title="GBTD"></a>GBTD</h2><p>GBDT（Gradient Boosting Decision Tree）是一种迭代的决策树算法，又叫 MART（Multiple Additive Regression Tree)，它通过构造一组弱的学习器（树），并把多颗决策树的结果累加起来作为最终的预测输出。该算法将决策树与集成思想进行了有效的结合。并且GBDT每一棵树都是回归树CART.。由于GBDT的核心在与累加所有树的结果作为最终结果，而分类树得到的离散分类结果对于预测分类并不是这么的容易叠加。这是区别于分类树的一个显著特征（毕竟男+女=是男是女?，这样的运算是毫无道理的），GBDT在运行时就使用到了回归树的这个性质，它将累加所有树的结果作为最终结果。所以GBDT中的树都是回归树，而不是分类树，它用来做回归预测，当然回归树经过调整之后也能用来做分类。</p>
<p>这里要先介绍GBDT简单版本的提升树Boosting Decision Tree，后面再介绍GBDT。</p>
<h3 id="提升树Boosting-Decision-Tree"><a href="#提升树Boosting-Decision-Tree" class="headerlink" title="提升树Boosting Decision Tree"></a>提升树Boosting Decision Tree</h3><p>提升树(Boosting Decision Tree)由于输出样本是连续值，因此我们通过迭代<strong>多棵</strong>回归树来共同决策（之前CART只是拟合一颗完整的回归树）。回归树的构造在上一节已经介绍过了，不再赘述。</p>
<p>我们利用平方误差来表示损失函数，其中每一棵回归树学习的是之前所有树的结论和残差，拟合得到一个当前的残差回归树。其中残差=真实值-预测值，提升树即是整个迭代过程生成的回归树的累加。提升树模型可以表示为决策树的加法模型：</p>
<script type="math/tex; mode=display">
f_M\left(x\right)=\sum_{m=1}^M{T\left(x;\varTheta_m\right)}</script><p>其中$T\left(x;\varTheta_m\right)$表示决策树；$\varTheta_m$为决策树的参数；M为树的个数。</p>
<p>提升树的过程如下，节点下所有点的均值作为该节点的预测值，例如左图的15与25。（这里是将特征分开处理并缩小了树的规模，若用CART可能会出现深度为3的回归树）</p>
<p><img src="/2018/08/04/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（六）：集成学习/03.png" alt></p>
<p>回归问题的提升树算法叙述如下：</p>
<p><img src="/2018/08/04/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（六）：集成学习/04.png" alt></p>
<p>对比初始的CART回归树与GBDT所生成的回归树，可以发现，最终的结果可能是相同的，那我们为什么还要使用GBDT呢？</p>
<ul>
<li>答案就是对模型过拟合的考虑。过拟合是指为了让训练集精度更高，学到了很多“仅在训练集上成立的规律”，导致换一个数据集后，当前规律的预测精度就不足以使人满意了。毕竟，在训练精度和实际精度（或测试精度）之间，后者才是我们想要真正得到的。</li>
<li>在上面这个例子中，初始的回归树为达到100%精度使用了3个特征（上网时长、时段、网购金额），但观察发现，分枝“上网时长&gt;1.1h”很显然过拟合了，不排除恰好A上网1.5h, B上网1小时，所以用上网时间是不是&gt;1.1小时来判断所有人的年龄很显然是有悖常识的。</li>
<li>而在GBDT中，两棵回归树仅使用了两个特征（购物金额与对百度知道的使用方式）就实现了100%的预测精度，其分枝依据更合乎逻辑（当然这里是相比较于上网时长特征而言），算法在运行中也体现了“如无必要，勿增实体”的奥卡姆剃刀原理</li>
</ul>
<h3 id="梯度提升决策树Gradient-Boosting-Decision-Tree"><a href="#梯度提升决策树Gradient-Boosting-Decision-Tree" class="headerlink" title="梯度提升决策树Gradient Boosting Decision Tree"></a>梯度提升决策树Gradient Boosting Decision Tree</h3><h4 id="GBDT回归算法"><a href="#GBDT回归算法" class="headerlink" title="GBDT回归算法"></a>GBDT回归算法</h4><p>提升树利用加法模型与向前分布算法实现学习的优化过程，即是通过迭代得到一系列的弱分类器，进而通过不同的组合策略得到相应的强学习器。在GBDT的迭代中，<strong>假设前一轮得到的强学习器为</strong>$f<em>{t−1}(x)$ ，对应的损失函数则为$L(y,f</em>{t−1}(x))$ 。<strong>因此新一轮迭代的目的就是找到一个弱学习器</strong>$h<em>t(x)$ ，<strong>使得损失函</strong>$L(y,f</em>{t−1}(x)+h_t(x))$ <strong>达到最小</strong>。<strong>因此问题的关键就在于对损失函数的度量，这也正是难点所在。当损失函数是平方损失和指数损失时，每一步优化是很简单的。但对一般损失函数而言，往往每一步优化没那么容易，如绝对值损失函数和Huber损失函数</strong>。常见的损失函数及其梯度如下表所示：</p>
<p><img src="/2018/08/04/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（六）：集成学习/05.png" alt></p>
<p>那我们怎么样才能找到一种通用的拟合方法呢？针对这一问题，Freidman提出了梯度提升算法：利用最速下降的近似方法，<strong>即利用损失函数的负梯度在当前模型的值</strong>，进而拟合一个CART回归树。其中第t轮的第i个样本的损失函数的扶梯度表示为，右下角的等式是求偏导后带入计算的</p>
<script type="math/tex; mode=display">
r_{ti}=-\left[\frac{\partial L\left(y,f\left(x_i\right)\right)}{\partial f\left(x_i\right)}\right]_{f\left(x\right)=f_{t-1}\;\,\left(x\right)}</script><p><strong>负梯度作为回归问题中提升树算法的残差的近似值</strong>（与其说负梯度作为残差的近似值，不如说残差是负梯度的一种特例，拟合一个回归树），这就是梯度提升决策树。假设样本数据为m，最大的迭代次数为T。其算法过程如下：</p>
<p><img src="/2018/08/04/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（六）：集成学习/06.png" alt></p>
<ul>
<li>step1. 初始化弱分类器，计算出使损失函数极小化的一个常数值c，此时树仅有一个根结点。c的均值可取样本y的均值。这个初始化得到的c将用于第一次计算负梯度$f(x<em>i)=f(t-1)=f(0)$的代入计算得到残差近似值$r</em>{ti}$。(第t代第i个样本)</li>
<li>step2(a) .计算每个样本的$r_{ti}$</li>
<li>step2(b). 利用$(x<em>i,r</em>{ti})i=1,2,3,…,m$，我们可以拟合一颗CART回归树，得到第t棵回归树（注意回归树节点内的均值求法不再是我们想要的了），其对应的叶节点区域为$R_{tj},j=1,2,3,…,J$，其中J为叶子节点的个数。</li>
<li>step2(c). 接下来，针对每一个叶子节点中的样本，要拟合叶子结点最好的输出值$c<em>{tj}$(不再是简单的求节点均值)，使得求出的损失函数最小。回顾之前写的新一轮迭代的目的，这时候的输出值$c</em>{tj}$组成就是我们想要的第t棵弱学习器$h_t(x)$。其实就是在上一棵强学习器树稍加改变决策树中叶节点值，希望拟合的误差越来越小。</li>
</ul>
<script type="math/tex; mode=display">
c_{tj}=\underset{c}{\underbrace{\arg\min}} \sum_{x_i \in R_{tj}}L(y_i,f_{t-1}(x_i)+c)</script><p>这样我们便得到本轮的弱学习器决策树拟合函数</p>
<script type="math/tex; mode=display">
h_t(x)=\sum _{j=1} ^{J} c_{tj},I(x \in R_{tj})</script><ul>
<li>step2(d). 更新强学习器，上一个强学习器+弱学习器</li>
</ul>
<script type="math/tex; mode=display">
f_t(x)=f_{t-1}(x)+\sum_{j=1}^{J}c_{tj},I(x\in R_{tj})</script><ul>
<li>step3. 得到输出的最后一轮的最终强学习器模型（最大迭代T轮）</li>
</ul>
<script type="math/tex; mode=display">
f(x)=f_T(x)=f_0(x)+\sum_{t=1}^{T}\sum_{j=1}^{J}c_{tj},I(x\in R_{tj})</script><h4 id="GBDT分类算法"><a href="#GBDT分类算法" class="headerlink" title="GBDT分类算法"></a>GBDT分类算法</h4><p>GBDT分类算法在思想上和回归算法没有区别，但是由于样本输出不是连续的值，而是离散的类别，导致我们无法直接从输出类别去拟合类别输出的误差。为解决此问题，我们尝试用类似于逻辑回归的对数似然损失函数的方法,也就是说我们用的是类别的预测概率值和真实概率值来拟合损失函数。对于对数似然损失函数，我们有二元分类和多元分类的区别。</p>
<h5 id="二元GBDT分类算法"><a href="#二元GBDT分类算法" class="headerlink" title="二元GBDT分类算法"></a>二元GBDT分类算法</h5><p>对于二元GBDT，如果用类似于逻辑回归的对数似然损失函数，则损失函数表示为</p>
<script type="math/tex; mode=display">
L(y,f(x))=log(1+exp(-yf(x)))</script><p>其中y∈{−1,1}。则此时的负梯度误差为</p>
<script type="math/tex; mode=display">
r_{ti}=-\left[\frac{\partial L(y_i,f(x_i))}{\partial f(x_i)} \right]_{f(x)=f_{t-1}(x)}=\frac{y_i}{1+exp(y_if(x_i))}</script><p>对于生成的决策树，我们各个叶子节点的最佳残差拟合值为</p>
<script type="math/tex; mode=display">
c_{tj}=\underset{c}{\underbrace{\arg\min}} \sum _{x_i\in R_{tj}}log(1+exp(-y_i(f_{t-1}(x_i)+c)))</script><p>由于上式比较难优化，我们一般使用近似值代替</p>
<script type="math/tex; mode=display">
c_{tj}=\frac{\sum _{x_i\in R_{tj}}r_{ti}}{\sum _{x_i \in R_{tj}}|r_{ti}|(1-|r_{ti}|)}</script><p>除了负梯度计算和叶子节点的最佳残差拟合的线性搜索外，二元GBDT分类和GBDT回归算法过程相同。</p>
<h5 id="多元GBDT分类算法"><a href="#多元GBDT分类算法" class="headerlink" title="多元GBDT分类算法"></a>多元GBDT分类算法</h5><p>多元GBDT要比二元GBDT复杂一些，对应的是多元逻辑回归和二元逻辑回归的复杂度差别。假如类别数为K，则我们的对数似然函数为</p>
<script type="math/tex; mode=display">
L(y,f(x))=-\sum_{k=1}^{K}y_k log(p_k(x))</script><p>其中如果样本输出类别为k，则$y_k=1$。第k类的概率$p_k(x)$的表达式为</p>
<script type="math/tex; mode=display">
p_k(x)=\frac {exp(f_k(x))}{\sum _{l=1}^{K}exp(f_l(x))}</script><p>集合上两式，我们可以计算出第t轮的第i个样本对应类别l的负梯度误差为</p>
<script type="math/tex; mode=display">
r_{til}=-\left[\frac{\partial L(y_i,f(x_i))}{\partial f(x_i)} \right]_{f_k(x)=f_{t-1,l}(x)}=y_{il}-p_{t-1,l}(x_i)</script><p>其实这里的误差就是样本i对应类别l的真实概率和t-1轮预测概率的差值。对于生成的决策树，我们各个叶子节点的最佳残差拟合值为</p>
<script type="math/tex; mode=display">
c_{tjl}=\underset{cjl}{\underbrace{\arg\min}} \sum_{i=1}^{m} \sum_{k=1}^{K}L(y_k,f_{t-1,l}(x))+\sum _{j=1}^{J}c_{jl},I(x_i\in R_{tj})</script><p>由于上式比较难优化，我们用近似值代替</p>
<script type="math/tex; mode=display">
c_{tjl}=\frac{K-1}{K}=\frac{\sum_{x_i\in R_{tjl}}r_{til}}{\sum _{x_i\in R_{til}}|r_{til}|(1-|r_{til}|)}</script><p>除了负梯度计算和叶子节点的最佳残差拟合的线性搜索，多元GBDT分类和二元GBDT分类以及GBDT回归算法过程相同。</p>
<h2 id="XGBoost"><a href="#XGBoost" class="headerlink" title="XGBoost"></a>XGBoost</h2><p>数据建模中，经常采用Boosting方法通过将成百上千个分类准确率较低的树模型组合起来，成为一个准确率很高的预测模型。这个模型会不断地迭代，每次迭代就生成一颗新的树。但在数据集较复杂的时候，可能需要几千次迭代运算，这将造成巨大的计算瓶颈。</p>
<p>针对这个问题。华盛顿大学的陈天奇博士开发的XGBoost（eXtreme Gradient Boosting）基于C++通过多线程实现了回归树的并行构建，并在原有Gradient Boosting算法基础上加以改进，从而极大地提升了模型训练速度和预测精度.</p>
<h3 id="梯度下降与牛顿法"><a href="#梯度下降与牛顿法" class="headerlink" title="梯度下降与牛顿法"></a>梯度下降与牛顿法</h3><p>在机器学习任务中，需要最小化损失函数L(θ)，其中θ是要求解的模型参数。梯度下降法常用来求解这种无约束最优化问题，它是一种迭代方法：选取初值$θ^0$ ,不断迭代，更新θ的值，进行损失函数的极小化。</p>
<ul>
<li>迭代公式：$θ^t = θ_{t-1}+△θ$ </li>
</ul>
<p><strong>梯度下降</strong>：将$L(θ^t)$ 在$θ^{t-1}$ 处进行一阶泰勒展开:</p>
<script type="math/tex; mode=display">L(θ^t)=L(θ^{t-1}+△θ)\approx L(θ^{t-1})+L'(θ^{t-1})△θ</script><p>要使得$L(θ^t)&lt;L(θ^{t-1})$ ,可取$△θ=-\alpha L’(θ^{t-1})$ ，则$θ^t = θ^{t-1}-\alpha L’(θ^{t-1})$<br>这里$\alpha$ 是步长，可通过line search确定，但一般直接赋一个小的数</p>
<p><strong>牛顿法</strong>：将$L(θ^t)$ 在$θ^{t-1}$ 处进行二阶泰勒展开:</p>
<script type="math/tex; mode=display">L(θ^t)\approx L(θ^{t-1})+L'(θ^{t-1})△θ+L''(θ^{t-1})\frac{(△θ)^2}{2}</script><p>可将一阶和二阶导数分别记为g 和 h,则:</p>
<script type="math/tex; mode=display">L(θ^t)\approx L(θ^{t-1})+g△θ+h\frac{(△θ)^2}{2}</script><p>要使得$L(θ^t)$极小，即让$g△θ+h\frac{(△θ)^2}{2}$ 极小，可令其对△θ求偏导值为0，求得$△θ=-\frac{g}{h}$ ,故$θ^t = θ^{t-1}+△θ=θ^{t-1}-\frac{g}{h}$ ,将其推广到向量形式，有$θ^t = θ^{t-1}-H^{-1}g$ </p>
<p>GBDT 在函数空间中利用梯度下降法进行优化<br>XGBoost 在函数空间中用牛顿法进行优化</p>
<h3 id="XGBoost的推导过程"><a href="#XGBoost的推导过程" class="headerlink" title="XGBoost的推导过程"></a>XGBoost的推导过程</h3><h4 id="定义目标函数"><a href="#定义目标函数" class="headerlink" title="定义目标函数"></a>定义目标函数</h4><p><strong>相比原始的GBDT，XGBoost的目标函数多了正则项，使得学习出来的模型更加不容易过拟</strong>合。有哪些指标可以衡量树的复杂度？树的深度，内部节点个数，<strong>叶子节点个数(T)，叶节点分数(w)</strong>…<br>XGBoost采用的是：T代表叶子数量，w代表叶子预测权值</p>
<p><img src="/2018/08/04/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（六）：集成学习/07.png" alt></p>
<p><strong>而XGBoost第t次迭代后，模型的预测等于前t-1次的模型预测加上第t棵树的预测</strong></p>
<p><img src="/2018/08/04/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（六）：集成学习/08.png" alt></p>
<p>即每次迭代生成一棵新的回归树，从而使预测值不断逼近真实值（即进一步最小化目标函数）。每一次保留原来的模型不变，加入一个新的函数f到模型里面。其中$\hat{y}_i\left(t-1\right)$就是t-1轮的模型预测，$f_t{(x_i)}$为新t轮加入的预测函数。选取的$f_t{(x_i)}$必须使我们的目标函数尽量最大地降低（这里应用到了Boosting的基本思想，即当前的基学习器重点关注以前所有学习器犯错误的那些数据样本，以此来达到提升的效果）</p>
<p>此时目标损失函数可写作：</p>
<p><img src="/2018/08/04/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（六）：集成学习/09.png" alt></p>
<p>如果我们考虑平方误差作为损失函数，公式可改写为：</p>
<p><img src="/2018/08/04/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（六）：集成学习/10.png" alt></p>
<blockquote>
<p>这里的化简没有看懂，感觉少了一项残差的平方。不过原等式$+f_t{(x_i)}$看做泰勒展开的$+\bigtriangleup x$ .</p>
</blockquote>
<p>公式中$y_i,\widehat y_i$ 都是已知的，<strong>模型要学习的只有第t棵树</strong>$f_t$ .另外对于损失函数不是平方误差的情况，我们可以采用如下的泰勒展开近似来定义一个近似的目标函数，方便我们进行下一步的计算。其中$g_i$和$h_i$为损失函数对$\widehat y_i^{t-1}$的一阶和二阶倒数。</p>
<p><img src="/2018/08/04/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（六）：集成学习/11.png" alt></p>
<p>这时候，所有东西都准备好了，<strong>最后我们怎么定义</strong>$f_t$呢？<strong>它可以代表一颗具有预测结果的树</strong>，即叶子节点有预测权重。我们定义w为树叶的权重序列，q为树的结构，那么q(x)代表样本x落在树叶的位置。</p>
<p><img src="/2018/08/04/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（六）：集成学习/12.png" alt></p>
<h4 id="目标函数的最小化"><a href="#目标函数的最小化" class="headerlink" title="目标函数的最小化"></a>目标函数的最小化</h4><p>得到了目标函数，接下来是最关键的一步，在这种新的定义下，我们可以把目标函数进行如下改写，其中$I$被定义为每个叶子上面样本集合$I_j={i| q(x_i)=j}$ 。$L(y_i,\widehat y_i^{t-1})$为真实值与前一个函数计算所得残差是已知的(我们都是在已知前一个树的情况下计算下一颗树的)，同时，在同一个叶子节点上的数的函数值是相同的，可以做合并，于是：</p>
<p><img src="/2018/08/04/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（六）：集成学习/13.jpg" alt></p>
<p>对上诉目标函数求导等于0，可以得到最后的结果：</p>
<p><img src="/2018/08/04/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（六）：集成学习/14.png" alt></p>
<p>得到这个目标函数，乍一看目标函数的计算与回归树的结构q函数没有什么关系，但是如果我们仔细回看目标函数的构成，就会发现<strong>其中$G_j$和$H_j$的取值是由第j个树叶上数据样本所决定的</strong>。而第jj个树上所具有的数据样本则是由树结构q函数决定的。也<strong>就是说，一旦回归树的结构q确定，那么相应的目标函数就能够根据上式计算出来。那么回归树的生成问题也就转换为找到一个最优的树结构q，使得它具有最小的目标函数。</strong></p>
<p><strong>计算求得的Obj目标函数代表了当指定一个树的结构的时候，目标函数上面最多减少多少</strong>。我们可以把它叫做<strong>结构分数</strong>（structure score）。可以把它认为是类似于基尼系数一样更加一般的对于树结构进行打分的函数。</p>
<p><strong>当回归树的结构确定时，我们前面已经推导出其最优的叶节点分数以及对应的最小损失值，问题是怎么确定树的结构？才能让得到的结构分数最好，目标函数损失降低最大</strong> 。主要有以下两种方法</p>
<ul>
<li>暴力枚举所有可能的树结构，选择损失值最小的 - NP难问题（树的结构有无穷种）</li>
<li>贪心法，每次尝试分裂一个叶节点，计算分裂前后的增益，选择增益最大的（主要）</li>
</ul>
<h4 id="确定树的结构（贪心法）"><a href="#确定树的结构（贪心法）" class="headerlink" title="确定树的结构（贪心法）"></a>确定树的结构（贪心法）</h4><p>分裂前后的增益怎么计算？</p>
<ul>
<li>ID3算法采用信息增益</li>
<li>C4.5算法采用信息增益比</li>
<li>CART采用Gini系数</li>
<li>XGBoost采用上诉优化函数的打分</li>
</ul>
<p>即每一次尝试区队已有的叶子加入一个分割。对于一个剧透的分割方案，我们可以获得的增益可以由如下公式计算得到：</p>
<p><img src="/2018/08/04/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（六）：集成学习/15.png" alt></p>
<p>这个公式形式上跟ID3算法（采用信息熵计算增益）或者CART算法（采用基尼指数计算增益） 是一致的，都是用分裂后的某种值减去分裂前的某种值，从而得到增益。<strong>为了限制树的生长</strong>，我们可以加入阈值，当增益大于阈值时才让节点分裂，上式中的$\gamma$即阈值，它是正则项里叶子节点数T的系数，<strong>所以xgboost在优化目标函数的同时相当于做了预剪枝</strong>。另外，<strong>上式中还有一个系数$\lambda$，是正则项里leaf score的L2模平方的系数，对leaf score做了平滑，也起到了防止过拟合的作用</strong>，这个是传统GBDT里不具备的特性。</p>
<blockquote>
<p> 但需要注意是：引入的分割不一定会使得情况变好，因为在引入分割的同时也引入新叶子的惩罚项。所以通常需要设定一个阈值，如果引入的分割带来的增益小于一个阀值的时候，我们可以剪掉这个分割。此外在XGBoost的具体实践中，通常会设置树的深度来控制树的复杂度，避免单个树过于复杂带来的过拟合问题。</p>
</blockquote>
<h4 id="如何使用及参数"><a href="#如何使用及参数" class="headerlink" title="如何使用及参数"></a>如何使用及参数</h4><p><img src="/2018/08/04/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（六）：集成学习/16.png" alt></p>
<p><img src="/2018/08/04/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（六）：集成学习/17.png" alt></p>
<h4 id="一些常见的问题"><a href="#一些常见的问题" class="headerlink" title="一些常见的问题"></a>一些常见的问题</h4><p>1、机器学习算法中GBDT和XGBOOST的区别有哪些？</p>
<p>2、为什么在实际的 kaggle 比赛中 gbdt 和 random forest 效果非常好？</p>
<p>3、 为什么xgboost/gbdt在调参时为什么树的深度很少就能达到很高的精度？</p>
<blockquote>
<p>这里就不花时间写了，可以参考知乎和一些博客文章。</p>
</blockquote>
<h1 id="Bagging和随机森林"><a href="#Bagging和随机森林" class="headerlink" title="Bagging和随机森林"></a>Bagging和随机森林</h1><p>如果采样出的每个子集都完全不同，则每个基学习器只用到一小部分训练数据，甚至不足以进行有效学习，这显然无法确保产生出比较好的基学习器。为了解决这个问题，我们可考虑使用相互有交叠的采样子集。</p>
<h2 id="Bagging"><a href="#Bagging" class="headerlink" title="Bagging"></a>Bagging</h2><p>随机取出一个样本放入采样集中，再把该样本放回初始数据集。这样的自助采样过程还给 Bagging带来了另一个优点：由于每个基学习器只使用了初始训练集中约 63.2%的样本，剩下约 36.8%的样本可用作验证集来对泛化性能进行包外估计(out-of-bag estimate)。Bagging通常对分类任务使用简单的投票法，对回归任务使用简单平均法。<br>Bagging的算法描述如下所诉($D_{bs}$是自助采样产生的样本分布,输出采用投票法)：</p>
<p><img src="/2018/08/04/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（六）：集成学习/18.png" alt></p>
<h2 id="随机森林"><a href="#随机森林" class="headerlink" title="随机森林"></a>随机森林</h2><p>随机森林(Random Forest)是Bagging的一个扩展变体。随机森林在以决策树为基学习器构建 Bagging集成的基础上，进一步在决策树的训练过程中引入了随机属性选择。具体来说，传统决策树在选择划分属性时是在当前结点的属性集合（假定有d个属性）中选择一个最优属性；而在随机森林中，对基决策树的每个结点，先从该结点的属性集合中随机选择一个包含k个属性的子集，然后再从这个子集中选择一个最优属性用于划分。这里的参数k控制了随机性的引入程度：若令 k=d，则基决策树的构建与传统决策树相同；若令k=1,则是随机选择一个属性用于划分；一般情况下，推荐值 k=log2d.随机森林简单、容易实现、计算开销小.</p>
<p>随机森林的训练效率常优于 Bagging，因为在个体决策树的构建过程中，Bagging使用的是“确定型”决策树，在选择划分属性时要对结点的所有属性进行考察，而随机森林使用的“随机型”决策树则只需考察一个属性子集。</p>
<p>由于这些树是随机生成的，大部分的树对解决分类或回归问题是没有意义的，那么生成上万的树有什么好处呢？好处便是生成的决策树中有少数非常好的决策树。当你要做预测的时候，新的观察值随着决策树自上而下的预测并被赋予一个预测值或标签。一旦森林中的每棵树都有了预测值或标签，所有的预测结果将被归总到一起，所有树的投票做为最终的预测结果。简单来说，会像大数原理一样，抛硬币的次数接近无穷，其正反概率会越接近真实概率1/2。大部分的树会相互抵消，最后得到一个泛化较好的结果，从而得到一个好的预测结果。</p>
<h1 id="学习器结合策略"><a href="#学习器结合策略" class="headerlink" title="学习器结合策略"></a>学习器结合策略</h1><p>假定集成包含 T 个基学习器h1,h2,…ht,其中hi在示例x上的输出为hi(x)下面介绍几种对hi进行结合的常见策略。</p>
<ul>
<li>投票法 1）硬投票  2）相对多数投票 3）加权投票</li>
<li>平均法 1）简单平均法 2）加权平均法（较好）</li>
<li>学习法 1）Stacking</li>
</ul>
<p><strong>Stacking</strong><br>当训练数据很多时，一种更为强大的结合策略是使用“学习法”，即通过另一个学习器来进行结合。Stacking是学习法的典型代表。这里我们把个体学习器称为初级学习器，用于结合的学习器称为次级学习器或元学习(metalearner)。</p>
<p><strong>Stacking先从初始数据集训练出初级学习器，然后“生成”一个新数据集用于训练次级学习器。在这个新数据集中，初级学习器的输出被当做样例输入特征，而初始样本的标记仍被当作样例标记</strong>。Stacking的算法描述如下，这里假定初级学习器使用不同的学习算法产生，即初级集成是异质的（初级学习器也可是同质的）。</p>
<p><img src="/2018/08/04/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（六）：集成学习/19.png" alt></p>
<p>train数据是初级训练器5折交叉得到的输出，test是初级训练器预测test后的均值</p>
<p><img src="/2018/08/04/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（六）：集成学习/27.jpg" alt></p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="投票分类"><a href="#投票分类" class="headerlink" title="投票分类"></a>投票分类</h2><p>像我们之前讨论的一样，我们会在一个项目快结束的时候使用集成算法，一旦你建立了一些好的分类器，就把他们合并为一个更好的分类器。事实上，在机器学习竞赛中获得胜利的算法经常会包含一些集成方法。</p>
<p>接下来的代码创建和训练了在 sklearn 中的投票分类器。这个分类器由三个不同的分类器组成（训练集是第五章中的 moons 数据集）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> VotingClassifier </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>log_clf = LogisticRegression() </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rnd_clf = RandomForestClassifier() </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>svm_clf = SVC()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>voting_clf = VotingClassifier(estimators=[(<span class="string">'lr'</span>, log_clf), (<span class="string">'rf'</span>, rnd_clf), &gt;&gt;&gt; (<span class="string">'svc'</span>, svm_clf)],voting=<span class="string">'hard'</span>) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>voting_clf.fit(X_train, y_train)</span><br></pre></td></tr></table></figure>
<p>让我们看一下在测试集上的准确率：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> clf <span class="keyword">in</span> (log_clf, rnd_clf, svm_clf, voting_clf): </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>    clf.fit(X_train, y_train) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>    y_pred = clf.predict(X_test) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>    print(clf.__class__.__name__, accuracy_score(y_test, y_pred)) </span><br><span class="line">LogisticRegression <span class="number">0.864</span> </span><br><span class="line">RandomForestClassifier <span class="number">0.872</span> </span><br><span class="line">SVC <span class="number">0.888</span> </span><br><span class="line">VotingClassifier <span class="number">0.896</span></span><br></pre></td></tr></table></figure>
<p><strong>你看！投票分类器比其他单独的分类器表现的都要好。</strong></p>
<p>如果所有的分类器都能够预测类别的概率（例如他们有一个predict_proba()方法），那么你就可以让 sklearn 以最高的类概率来预测这个类，平均在所有的分类器上。这种方式叫做<strong>软投票</strong>。<strong>他经常比硬投票表现的更好，因为它给予高自信的投票更大的权重。你可以通过把voting=”hard”设置为voting=”soft”来保证分类器可以预测类别概率。然而这不是 SVC 类的分类器默认的选项，所以你需要把它的probability hyperparameter设置为True</strong>（<strong>这会使 SVC 使用交叉验证去预测类别概率，其降低了训练速度，但会添加predict_proba()方法</strong>）。如果你修改了之前的代码去使用软投票，你会发现投票分类器正确率高达 91%</p>
<h2 id="Bagging-和-Pasting"><a href="#Bagging-和-Pasting" class="headerlink" title="Bagging 和 Pasting"></a>Bagging 和 Pasting</h2><p>就像之前讲到的，可以通过使用不同的训练算法去得到一些不同的分类器。另一种方法就是对每一个分类器都使用相同的训练算法，但是在不同的训练集上去训练它们。<strong>有放回采样被称为装袋（Bagging，是 bootstrap aggregating 的缩写）。无放回采样称为粘贴（pasting）</strong></p>
<p>换句话说，Bagging 和 Pasting 都允许在多个分类器上对训练集进行多次采样，但只有 Bagging 允许对同一种分类器上对训练集进行进行多次采样。</p>
<p><strong>当所有的分类器被训练后，集成可以通过对所有分类器结果的简单聚合来对新的实例进行预测。聚合函数通常对分类是统计模式（例如硬投票分类器）或者对回归是平均</strong>。<strong>每一个单独的分类器在如果在原始训练集上都是高偏差，但是聚合降低了偏差和方差</strong>。通常情况下，集成的结果是有一个相似的偏差，但是对比与在原始训练集上的单一分类器来讲<strong>有更小的方差</strong>。</p>
<h2 id="sklearn-中的-Bagging-和-Pasting"><a href="#sklearn-中的-Bagging-和-Pasting" class="headerlink" title="sklearn 中的 Bagging 和 Pasting"></a>sklearn 中的 Bagging 和 Pasting</h2><p>sklearn 为 Bagging 和 Pasting 提供了一个简单的API：BaggingClassifier类（或者对于回归可以是BaggingRegressor。接下来的代码训练了一个 500 个决策树分类器的集成，每一个都是在数据集上有放回采样 100 个训练实例下进行训练（<strong>这是 Bagging 的例子，如果你想尝试 Pasting，就设置bootstrap=False</strong>）。<strong>n_jobs参数告诉 sklearn 用于训练和预测所需要 CPU 核的数量。（-1 代表着 sklearn 会使用所有空闲核）：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> BaggingClassifier </span><br><span class="line">&gt;&gt;&gt;<span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line">&gt;&gt;&gt;bag_clf = BaggingClassifier(DecisionTreeClassifier(), n_estimators=<span class="number">500</span>, 	max_samples=<span class="number">100</span>, bootstrap=<span class="literal">True</span>, n_jobs=<span class="number">-1</span>) </span><br><span class="line">&gt;&gt;&gt;bag_clf.fit(X_train, y_train) </span><br><span class="line">&gt;&gt;&gt;y_pred = bag_clf.predict(X_test)</span><br></pre></td></tr></table></figure>
<p><strong>如果基分类器可以预测类别概率（例如它拥有predict_proba()方法），那么BaggingClassifier会自动的运行软投票，这是决策树分类器的情况。</strong></p>
<p>下图对比了单一决策树的决策边界和 Bagging 集成 500 个树的决策边界，两者都在 moons 数据集上训练。正如你所看到的，集成的分类比起单一决策树的分类产生情况更好：集成有一个可比较的偏差但是有一个较小的方差（它在训练集上的错误数目大致相同，但决策边界较不规则）。</p>
<p><img src="/2018/08/04/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（六）：集成学习/20.png" alt></p>
<p><strong>Bootstrap 在每个预测器被训练的子集中引入了更多的分集，所以 Bagging 结束时的偏差比 Pasting 更高，但这也意味着预测因子最终变得不相关，从而减少了集合的方差。总体而言，Bagging 通常会导致更好的模型，这就解释了为什么它通常是首选的</strong>。然而，如果你有空闲时间和 CPU 功率，可以使用交叉验证来评估 Bagging 和 Pasting 哪一个更好。</p>
<h2 id="Out-of-Bag-评价"><a href="#Out-of-Bag-评价" class="headerlink" title="Out-of-Bag 评价"></a>Out-of-Bag 评价</h2><p>对于 Bagging 来说，一些实例可能被一些分类器重复采样，但其他的有可能不会被采样。BaggingClassifier默认采样。<strong>BaggingClassifier默认是有放回的采样m个实例 （bootstrap=True），其中m是训练集的大小</strong>，这意味着平均下来只有63%的训练实例被每个分类器采样，<strong>剩下的37%个没有被采样的训练实例就叫做 Out-of-Bag 实例。注意对于每一个的分类器它们的 37% 不是相同的</strong>。</p>
<p><strong>因为在训练中分类器从来没有看到过 oob 实例，所以它可以在这些实例上进行评估，而不需要单独的验证集或交叉验证</strong>。你可以拿出每一个分类器的 oob 来评估集成本身。</p>
<p>在 sklearn 中，你可以在训练后需要创建一个BaggingClassifier来自动评估时设置oob<em>score=True来自动评估。接下来的代码展示了这个操作。评估结果通过变量oob_score</em>来显示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bag_clf = BaggingClassifier(DecisionTreeClassifier(), n_estimators=<span class="number">500</span>,bootstrap=<span class="literal">True</span>, n_jobs=<span class="number">-1</span>, oob_score=<span class="literal">True</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bag_clf.fit(X_train, y_train) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bag_clf.oob_score_ </span><br><span class="line"><span class="number">0.93066666666666664</span></span><br></pre></td></tr></table></figure>
<p>根据这个 obb 评估，BaggingClassifier可以再测试集上达到93.1%的准确率，让我们修改一下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y_pred = bag_clf.predict(X_test) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>accuracy_score(y_test, y_pred) </span><br><span class="line"><span class="number">0.93600000000000005</span></span><br></pre></td></tr></table></figure>
<p>我们在测试集上得到了 93.6% 的准确率，足够接近了！</p>
<p><strong>对于每个训练实例 oob 决策函数也可通过oob<em>decision_function</em>变量来展示</strong>。在这种情况下（当基决策器有predict_proba()时）决策函数会对每个训练实例返回类别概率。例如，oob 评估预测第二个训练实例有 60.6% 的概率属于正类（39.4% 属于负类）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bag_clf.oob_decision_function_ </span><br><span class="line">array([[ <span class="number">0.</span>,  <span class="number">1.</span>], [ <span class="number">0.60588235</span>,  <span class="number">0.39411765</span>],[ <span class="number">1.</span>, <span class="number">0.</span> ], </span><br><span class="line"><span class="meta">... </span> [ <span class="number">1.</span> ,  <span class="number">0.</span> ],[ <span class="number">0.</span>,  <span class="number">1.</span>],[ <span class="number">0.48958333</span>,  <span class="number">0.51041667</span>]])</span><br></pre></td></tr></table></figure>
<h2 id="随机森林-1"><a href="#随机森林-1" class="headerlink" title="随机森林"></a>随机森林</h2><p>正如我们所讨论的，随机森林是决策树的一种集成，通常是通过 bagging 方法（有时是 pasting 方法）进行训练，通常用max_samples设置为训练集的大小。与建立一个BaggingClassifier然后把它放入 DecisionTreeClassifier 相反，你可以使用更方便的也是对决策树优化够的RandomForestClassifier（对于回归是RandomForestRegressor）。接下来的代码训练了带有 500 个树（每个被限制为 16 叶子结点）的决策森林，使用所有空闲的 CPU 核：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier</span><br><span class="line">&gt;&gt;&gt;rnd_clf = RandomForestClassifier(n_estimators=<span class="number">500</span>, max_leaf_nodes=<span class="number">16</span>, n_jobs=<span class="number">-1</span>) </span><br><span class="line">&gt;&gt;&gt;rnd_clf.fit(X_train, y_train)</span><br><span class="line">&gt;&gt;&gt;y_pred_rf = rnd_clf.predict(X_test)</span><br></pre></td></tr></table></figure>
<p>除了一些例外，RandomForestClassifier使用DecisionTreeClassifier的所有超参数（决定数怎么生长），把BaggingClassifier的超参数加起来来控制集成本身</p>
<p><strong>随机森林算法在树生长时引入了额外的随机；与在节点分裂时需要找到最好分裂特征相反，它在一个随机的特征集中找最好的特征。它导致了树的差异性，并且再一次用高偏差换低方差，总的来说是一个更好的模型</strong>。以下是BaggingClassifier大致相当于之前的randomforestclassifier：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;bag_clf = BaggingClassifier(DecisionTreeClassifier(splitter=<span class="string">"random"</span>, max_leaf_nodes=<span class="number">16</span>),n_estimators=<span class="number">500</span>, max_samples=<span class="number">1.0</span>, bootstrap=<span class="literal">True</span>, n_jobs=<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>
<h2 id="极端随机树"><a href="#极端随机树" class="headerlink" title="极端随机树"></a>极端随机树</h2><p><strong>当你在随机森林上生长树时，在每个结点分裂时只考虑随机特征集上的特征（正如之前讨论过的一样）。相比于找到更好的特征我们可以通过使用对特征使用随机阈值使树更加随机（像规则决策树一样）。</strong></p>
<p>这种极端随机的树被简称为 Extremely Randomized Trees（极端随机树），或者更简单的称为 Extra-Tree。再一次用高偏差换低方差。它还使得 Extra-Tree 比规则的随机森林更快地训练，因为在每个节点上找到每个特征的最佳阈值是生长树最耗时的任务之一。</p>
<p>你可以使用 sklearn 的ExtraTreesClassifier来创建一个 Extra-Tree 分类器。他的 API 跟RandomForestClassifier是相同的，相似的， ExtraTreesRegressor 跟RandomForestRegressor也是相同的 API。</p>
<p><strong>我们很难去分辨ExtraTreesClassifier和RandomForestClassifier到底哪个更好。通常情况下是通过交叉验证来比较它们（使用网格搜索调整超参数）</strong></p>
<h2 id="特征重要度"><a href="#特征重要度" class="headerlink" title="特征重要度"></a>特征重要度</h2><p><strong>最后，如果你观察一个单一决策树，重要的特征会出现在更靠近根部的位置，而不重要的特征会经常出现在靠近叶子的位置。因此我们可以通过计算一个特征在森林的全部树中出现的平均深度来预测特征的重要性</strong>。sklearn 在训练后会自动计算每个特征的重要度。你可以通过feature<em>importances</em>变量来查看结果。例如如下代码在 iris 数据集（第四章介绍）上训练了一个RandomForestClassifier模型，然后输出了每个特征的重要性。看来，最重要的特征是花瓣长度（44%）和宽度（42%），而萼片长度和宽度相对比较是不重要的（分别为 11% 和 2%）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>iris = load_iris() </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rnd_clf = RandomForestClassifier(n_estimators=<span class="number">500</span>, n_jobs=<span class="number">-1</span>) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rnd_clf.fit(iris[<span class="string">"data"</span>], iris[<span class="string">"target"</span>]) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> name, score <span class="keyword">in</span> zip(iris[<span class="string">"feature_names"</span>], rnd_clf.feature_importances_): </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>    print(name, score) </span><br><span class="line">sepal length (cm) <span class="number">0.112492250999</span></span><br><span class="line">sepal width (cm) <span class="number">0.0231192882825</span> </span><br><span class="line">petal length (cm) <span class="number">0.441030464364</span> </span><br><span class="line">petal width (cm) <span class="number">0.423357996355</span></span><br></pre></td></tr></table></figure>
<p>相似的，如果你在 MNIST 数据及上训练随机森林分类器（在第三章上介绍），然后画出每个像素的重要性，你可以得到下图</p>
<p><img src="/2018/08/04/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（六）：集成学习/21.png" alt></p>
<p>随机森林可以非常方便快速得了解哪些特征实际上是重要的，特别是你需要进行特征选择的时候</p>
<h2 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h2><p>下图显示连续五次预测的 moons 数据集的决策边界（在本例中，每一个分类器都是高度正则化带有 RBF 核的 SVM）。<strong>第一个分类器误分类了很多实例，所以它们的权重被提升了。第二个分类器因此对这些误分类的实例分类效果更好，以此类推</strong>。右边的图代表了除了学习率减半外（误分类实例权重每次迭代上升一半）相同的预测序列（误分类的样本权重提升速率即学习率）。你可以看出，序列学习技术与梯度下降很相似，除了调整单个预测因子的参数以最小化代价函数之外，AdaBoost 增加了集合的预测器，逐渐使其更好。</p>
<p><img src="/2018/08/04/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（六）：集成学习/22.png" alt></p>
<p><strong>klearn 通常使用 Adaboost 的多分类版本 SAMME（这就代表了 分段加建模使用多类指数损失函数）。如果只有两类别，那么 SAMME 是与 Adaboost 相同的。如果分类器可以预测类别概率（例如如果它们有predict_proba()），如果 sklearn 可以使用 SAMME 叫做SAMME.R的变量（R 代表“REAL”），这种依赖于类别概率的通常比依赖于分类器的更好。</strong></p>
<p>接下来的代码训练了使用 sklearn 的AdaBoostClassifier基于 200 个决策树桩 Adaboost 分类器（正如你说期待的，对于回归也有AdaBoostRegressor）。<strong>一个决策树桩是max_depth=1的决策树-换句话说，是一个单一的决策节点加上两个叶子结点。这就是AdaBoostClassifier的默认基分类器</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> AdaBoostClassifier</span><br><span class="line">&gt;&gt;&gt;ada_clf = AdaBoostClassifier(DecisionTreeClassifier(max_depth=<span class="number">1</span>), n_estimators=<span class="number">200</span>,algorithm=<span class="string">"SAMME.R"</span>, learning_rate=<span class="number">0.5</span>) </span><br><span class="line">&gt;&gt;&gt;ada_clf.fit(X_train, y_train)</span><br></pre></td></tr></table></figure>
<p><strong>如果你的 Adaboost 集成过拟合了训练集，你可以尝试减少基分类器的数量或者对基分类器使用更强的正则化。</strong></p>
<h2 id="梯度提升"><a href="#梯度提升" class="headerlink" title="梯度提升"></a>梯度提升</h2><p>另一个非常著名的提升算法是梯度提升。与 Adaboost 一样，梯度提升也是通过向集成中逐步增加分类器运行的，每一个分类器都修正之前的分类结果。然而，它并不像 Adaboost 那样每一次迭代都更改实例的权重，这个方法<strong>是去使用新的分类器去拟合前面分类器预测的残差 。</strong></p>
<p>让我们通过一个使用决策树当做基分类器的简单的回归例子（回归当然也可以使用梯度提升）。这被叫做梯度提升回归树（GBRT，Gradient Tree Boosting 或者 Gradient Boosted Regression Trees）。首先我们用DecisionTreeRegressor去拟合训练集（例如一个有噪二次训练集）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeRegressor </span><br><span class="line">&gt;&gt;&gt;tree_reg1 = DecisionTreeRegressor(max_depth=<span class="number">2</span>) </span><br><span class="line">&gt;&gt;&gt;tree_reg1.fit(X, y)</span><br></pre></td></tr></table></figure>
<p>现在在第一个分类器的残差上训练第二个分类器：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;y2 = y - tree_reg1.predict(X) </span><br><span class="line">&gt;&gt;&gt;tree_reg2 = DecisionTreeRegressor(max_depth=<span class="number">2</span>) </span><br><span class="line">&gt;&gt;&gt;tree_reg2.fit(X, y2)</span><br></pre></td></tr></table></figure>
<p>随后在第二个分类器的残差上训练第三个分类器：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;y3 = y2 - tree_reg1.predict(X) </span><br><span class="line">&gt;&gt;&gt;tree_reg3 = DecisionTreeRegressor(max_depth=<span class="number">2</span>) </span><br><span class="line">&gt;&gt;&gt;tree_reg3.fit(X, y3)</span><br></pre></td></tr></table></figure>
<p>现在我们有了一个包含三个回归器的集成。它可以通过集成所有树的预测来在一个新的实例上进行预测。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;y_pred = sum(tree.predict(X_new) <span class="keyword">for</span> tree <span class="keyword">in</span> (tree_reg1, tree_reg2, tree_reg3))</span><br></pre></td></tr></table></figure>
<p><strong>下图左栏展示了这三个树的预测，在右栏展示了集成的预测。在第一行，集成只有一个树，所以它与第一个树的预测相似。在第二行，一个新的树在第一个树的残差上进行训练。在右边栏可以看出集成的预测等于前两个树预测的和</strong>。相同的，在第三行另一个树在第二个数的残差上训练。你可以看到集成的预测会变的更好。</p>
<p><img src="/2018/08/04/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（六）：集成学习/23.png" alt></p>
<p><strong>我们可以使用 sklean 中的GradientBoostingRegressor来训练 GBRT 集成。与RandomForestClassifier相似，它也有超参数去控制决策树的生长（例如max_depth，min_samples_leaf等等），也有超参数去控制集成训练，例如基分类器的数量（n_estimators）</strong>。接下来的代码创建了与之前相同的集成：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> GradientBoostingRegressor</span><br><span class="line">&gt;&gt;&gt;gbrt = GradientBoostingRegressor(max_depth=<span class="number">2</span>, n_estimators=<span class="number">3</span>, learning_rate=<span class="number">1.0</span>) </span><br><span class="line">&gt;&gt;&gt;gbrt.fit(X, y)</span><br></pre></td></tr></table></figure>
<p><strong>超参数learning_rate 确立了每个树的贡献。如果你把它设置为一个很小的树，例如 0.1，在集成中就需要更多的树去拟合训练集，但预测通常会更好。这个正则化技术叫做 shrinkage。</strong>下图 展示了两个在低学习率上训练的 GBRT 集成：其中左面是一个没有足够树去拟合训练集的树，右面是有过多的树过拟合训练集的树。</p>
<p><img src="/2018/08/04/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（六）：集成学习/24.png" alt></p>
<p><strong>为了找到树的最优数量，你可以使用早停技术。最简单使用这个技术的方法就是使用staged_predict()：它在训练的每个阶段（用一棵树，两棵树等）返回一个迭代器。加下来的代码用 120 个树训练了一个 GBRT 集成，然后在训练的每个阶段验证错误以找到树的最佳数量，最后使用 GBRT 树的最优数量训练另一个集成</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line">&gt;&gt;&gt;<span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line">&gt;&gt;&gt;<span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> mean_squared_error</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;X_train, X_val, y_train, y_val = train_test_split(X, y)</span><br><span class="line">&gt;&gt;&gt;gbrt = GradientBoostingRegressor(max_depth=<span class="number">2</span>, n_estimators=<span class="number">120</span>) </span><br><span class="line">&gt;&gt;&gt;gbrt.fit(X_train, y_train)</span><br><span class="line">&gt;&gt;&gt;errors = [mean_squared_error(y_val, y_pred)         </span><br><span class="line">     <span class="keyword">for</span> y_pred <span class="keyword">in</span> gbrt.staged_predict(X_val)] </span><br><span class="line">&gt;&gt;&gt;bst_n_estimators = np.argmin(errors)</span><br><span class="line">&gt;&gt;&gt;gbrt_best = GradientBoostingRegressor(max_depth=<span class="number">2</span>,n_estimators=bst_n_estimators) </span><br><span class="line">&gt;&gt;&gt;gbrt_best.fit(X_train, y_train)</span><br></pre></td></tr></table></figure>
<p>验证错误在图的左面展示，最优模型预测被展示在右面</p>
<p><img src="/2018/08/04/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（六）：集成学习/25.png" alt></p>
<p><strong>你也可以早早的停止训练来实现早停（与先在一大堆树中训练，然后再回头去找最优数目相反）</strong>。你可以通过设置warm_start=True来实现 ，这使得当fit()方法被调用时 sklearn 保留现有树，并允许增量训练。接下来的代码在当一行中的五次迭代验证错误没有改善时会停止训练：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;gbrt = GradientBoostingRegressor(max_depth=<span class="number">2</span>, warm_start=<span class="literal">True</span>)</span><br><span class="line">min_val_error = float(<span class="string">"inf"</span>) </span><br><span class="line">error_going_up = <span class="number">0</span> </span><br><span class="line"><span class="keyword">for</span> n_estimators <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">120</span>):    </span><br><span class="line">    gbrt.n_estimators = n_estimators    </span><br><span class="line">    gbrt.fit(X_train, y_train)    </span><br><span class="line">    y_pred = gbrt.predict(X_val)    </span><br><span class="line">    val_error = mean_squared_error(y_val, y_pred)    </span><br><span class="line">    <span class="keyword">if</span> val_error &lt; min_val_error:        </span><br><span class="line">        min_val_error = val_error        </span><br><span class="line">        error_going_up = <span class="number">0</span>    </span><br><span class="line">    <span class="keyword">else</span>:        </span><br><span class="line">        error_going_up += <span class="number">1</span>        </span><br><span class="line">        <span class="keyword">if</span> error_going_up == <span class="number">5</span>:            </span><br><span class="line">            <span class="keyword">break</span>  <span class="comment"># early stopping</span></span><br></pre></td></tr></table></figure>
<p><strong>GradientBoostingRegressor也支持指定用于训练每棵树的训练实例比例的超参数subsample。例如如果subsample=0.25，那么每个树都会在 25% 随机选择的训练实例上训练。你现在也能猜出来，这也是个高偏差换低方差的作用。它同样也加速了训练。这个技术叫做随机梯度提升。</strong></p>
<p>也可能对其他损失函数使用梯度提升。这是由损失超参数控制（见 sklearn 文档）。</p>
<h2 id="Stacking"><a href="#Stacking" class="headerlink" title="Stacking"></a>Stacking</h2><p>本章讨论的最后一个集成方法叫做 Stacking（stacked generalization 的缩写）。这个算法基于一个简单的想法：不使用琐碎的函数（如硬投票）来聚合集合中所有分类器的预测，我们为什么不训练一个模型来执行这个聚合？图 展示了这样一个在新的回归实例上预测的集成。底部三个分类器每一个都有不同的值（3.1，2.7 和 2.9），然后最后一个分类器（叫做 blender 或者 meta learner ）把这三个分类器的结果当做输入然后做出最终决策（3.0）</p>
<p><img src="/2018/08/04/Sklearn 与 TensorFlow 机器学习实用指南/Sklearn-与-TensorFlow-机器学习实用指南（六）：集成学习/26.png" alt></p>
<h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><ol>
<li>如果你在相同训练集上训练 5 个不同的模型，它们都有 95% 的准确率，那么你是否可以通过组合这个模型来得到更好的结果？如果可以那怎么做呢？如果不可以请给出理由。</li>
<li>软投票和硬投票分类器之间有什么区别？</li>
<li>是否有可能通过分配多个服务器来加速 bagging 集成系统的训练？pasting 集成，boosting 集成，随机森林，或 stacking 集成怎么样？</li>
<li>out-of-bag 评价的好处是什么？</li>
<li>是什么使 极端随机树Extra-Tree 比规则随机森林更随机呢？这个额外的随机有什么帮助呢？那这个 Extra-Tree 比规则随机森林谁更快呢？</li>
<li>如果你的 Adaboost 模型欠拟合，那么你需要怎么调整超参数？</li>
<li>如果你的梯度提升过拟合，那么你应该调高还是调低学习率呢？</li>
</ol>
<hr>
<p>1、只要模型间多样性较大，组合成一个集合模型，会起到一定的效果。</p>
<p>2、硬投票分类器只计算集成中每个分类器的投票数，并选择得票最多的类。 软投票分类器计算每个类的平均估计概率，并选择具有最高概率的类。 软投票使概率大的类别权重更高，通常表现更好，但只有在可以估计类概率的分类器时才有效（例如，对于Scikit-Learn中的SVM分类器，您必须设置probability = True）。</p>
<p>3、 bagging，pasting，随机森林是可以的。boosting 集成因为学习器需要基于先前的学习器构建，因此训练是连续的，故不适合。至于stacking 集成，给定层中的所有预测变量彼此独立，因此可以在多个服务器上并行训练它们。 但是，一层中的预测变量只能在前一层中的预测变量都经过训练后才能进行训练。</p>
<p>4、未被训练过得实例可以当做验证集</p>
<p>5、在随机森林中，只考虑特征的随机子集并在每个节点处进行分割。 对于Extra-Trees也是如此，但它们更进一步：不是像常规决策树一样搜索最佳阈值，而是为每个特征使用随机阈值。 这种额外的随机性就像一种正则化的形式：如果随机森林过度拟合训练数据，极端随机树可能表现更好。 此外，由于Extra-Trees不会搜索最佳阈值，因此它们比随机森林训练要快得多。 然而，在做出预测时，它们既不比随机森林更快也不慢。</p>
<p>6、如果您的AdaBoost集合欠拟合，可以尝试增加学习器的数量或减少基本学习器的正则化超参数。 也可以尝试稍微提高学习率。</p>
<p>7、如果您的Gradient Boosting过拟合，应该尝试降低学习率。 你也可以使用早期停止法。</p>

          
        
      
    </div>
    
    
    
    
    
    
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Mosbyllc">
            
              <p class="site-author-name" itemprop="name">Mosbyllc</p>
              <p class="site-description motion-element" itemprop="description">Sometimes thing have to fall apart to make way for better things.</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">62</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">74</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/kugua233" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:1499913789@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Recommended reading
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://wulc.me/" title="Wulc" target="_blank">Wulc</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://blog.csdn.net/qq_15262671/article/details/78481922" title="Pinard" target="_blank">Pinard</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://donche.github.io/" title="Donche" target="_blank">Donche</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://xtf615.com/" title="XFT" target="_blank">XFT</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://seawaylee.github.io/" title="Seawaylee" target="_blank">Seawaylee</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-star"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mosbyllc</span>

  
</div>











        







        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  


  

  

</body>
</html>
