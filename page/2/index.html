<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="Mosbyllc" type="application/atom+xml">






<meta name="description" content="Sometimes thing have to fall apart to make way for better things.">
<meta property="og:type" content="website">
<meta property="og:title" content="Mosbyllc">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Mosbyllc">
<meta property="og:description" content="Sometimes thing have to fall apart to make way for better things.">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Mosbyllc">
<meta name="twitter:description" content="Sometimes thing have to fall apart to make way for better things.">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"right","display":"always","offset":12,"b2t":true,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/">





  <title>Mosbyllc</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Mosbyllc</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>

<link href="https://cdn.bootcss.com/KaTeX/0.7.1/katex.min.css" rel="stylesheet">



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/06/数据挖掘概念与技术/数据挖掘概念与技术笔记（5）：分类/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mosbyllc">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mosbyllc">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/06/数据挖掘概念与技术/数据挖掘概念与技术笔记（5）：分类/" itemprop="url">数据挖掘概念与技术笔记（5）：分类</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-06T17:06:14+08:00">
                2018-11-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据挖掘/" itemprop="url" rel="index">
                    <span itemprop="name">数据挖掘</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2,774
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  10
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这一章很多概念都是之前就接触了，就不一一记录了，这里记录一些感兴趣的吧。</p>
<h2 id="决策树剪枝"><a href="#决策树剪枝" class="headerlink" title="决策树剪枝"></a>决策树剪枝</h2><p>为了避免决策树过拟合数据，一般要对决策树进行剪枝：<strong>先剪枝和后剪枝</strong></p>
<p>在先剪枝方法中，通过提前停止树的构造（例如，通过决定在给定的结点上不再分裂或划分训练样本的子集）而对树“剪枝”。在构造树时，统计意义下的度量，如信息增益、基尼指数等，可以用于评估分裂的优劣。如果在一个结点划分样本将导致低于预定义阈值的分裂，则给定子集的进一步划分将停止。然而，选取一个适当的阈值是困难的。较高的阈值可能导致过分简化的树，而较低的阈值可能使得树的化简太少。</p>
<p>第二种更常用的方法是后剪枝，它由“完全生长”的树之后再剪去分枝，通过用叶子节点替换要删除的分枝。CART使用的代价复杂度剪枝算法是后剪枝方法的一个实例。该方法把树的复杂度看做树叶节点的个数和树的错误率的函数，如果减去节点N的子树导致较小的代价复杂度，则剪掉该子树；否则，保留该子树。</p>
<h2 id="可伸缩性与决策树"><a href="#可伸缩性与决策树" class="headerlink" title="可伸缩性与决策树"></a>可伸缩性与决策树</h2><p>已有的决策树算法，如ID3、C4.5和CART都是为相对较小的数据集规模。另外，大部分情况下，大规模的训练数据不能放在内存！因此，由于训练元组在主存和高速缓存换进换出，决策树的构造可能变得效率低下。最近，已经提出了一些可以解决伸缩问题的决策树算法，例如，<strong>RainForest（雨林）能适应可用的内存量，采用了一种新的数据结构形式</strong>。</p>
<p><img src="/2018/11/06/数据挖掘概念与技术/数据挖掘概念与技术笔记（5）：分类/01.png" alt></p>
<p> 转为AVC集的聚集信息的数据结构来存放 </p>
<p><img src="/2018/11/06/数据挖掘概念与技术/数据挖掘概念与技术笔记（5）：分类/02.png" alt></p>
<p><strong>另外一种方法是采用树构造的自助乐观算法（BOAT）</strong>，它采用了统计学计数，创建给定训练数据的一些较小的样本（或子集），其中每个子集都能放在内存中。使用每个子集构造一颗树，导致多棵树，并使用它们构造一个新树。</p>
<h2 id="使用IF-THEN规则分类"><a href="#使用IF-THEN规则分类" class="headerlink" title="使用IF-THEN规则分类"></a>使用IF-THEN规则分类</h2><p>基于规则的分类器使用一组IF-THEN规则进行分类。一个IF-THEN的规则R1一般表示形式有如下两种</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">R1:IF age=youth AND student=yes THEN buys_conmputer = yes </span><br><span class="line"></span><br><span class="line">R1:IF age=youth ^ student=yes THEN buys_computer = yes</span><br></pre></td></tr></table></figure>
<p> 规<strong>则R可以用覆盖率和准确率来评估</strong>。给定类标记的数据集D中的一个元组X，设$n<em>{covers}$为规则R覆盖的元组数，$n</em>{covers}$为R正确分类的元组数，|D|是D中的总元组数，可将R的<strong>覆盖率</strong>和<strong>准确率</strong>定义为： </p>
<script type="math/tex; mode=display">
coverage(R)=\frac{n_{cover}}{|D|} \\ accuracy(R)=\frac{n_{correct}}{n_{covers}}</script><h3 id="如何建立基于规则的分类器呢"><a href="#如何建立基于规则的分类器呢" class="headerlink" title="如何建立基于规则的分类器呢"></a>如何建立基于规则的分类器呢</h3><ul>
<li>1、根据决策树提取规则</li>
</ul>
<p><strong>对从根到树叶节点的每条路经创建一个规则</strong>。沿着给定路经上的每个属性-值的逻辑AND形成规则前件（“IF”部分）。叶结点包含类预测，形成规则后件（“THEN”部分）。<strong>由于这些规则都是直接从书中提取的，所以它们是互斥的和穷举的</strong>（互斥意味不可能存在规则冲突），<strong>因此规则的序不重要——它们是无序的</strong>。</p>
<p>由于每个树叶对应一个规则，所以提取的规则集的量也很多。所以有两种解决方法，第一种是先对决策树剪枝，然后提取规则。另外一种是直接提取规则，然后修剪规则，对于不能提高规则的估计准确率的任何条件都可以删减，从而泛化该规则。</p>
<ul>
<li>2、使用顺序覆盖算法</li>
</ul>
<p>顺序覆盖算法是最广泛使用的挖掘分类规则取集的方法，有许多流行的顺序覆盖算法，包括AQ、CN2和最近提出的RIPPER。算法的一般策略如下：一次学习一个规则，每学习一个规则，就删除该规则覆盖的元组，并在剩下的元组上重负该过程。</p>
<p><img src="/2018/11/06/数据挖掘概念与技术/数据挖掘概念与技术笔记（5）：分类/03.png" alt></p>
<p>从最一般的规则开始，即从规则前件条件为空的规则开始。该规则是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IF  THEN loan_decision = accept</span><br></pre></td></tr></table></figure>
<p>然后，我们考虑每个可以添加到该规则中可能属性测试。Learn_One_Rule采用一种贪心策略，每次选择最能提高规则质量的属性。目前，我们使用规则的准确率作为质量度量。假设Learn_One_Rule发现属性测试income=high最大限度地提高了当前（空）规则的准确率。把它添加到条件中，当前规则变成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IF income=high THEN loan_decision = accept</span><br></pre></td></tr></table></figure>
<p>下一次迭代时，再次考虑可能的属性测试，结果选中credit_rating=excellent，当前规则增长，变成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IF income=high AND credit_rating=excellent THEN loan_decision = accept</span><br></pre></td></tr></table></figure>
<p>重复该过程，直到结果规则达到可接受的质量水平。另外，贪心策略如果不自觉选到一个很差的属性怎么办，为了减少这种发生的几率，可以选出最好的k个而不是最好的一个属性添加到当前规则。</p>
<h3 id="规则质量的度量"><a href="#规则质量的度量" class="headerlink" title="规则质量的度量"></a>规则质量的度量</h3><p>Learn_One_Rule需要度量规则的质量，之前我们用的是准确率。但准确率本身并非规则质量的可靠估计。这里介绍几个相对有用的几种度量：1）、熵 ；2）、信息增益；3）考虑覆盖率的统计检验</p>
<p>我们想知道给定属性测试到condition中是否导致更好的规则，我们称新的条件为condition’，换言之，我们想知道R’是否比R好。</p>
<p><strong>熵</strong>：D是condition’覆盖元组集合，而$p_i$是D中$C_i$类的概率。熵越小，condition’越好。熵更偏向于覆盖单个类大量元组和少量其他类元组的条件。</p>
<p><strong>信息增益</strong>：FOIL算法是一种学习一阶逻辑规则的顺序覆盖算法，FOIL用下式估计扩展condition’s而获得信息</p>
<script type="math/tex; mode=display">
FOIL\_Gain=pos'\times (log_2\frac{pos'}{pos'+neg'}-log_2\frac{pos}{pos+neg})</script><p>它偏向于具有高准确率并且覆盖许多正元组的规则</p>
<p><strong>似然率统计量</strong></p>
<script type="math/tex; mode=display">
Likelihood\_Ratio=2\sum_{i=1}^mf_ilog(\frac{f_i}{e_i})</script><p>其中，m是类数，$f_i$是这些元组类i的观测概率，$e_i$是规则随机预测时类i的期望频率。似然率有助于识别具有显著覆盖率的规则。</p>
<p>CN2使用熵和似然率检验，而FOIL的信息增益被RIPPER使用。</p>
<h3 id="规则剪枝"><a href="#规则剪枝" class="headerlink" title="规则剪枝"></a>规则剪枝</h3><p>之前说了可以在决策树生成之后对规则剪枝，有很多剪枝策略。这里介绍FOIL使用的一种简单但很有效的方法，给定规则R，有：</p>
<script type="math/tex; mode=display">
FOIL\_Prune(R)=\frac{pos-neg}{pos+neg}</script><p>其中，pos和neg分别为规则R覆盖的正元组数和负元组数。这个值将随着R在剪枝集上的准确率增加而增加。因此，如果R剪枝后版本的FOIL_Prune值较高，则对R剪枝。</p>
<h3 id="如何使用规则分类器来预测元组类标号呢？"><a href="#如何使用规则分类器来预测元组类标号呢？" class="headerlink" title="如何使用规则分类器来预测元组类标号呢？"></a>如何使用规则分类器来预测元组类标号呢？</h3><p>如果正常的话，R1是唯一满足的规则，则该规则激活，返回X的类预测。但如果有多个规则被触发，它们指定了不同的类，这时则需要一种解决冲突的策略来决定激活哪一个规则。我们考察两种，即规模序和规则序：</p>
<p>规模序：方案吧最高优先权赋予给”最苛刻”要求的规则，其中苛刻性用<strong>规则前件的规模度量</strong>（类似于树的深度）</p>
<p>规则序：这<strong>种序可以是基于类的或基于规则的</strong>。<strong>使用基于类的序</strong>，类按”重要性”递减排序，如按普遍性的降序排序；<strong>基于规则的序</strong>，或者根据领域专家的建议，把规则组织成一个优先权列表。</p>
<h2 id="使用统计显著性检验选择模型"><a href="#使用统计显著性检验选择模型" class="headerlink" title="使用统计显著性检验选择模型"></a>使用统计显著性检验选择模型</h2><p>在前面我们已经使用了 一些策略来测算分类器的准确率（例如K折交叉验证）。在这里，我们假设经处理，最后生成了两个分类器，他们的评估度量都不相同，那么我们应该选择哪个分类器呢？</p>
<p>直观的看法当然是选择指标好的那个分类器呀，但是 实际上这种差别很有可能是偶然的。我们为了判定这种差别是否是偶然的，还需要进行<strong>统计显著性检验</strong>。 此外，希望得到平均错误率的置信界，使得我们可以做出这样的陈述：”对于未来样本的95%，观测到的均值将不会偏离正、负两个标准差”或者”一个模型比另外一个模型好，误差幅度为±4±4”</p>
<p>这里用的是显著性检验是t-检验。知乎上给出了相关的解释 ： <a href="https://www.zhihu.com/question/60321751/answer/399954823" target="_blank" rel="noopener">知乎t检验解释</a> <a href="https://www.zhihu.com/question/60321751/answer/399954823" target="_blank" rel="noopener">https://www.zhihu.com/question/60321751/answer/399954823</a></p>
<p> 对于10-折交叉验证（k=10）的第ii轮，设$err(M_1)_i$(或$err(M_2)_i$)是模型$M_1$(或$M_2$)在第i轮的错误率。对$M_1$的错误率取平均值得到$M_1$的平均错误率，记为$\overline {err}(M_1)$，类似的，可以得到$\overline {err}(M_2)$。两个模型差的方差记为$var(M_1-M_2)$。在我们的例子中，k=10，这里的k个样本是从每个模型的10-折交叉验证得到的错误率。逐对比较t-统计量按下式计算： </p>
<script type="math/tex; mode=display">
t=\frac{\overline{err}(M_1)-\overline{err}(M_2)}{\sqrt{var(M_1-M_2)/k}}</script><p> 其中 </p>
<script type="math/tex; mode=display">
var(M_1-M_2)=\frac{1}{k}\sum_{i=1}^k[err(M_1)_i-err(M_2)_i-(\overline{err}(M_1)-\overline{err}(M_2))]^2</script><p>为了计算$M_1$和$M_2$是否显著不同，计算t并选择显著水平sig。实践中，通常使用5%或1%的显著水平。然后，查找t-分布表。通常该表以自由度为行（k个样本具有k-1个自由度，对于我们的例子，自由度为9），显著水平为列。假定要确定$M_1$和$M_2$之间的差对总体的95%（即sig=5%或0.05）是否显著不同。然而，由于t分布是对称的，通常只显示分布上部的百分点，因此，找z=sig/2=0.025的表值，其中z也称为置信界。如果t&gt;z或t&lt;-z，则t落在拒斥域，在分布的尾部。这意味着可以拒绝$M_1$和$M_2$的均值相同的原假设，并断言两个模型之间存在统计的显著的差别。否则，如果不能拒绝原假设，于是断言$M_1$和$M_2$之间的差可能是随机的。</p>
<p>如果有两个检验集而不是单个检验集，则使用t-检验的非逐对版本，其中两个模型的均值之间的方差估计为：</p>
<script type="math/tex; mode=display">
var(M_1-M_2)=\sqrt{\frac{var(M_1)}{k_1}+\frac{var(M_2)}{k_2}}</script><p> 其中，k1和k2分别用于M1和M2的交叉验证样本数（在我们的情况下，10-折交叉验证的轮）。这也称为两个样本的t检验。在查t分布表时，自由度取两个模型的最小自由度。 </p>

          
        
      
    </div>
    
    
    
    
    
    
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/05/数据挖掘概念与技术/数据挖掘概念与技术笔记（4）：高级模式挖掘/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mosbyllc">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mosbyllc">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/05/数据挖掘概念与技术/数据挖掘概念与技术笔记（4）：高级模式挖掘/" itemprop="url">数据挖掘概念与技术笔记（4）：高级模式挖掘</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-05T17:06:14+08:00">
                2018-11-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据挖掘/" itemprop="url" rel="index">
                    <span itemprop="name">数据挖掘</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3,378
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  12
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>于大量的研究、问题的多方面扩展和广泛的应用研究。频繁模式挖掘已经远远超过了事务数据。<strong>这里，我们介绍其他多种挖掘模式类型的方法，包括多层模式、多维模式、稀有模式、负模式、受约束的频繁模式和巨型模式挖掘</strong>。书上的内容都是比较浅显，更多的是介绍性的东西，可能需要到实际工作上才能理解更深一些。</p>
<h2 id="挖掘多层关联规则"><a href="#挖掘多层关联规则" class="headerlink" title="挖掘多层关联规则"></a>挖掘多层关联规则</h2><p>对于许多应用，在较高的抽象层（抽象的大类，例如电脑，而不是具体某种品牌和型号的电脑）发现的强关联规则，可能有很高的支持度，但可能是常识性知识。我们希望往下钻，在更细节的层次发现新颖的模式。另外一方面，在较低或原始抽象层，可能有太多的零散模式，其中一些只不过是较高层模式的平方特化。</p>
<p>在这种较低层或原始层数据中很难发现有趣的规则模式，例如，“Dell Studio XPS 16 Notebook”和“Logitech VX Nano Cordless Laser Mouse”每个都在很少一部分事务中出现，则可能很难找到涉及它们的强关联规则。少数人同时购买它们，使得该商品集不太可能满足最小支持度。然而，我们预料，在这些商品的泛化抽象之间，如在”Dell Notebook” 和”Cordless Mouse”之间，可望更容易发现强规则。这种在多个抽象层的数据上挖掘产生的规则称为多层关联规则，一般采用如下自顶向下的方法：</p>
<ul>
<li><strong>对于所有层使用一致的支持度（称作一致支持度）</strong>：在每一层挖掘时，使用相同的最小支持度阈值</li>
</ul>
<p>然<strong>而，一致支持度方法有一些困难。较低层次抽象的项不大可能象较高层次抽象的项出现得那么频繁。如果最小支持度阈值设置太高，可能丢掉出现在较低抽象层中有意义的关联规则。如果阈值设置太低，可能会产生出现在较高抽象层的无兴趣的关联规则。这导致了下面的方法</strong>：</p>
<ul>
<li>在较低层使用递减的支持度（称作递减支持度）：每个抽象层有它自己的最小支持度阈值。抽象层越低，对应的阈值越小。</li>
<li>使用基于项或基于分组的最小支持度：例如，用户可以根据产品价格或者根据感兴趣的商品设置最小支持度，对如”价格超过1000美元的照相机”或”平板电脑” 设置特别低的支持度，以便特别关注这类商品的关联模式</li>
</ul>
<p>为了从具有不同支持度阈值的组中挖掘混合项模式，通常在挖掘中取所有组的最低支持度阈值。这将避免过滤掉有价值的模式，该模式包含来自具有最低支持度阈值组的项。同时，每组的最小支持阈值应该保持，以免从每个组产生无趣的项集。</p>
<h3 id="检查多层关联规则冗余性"><a href="#检查多层关联规则冗余性" class="headerlink" title="检查多层关联规则冗余性"></a>检查多层关联规则冗余性</h3><p>挖掘多层关联规则一个严重的副作用是，由于项之间的“祖先”关系，可能产生一些多个抽象层上的冗余的规则，例如：”desktop computer”是”IBM desktop computer”的祖先，有以下规则：</p>
<p><img src="/2018/11/05/数据挖掘概念与技术/数据挖掘概念与技术笔记（4）：高级模式挖掘/01.png" alt></p>
<p>如果后一个具有较小一般性的规则不提供新的信息，应当删除它。让我们看看如何来确定。规则 R1 是规则 R2 的祖先，如果R1能够通过将R2中的项，用它在概念分层（分配比率）中的祖先替换得到，则可以将R2删除。</p>
<p>以上诉规则例子：假定规则(6.9)具有 70%置信度，8%支持度，<strong>并且大约四分之一的”desktop computer”销售是”IBM desktop computer”</strong>。可以期望规则(6.10)具有大约 70%的置信度（由于所有的”IBM desktop computer”样本也是” desktop computer”样本）和 2%（即，8%×1/4）的支持度。也就是说，根据实际销量的分层可以通过R1推到出R2的规则与规则(6.10)相差无几，则R2规则是冗余的。</p>
<h2 id="挖掘多维关联规则"><a href="#挖掘多维关联规则" class="headerlink" title="挖掘多维关联规则"></a>挖掘多维关联规则</h2><p>本节，你将学习挖掘多维关联规则的方法。<strong>多维关联规则是涉及多个属性或谓词的规则</strong>（例如，关于顾客的 buys 和顾客的 age 的规则）。<strong>我们把规则中每个不同的谓词称作维</strong>。例如：</p>
<script type="math/tex; mode=display">
age(X, "20...29") \land buys(X, "laptop")⇒buys(X, "HP\ printer")</script><p>其中，数据库属性可能是分类属性和量化属性（数值），对于量化属性，挖掘多维相关规则的计数可以分为两种基本方法：</p>
<ul>
<li>第一种方法：使用预定义的概念分层对量化属性离散化，例如，income 的概念分层可以用于以区间值，如“0…20K”代替</li>
<li>第二种方法：根据数据的分布，将量化属性离散化或聚类到“箱”</li>
</ul>
<p>正如前面讨论的，我们可以把量化属性离散化为多个区间，而后在关联挖掘时把它们看做是分类属性。然而，这种简单的离散化可能导致产生大量的规则，其中许多规则可能没什么用。这里我们介绍三种方法，帮助克服这一困难，以便发现新颖的关联关系：</p>
<ul>
<li>1、数据立方体方法</li>
<li>2、基于聚类的方法</li>
<li>3、揭示异常行为的统计学方法</li>
</ul>
<h2 id="挖掘稀有模式和负模式"><a href="#挖掘稀有模式和负模式" class="headerlink" title="挖掘稀有模式和负模式"></a>挖掘稀有模式和负模式</h2><p>迄今为止，介绍的都是挖掘频繁模式，然而，有时令人感兴趣的不是频繁模式，而是发现<strong>稀有的模式</strong>（例如钻石表的销售是稀有的），或发现反映项之间的<strong>负相关的模式</strong>（例如发现顾客频繁地购买经典可口可乐或无糖可乐，但不可能一起都买）。</p>
<ul>
<li><strong>稀有模式</strong>：是指其支持度低于（或远低于）用户指定的最小支持度阈值的模式。然而，由于大多数项集的出现频度通常都低于甚至远低于最小支持度阈值，因此实践中允许用户指定稀有模式的其他条件是可取的。</li>
<li><strong>负相关模式</strong>：如果项集X和Y 都是频繁的，但很少一起出现$(sup(X \cup Y) &lt; sup(X) \times sup(Y))$ ，则项集X和Y是负相关的，并且$X\cup Y$ 是负相关模式.如果$(sup(X \cup Y) \ll sup(X) \times sup(Y))$， 则项集X和Y是强负相关的，并且$X\cup Y$是强负相关模式。 </li>
</ul>
<p><strong>然而，上面这个公式度量不是零不变的，只能有效地解决非零事务的数据</strong>。如果数据库存在大量的零事务，则应该使用零不变度量Kulczynski，下面给出具体定义：</p>
<p><strong>零不变负相关模式</strong>：假设项集X和Y都是频繁的，即$sup(X)\geq min_sup$ ，$sup(Y)\geq min_sup$ ， 其中$min_sup$是最小支持度阈值。如果有$(P(X|Y)+P(Y|X))/2&lt;\epsilon$，其中$\epsilon$是负模式阈值，则$X\cup Y$是负相关模式。 </p>
<h2 id="基于约束的频繁模式挖掘"><a href="#基于约束的频繁模式挖掘" class="headerlink" title="基于约束的频繁模式挖掘"></a>基于约束的频繁模式挖掘</h2><p><strong>作为限制搜索空间的约束条件</strong>，这种策略称为基于约束的挖掘。</p>
<p><strong>元规则</strong>就是挖掘用户感兴趣的规则的<strong>语法形式</strong>，例如：</p>
<script type="math/tex; mode=display">
P_1(X,Y)\land P_2(X,W) \Rightarrow buys(X, "officesoftware")</script><p>其中，P1和P2是谓词变量，在挖掘过程中被例示为给定数据库的属性；X是变量，代表顾客；Y和W是分别赋给P1和P2的属性值。</p>
<p>对于规则约束，如何使用规则约束对搜索空间进行剪枝？主要有两种方法：1、对模式空间剪枝；2、数据空间剪枝</p>
<h3 id="对模式空间剪枝"><a href="#对模式空间剪枝" class="headerlink" title="对模式空间剪枝"></a>对模式空间剪枝</h3><p>根据约束如何与模式挖掘过程配合，模式剪枝约束可以分为五类：1）反单调的；2）单调的；3）简洁的；4）可转变的；5）不可转变的（这个不重要）</p>
<ul>
<li>反单调的：规则约束$”sum(I.price)\leq 100”$，如果一个候选项集中的商品价格和大于 100 美元，则该项集可以由搜索空间剪去，因为向该项集中进一步添加项将会使它更贵，因此不可能满足限制。换一句话说，如果一个项集不满足该规则限制，它的任何超集也不可能满足该规则限制。如果一个规则具有这一性质，则称它是反单调的。 </li>
<li>单调的：规则约束$”sum(I.price)\geq 100”$，集合中的单价和大于 100，进一步添加更多的项到此项集将增加价格，并且总是满足该限制。因此，在项集 I 上进一步检查该限制是多余的。换言之，如果一个项集满足这个规则限制，它的所有超集也满足。如果一个规则具有这一性质，则称它是单调的。 </li>
<li>简洁：对于这类约束，我们可以枚举并且仅仅列出所有确保满足该限制的集合。因为有一个精确“公式”，产生满足简洁限制的所有集合，在挖掘过程中不必迭代地检验规则限制 </li>
<li>可转变的约束：有些限制不属于以上三类。然而，如果项集中的项以特定的次序排列，则对于频繁项集挖掘过程，限制可能成为单调的或反单调的。例如，限制“avg(I.price)”既不是反单调的，也不是单调的。然而，如果事务中的项以单价的递增序添加到项集中，则该限制就成了反单调的。类似的，如果是递减顺序添加则是单调的。 </li>
</ul>
<h3 id="对数据空间剪枝"><a href="#对数据空间剪枝" class="headerlink" title="对数据空间剪枝"></a>对数据空间剪枝</h3><p>第二种对基于约束的频繁模式挖掘的搜索空间进行剪枝的方法是对数据空间剪枝。这种策略是剪掉对其后挖掘过程中可满足模式的产生没有贡献的数据片段。例如，对于约束是数据简洁的，如果一个挖掘查询要求被挖掘模式必须包含数码相机，则可以在挖掘过程开始减剪掉所有不包含数码相机的事务。对于约束的反单调的，基于当前模式，如果一个数据项不满足数据反单调约束，则可以剪掉它，因为在剩下的挖掘过程中，它不能对当前模式的超模式的产生有任何贡献。</p>
<h2 id="巨型模式"><a href="#巨型模式" class="headerlink" title="巨型模式"></a>巨型模式</h2><p>对于数据库有数百或者数千维的数据，用已介绍方法来挖掘高维数据是非常低效的，一种是使用垂直格式数据，之前已经介绍过了。另外一种新的方向是用模型融合，用于巨型模式，即非常长的模式(例如蛋白质的DNA长序列)。这种方法在模式搜索空间中跳跃，得到巨型频繁模式完全集的一个很好的近似解。</p>
<p>对于Apriori和FP-growth算法，会不可避免产生大量中型模式，使得它不可能达到巨型模式。因此提出了模式融合，它融合了少量较短的频繁模式，形成巨型模式候选。</p>
<p>书上提到了<strong>核模式</strong>的概念，这里没怎么看懂，觉得是<strong>核模式代表了一定的鲁棒性</strong>。但是书上也直接给出了推论，巨型模式比较短模式有更多的核模式，更鲁棒。也就是说，如果从该模式中去掉少量项，则结果模式会有类似的支集。巨型模式较低层的核模式叫做<strong>核后代</strong>。<strong>所以基于这个特性，模式融合可以融合少量较短的频繁模式</strong>。这也是它为什么被称为模式融合的原因 ，因此巨型模式可以通过合并其核模式的真子集产生，<strong>例如， abcef可以通过它的两个核模式ab和cef产生。而不需要用单个项增量地扩展，而是与池中多个模式进行凝聚，这样能够迅速地到达巨型模式</strong>。</p>
<p>模型融合包括以下两个阶段：</p>
<ul>
<li><p>1、池初始化</p>
<p>模式融合假定有一个短频繁模式的初始池。这是一个短长度的频繁模式挖掘集。这个初始值可以用任意已有的有效挖掘算法挖掘。</p>
</li>
<li><p>2、迭代的模式融合</p>
<p>用户首先指定一个参数K的值（K代表挖掘模式的最大个数），然后从当前池中随机地选取K个种子，对于每个种子，我们找出直径为ττ的球内的所有模式。然后，每个”球“中的所有模式融合在一起，形成一个超模式集，这些超模式形成新的池，然后再从这个新的池子中随机地找到K个种子，然后重复上面的工作，一直迭代，直到不能融合为止</p>
</li>
</ul>
<p>因此，该方法可以绕过中型模式，通往巨型模式。</p>
<p>7.5/7.6的内容暂时不是特别重要，用到再补。</p>

          
        
      
    </div>
    
    
    
    
    
    
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/02/数据挖掘概念与技术/数据挖掘概念与技术笔记（3）：挖掘频繁模式、关联和相关性/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mosbyllc">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mosbyllc">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/02/数据挖掘概念与技术/数据挖掘概念与技术笔记（3）：挖掘频繁模式、关联和相关性/" itemprop="url">数据挖掘概念与技术笔记（3）：挖掘频繁模式、关联和相关性</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-02T17:06:14+08:00">
                2018-11-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据挖掘/" itemprop="url" rel="index">
                    <span itemprop="name">数据挖掘</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3,569
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  13
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="关联规则"><a href="#关联规则" class="headerlink" title="关联规则"></a>关联规则</h3><p>关联规则可以用以下表示：</p>
<script type="math/tex; mode=display">
computer\Rightarrow antivirus\_software[support=2\%;confidence=60\%]</script><p>规则的支持度和置信度是两个规则兴趣度度量，它们分别反映发现规则的有用性和确定性。上诉关联规则<br>的<strong>支持度（表示同时包含A和B的事务占所有事物的比例）为2%，意味所分析的事务的2%显示 计算机和杀毒软件被同时购买。置信度（表示包含A的事务同时也包含B的比例） 60%意味购买计算机的顾客 60%的几率也购买财务管理软件</strong>。一般如果关联规则<strong>满足最小支持度阈值和最小置信度阈值</strong>，则认为关联规则是有趣的，是值得关注的现象。</p>
<h3 id="频繁项集、闭项集、极大项集"><a href="#频繁项集、闭项集、极大项集" class="headerlink" title="频繁项集、闭项集、极大项集"></a>频繁项集、闭项集、极大项集</h3><p>设任务相关的数据 D 是数据库事务的集合，每一个事务有一个标识符，称作 TID。设A、B是两个项集，有：</p>
<script type="math/tex; mode=display">
support(A\Rightarrow B)=P(A\cup B) \\ confidence(A\Rightarrow B)=P(B\vert A)</script><p>同时满足最小支持度阈值(min_sup)和最小置信度阈值(min_conf)的规则称作强规则</p>
<p>项的集合称为项集。包含 k 个项的项集称为 k-项集。项集的出现频率是包含项集的事务数，简称为项集的频率、支持计数或计数。如果项集满足最小支持度，则称它为频繁项集。频繁 k -项集的集合通常记作 LkLk。一般而言，关联规则的挖掘是一个两步的过程：</p>
<p>1、<strong>找出所有频繁项集</strong>：根据定义，这些项集出现的频繁性至少和预定义的最小支持计数一样。</p>
<p>2、<strong>由频繁项集产生强关联规则</strong>：根据定义，这些规则必须满足最小支持度和最小置信度。</p>
<p>从大型数据集中挖掘项集的主要挑战是，这种挖掘常常产生大量满足最小支持度（min_sup）阈值的项集，当min_sup设置的很低的时候尤其如此，这是因为如果一个项集的频繁的（项集每个项计数都满足最小支持度），则它的每个子集都是频繁的。因此，得到的频繁项集的总个数太大了，为了更好的计算和存储，引入了闭频繁项集和极大频繁项集的概念。</p>
<ul>
<li><strong>闭频繁项集</strong>：指这个项集X既是频繁项集又是闭项集，闭项集是指不存在真超项集Y和此项集X具有相同的支持度计数</li>
<li><strong>极大频繁项集</strong>：指这个项集X既是频繁项集又是极大项集，极大项集是指不存在频繁的真超项集Y，它已经是最大规模频繁项集了。</li>
</ul>
<p>一个举例：(AB项集为非闭是因为和ABC项集具有相同的支持度计数，ABC为非极大是存在频繁项集ABCD)</p>
<p><img src="/2018/11/02/数据挖掘概念与技术/数据挖掘概念与技术笔记（3）：挖掘频繁模式、关联和相关性/01.png" alt></p>
<h2 id="挖掘频繁项集的方法"><a href="#挖掘频繁项集的方法" class="headerlink" title="挖掘频繁项集的方法"></a>挖掘频繁项集的方法</h2><h3 id="Apriori-算法"><a href="#Apriori-算法" class="headerlink" title="Apriori 算法"></a>Apriori 算法</h3><p>算法是一种最有影响的挖掘布尔关联规则频繁项集的算法。Apriori 使用一种称作逐层搜索的迭代方法，<strong>k项集用于探索(k+1)项集</strong>。首先，找出频繁 1-项集的集合。该集合记作 L1。L1用于找频繁 2-项集的集合 L2，而L2用于找L3，如此下去，直到不能找到频繁 k-项集.</p>
<p>所以关键在于须看看如何用频繁项集$L<em>k$找到频繁项集$L</em>{k+1}$.具体是由以下两步组成：</p>
<p>1、连接步：为找 $L<em>k$，通过$L</em>{k - 1}$与自己连接产生候选 k-项集的集合。假定事务或项集中的项按字典次序排序，如果$L_{k - 1}$它们前(k-2)个项相同的，则可以执行连接操作。</p>
<p>2、剪枝步：连接操作得到$C<em>k$，$C_k$是 $L_k$的超集，可以通过扫描数据库计算支持度从而在$C_k$里确定$L_k$。然而，$C_k$可能很大，这样所涉及的计算量就很大。为压缩 $C_k$，可以用以下办法使用 Apriori 先验性质：任何非频繁的(k-1)项集都不是可能是频繁 k项集的子集(频繁项集的子集一定是频繁的)。因此，如果一个候选 k项集的(k-1)子集不在 $L\</em>{k - 1}$中 ($L_{k - 1}$包含所有频繁的k-1项集，若某个k-1项集不在里面则是不频繁的)，则该候选也不可能是频繁的，从而可以由$C_k$中删除。</p>
<p> 一个例子: </p>
<p><img src="/2018/11/02/数据挖掘概念与技术/数据挖掘概念与技术笔记（3）：挖掘频繁模式、关联和相关性/02.png" alt></p>
<p> aproori算法过程：假设最小支持度计数为2，即min_sup=2 </p>
<p><img src="/2018/11/02/数据挖掘概念与技术/数据挖掘概念与技术笔记（3）：挖掘频繁模式、关联和相关性/03.png" alt></p>
<p> 其中，$L_2$连接步寻找$L_3$，要将$L_2$的前（3-2）个相同的项连接起来，得到{I1,I2,I3}, {I1,I2,I5}, {I1,I3,I5}, {I2,I3,I4}, {I2,I3,I5}, {I2,I4,I5}，然后执行剪枝步，扫描整个数据库，可以得到剩下的{1,I2,I3}, {I1,I2,I5}。或者使用Apriori 先验性质：举{I2,I4,I5}项集为例，{I2,I4,I5}的2项子集为{I2,I4}, {I2,I5} 和 {I4,I5}。但{I4, I5}不是$L_2$的元素，因此不是频繁的。同理L3L3连接步得到{I1, I2, I3, I5}的其中一个3项集{I2,I3,I5}不是$L_3$的元素，因此{I1, I2, I3, I5}也不是频繁的。 </p>
<h3 id="由频繁项集产生关联规则"><a href="#由频繁项集产生关联规则" class="headerlink" title="由频繁项集产生关联规则"></a>由频繁项集产生关联规则</h3><p>一旦由数据库 D 中的事务找出频繁项集，由它们产生强关联规则是直接了当的（强关联规则满足最小支持度和最小置信度）。对于置信度，可以用下式，其中条件概率用项集支持度计数表示</p>
<script type="math/tex; mode=display">
confidence(A\Rightarrow B)=P(A\vert B)=\frac{support\_count(A\cup B)}{support\_count(A)}</script><p><img src="/2018/11/02/数据挖掘概念与技术/数据挖掘概念与技术笔记（3）：挖掘频繁模式、关联和相关性/04.png" alt></p>
<h3 id="FP-growth算法"><a href="#FP-growth算法" class="headerlink" title="FP-growth算法"></a>FP-growth算法</h3><p>正如我们已经看到的，在许多情况下，Apriori 的候选产生-检查方法大幅度压缩了候选项集的大小，并导致很好的性能。然而，它可能受两种超高开销的影响：</p>
<ul>
<li>它可能需要产生大量候选项集。例如，如果有 10^4个频繁 1-项集，则 Apriori 算法需要产生多达 10^7个候选 2-项集</li>
<li>它可能需要重复地扫描数据库</li>
</ul>
<p>“ 可以设计一种方法，挖掘全部频繁项集，而不产生候选吗？”一种有趣的方法称作<strong>频繁模式增长</strong>，或简单地，FP-增长，它采取如下分治策略：<strong>将提供频繁项集的数据库压缩到一棵频繁模式树（或 FP-树）</strong>，但仍保留项集关联信息；然后，将这种压缩后的数据库分成一组条件数据库（一种特殊类型的投影数据库），每个关联一个频繁项，并分别挖掘每个数据库。</p>
<p>FP-growth算法的优点是采用了高级的数据结构。那么这种高级的数据结构是什么呢？实际上就是FP树。 FP树是一种输入数据的压缩表示。他通过把事务映射到FP树上来构造一条路径。这样如果不同事务之间的重叠路径越多，那么就有理由认为他们是频繁项集。由于不同的事务可能会有若干个相同的项，因此它们的路径相互重叠越多，则使用FP树结构获得的压缩效果越好。</p>
<p><strong>FP-growth算法的基本过程1）构建FP数。 2）从FP树中挖掘频繁项集</strong></p>
<p>依然是用之前那个例子：</p>
<p><img src="/2018/11/02/数据挖掘概念与技术/数据挖掘概念与技术笔记（3）：挖掘频繁模式、关联和相关性/02.png" alt></p>
<p>数据库的第一次扫描与 Apriori 相同，它<strong>导出频繁项（1-项集）的集合，并得到它们的支持度计数（频繁性）</strong>。设最小支持度计数为 2。频繁项的集合<strong>按支持度计数的递减序排序。结果集或表记作 L</strong>。这样，<strong>我们有 L = [I2:7, I1:6, I3:6, I4:2, I5:2]。</strong></p>
<p>然后，FP-树构造如下：首先，创建树的根结点，用“null”标记。二次扫描数据库 D。<strong>每个事务中的项按 L 中的次序处理（即，根据递减支持度计数排序）</strong>并<strong>对每个事务创建一个分枝</strong>。例如，第一个事务“T100: I1, I2, I5”按 L 的次序包含三个项{ I2, I1, I5}，导致构造树的第一个分枝[(I2:1), (I1:1), (I5:1)]。该分枝具有三个结点，其中，I2 作为根的子女链接，I1 链接到 I2，I5 链接到 I1。第二个事务 T200 按 L 的次序包含项 I2 和 I4，它导致一个分枝，其中，I2 链接到根，I4 链接到 I2。然而，该分枝应当与 T100 已存在的路径共享前缀 I2。这样，我们将结点 I2 的计数增加 1，并创建一个新结点(I4:1)，它作为(I2:2)的子女链接。一般地，当为一个事务考虑增加分枝时，沿共同前缀上的每个结点的计数增加 1，为随在前缀之后的项创建结点并链接。</p>
<p>按TID顺序T100到T900，不断创建节点和连接，并更新节点的支持度计数，知道完成FP树的构建</p>
<p><img src="/2018/11/02/数据挖掘概念与技术/数据挖掘概念与技术笔记（3）：挖掘频繁模式、关联和相关性/05.png" alt></p>
<p>构建好FP树后，开始利用FP树挖掘频繁项集。FP-树挖掘处理如下。<strong>由长度为 1 的频繁模式（初始后缀模式）开始，构造它的条件模式基</strong>（一个“子数据库”， 由 FP-树中与后缀模式一起出现的前缀路径集组成）<strong>。然后，构造它的（条件）FP-树，并递归地在该树上进行挖掘。</strong>模式增长通过后缀模式与由条件 FP-树产生的频繁模式连接实现。</p>
<p>FP-树的挖掘总结在表 6.1 中，细节如下。<strong>让我们首先考虑 I5，它是 L 中的最后一个项，而不是第一个</strong>。其原因随着我们解释 FP-树挖掘过程就会清楚。I5 出现在上图 的 FP-树的两个分枝。（I5 的出现容易通过沿它的结点链到。）<strong>它的两个对应前缀路径是[(I2, I1:1)&gt;和&lt;(I2, I1, I3:1)]</strong>，它们形成I5 的<strong>条件模式基</strong>。<strong>然后以及条件模式基和最小支持度计数构建条件FP树</strong>，它的条件 FP-树只包含单个路径[(I2:2, I1:2)] (括号里面为路径形式，给出构建的FP树种每个节点的支持度计数)；不包含 I3，因为它的支持度计数为 1，小于最小支持度计数。<strong>最后，I5与该路径产生频繁模式的所有组合（I5与路径的所有组合一定是要包含I5的）</strong>。组合的支持度计数是根据与结合的节点的支持数决定的。</p>
<p><img src="/2018/11/02/数据挖掘概念与技术/数据挖掘概念与技术笔记（3）：挖掘频繁模式、关联和相关性/06.png" alt></p>
<p> 类似的，对于 I4，它的两个前缀形成条件模式基{(I2 I1:1), (I2:1)}，产生一个单结点的条件 FP-树&lt; I2:2&gt;，并导出一个频繁模式 I2 I4:2。与以上分析类似，I3 的条件模式基是{(I2 I1:2), (I2:2), (I1:2)}。它的条件 FP-树有两个分枝&lt; I2:4, I1:2&gt;和&lt; I1:2&gt;，如图 6.9 所示，它产生模式集：{I2 I3:4, I1 I3:2, I2 I1 I3:2}. </p>
<p><img src="/2018/11/02/数据挖掘概念与技术/数据挖掘概念与技术笔记（3）：挖掘频繁模式、关联和相关性/07.png" alt></p>
<p>FP-增长方法将发现长频繁模式的问题转换成递归地发现一些短模式，然后与后缀连接。它使用最不<br>频繁的项作后缀，提供了好的选择性。该方法大大降低了搜索开销。</p>
<h3 id="使用垂直数据格式挖掘频繁项集"><a href="#使用垂直数据格式挖掘频繁项集" class="headerlink" title="使用垂直数据格式挖掘频繁项集"></a>使用垂直数据格式挖掘频繁项集</h3><p>Apriori算法和FP-growth算法都是从TID-项集格式（即{TID : itemset }）的事务集中挖掘频繁模式，其中TID是事务标识符， 而itemset是事务TID中购买的商品。这种数据格式称为<strong>水平数据格式</strong>。或者，数据也可以用项-TID集格式（即{item ： TID_set}）表示，这种格式称为<strong>垂直数据格式</strong>。</p>
<p><img src="/2018/11/02/数据挖掘概念与技术/数据挖掘概念与技术笔记（3）：挖掘频繁模式、关联和相关性/08.png" alt></p>
<p> 通过取每对频繁项的TID集的交，可以在该数据集上进行挖掘。项集的支持度计数为TID-集的元素个数。 </p>
<p><img src="/2018/11/02/数据挖掘概念与技术/数据挖掘概念与技术笔记（3）：挖掘频繁模式、关联和相关性/09.png" alt></p>
<h2 id="强规则不一定是有趣的"><a href="#强规则不一定是有趣的" class="headerlink" title="强规则不一定是有趣的"></a>强规则不一定是有趣的</h2><p>大部分关联规则挖掘算法使用支持度-置信度框架。尽管使用最小支持度和置信度阈值排除了一些无兴趣的规则的探<br>查，仍然会产生一些对用户来说不感兴趣的规则。<strong>当A与B是负相关时，规则 A ⇒ B 的置信度有一定的欺骗性</strong>。因此，支持度和置信度度量不足以过滤掉无趣的关联规则，为<strong>了处理这个问题，可以使用相关性度量来扩充关联规则的支持度-置信度框架</strong>。这导致如下形式的相关规则</p>
<script type="math/tex; mode=display">
A\Rightarrow B[support , confidence, correlation]</script><h3 id="提升度（lift）"><a href="#提升度（lift）" class="headerlink" title="提升度（lift）"></a>提升度（lift）</h3><p>提升度（lift）是一种简单的相关性度量，A和B出现之间的<strong>提升度</strong>可以通过计算下式得到</p>
<script type="math/tex; mode=display">
lift(A,B)=\frac{P(A\cup B)}{P(A)P(B)}</script><p>如果lift(A,B)值小于1，则A的出现和B的出现是负相关的，意味一个出现可能导致另一个不出现。如果值大于1，则A和B是正相关的，意味着每一个的出现都蕴含另一个的出现。如果结果值等于1，则A和B是独立的，它们之间没有相关性。</p>
<h3 id="使用提升度的相关分析"><a href="#使用提升度的相关分析" class="headerlink" title="使用提升度的相关分析"></a>使用提升度的相关分析</h3><p>如果我们要分析如下的关联规则：</p>
<script type="math/tex; mode=display">
buys(X, "computer games")\Rightarrow buys(X, "videos") \\ [support = 40\%, confidence=66\%]</script><p> 且有下面的事务相依表： </p>
<p><img src="/2018/11/02/数据挖掘概念与技术/数据挖掘概念与技术笔记（3）：挖掘频繁模式、关联和相关性/10.png" alt></p>
<p><img src="/2018/11/02/数据挖掘概念与技术/数据挖掘概念与技术笔记（3）：挖掘频繁模式、关联和相关性/11.png" alt></p>
<h3 id="使用卡方检测的相关分析"><a href="#使用卡方检测的相关分析" class="headerlink" title="使用卡方检测的相关分析"></a>使用卡方检测的相关分析</h3><p><img src="/2018/11/02/数据挖掘概念与技术/数据挖掘概念与技术笔记（3）：挖掘频繁模式、关联和相关性/12.png" alt></p>
<p><img src="/2018/11/02/数据挖掘概念与技术/数据挖掘概念与技术笔记（3）：挖掘频繁模式、关联和相关性/13.png" alt></p>
<h3 id="模式评估度量比较"><a href="#模式评估度量比较" class="headerlink" title="模式评估度量比较"></a>模式评估度量比较</h3><p>最近，另外一些模式评估度量引起了关注，本书介绍了四种这样的度量：全置信度、最大置信度、Kulczynsji和余弦。然后，比较它们的有效性，并且与提升度和卡方检测$X^2$进行比较。</p>
<p>全置信度：</p>
<script type="math/tex; mode=display">
all\_conf(A,B)=\frac{sup(A\cup B)}{max\{sup(A), sup(B)\}}=min\{P(A|B),P(B|A)\}</script><p> 最大置信度： </p>
<script type="math/tex; mode=display">
max\_conf(A,B)=max\{P(A|B),P(B|A)\}</script><p> Kulczynski: </p>
<script type="math/tex; mode=display">
Kulc(A,B)=\frac{1}{2}(P(A|B)+P(B|A))</script><p> 余弦： </p>
<script type="math/tex; mode=display">
cosine(A,B)=\frac{sup(A\cup B)}{\sqrt{sup(A)\times sup(B)}}=\sqrt{P(A|B)\times P(B|A)}</script><p> 对于评估所发现的模式联系，哪一个度量最好呢？<strong>对于零事务提升度和卡方检测效果都不好</strong>，<strong>零事务是指不包含任何考察项集的事务。典型地，零事务的个数可能远远大于个体的购买的个数，因为许多人都即不买牛奶也不买咖啡。另一方面，上面的新的四种度量都能解决零事务，因为他们的定义都消除了零事务的影响。</strong>一般的，推荐Kluc优先。 </p>

          
        
      
    </div>
    
    
    
    
    
    
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/02/数据挖掘概念与技术/数据挖掘概念与技术笔记（2）：数据预处理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mosbyllc">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mosbyllc">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/02/数据挖掘概念与技术/数据挖掘概念与技术笔记（2）：数据预处理/" itemprop="url">数据挖掘概念与技术笔记（2）：数据预处理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-02T17:06:13+08:00">
                2018-11-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据挖掘/" itemprop="url" rel="index">
                    <span itemprop="name">数据挖掘</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  740
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  3
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="冗余和相关分析"><a href="#冗余和相关分析" class="headerlink" title="冗余和相关分析"></a>冗余和相关分析</h2><h3 id="分类属性的-X-2-卡方检测"><a href="#分类属性的-X-2-卡方检测" class="headerlink" title="分类属性的$X^2$卡方检测"></a>分类属性的$X^2$卡方检测</h3><p>对于分类属性，两个属性A和B的相关联系可以通过X2X2(卡方)检测。</p>
<p>以下为一个典型的<strong>四格卡方检验</strong>，我们想知道喝牛奶对感冒发病率有没有影响：</p>
<p><img src="/2018/11/02/数据挖掘概念与技术/数据挖掘概念与技术笔记（2）：数据预处理/01.png" alt></p>
<p>通过简单的统计我们得出喝牛奶组和不喝牛奶组的感冒率为30.94%和25.00%，两者的差别可能是抽样误差导致，也有可能是牛奶对感冒率真的有影响。</p>
<p>得到的感冒率可能是抽样误差导致，也有可能是牛奶对感冒率真的有影响。</p>
<p>为了确定真实原因,我们<strong>先假设喝牛奶对感冒发病率是没有影响的</strong>,即喝牛奶喝感冒时独立无关的,所以我们可以得出感冒的<strong>实际发病率</strong>是(43 + 28)/(43 + 28 + 96 + 84)= 28.29%</p>
<p>所以,<strong>理论的四格表</strong>应该如下表所示:</p>
<p><img src="/2018/11/02/数据挖掘概念与技术/数据挖掘概念与技术笔记（2）：数据预处理/02.png" alt></p>
<p> 即下表: </p>
<p><img src="/2018/11/02/数据挖掘概念与技术/数据挖掘概念与技术笔记（2）：数据预处理/03.png" alt></p>
<p><strong>如果喝牛奶喝感冒真的是独立无关的,那么四格表里的理论值和实际值差别应该会很小。</strong></p>
<p>$X^2$卡方检测值可以用下式计算：</p>
<script type="math/tex; mode=display">
x^2=\sum\frac{(A-T)^2}{T}</script><p>其中，A为实际值，T为理论值。$x^2$值用于衡量实际值与理论值的差异程度和相对大小，值越小属性越独立无关，值越大，属性是统计相关的。</p>
<p>根据上面的卡方检验公式，有</p>
<script type="math/tex; mode=display">
x^2=\frac{(43-39.3231)^2}{39.3231}+\frac{(28-31.6848)^2}{31.6848}+\frac{(96-99.6769)^2}{99.6769}+\frac{(84-80.3152)^2}{80.3152}=1.077</script><p><strong>卡方分布的临界值</strong>:</p>
<p>上一步我们得到了卡方的值,但是如何通过卡方的值来判断喝牛奶和感冒是否真的是独立无关的?也就是说,怎么知道无关性假设是否可靠?</p>
<p><img src="/2018/11/02/数据挖掘概念与技术/数据挖掘概念与技术笔记（2）：数据预处理/04.png" alt></p>
<p><strong>答案是,通过查询卡方分布的临界值表</strong>。这里需要用到一个<strong>自由度的概念</strong>,自由度等于V =(行数- 1)*(列数- 1),对四格表,自由V = 1度。对V = 1,喝牛奶和感概冒95%率不相关的卡方分布的临界概率是:3.84。即如果卡方大于3.84,则认为喝牛奶和感冒有95%的概率相关，有统计联系。</p>
<p><strong>显然1.077 &lt; 3.84,没有达到卡方分布的临界值,所以喝牛奶和感冒独立不相关的假设成立,说明两者之间没说明联系</strong>。</p>
<h3 id="数值类型的皮尔逊相关系数"><a href="#数值类型的皮尔逊相关系数" class="headerlink" title="数值类型的皮尔逊相关系数"></a>数值类型的皮尔逊相关系数</h3><script type="math/tex; mode=display">
r_{A,B}=\frac{\sum_{i=1}^n(a_i-\bar A)(b_i-\bar B)}{n\sigma_A \sigma_B}</script><p> 其中，$\bar A$和$\bar B$为均值，和$\sigma_A$ 和$\sigma_B$为标准差。 </p>
<h3 id="数值类型的协方差"><a href="#数值类型的协方差" class="headerlink" title="数值类型的协方差"></a>数值类型的协方差</h3><p>在概率学和统计学中，协方差和方差是两个类型的度量，<strong>评估两个属性如何一起变化。</strong></p>
<script type="math/tex; mode=display">
Cov(A,B)=\frac{\sum_{i=1}^n(a_i-\bar A)(b_i-\bar B)}{n}=E(A\cdot B)-\bar A\bar B</script><p> 其中，$E(A\cdot B)$表示期望 ，用均值表示。</p>
<p> <strong>协方差值为0表示具有独立性，协方差越大代表两个属性会一起变化。</strong></p>
<h3 id="小波变换"><a href="#小波变换" class="headerlink" title="小波变换"></a>小波变换</h3><p>知乎这里讲的很清楚了，主要用于选出有效的特征属性。</p>
<p><a href="https://zhuanlan.zhihu.com/p/22450818" target="_blank" rel="noopener">戳我</a></p>

          
        
      
    </div>
    
    
    
    
    
    
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/01/数据挖掘概念与技术/数据挖掘概念与技术笔记（1）：数据认识/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mosbyllc">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mosbyllc">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/01/数据挖掘概念与技术/数据挖掘概念与技术笔记（1）：数据认识/" itemprop="url">数据挖掘概念与技术笔记（1）：数据认识</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-01T17:06:13+08:00">
                2018-11-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据挖掘/" itemprop="url" rel="index">
                    <span itemprop="name">数据挖掘</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,625
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  6
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="数据的基本统计描述"><a href="#数据的基本统计描述" class="headerlink" title="数据的基本统计描述"></a>数据的基本统计描述</h2><h3 id="中心趋势度量：均值、中位数和众数"><a href="#中心趋势度量：均值、中位数和众数" class="headerlink" title="中心趋势度量：均值、中位数和众数"></a>中心趋势度量：均值、中位数和众数</h3><p>尽管均值是描述数据集的最有用的单个量，但是它并非总是度量数据中心的最佳方法。主要问题是，均值对极端值（例如、离群点）很敏感。为了解决这个问题，我们可以采用结尾均值。结尾均值是丢弃高低极端值后的均值。</p>
<p>对于倾斜（非对称）数据，数据中心的更好的度量是中位数。</p>
<h3 id="度量数据散布：极差、四分位数、方差、标准差和四分位数极差"><a href="#度量数据散布：极差、四分位数、方差、标准差和四分位数极差" class="headerlink" title="度量数据散布：极差、四分位数、方差、标准差和四分位数极差"></a>度量数据散布：极差、四分位数、方差、标准差和四分位数极差</h3><p>极差：集合的最大值减去最小值</p>
<p>四分位数第1个四分位数记作$Q_1$，是第25个百分位数，第2个为50%，第3个四分位数记作$Q_3$，第75个百分位数。其中，第1个和第3个百分位数之间的距离是散布的一种简单度量，它给出被数据的中间一半所覆盖的范围。该距离称为四分位数极差（IQR），定义为</p>
<script type="math/tex; mode=display">
IQR=Q_3-Q_1</script><p>识别离群点的通常规则是，挑选落在第3个四分位数之上或第1个四分位数之下至少1.5×IQR处的值。</p>
<p>盒图是一种流行的分布的直观表示，盒图表示了五数概括：</p>
<ul>
<li>盒的端点一般在Q1和Q3四分位数上，使得盒的长度是四分位数极差</li>
<li>中位数用盒内的线标记</li>
<li>盒外的两条线（称为胡须）延伸到集合的最大和最小值</li>
</ul>
<p>方差和标准差：标准差是方差的平方根，低的标准差表示数据观测趋向于非常靠近均值。</p>
<h3 id="分位数图"><a href="#分位数图" class="headerlink" title="分位数图"></a>分位数图</h3><p><strong>分位数图</strong>是一种观察数据分布的简单有效的方法。首先，它显示所有的数据（允许用户评估总的情况和不寻常的出现），并将数据由小到大排序，每个观测值$x_(i)$  与一个百分数 $f_i$ 配对。下图表示了单价数据的分位数图。</p>
<p><img src="/2018/11/01/数据挖掘概念与技术/数据挖掘概念与技术笔记（1）：数据认识/01.png" alt></p>
<p><strong>分位数-分位数图</strong>，或 <strong>q-q 图</strong>对着另一个的对应分位数，绘制一个单变量分布的分位数。它是一<br>种强有力的直观表示工具，使得用户可以观察从一个分布到另一个是否有移位。</p>
<p>假定对于变量单价，我们有两个观测集，取自两个不同的分店。每组数据都已按递增序排序。下图给出两个部门的QQ图（分位数-分位数图） </p>
<p><img src="/2018/11/01/数据挖掘概念与技术/数据挖掘概念与技术笔记（1）：数据认识/02.png" alt></p>
<h2 id="度量数据的相似性和相异性"><a href="#度量数据的相似性和相异性" class="headerlink" title="度量数据的相似性和相异性"></a>度量数据的相似性和相异性</h2><p>一般的，<strong>如果两个对象i和j不相似</strong>，则他们的相似性度量将<strong>返回0</strong>。<strong>反之两个对象相似则返回1</strong>。</p>
<h3 id="数据矩阵和相异性矩阵"><a href="#数据矩阵和相异性矩阵" class="headerlink" title="数据矩阵和相异性矩阵"></a>数据矩阵和相异性矩阵</h3><p>数据矩阵称对象-属性结构，形式为n×p（n个对象p个属性）矩阵存放n个数据对象，每行对应于一个对象；相异性矩阵存放n个对象两两之间的相似度量，是个n×n对称矩阵(类似皮尔逊相关系数)</p>
<h3 id="分类属性的邻近性度量"><a href="#分类属性的邻近性度量" class="headerlink" title="分类属性的邻近性度量"></a>分类属性的邻近性度量</h3><p>如何计算分类属性所刻画对象之间的相异性？两个对象i和j之间的相异性可以根据不匹配率来计算：</p>
<script type="math/tex; mode=display">
d(i,j)=\frac{p-m}{p}</script><p> 其中，m是匹配的数目（即i和j取值相同状态的属性数），而p是刻画对象的属性总数。<strong>假设我们有表2.2中的4个对象的数据样本</strong>，每个对象3个属性，<strong>其中只有一个分类属性test-1</strong>，在上面的式子中，当对象i和j属性匹配时， $d(i,j)=0$ 当对象不匹配时，  $d(i,j)=1$.</p>
<p><img src="/2018/11/01/数据挖掘概念与技术/数据挖掘概念与技术笔记（1）：数据认识/03.png" alt></p>
<p><img src="/2018/11/01/数据挖掘概念与技术/数据挖掘概念与技术笔记（1）：数据认识/04.png" alt></p>
<h3 id="布尔属性的邻近性度量"><a href="#布尔属性的邻近性度量" class="headerlink" title="布尔属性的邻近性度量"></a>布尔属性的邻近性度量</h3><h3 id><a href="#" class="headerlink" title></a><img src="/2018/11/01/数据挖掘概念与技术/数据挖掘概念与技术笔记（1）：数据认识/05.png" alt></h3><p><strong>上面表示两个对象的取0或1的属性数目(q,s,r,t)</strong></p>
<p>对于<strong>对称的二元属性（布尔属性），是指每个属性都同样重要。基于对称二元属性的相异性称作对称的二元相异性</strong>。如果对象i和j都用对称的二元属性刻画，则i和j的<strong>相异性</strong>为：</p>
<script type="math/tex; mode=display">
d(i,j)=\frac{r+s}{q+r+s+t}</script><p> 互补的,相似性可用下式计算： </p>
<script type="math/tex; mode=display">
sim(i，j)=1-d(i,j)</script><p> 一个例子：下面gender为对称属性，其余为非对称属性（共6个），<strong>这里我们只考虑患者(对象)非对称属性</strong>，值Y(yes)和P(positive)都设置为1，N(no,negative)为0. <strong>采用上面非对称的二元相异性计算公式</strong>。 </p>
<p><img src="/2018/11/01/数据挖掘概念与技术/数据挖掘概念与技术笔记（1）：数据认识/06.png" alt></p>
<p><img src="/2018/11/01/数据挖掘概念与技术/数据挖掘概念与技术笔记（1）：数据认识/07.png" alt></p>
<h3 id="数值属性的相异性：闵可夫斯基距离"><a href="#数值属性的相异性：闵可夫斯基距离" class="headerlink" title="数值属性的相异性：闵可夫斯基距离"></a>数值属性的相异性：闵可夫斯基距离</h3><script type="math/tex; mode=display">
d(i,j)=\sqrt[p]{|x_{i1}-x_{j1}|^p+|x_{i2}-x_{j2}|^p+...+|x_{i1}-x_{j1}|^p}</script><h3 id="偏序属性的邻近性度量"><a href="#偏序属性的邻近性度量" class="headerlink" title="偏序属性的邻近性度量"></a>偏序属性的邻近性度量</h3><p>偏序属性的值之间具有意义的序或排位，例如size属性的序列值[small, medium, large]. 计算这种偏序属性首先计算状态在序数属性上的排名，并映射到[0, 1]数值上。然后把转换后的数值用闵可夫斯基距离来计算相似性。排名转换公式如下：</p>
<script type="math/tex; mode=display">
z_{if}=\frac{r_{if}-1}{M_f-1}</script><p>其中，属性$f$有$M<em>f$个有序的状态，表示排位$1,2…M_f$。排位$r</em>{if}$表示当前属性状态排名。</p>
<p>一个例子：</p>
<p><img src="/2018/11/01/数据挖掘概念与技术/数据挖掘概念与技术笔记（1）：数据认识/03.png" alt></p>
<p> test-2偏序属性，有三个状态，即$M_f$=3，四个对象转换为排位分别为3、1、2、3。然后分别映射为1.0、0.0、0.5、1.0数值，最后可以使用欧几里得距离来计算如下的相异性矩阵。</p>
<p><img src="/2018/11/01/数据挖掘概念与技术/数据挖掘概念与技术笔记（1）：数据认识/08.png" alt></p>
<h3 id="混合类型属性的相异性"><a href="#混合类型属性的相异性" class="headerlink" title="混合类型属性的相异性"></a>混合类型属性的相异性</h3><p>解决这种情况的方法是讲所有类型一起处理，<strong>把所有有意义的属性转换到共同区间[0.0 , 1.0]上</strong></p>
<p> <img src="/2018/11/01/数据挖掘概念与技术/数据挖掘概念与技术笔记（1）：数据认识/09.png" alt></p>
<p>1、如果是数值，用归一化。2、如果是类别属性，匹配为1不匹配为0。3、偏序将排位先转为数值，再按数值的归一化处理。</p>
<p>一个例子：（混合了分类、偏序、和数值）</p>
<p><img src="/2018/11/01/数据挖掘概念与技术/数据挖掘概念与技术笔记（1）：数据认识/03.png" alt></p>
<p>之前，处理test-1(分类属性)和test-2(偏序属性)的过程已经给出，可以使用它们之前的相异性矩阵。所以这里首先计算test-3(数值属性)的相异性矩阵。有max=64，min=22，比较对象用归一化处理后，得到test-3的相异性矩阵：</p>
<p><img src="/2018/11/01/数据挖掘概念与技术/数据挖掘概念与技术笔记（1）：数据认识/10.png" alt></p>
<p>其中，d(3,1)是对象1和对象3每个不同属性的相似性矩阵计算得到的值，总的处理方式还是归一化。</p>
<h3 id="余弦相似性"><a href="#余弦相似性" class="headerlink" title="余弦相似性"></a>余弦相似性</h3><p>给出了四个文档的词频向量，用于比较这些文档之间的相似性。</p>
<p><img src="/2018/11/01/数据挖掘概念与技术/数据挖掘概念与技术笔记（1）：数据认识/11.png" alt></p>
<p><img src="/2018/11/01/数据挖掘概念与技术/数据挖掘概念与技术笔记（1）：数据认识/12.png" alt></p>

          
        
      
    </div>
    
    
    
    
    
    
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/24/数据结构与算法/动态规划/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mosbyllc">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mosbyllc">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/24/数据结构与算法/动态规划/" itemprop="url">动态规划</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-24T17:06:13+08:00">
                2018-09-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构与算法/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构与算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  4,724
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  22
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="五问动态规划"><a href="#五问动态规划" class="headerlink" title="五问动态规划"></a>五问动态规划</h2><p>问：动态规划是什么？</p>
<p><strong>答：</strong>动态规划是一种通过“大而化小”的思路解决问题的算法。区别于一些固定形式的算法，如二分法，宽度优先搜索法，动态规划没有实际的步骤来规定第一步做什么第二步做什么。所以更加确切的说，动态规划是一种解决问题的思想。这种思想的本质是，一个规模比较大的问题（假如用2-3个参数可以表示），是通过规模比较小的若干问题的结果来得到的（通过取最大，取最小，或者加起来之类的运算）所以我们经常看到的动态规划的核心——状态转移方程都长成这样：</p>
<script type="math/tex; mode=display">
f[i][j] = f[i - 1][j] + f[i][j - 1]</script><script type="math/tex; mode=display">
f[i] = max\{f[j]    if   j < i and …\} + 1</script><script type="math/tex; mode=display">
f[i][j] = f[0][j - 1] \&\& judge(1,i)   ||   f[1][j - 1] \&\& judge(2,i) ||</script><p>问：动态规划什么时候可以用？</p>
<p>答：动态规划解决的一定是最优化问题。一个问题必须有重叠的子问题和最优子结构，才能使用动态规划取解决问题。</p>
<p>问：动态规划的常见类型有哪些？</p>
<ul>
<li>矩阵型</li>
<li>序列型</li>
<li>双序列型</li>
<li>划分型</li>
<li>区间型</li>
<li>背包型</li>
</ul>
<p>问：什么样的问题适合使用动态规划？</p>
<p><strong>答：</strong>可以使用动态规划的问题一般都有一些特点可以遵循。如题目的问法一般是三种方式：</p>
<ol>
<li>求最大值/最小值</li>
<li>求可不可行</li>
<li>求方案总数</li>
</ol>
<p>如果你碰到一个问题，是问你这三个问题之一的，那么有90%的概率是使用动态规划来求解。要重点说明的是，如果一个问题让你求出“所有的”方案和结果，则肯定不是使用动态规划。</p>
<p>解决一个动态规划问题的步骤是什么？</p>
<p><strong>答：</strong>首先判断是否是动态规划的问题，如果是，则尝试将其进行分类常见类型，找到对应的类别和相似的问题。接着从下面的4个要素去逐步剖析解决这道题：</p>
<ol>
<li>状态是什么</li>
<li>状态转移方程是什么</li>
<li>状态的初始值是什么</li>
<li>问题要求的最后答案是什么</li>
</ol>
<p>每个步骤分析完成之后，就基本上解决了整道动态规划的问题。</p>
<h2 id="动态规划相关题"><a href="#动态规划相关题" class="headerlink" title="动态规划相关题"></a>动态规划相关题</h2><h3 id="交叉字符串"><a href="#交叉字符串" class="headerlink" title="交叉字符串"></a>交叉字符串</h3><p><strong>题目</strong>：给出三个字符串:s1、s2、s3，判断s3是否由s1和s2交叉构成。</p>
<p><strong>样例</strong></p>
<p>比如 s1 = <strong>“aabcc”</strong> s2 = <strong>“dbbca”</strong></p>
<ul>
<li>当 s3 = <strong>“aadbbcbcac”</strong>，返回 true.</li>
</ul>
<ul>
<li>当 s3 = <strong>“aadbbbaccc”</strong>， 返回 false.</li>
</ul>
<p><strong>思路：</strong></p>
<p> 1.这题我们利用动态规划加记忆化搜索。如果能够进行交叉组成，利用动态规划，建立 $boolean    dp[i][j]$， 意思是s1的第i为 和s2的第j为是否能够够成s3的i + j 长度的交叉字符串。不一定要每个字符交替插入，s1 = aa, s2 = d 也可以组成s3 = aad。记忆矩阵这里要清楚定义，一个维度是s1的长度，一个维度是s2的长度。 </p>
<p> 2.因此状态转移方程就可以写成: </p>
<script type="math/tex; mode=display">
dp[i][j] = 1) dp[i][j-1] if s3[i+j -1] == s2[j-1] 2) dp[i-1][j] if s3[i+j-1] == s1[i-1]</script><p> 3.初始条件要注意，我们这里是把记忆矩阵建立为$test$，因此第一行就是没有s1的情况下看看s2能不能与s3配对，第一列就是在没有s2的情况下能不能与s3配对。<br>4.最后就是看最右下角的dp。时间复杂度是o(n*m)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @params s1, s2, s3: Three strings as description.</span></span><br><span class="line"><span class="string">    @return: return True if s3 is formed by the interleaving of</span></span><br><span class="line"><span class="string">             s1 and s2 or False if not.</span></span><br><span class="line"><span class="string">    @hint: you can use [[True] * m for i in range (n)] to allocate a n*m matrix.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isInterleave</span><span class="params">(self, s1, s2, s3)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">if</span> s1 <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> s2 <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> s3 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> len(s1) + len(s2) != len(s3):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 初始边界s1行s2列的false</span></span><br><span class="line">        interleave = [[<span class="literal">False</span>] * (len(s2) + <span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s1) + <span class="number">1</span>)]</span><br><span class="line">        interleave[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s1)):</span><br><span class="line">            interleave[i + <span class="number">1</span>][<span class="number">0</span>] = s1[:i + <span class="number">1</span>] == s3[:i + <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s2)):</span><br><span class="line">            interleave[<span class="number">0</span>][i + <span class="number">1</span>] = s2[:i + <span class="number">1</span>] == s3[:i + <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s1)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(s2)):</span><br><span class="line">                interleave[i + <span class="number">1</span>][j + <span class="number">1</span>] = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">if</span> s1[i] == s3[i + j + <span class="number">1</span>]:</span><br><span class="line">                    interleave[i + <span class="number">1</span>][j + <span class="number">1</span>] = interleave[i][j + <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> s2[j] == s3[i + j + <span class="number">1</span>]:</span><br><span class="line">                    interleave[i + <span class="number">1</span>][j + <span class="number">1</span>] |= interleave[i + <span class="number">1</span>][j]</span><br><span class="line">        <span class="keyword">return</span> interleave[len(s1)][len(s2)]</span><br></pre></td></tr></table></figure>
<h3 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h3><p><strong>描述</strong>：给定一个整数序列，找到最长上升子序列（LIS，<strong>不要求一定连续</strong>），返回LIS的长度。例如现在有序列A={1,2,3,-1,-2,7,9}，它的最长上升子序列为{1,2,3,7,9}，长度为5.</p>
<p>思路：dp[i] 表示走到第i个元素时的当前最大连续子序列的长度 ，这样对A[i]有两种可能：</p>
<p>1、如果A[i]之前的元素A[j]，其中$jdp[i]$，那么可以把A[i]拼接到A[j]的后面</p>
<p>2、如果之前的元素都比A[i]大，则A[i]自己成为最大的上升自序，长度为1</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param nums: The integer array</span></span><br><span class="line"><span class="string">    @return: The length of LIS (longest increasing subsequence)</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestIncreasingSubsequence</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">if</span> nums <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [<span class="number">1</span>] * len(nums) <span class="comment"># 边界初始条件</span></span><br><span class="line">        <span class="keyword">for</span> curr, val <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">for</span> prev <span class="keyword">in</span> xrange(curr):</span><br><span class="line">                <span class="keyword">if</span> nums[prev] &lt; val:  <span class="comment"># 如果之前的元素大于等于curr，则dp[curr]为初始的1</span></span><br><span class="line">                    dp[curr] = max(dp[curr], dp[prev] + <span class="number">1</span>) <span class="comment">#状态转移方程</span></span><br><span class="line">        <span class="keyword">return</span> max(dp)</span><br></pre></td></tr></table></figure>
<h3 id="单词拆分"><a href="#单词拆分" class="headerlink" title="单词拆分 ++"></a>单词拆分 ++</h3><p><strong>描述</strong>：给定字符串 s 和单词字典 dict，确定 s 是否可以分成一个或多个以空格分隔的子串，并且这些子串都在字典中存在。</p>
<p><strong>样例</strong>：给出s = <strong>“lintcode”</strong>，dict = <strong>[“lint”,”code”]</strong>返回 true 因为<strong>“lintcode”</strong>可以被空格切分成<strong>“lint code”</strong></p>
<p>思路：如果最大字典长度为k，f[i]的状态由前面i-k到i-1之间决定，这中间任何一段属于dict则f[I]为True</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param s: A string s</span></span><br><span class="line">    <span class="comment"># @param dict: A dictionary of words dict</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wordBreak</span><span class="params">(self, s, dict)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(dict) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> len(s) == <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">        n = len(s)</span><br><span class="line">        f = [<span class="literal">False</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        f[<span class="number">0</span>] = <span class="literal">True</span>  <span class="comment"># 初始边界</span></span><br><span class="line">        </span><br><span class="line">        maxLength = max([len(w) <span class="keyword">for</span> w <span class="keyword">in</span> dict]) <span class="comment">#先计算字典中最大长度，减少复杂度</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, min(i, maxLength) + <span class="number">1</span>): <span class="comment">#不必遍历i之前的所有j</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> f[i - j]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> s[i - j:i] <span class="keyword">in</span> dict:</span><br><span class="line">                    f[i] = <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">break</span> <span class="comment"># 有一个满足即可判断下一个f[i+1]</span></span><br><span class="line">        <span class="keyword">return</span> f[n]</span><br></pre></td></tr></table></figure>
<h3 id="数字三角形"><a href="#数字三角形" class="headerlink" title="数字三角形"></a>数字三角形</h3><p><strong>描述</strong>：给定一个数字三角形，找到从顶部到底部的最小路径和。每一步可以移动到下面一行的相邻数字上</p>
<p><strong>样例</strong>：比如，给出下列数字三角形：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">     [<span class="number">2</span>],</span><br><span class="line">    [<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">   [<span class="number">6</span>,<span class="number">5</span>,<span class="number">7</span>],</span><br><span class="line">  [<span class="number">4</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">3</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>从顶到底部的最小路径和为11 ( 2 + 3 + 5 + 1 = 11)。</p>
<p><strong>思路</strong>：自底向上的动态规划, 当前位置由左下或者右下最小值决定，时间复杂度O(n), python3 实现 ， triangle数组代表第i行第j个数字</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param triangle: a list of lists of integers</span></span><br><span class="line"><span class="string">    @return: An integer, minimum path sum</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumTotal</span><span class="params">(self, triangle)</span>:</span></span><br><span class="line">        rows = len(triangle)</span><br><span class="line">        dp = [[<span class="number">0</span>] * len(triangle[row]) <span class="keyword">for</span> row <span class="keyword">in</span> range(rows)] </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(triangle[rows - <span class="number">1</span>])):</span><br><span class="line">            dp[rows - <span class="number">1</span>][i] = triangle[rows - <span class="number">1</span>][i] <span class="comment">#初始边界</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(rows - <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>):</span><br><span class="line">                dp[i][j] = min(dp[i + <span class="number">1</span>][j], dp[i + <span class="number">1</span>][j + <span class="number">1</span>]) + triangle[i][j] <span class="comment">#状态转移方程</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h3 id="最小路径和"><a href="#最小路径和" class="headerlink" title="最小路径和"></a>最小路径和</h3><p>描述：给定一个只含非负整数的m×n网格，找到一条<strong>从左上角到右下角</strong>的可以使数字和最小的路径。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param grid: a list of lists of integers.</span></span><br><span class="line"><span class="string">    @return: An integer, minimizes the sum of all numbers along its path</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minPathSum</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(grid)): </span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(grid[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">and</span> j &gt; <span class="number">0</span>:</span><br><span class="line">                    grid[i][j] += grid[i][j<span class="number">-1</span>] <span class="comment"># 第一行，只在左边</span></span><br><span class="line">                <span class="keyword">elif</span> j == <span class="number">0</span> <span class="keyword">and</span> i &gt; <span class="number">0</span>:</span><br><span class="line">                    grid[i][j] += grid[i<span class="number">-1</span>][j] <span class="comment"># 第一列，只在右边</span></span><br><span class="line">                <span class="keyword">elif</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> j &gt; <span class="number">0</span>:</span><br><span class="line">                    grid[i][j] += min(grid[i<span class="number">-1</span>][j], grid[i][j<span class="number">-1</span>])  <span class="comment"># 由上面和左面的最小路径决定</span></span><br><span class="line">        <span class="keyword">return</span> grid[len(grid) - <span class="number">1</span>][len(grid[<span class="number">0</span>]) - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯 ++"></a>爬楼梯 ++</h3><p>描述：假设你正在爬楼梯，需要n步你才能到达顶部。但每次你只能爬一步或者两步，你能有多少种不同的方法？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param n: An integer</span></span><br><span class="line"><span class="string">    @return: An integer</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        result=[<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-2</span>):</span><br><span class="line">            result.append(result[<span class="number">-2</span>]+result[<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> result[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="不同的路径"><a href="#不同的路径" class="headerlink" title="不同的路径"></a>不同的路径</h3><p><strong>描述</strong>：有一个机器人的位于一个 m × n 个网格左上角。机器人每一时刻只能向下或者向右移动一步。机器人试图达到网格的右下角。问有多少条不同的路径？</p>
<p><strong>思路</strong>：有左边一格的路径数和上面一格的路径数决定</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span><span class="params">(self, m, n)</span>:</span></span><br><span class="line">        paths = [[<span class="number">0</span>] * n <span class="keyword">for</span> i <span class="keyword">in</span> range(m)] <span class="comment">#初始边界</span></span><br><span class="line">        <span class="comment"># initial rows</span></span><br><span class="line">        paths[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">            paths[x][<span class="number">0</span>] = paths[x - <span class="number">1</span>][<span class="number">0</span>] <span class="comment">#边界</span></span><br><span class="line">        <span class="comment"># initail columns</span></span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            paths[<span class="number">0</span>][y] = paths[<span class="number">0</span>][y - <span class="number">1</span>] <span class="comment">#边界</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">                paths[x][y] = paths[x <span class="number">-1</span>][y] + paths[x][y - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> paths[m - <span class="number">1</span>][n - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离 +"></a>编辑距离 +</h3><p><strong>题目</strong>：给出两个单词word1和word2，计算出将word1 转换为word2的最少操作次数。你总共三种操作方法：</p>
<ul>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ul>
<p><strong>样例</strong>：给出 work1=”mart” 和 work2=”karma”，返回 3。（先进行2个替换，后面进行1个插入）</p>
<p>思路：f[i][j代表第一个字符串以i结尾匹配上（编辑成）第二个字符串以j结尾的字符串，最少需要多少次编辑。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param word1: A string</span></span><br><span class="line"><span class="string">    @param word2: A string</span></span><br><span class="line"><span class="string">    @return: The minimum number of steps.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDistance</span><span class="params">(self, word1, word2)</span>:</span></span><br><span class="line">        n, m = len(word1), len(word2)</span><br><span class="line">        f = [[<span class="number">0</span>] * (m + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n + <span class="number">1</span>)]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n + <span class="number">1</span>):</span><br><span class="line">            f[i][<span class="number">0</span>] = i <span class="comment"># 边界</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(m + <span class="number">1</span>):</span><br><span class="line">            f[<span class="number">0</span>][j] = j <span class="comment"># 边界</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]:</span><br><span class="line">                    f[i][j] = min(f[i - <span class="number">1</span>][j - <span class="number">1</span>], f[i - <span class="number">1</span>][j] + <span class="number">1</span>, f[i][j - <span class="number">1</span>] + <span class="number">1</span>)</span><br><span class="line">                    <span class="comment"># equivalent to f[i][j] = f[i - 1][j - 1]</span></span><br><span class="line">                <span class="keyword">else</span>: <span class="comment">#分别代表替换，插入，删除</span></span><br><span class="line">                    f[i][j] = min(f[i - <span class="number">1</span>][j - <span class="number">1</span>], f[i - <span class="number">1</span>][j], f[i][j - <span class="number">1</span>]) + <span class="number">1</span></span><br><span class="line">                        </span><br><span class="line">        <span class="keyword">return</span> f[n][m]</span><br></pre></td></tr></table></figure>
<h3 id="正则表达式匹配"><a href="#正则表达式匹配" class="headerlink" title="正则表达式匹配 ++"></a>正则表达式匹配 ++</h3><p><strong>描述</strong>：实现支持<strong>‘.’</strong>和<strong>‘*‘</strong>的正则表达式匹配。’.’匹配任意一个字母。’*’匹配零个或者多个前面的元素。匹配应该覆盖整个输入字符串，而不仅仅是一部分。返回true 和 false</p>
<p><strong>样例</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">isMatch(<span class="string">"aa"</span>,<span class="string">"a"</span>) → false</span><br><span class="line"></span><br><span class="line">isMatch(<span class="string">"aa"</span>,<span class="string">"aa"</span>) → true</span><br><span class="line"></span><br><span class="line">isMatch(<span class="string">"aaa"</span>,<span class="string">"aa"</span>) → false</span><br><span class="line"></span><br><span class="line">isMatch(<span class="string">"aa"</span>, <span class="string">"a*"</span>) → true</span><br><span class="line"></span><br><span class="line">isMatch(<span class="string">"aa"</span>, <span class="string">".*"</span>) → true</span><br><span class="line"></span><br><span class="line">isMatch(<span class="string">"ab"</span>, <span class="string">".*"</span>) → true</span><br><span class="line"></span><br><span class="line">isMatch(<span class="string">"aab"</span>, <span class="string">"c*a*b"</span>) → true</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># DP</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s, p)</span>:</span></span><br><span class="line">        dp = [[<span class="literal">False</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(p) + <span class="number">1</span>)] <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, len(s) + <span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(p) + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> (p[i - <span class="number">1</span>] == <span class="string">'*'</span>):</span><br><span class="line">                dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i - <span class="number">2</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(s) + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(p) + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> p[j - <span class="number">1</span>] == <span class="string">'*'</span>:</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">2</span>]</span><br><span class="line">                    <span class="keyword">if</span> s[i - <span class="number">1</span>] == p[j - <span class="number">2</span>] <span class="keyword">or</span> p[j - <span class="number">2</span>] == <span class="string">'.'</span>:</span><br><span class="line">                        dp[i][j] |= dp[i<span class="number">-1</span>][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> s[i - <span class="number">1</span>] == p[j - <span class="number">1</span>] <span class="keyword">or</span> p[j - <span class="number">1</span>] == <span class="string">'.'</span>:</span><br><span class="line">                        dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> dp[len(s)][len(p)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 懒癌版</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s, p)</span>:</span></span><br><span class="line">        <span class="comment"># '$'字符规则代表匹配字符串的末尾，匹配返回一个Match 对象，否则返回None</span></span><br><span class="line">        <span class="keyword">return</span> re.match(p + <span class="string">'$'</span>, s) != <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<h3 id="不同的二叉查找树-II"><a href="#不同的二叉查找树-II" class="headerlink" title="不同的二叉查找树 II"></a>不同的二叉查找树 II</h3><p><strong>描述：</strong>给出n，生成所有由1…n为节点组成的不同的二叉查找树</p>
<p><strong>样例</strong>：给出n = 3，生成所有5种不同形态的二叉查找树：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>         <span class="number">3</span>     <span class="number">3</span>       <span class="number">2</span>    <span class="number">1</span></span><br><span class="line"> \       /     /       / \    \</span><br><span class="line">  <span class="number">3</span>     <span class="number">2</span>     <span class="number">1</span>       <span class="number">1</span>   <span class="number">3</span>    <span class="number">2</span></span><br><span class="line"> /     /       \                \</span><br><span class="line"><span class="number">2</span>     <span class="number">1</span>         <span class="number">2</span>                <span class="number">3</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Definition of TreeNode:</span></span><br><span class="line"><span class="string">class TreeNode:</span></span><br><span class="line"><span class="string">    def __init__(self, val):</span></span><br><span class="line"><span class="string">        this.val = val</span></span><br><span class="line"><span class="string">        this.left, this.right = None, None</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @paramn n: An integer</span></span><br><span class="line">    <span class="comment"># @return: A list of root</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateTrees</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">return</span> self.dfs(<span class="number">1</span>, n)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, start, end)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> start &gt; end: <span class="keyword">return</span> [<span class="literal">None</span>]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> rootval <span class="keyword">in</span> range(start, end+<span class="number">1</span>):</span><br><span class="line">            LeftTree = self.dfs(start, rootval<span class="number">-1</span>)</span><br><span class="line">            RightTree = self.dfs(rootval+<span class="number">1</span>, end)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> LeftTree:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> RightTree:</span><br><span class="line">                    root = TreeNode(rootval)</span><br><span class="line">                    root.left = i</span><br><span class="line">                    root.right = j</span><br><span class="line">                    res.append(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="乘积最大子序列"><a href="#乘积最大子序列" class="headerlink" title="乘积最大子序列 +"></a>乘积最大子序列 +</h3><p><strong>描述</strong>：找出一个序列中乘积最大的连续子序列（至少包含一个数）</p>
<p><strong>样例</strong>：比如, 序列 <code>[2,3,-2,4]</code> 中乘积最大的子序列为 <code>[2,3]</code> ，其乘积为<code>6</code>。</p>
<p>思路：这道题和maximal subarray思路一样，不同的是对于加法加上负数会变小，加上正数会变大；而对于乘法，乘以正数有可能变大也有可能变小（原数是负数的情况下），乘以负数也有可能变大或者变小</p>
<p>所以需要两个变量：<br>min_p表示行进到当前subarray能得到的最小的积<br>max_p表示行进到当前subarray能得到的最大的积</p>
<p>对于某一个subarray来说，它最大的积，有可能来自之前的最大积乘以一个正数，或者之前的最小积乘以一个负数，或者nums[i]就是最大的<br>因此 $max_p = max(nums[i], max_p × nums[i], min_p × nums[i])$<br>最小积同理</p>
<p>最后用res变量跟踪一下全局最大</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param nums: An array of integers</span></span><br><span class="line"><span class="string">    @return: An integer</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProduct</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            </span><br><span class="line">        global_max = prev_max = prev_min = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums[<span class="number">1</span>:]:</span><br><span class="line">            <span class="keyword">if</span> num &gt; <span class="number">0</span>:</span><br><span class="line">                curt_max = max(num, prev_max * num)</span><br><span class="line">                curt_min = min(num, prev_min * num)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                curt_max = max(num, prev_min * num)</span><br><span class="line">                curt_min = min(num, prev_max * num)</span><br><span class="line">            </span><br><span class="line">            global_max = max(global_max, curt_max)</span><br><span class="line">            prev_max, prev_min = curt_max, curt_min</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> global_max</span><br></pre></td></tr></table></figure>
<h3 id="通配符匹配"><a href="#通配符匹配" class="headerlink" title="通配符匹配"></a>通配符匹配</h3><p><strong>描述</strong>：判断两个可能包含通配符“？”和“*”的字符串是否匹配。匹配规则如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'?'</span> 可以匹配任何单个字符。</span><br><span class="line"><span class="string">'*'</span> 可以匹配任意字符串（包括空字符串）。</span><br><span class="line">两个串完全匹配才算匹配成功。</span><br></pre></td></tr></table></figure>
<p>样例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">isMatch(<span class="string">"aa"</span>,<span class="string">"a"</span>) → false</span><br><span class="line">isMatch(<span class="string">"aa"</span>,<span class="string">"aa"</span>) → true</span><br><span class="line">isMatch(<span class="string">"aaa"</span>,<span class="string">"aa"</span>) → false</span><br><span class="line">isMatch(<span class="string">"aa"</span>, <span class="string">"*"</span>) → true</span><br><span class="line">isMatch(<span class="string">"aa"</span>, <span class="string">"a*"</span>) → true</span><br><span class="line">isMatch(<span class="string">"ab"</span>, <span class="string">"?*"</span>) → true</span><br><span class="line">isMatch(<span class="string">"aab"</span>, <span class="string">"c*a*b"</span>) → false</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param s: A string</span></span><br><span class="line"><span class="string">    @param p: A string includes "?" and "*"</span></span><br><span class="line"><span class="string">    @return: A boolean</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s, p)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        m = len(p)</span><br><span class="line">        f = [[<span class="literal">False</span>] * (m + <span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(n + <span class="number">1</span>)]</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">and</span> p.count(<span class="string">'*'</span>) == m:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, m + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> j &gt; <span class="number">0</span>:</span><br><span class="line">                    f[i][j] |= f[i<span class="number">-1</span>][j<span class="number">-1</span>] <span class="keyword">and</span> (s[i<span class="number">-1</span>] == p[j<span class="number">-1</span>] <span class="keyword">or</span> p[j - <span class="number">1</span>] <span class="keyword">in</span> [<span class="string">'?'</span>, <span class="string">'*'</span>])</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> j &gt; <span class="number">0</span>:</span><br><span class="line">                    f[i][j] |= f[i - <span class="number">1</span>][j] <span class="keyword">and</span> p[j - <span class="number">1</span>] == <span class="string">'*'</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> j &gt; <span class="number">0</span>:</span><br><span class="line">                    f[i][j] |= f[i][j - <span class="number">1</span>] <span class="keyword">and</span> p[j - <span class="number">1</span>] == <span class="string">'*'</span></span><br><span class="line">        <span class="keyword">return</span> f[n][m]</span><br></pre></td></tr></table></figure>
<h3 id="打劫房屋"><a href="#打劫房屋" class="headerlink" title="打劫房屋 ++"></a>打劫房屋 ++</h3><p><strong>描述</strong>：假设你是一个专业的窃贼，准备沿着一条街打劫房屋。每个房子都存放着特定金额的钱。你面临的唯一约束条件是：相邻的房子装着相互联系的防盗系统，且 <strong>当相邻的两个房子同一天被打劫时，该系统会自动报警</strong>。给定一个非负整数列表，表示每个房子中存放的钱， 算一算，如果今晚去打劫，你最多可以得到多少钱 <strong>在不触动报警装置的情况下</strong>。</p>
<p> <strong>样例</strong>：给定 <code>[3, 8, 4]</code>, 返回 <code>8</code>. </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param A: An array of non-negative integers</span></span><br><span class="line"><span class="string">    @return: The maximum amount of money you can rob tonight</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">houseRobber</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> A:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(A) &lt;= <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> max(A)</span><br><span class="line">            </span><br><span class="line">        f = [<span class="number">0</span>] * len(A)</span><br><span class="line">        f[<span class="number">0</span>], f[<span class="number">1</span>] = A[<span class="number">0</span>], max(A[<span class="number">0</span>], A[<span class="number">1</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(A)):</span><br><span class="line">            f[i] = max(f[i - <span class="number">1</span>], f[i - <span class="number">2</span>] + A[i])</span><br><span class="line">        <span class="keyword">return</span> f[len(A) - <span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 使用滚动数组版本</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param A: An array of non-negative integers</span></span><br><span class="line"><span class="string">    @return: The maximum amount of money you can rob tonight</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">houseRobber</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> A:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(A) &lt;= <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> max(A)</span><br><span class="line">            </span><br><span class="line">        f = [<span class="number">0</span>] * <span class="number">3</span></span><br><span class="line">        f[<span class="number">0</span>], f[<span class="number">1</span>] = A[<span class="number">0</span>], max(A[<span class="number">0</span>], A[<span class="number">1</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(A)):</span><br><span class="line">            f[i % <span class="number">3</span>] = max(f[(i - <span class="number">1</span>) % <span class="number">3</span>], f[(i - <span class="number">2</span>) % <span class="number">3</span>] + A[i])</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> f[(len(A) - <span class="number">1</span>) % <span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<h3 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a>买卖股票的最佳时机</h3><p><strong>描述</strong>：假设你有一个数组，它的第i个元素是一支给定的股票在第i天的价格。设计一个算法来找到最大的利润。你最多可以完成 <code>k</code> 笔交易。你不可以同时参与多笔交易(你必须在再次购买前出售掉之前的股票)</p>
<p>样例：给定价格 = <code>[4,4,6,1,1,4,2,5]</code>, 且 k = <code>2</code>, 返回 <code>6</code>.（1买4卖，2买5卖）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param k: an integer</span></span><br><span class="line"><span class="string">    @param prices: an integer array</span></span><br><span class="line"><span class="string">    @return: an integer which is maximum profit</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, k, prices)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        size = len(prices)</span><br><span class="line">        <span class="keyword">if</span> k &gt;= size / <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> self.quickSolve(size, prices)</span><br><span class="line">        dp = [<span class="literal">None</span>] * (<span class="number">2</span> * k + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(size):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(min(<span class="number">2</span> * k, i + <span class="number">1</span>) , <span class="number">0</span> , <span class="number">-1</span>):</span><br><span class="line">                dp[j] = max(dp[j], dp[j - <span class="number">1</span>] + prices[i] * [<span class="number">1</span>, <span class="number">-1</span>][j % <span class="number">2</span>])</span><br><span class="line">        <span class="keyword">return</span> max(dp)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quickSolve</span><span class="params">(self, size, prices)</span>:</span></span><br><span class="line">        sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(size - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> prices[x + <span class="number">1</span>] &gt; prices[x]:</span><br><span class="line">                sum += prices[x + <span class="number">1</span>] - prices[x]</span><br><span class="line">        <span class="keyword">return</span> sum</span><br></pre></td></tr></table></figure>
<h3 id="解码方法"><a href="#解码方法" class="headerlink" title="解码方法+"></a>解码方法+</h3><p><strong>描述</strong>：有一个消息包含<code>A-Z</code>通过以下规则编码，现在给你一个加密过后的消息，问有几种解码的方式</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">'A' -&gt; 1</span><br><span class="line">'B' -&gt; 2</span><br><span class="line">...</span><br><span class="line">'Z' -&gt; 26</span><br></pre></td></tr></table></figure>
<p><strong>样例</strong>：给你的消息为<code>12</code>，有两种方式解码 AB(12) 或者 L(12). 所以返回 <code>2</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param &#123;string&#125; s a string,  encoded message</span></span><br><span class="line">    <span class="comment"># @return &#123;int&#125; an integer, the number of ways decoding</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numDecodings</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># Write your code here</span></span><br><span class="line">        <span class="keyword">if</span> s == <span class="string">""</span> <span class="keyword">or</span> s[<span class="number">0</span>] == <span class="string">'0'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        dp=[<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,len(s) + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="number">10</span> &lt;= int(s[i - <span class="number">2</span> : i]) &lt;=<span class="number">26</span> <span class="keyword">and</span> s[i - <span class="number">1</span>] != <span class="string">'0'</span>:</span><br><span class="line">                dp.append(dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>])</span><br><span class="line">            <span class="keyword">elif</span> int(s[i<span class="number">-2</span> : i]) == <span class="number">10</span> <span class="keyword">or</span> int(s[i - <span class="number">2</span> : i]) == <span class="number">20</span>:</span><br><span class="line">                dp.append(dp[i - <span class="number">2</span>])</span><br><span class="line">            <span class="keyword">elif</span> s[i<span class="number">-1</span>] != <span class="string">'0'</span>:</span><br><span class="line">                dp.append(dp[i<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[len(s)]</span><br></pre></td></tr></table></figure>
<h3 id="完美平方"><a href="#完美平方" class="headerlink" title="完美平方"></a>完美平方</h3><p><strong>描述</strong>：给一个正整数 n, 找到若干个完全平方数(比如1, 4, 9, … )使得他们的和等于 n。你需要让平方数的个数最少。</p>
<p><strong>样例</strong>：</p>
<p>给出 n = <code>12</code>, 返回 <code>3</code> 因为 <code>12 = 4 + 4 + 4</code>。<br>给出 n = <code>13</code>, 返回 <code>2</code> 因为 <code>13 = 4 + 9</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numSquares</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        dp = []</span><br><span class="line">        <span class="keyword">import</span> sys</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n+<span class="number">1</span>):</span><br><span class="line">            dp.append(sys.maxint)</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i * i &lt;= n:</span><br><span class="line">            dp[i*i] = <span class="number">1</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n+<span class="number">1</span>):</span><br><span class="line">            j = <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j * j &lt;= i:</span><br><span class="line">                dp[i] = min(dp[i], dp[i-j*j] + <span class="number">1</span>)</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    
    
    
    
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/21/数据结构与算法/重点掌握/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mosbyllc">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mosbyllc">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/21/数据结构与算法/重点掌握/" itemprop="url">重点掌握</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-21T17:06:13+08:00">
                2018-09-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构与算法/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构与算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,568
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  8
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#节点类</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,data = <span class="number">-1</span>)</span>:</span></span><br><span class="line">        self.data = data</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#树类</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.root = Node()</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self,data)</span>:</span></span><br><span class="line">        <span class="comment"># 为树加入节点</span></span><br><span class="line">        node  = Node(data)</span><br><span class="line">        <span class="keyword">if</span> self.root.data == <span class="number">-1</span>:        <span class="comment">#如果树为空，就对根节点赋值</span></span><br><span class="line">            self.root = node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            myQueue = []</span><br><span class="line">            treeNode = self.root</span><br><span class="line">            myQueue.append(treeNode)</span><br><span class="line">            <span class="keyword">while</span> myQueue:              <span class="comment">#对已有的节点进行层次遍历</span></span><br><span class="line">                treeNode = myQueue.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> treeNode.left:</span><br><span class="line">                    treeNode.left = node</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">elif</span> <span class="keyword">not</span> treeNode.right:</span><br><span class="line">                    treeNode.right = node</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    myQueue.append(treeNode.left)</span><br><span class="line">                    myQueue.append(treeNode.right)</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pre_order_recursion</span><span class="params">(self,root)</span>:</span>     <span class="comment">#递归实现前序遍历</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">print</span> root.data,</span><br><span class="line">        self.pre_order_recursion(root.left)</span><br><span class="line">        self.pre_order_recursion(root.right)</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pre_order_stack</span><span class="params">(self,root)</span>:</span>         <span class="comment">#堆栈实现前序遍历（非递归）</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        myStack = []</span><br><span class="line">        node = root</span><br><span class="line">        <span class="keyword">while</span> myStack <span class="keyword">or</span> node:</span><br><span class="line">            <span class="keyword">while</span> node:       <span class="comment">#从根节点开始，一直寻找他的左子树</span></span><br><span class="line">                <span class="keyword">print</span> node.data,     <span class="comment"># 先序，进栈前就要读取了</span></span><br><span class="line">                myStack.append(node) <span class="comment"># 先存进栈，以后还需要它的右节点</span></span><br><span class="line">                node = node.left</span><br><span class="line">            node = myStack.pop()    <span class="comment">#while结束表示当前节点node为空，即前一个节点没有左子树了</span></span><br><span class="line">            node = node.right       <span class="comment">#开始查看它的右子树</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">in_order_recursion</span><span class="params">(self,root)</span>:</span>      <span class="comment">#递归实现中序遍历</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.in_order_recursion(root.left)</span><br><span class="line">        <span class="keyword">print</span> root.data,</span><br><span class="line">        self.in_order_recursion(root.right)</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">in_order_stack</span><span class="params">(self,root)</span>:</span>        <span class="comment">#堆栈实现中序遍历（非递归）</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        myStack = []</span><br><span class="line">        node = root</span><br><span class="line">        <span class="keyword">while</span> myStack <span class="keyword">or</span> node:     <span class="comment">#从根节点开始，一直寻找它的左子树</span></span><br><span class="line">            <span class="keyword">while</span> node:</span><br><span class="line">                myStack.append(node) </span><br><span class="line">                node = node.left</span><br><span class="line">            node = myStack.pop() <span class="comment"># 中序，弹出来后才读取</span></span><br><span class="line">            <span class="keyword">print</span> node.data,</span><br><span class="line">            node = node.right</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post_order_recursion</span><span class="params">(self,root)</span>:</span>     <span class="comment">#递归实现后序遍历</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.post_order_recursion(root.left)</span><br><span class="line">        self.post_order_recursion(root.right)</span><br><span class="line">        <span class="keyword">print</span> root.data,</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post_order_stack</span><span class="params">(self, root)</span>:</span>  <span class="comment"># 堆栈实现后序遍历（非递归）</span></span><br><span class="line">        <span class="comment"># 先遍历根节点，再遍历右子树，最后是左子树，这样就可以转化为和先序遍历一个类型了，最后只把遍历结果逆序输出就OK了。</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        myStack1 = []</span><br><span class="line">        myStack2 = []</span><br><span class="line">        node = root</span><br><span class="line">        <span class="keyword">while</span> myStack1 <span class="keyword">or</span> node:</span><br><span class="line">            <span class="keyword">while</span> node:</span><br><span class="line">                myStack2.append(node)</span><br><span class="line">                myStack1.append(node)</span><br><span class="line">                node = node.right</span><br><span class="line">            node = myStack1.pop()</span><br><span class="line">            node = node.left</span><br><span class="line">        <span class="keyword">while</span> myStack2:</span><br><span class="line">            <span class="keyword">print</span> myStack2.pop().data,</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">level_order_queue</span><span class="params">(self,root)</span>:</span>       <span class="comment">#队列实现层次遍历（非递归）</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root :</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        myQueue = []</span><br><span class="line">        node = root</span><br><span class="line">        myQueue.append(node)</span><br><span class="line">        <span class="keyword">while</span> myQueue:</span><br><span class="line">            node = myQueue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">print</span> node.data,</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                myQueue.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                myQueue.append(node.right)</span><br><span class="line">                </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment">#主函数</span></span><br><span class="line">    datas = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line">    tree = Tree()          <span class="comment">#新建一个树对象</span></span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> datas:</span><br><span class="line">        tree.add(data)      <span class="comment">#逐个加入树的节点</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">print</span> <span class="string">'递归实现前序遍历：'</span></span><br><span class="line">    tree.pre_order_recursion(tree.root)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">print</span> <span class="string">'\n堆栈实现前序遍历'</span></span><br><span class="line">    tree.pre_order_stack(tree.root)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">print</span> <span class="string">"\n\n递归实现中序遍历："</span></span><br><span class="line">    tree.in_order_recursion(tree.root)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">print</span> <span class="string">"\n堆栈实现中序遍历："</span></span><br><span class="line">    tree.in_order_stack(tree.root)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">print</span> <span class="string">'\n\n递归实现后序遍历：'</span></span><br><span class="line">    tree.post_order_recursion(tree.root)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">print</span> <span class="string">'\n堆栈实现后序遍历：'</span></span><br><span class="line">    tree.post_order_stack(tree.root)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">print</span> <span class="string">'\n\n队列实现层次遍历：'</span></span><br><span class="line">    tree.level_order_queue(tree.root)！</span><br></pre></td></tr></table></figure>
<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  二分查找</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">BinarySearch</span><span class="params">(array,t)</span>:</span></span><br><span class="line">    low = <span class="number">0</span></span><br><span class="line">    height = len(array)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> low &lt; height:</span><br><span class="line">        mid = (low+height)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> array[mid] &lt; t:</span><br><span class="line">            low = mid + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> array[mid] &gt; t:</span><br><span class="line">            height = mid - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> array[mid]</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">print</span> BinarySearch([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">34</span>,<span class="number">56</span>,<span class="number">57</span>,<span class="number">78</span>,<span class="number">87</span>],<span class="number">57</span>)</span><br></pre></td></tr></table></figure>
<h3 id="广度优先与深度优先"><a href="#广度优先与深度优先" class="headerlink" title="广度优先与深度优先"></a>广度优先与深度优先</h3><p><strong>下面的代码强调一下: dfs和bfs区别（重点）</strong></p>
<ol>
<li>pop()和pop(0)</li>
<li>order加入w的时机</li>
<li>判断w的条件</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">深度优先遍历： 是一种用于遍历树或者图的算法。沿着树的深度遍历树的节点，尽可能深地搜索树的分支。当节点v的所在边都被搜索过了。搜索将回溯到节点v的那条边的起始节点。直到已发现从源节点可达的所有节点为止。如果还存在未发现的节点，则选择其中一个作为源节点并重复上述过程，整个进程反复进行直到所有节点都被访问为止.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">广度优先遍历：从根节点开始，沿着树的宽度遍历树的节点，如果所有节点都被访问，则算法终止</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, nodes, sides)</span>:</span></span><br><span class="line">        <span class="comment"># nodes表示用户输入的点，int型，sides表示用户输入的边，是一个二元组(u, v)</span></span><br><span class="line">        <span class="comment"># self.sequence是字典，key是点，value是与key相连的边</span></span><br><span class="line">        self.sequence = &#123;&#125;</span><br><span class="line">        <span class="comment"># self.side是临时变量，主要用于保存与 指定点v 相连接的点</span></span><br><span class="line">        self.side = []</span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> nodes:</span><br><span class="line">            <span class="keyword">for</span> side <span class="keyword">in</span> sides:</span><br><span class="line">                u, v = side</span><br><span class="line">                <span class="keyword">if</span> node == u:</span><br><span class="line">                    self.side.append(v)</span><br><span class="line">                <span class="keyword">elif</span> node == v:</span><br><span class="line">                    self.side.append(u)</span><br><span class="line">            <span class="comment"># 第二层主要是遍历属于这个点的所有边，然后将点和边组成字典</span></span><br><span class="line">            self.sequence[node] = self.side</span><br><span class="line">            self.side = []</span><br><span class="line">        <span class="comment"># print self.sequence</span></span><br><span class="line">        <span class="comment"># &#123;1: [2, 3], 2: [1, 4, 5], 3: [1, 6, 7], 4: [2, 8], 5: [2, 8], 6: [3, 7], 7: [3, 6], 8: [4, 5]&#125;</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, node0)</span>:</span></span><br><span class="line">        <span class="comment"># order里面存放的是具体的访问路径，已经遍历的了</span></span><br><span class="line">        queue, order = [], []</span><br><span class="line">        queue.append(node0)</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            v = queue.pop()  <span class="comment"># 取出最后一个，为上一个刚加入节点的连接节点</span></span><br><span class="line">            order.append(v) <span class="comment"># 深度优先先加入，注意这个order的加入顺序</span></span><br><span class="line">            <span class="keyword">for</span> w <span class="keyword">in</span> self.sequence[v]: <span class="comment"># 两边</span></span><br><span class="line">                <span class="comment"># 不在order表示没被遍历，</span></span><br><span class="line">                <span class="keyword">if</span> w <span class="keyword">not</span> <span class="keyword">in</span> order <span class="keyword">and</span> w <span class="keyword">not</span> <span class="keyword">in</span> queue:</span><br><span class="line">                    queue.append(w)</span><br><span class="line">        <span class="keyword">return</span> order</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># bfs同理</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(self, node0)</span>:</span></span><br><span class="line">        queue, order = [], []</span><br><span class="line">        queue.append(node0)</span><br><span class="line">        order.append(node0)</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            v = queue.pop(<span class="number">0</span>)  <span class="comment"># 层次遍历按迅速取出</span></span><br><span class="line">            <span class="keyword">for</span> w <span class="keyword">in</span> self.sequence[v]:</span><br><span class="line">                <span class="comment"># if w not in order and w not in queue:</span></span><br><span class="line">                <span class="keyword">if</span> w <span class="keyword">not</span> <span class="keyword">in</span> order</span><br><span class="line">                    order.append(w) <span class="comment"># 没被遍历就直接将两边加入order</span></span><br><span class="line">                    queue.append(w)</span><br><span class="line">        <span class="keyword">return</span> order</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">        nodes = [i+<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">8</span>)]</span><br><span class="line">        sides = [(<span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line">                 (<span class="number">1</span>, <span class="number">3</span>),</span><br><span class="line">                 (<span class="number">2</span>, <span class="number">4</span>),</span><br><span class="line">                 (<span class="number">2</span>, <span class="number">5</span>),</span><br><span class="line">                 (<span class="number">4</span>, <span class="number">8</span>),</span><br><span class="line">                 (<span class="number">5</span>, <span class="number">8</span>),</span><br><span class="line">                 (<span class="number">3</span>, <span class="number">6</span>),</span><br><span class="line">                 (<span class="number">3</span>, <span class="number">7</span>),</span><br><span class="line">                 (<span class="number">6</span>, <span class="number">7</span>)]</span><br><span class="line"> </span><br><span class="line">        G = Graph(nodes, sides)</span><br><span class="line">        <span class="keyword">print</span> G.dfs(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">print</span> G.bfs(<span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    
    
    
    
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/19/数据结构与算法/字符串解题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mosbyllc">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mosbyllc">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/19/数据结构与算法/字符串解题/" itemprop="url">字符串解题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-19T17:06:13+08:00">
                2018-09-19
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构与算法/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构与算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,317
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  6
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>字符串相关题_python版</p>
<h3 id="最长无重复字符子串长度"><a href="#最长无重复字符子串长度" class="headerlink" title="最长无重复字符子串长度"></a>最长无重复字符子串长度</h3><p><strong>题目</strong>：给定一个字符串，请找出其中无重复字符的最长子字符串。例如，在”abcabcbb”中，其无重复字符的最长子字符串是”abc”，其长度为 3。</p>
<p><strong>思路</strong>：遍历字符串中的每一个元素。借助一个辅助键值对来存储某个元素最后一次出现的下标。用一个整形变量存储当前无重复字符的子串开始的下标。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 分析 a b c d e f g d 此时从最近重复的前一个字符d的后一位开始记，即e标记为start。此时继续取下一个数， 例如a，它的前一个字符下标为d[s[i]]=0，若d[s[i]]&lt;start，则不需要更新start,否则更新start。新的无重复子串变为e f g d a</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param: s: a string</span></span><br><span class="line"><span class="string">    @return: an integer</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> s <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> len(s) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        d = &#123;&#125; <span class="comment"># 存储某个元素最后一次出现的下标</span></span><br><span class="line">        tmp = <span class="number">0</span> <span class="comment"># 存储每次循环中最长的子串长度</span></span><br><span class="line">        start = <span class="number">0</span>  <span class="comment"># 记录最近重复字符所在的位置+1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)): <span class="comment"># 下标</span></span><br><span class="line">            <span class="comment"># 判断当前字符是否在字典中和当前字符的下标是否大于等于最近重复字符的所在位置</span></span><br><span class="line">            <span class="keyword">if</span> s[i] <span class="keyword">in</span> d <span class="keyword">and</span> d[s[i]] &gt;= start: <span class="comment"># 这里的d[s[i]]为前一个重复的下标</span></span><br><span class="line">                start = d[s[i]] + <span class="number">1</span></span><br><span class="line">            tmp = i - start + <span class="number">1</span></span><br><span class="line">            d[s[i]] = i</span><br><span class="line">            res = max(res, tmp)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="最长回文字符串"><a href="#最长回文字符串" class="headerlink" title="最长回文字符串"></a>最长回文字符串</h3><p>思路一：中心扩展法。根据回文的特性，显然所有的回文串都是对称的。<strong>长度为奇数回文串以最中间字符的位置为对称轴左右对称，而长度为偶数的回文串的对称轴在中间两个字符之间的空隙</strong>。可否利用这种对称性来提高算法效率呢？答案是肯定的。我们知道整个字符串中的所有字符，以及字符间的空隙，都可能是某个回文子串的对称轴位置。<strong>可以遍历这些位置，在每个位置上同时向左和向右扩展，直到左右两边的字符不同，或者达到边界</strong>。对于一个长度为n的字符串，这样的位置一共有n+n-1=2n-1个 ，时间复杂度O(n^2)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        str_length = len(s)</span><br><span class="line">        max_length = <span class="number">0</span>   <span class="comment"># 记录最大字符串长度,不是对称长度</span></span><br><span class="line">        start = <span class="number">0</span>  <span class="comment"># 记录位置</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(str_length): <span class="comment"># 当前下标位置</span></span><br><span class="line">            <span class="comment"># 对称位置在对称轴间隙，偶数</span></span><br><span class="line">            <span class="keyword">if</span> i - max_length &gt;= <span class="number">1</span> <span class="keyword">and</span> s[i-max_length<span class="number">-1</span>: i+<span class="number">1</span>] == s[i-max_length<span class="number">-1</span>: i+<span class="number">1</span>][::<span class="number">-1</span>]:</span><br><span class="line">                <span class="comment"># 记录当前开始位置</span></span><br><span class="line">                start = i - max_length - <span class="number">1</span></span><br><span class="line">                max_length += <span class="number">2</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 对称位置在对称字符，奇数</span></span><br><span class="line">            <span class="keyword">if</span> i - max_length &gt;= <span class="number">0</span> <span class="keyword">and</span> s[i-max_length: i+<span class="number">1</span>] == s[i-max_length: i+<span class="number">1</span>][::<span class="number">-1</span>]:</span><br><span class="line">                start = i - max_length</span><br><span class="line">                max_length += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 返回最长回文子串</span></span><br><span class="line">        <span class="keyword">return</span> s[start: start + max_length]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = <span class="string">"babad"</span></span><br><span class="line">    <span class="comment"># s = "cbbd"</span></span><br><span class="line">    sl = Solution()</span><br><span class="line">    print(sl.longestPalindrome(s))</span><br></pre></td></tr></table></figure>
<p>思路二：马拉车算法</p>
<p><a href="https://segmentfault.com/a/1190000003914228#articleHeader0" target="_blank" rel="noopener">看这篇</a></p>
<h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><p><a href="http://www.ruanyifeng.com/blog/2013/05/Knuth–Morris–Pratt_algorithm.html" target="_blank" rel="noopener">过程描述看这篇</a></p>
<p>其实就是,<strong>对模式串p进行预处理,得到前后缀的部分匹配表,使得我们可以借助已知信息,算出可以右移多少位.即 kmp = 朴素匹配 + 移动多位</strong>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#KMP</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kmp_match</span><span class="params">(self, s, p)</span>:</span>  </span><br><span class="line">        m = len(s)</span><br><span class="line">        n = len(p)  </span><br><span class="line">        cur = <span class="number">0</span>  <span class="comment"># 起始指针cur，累积移动数  </span></span><br><span class="line">        table = self.partial_table(p)  </span><br><span class="line">        <span class="keyword">while</span> cur &lt;= m-n: <span class="comment"># 长度不够就终止  </span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n):  <span class="comment"># 一次p从头开始匹配的长度 </span></span><br><span class="line">                <span class="keyword">if</span> s[i+cur] != p[i]:  </span><br><span class="line">                    <span class="comment"># 移动位数 = 已匹配的字符数 - 对应的部分匹配值</span></span><br><span class="line">                    <span class="comment"># 有了部分匹配表,我们不只是单纯的1位1位往右移,可以一次移动多位  </span></span><br><span class="line">                    cur += max(i - table[i<span class="number">-1</span>], <span class="number">1</span>) </span><br><span class="line">                    <span class="keyword">break</span>  </span><br><span class="line">            <span class="keyword">else</span>: <span class="comment"># 执行了break就不会执行这句，相当于for循环里所有都满足 s[i+cur] == p[i]</span></span><br><span class="line">                <span class="keyword">return</span> cur <span class="comment"># 返回匹配开始的位置</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>  <span class="comment"># 匹配失败</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#部分匹配表  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partial_table</span><span class="params">(self, p)</span>:</span>  </span><br><span class="line">        <span class="string">'''''partial_table("ABCDABD") -&gt; [0, 0, 0, 0, 1, 2, 0]'''</span>  </span><br><span class="line">        prefix = set()  </span><br><span class="line">        table = [<span class="number">0</span>]  </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(p)):  <span class="comment"># 从1开始进行前后缀比较  </span></span><br><span class="line">            prefix.add(p[:i])  <span class="comment"># 前缀每次累加就行</span></span><br><span class="line">            postfix = set()</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, i+<span class="number">1</span>):  <span class="comment"># i+1 因为i需要包括</span></span><br><span class="line">                postfix.add(p[j:i+<span class="number">1</span>]) </span><br><span class="line">            <span class="comment"># print(prefix, postfix)</span></span><br><span class="line">            <span class="comment"># print(prefix&amp;postfix, len(prefix&amp;postfix))</span></span><br><span class="line">            <span class="comment"># table.append(len((sorted((prefix&amp;postfix),key = len)or &#123;''&#125;).pop()))</span></span><br><span class="line">            <span class="keyword">if</span> prefix&amp;postfix:</span><br><span class="line">                table.append(max(map(len,prefix&amp;postfix)))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                table.append(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> table</span><br></pre></td></tr></table></figure>
<h3 id="字符串去重"><a href="#字符串去重" class="headerlink" title="字符串去重"></a>字符串去重</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string = <span class="string">'abc123456ab2s'</span>r = <span class="string">''</span>.join(x <span class="keyword">for</span> i, x <span class="keyword">in</span> enumerate(string) <span class="keyword">if</span> string.index(x) == i)</span><br></pre></td></tr></table></figure>
<h3 id="统计一个字符串中英文字母、空格、数字的个数"><a href="#统计一个字符串中英文字母、空格、数字的个数" class="headerlink" title="统计一个字符串中英文字母、空格、数字的个数"></a>统计一个字符串中英文字母、空格、数字的个数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line">s = raw_input(<span class="string">'请输入一个字符串:\n'</span>)</span><br><span class="line">letters = <span class="number">0</span></span><br><span class="line">space = <span class="number">0</span></span><br><span class="line">digit = <span class="number">0</span></span><br><span class="line">others = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">    <span class="keyword">if</span> c.isalpha():</span><br><span class="line">        letters += <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> c.isspace():</span><br><span class="line">        space += <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> c.isdigit():</span><br><span class="line">        digit += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        others += <span class="number">1</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'char = %d,space = %d,digit = %d,others = %d'</span> % (letters,space,digit,others)</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    
    
    
    
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/16/数据结构与算法/数组解题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mosbyllc">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mosbyllc">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/16/数据结构与算法/数组解题/" itemprop="url">数组解题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-16T17:06:13+08:00">
                2018-09-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构与算法/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构与算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2,104
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  9
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p> 数组相关题_python版 </p>
<h3 id="寻找某个值的区间（leetcode-34-Search-for-a-Range）"><a href="#寻找某个值的区间（leetcode-34-Search-for-a-Range）" class="headerlink" title="寻找某个值的区间（leetcode 34 Search for a Range）"></a>寻找某个值的区间（leetcode 34 Search for a Range）</h3><p>题目：这题要求在一个排好序可能有重复元素的数组里面找到包含某个值的区间范围。<strong>要求使用O(log n)的时间</strong>，所以我们采用两次二分查找。</p>
<blockquote>
<p>For Example：<br>Given [5, 7, 7, 8, 8, 10] and target value 8,<br>return [3, 4].</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param A, a list of integers</span></span><br><span class="line">    <span class="comment"># @param target, an integer to be searched</span></span><br><span class="line">    <span class="comment"># @return a list of length 2, [index1, index2]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchRange</span><span class="params">(self, A, target)</span>:</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = len(A) - <span class="number">1</span>      </span><br><span class="line">        result = [<span class="number">-1</span>, <span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = (left + right) / <span class="number">2</span>           </span><br><span class="line">            <span class="keyword">if</span> A[mid] &gt; target:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> A[mid] &lt; target:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: <span class="comment"># 找到时</span></span><br><span class="line">                result[<span class="number">0</span>] = mid</span><br><span class="line">                result[<span class="number">1</span>] = mid</span><br><span class="line">                </span><br><span class="line">                i = mid - <span class="number">1</span> <span class="comment"># 向前找</span></span><br><span class="line">                <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> A[i] == target:</span><br><span class="line">                    result[<span class="number">0</span>] = i</span><br><span class="line">                    i -= <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">                i = mid + <span class="number">1</span> <span class="comment"># 向后找</span></span><br><span class="line">                <span class="keyword">while</span> i &lt; len(A) <span class="keyword">and</span> A[i] == target:</span><br><span class="line">                    result[<span class="number">1</span>] = i</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h3 id="第K个数的问题"><a href="#第K个数的问题" class="headerlink" title="第K个数的问题"></a>第K个数的问题</h3><p>题目：这题是一道很好的面试题目，首先题目短小，很快就能说清题意而且有很多种解法。从简单到复杂的解法都有，梯度均匀。解决它不需要预先知道特殊领域知识。</p>
<p>这题有很多思路：</p>
<ol>
<li>按从大到小全排序，然后取第k个元素，时间复杂度O(nlogn)，空间复杂度O(1)</li>
<li>利用堆进行部分排序。维护一个大根堆，将数组元素全部压入堆，然后弹出k次，第k个就是答案。时间复杂度O(klogn)O(klogn)，空间复杂度O(n)O(n)</li>
<li>选择排序，第k次选择后即可得到第k大的数，时间复杂度O(nk)，空间复杂度O(1)</li>
</ol>
<p>以上三种方法时间复杂度太高。下面介绍两种<strong>更好的方法</strong>：</p>
<blockquote>
<p>维持K大小的堆排序（优先队列）</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">用容量为K的最大堆来存储最小的K个数。最大堆的堆顶元素就是最小K个数中的最大的一个。每次扫描一个数据X，如果X比堆顶元素Y大，则不需要改变原来的堆。如果X比堆顶元素小，那么用X替换堆顶元素Y，在替换之后，X可能破坏了最大堆的结构，需要调整堆来维持堆的性质。用优先队列思想也一样，只不过k大小的队列每次移动的元素量较大，堆会好一些。</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># 使用了heapq的内置数据结构，用了一个trick 因为默认是创建小顶堆，所以在添加元素的时候加个 负号就变成大顶堆了。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetLeastNumbers_Solution</span><span class="params">(self, tinput, k)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> k &gt; len(tinput) <span class="keyword">or</span> k == <span class="number">0</span>: <span class="keyword">return</span> []</span><br><span class="line">        heap = []</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> tinput:</span><br><span class="line">            <span class="keyword">if</span> len(heap) &lt; k:</span><br><span class="line">                heapq.heappush(heap, -num)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> -num &gt; heap[<span class="number">0</span>]:</span><br><span class="line">                    heapq.heapreplace(heap, -num)</span><br><span class="line">        <span class="keyword">return</span> sorted(list(map(<span class="keyword">lambda</span> x: x*<span class="number">-1</span>, heap)))</span><br></pre></td></tr></table></figure>
<blockquote>
<p> 快速排序，时间复杂度近似O（n） </p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">利用快速排序的思想，从数组S中随机找出一个元素X，把数组分为两部分Sa和Sb。Sa中的元素大于等于X，Sb中元素小于X。这时有两种情况：</span></span><br><span class="line"><span class="string">1. Sa中元素的个数小于k，则Sb中的第k-|Sa|个元素即为第k大数；</span></span><br><span class="line"><span class="string">2. Sa中元素的个数大于等于k，则返回Sa中的第k大数。时间复杂度近似为O(n)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">qselect</span><span class="params">(A,k)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(A)&lt;k:<span class="keyword">return</span> A</span><br><span class="line">    pivot = A[<span class="number">-1</span>]</span><br><span class="line">    right = [pivot] + [x <span class="keyword">for</span> x <span class="keyword">in</span> A[:<span class="number">-1</span>] <span class="keyword">if</span> x&gt;=pivot]</span><br><span class="line">    rlen = len(right)</span><br><span class="line">    <span class="keyword">if</span> rlen==k:</span><br><span class="line">        <span class="keyword">return</span> right</span><br><span class="line">    <span class="keyword">if</span> rlen&gt;k:</span><br><span class="line">        <span class="keyword">return</span> qselect(right, k)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        left = [x <span class="keyword">for</span> x <span class="keyword">in</span> A[:<span class="number">-1</span>] <span class="keyword">if</span> x&lt;pivot]</span><br><span class="line">        <span class="keyword">return</span> qselect(left, k-rlen) + right</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">    <span class="keyword">print</span> qselect([<span class="number">11</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">9</span>], i)</span><br></pre></td></tr></table></figure>
<h3 id="求根算法（-LeetCode-69）"><a href="#求根算法（-LeetCode-69）" class="headerlink" title="求根算法（ LeetCode 69）"></a>求根算法（ LeetCode 69）</h3><p>题目：计算并返回 x 的平方根，其中 x 是非负整数。 由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p>
<p>思路一：直接从1到x/2之间遍历，判断是否是平方根的条件是，i*i小于等于x并且小于等于x并且(i+1)*(i+1)大于x，则返回i。超时 。</p>
<p>思路二：二分查找法。初始化i=0，j=x，mid=0。进入循环，找到中间值mid = (i + j) / 2，如果mid&gt;x / mid，表示mid不是平方根，且数值过大，则j=mid。如果mid小于等于x / mid，则判断(mid + 1) &gt; x / (mid + 1)，表示mid*mid小于x，并且mid再加1后的平方就会比x大，这表示mid就是那个平方根，返回mid。否则表示mid过小，i=mid。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type x: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> x==<span class="number">0</span> <span class="keyword">or</span> x==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">        i=<span class="number">0</span></span><br><span class="line">        j=x</span><br><span class="line">        mid=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            mid=(i+j)/<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> mid&gt;x/mid:</span><br><span class="line">                j=mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> (mid+<span class="number">1</span>)&gt;x/(mid+<span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">return</span> mid</span><br><span class="line">                i=mid</span><br></pre></td></tr></table></figure>
<h3 id="数组中后面的数减前面的数的差的最大值"><a href="#数组中后面的数减前面的数的差的最大值" class="headerlink" title="数组中后面的数减前面的数的差的最大值"></a>数组中后面的数减前面的数的差的最大值</h3><p>题目：如何求数组中数对差最大。数对差是指一个数组中某两个元素a和b（并且a排在b的前面），a减去b所得到的差值。</p>
<p>思路一：遍历存储最大值</p>
<p>思路二：首先求出数组中任意一对相邻的数据之间的差值，得到一个新的数组。如果某两个数据之间的数对差最大，也就是说这两个数据之间的差值最大。假设这两个数据的位置是i和j，那么这两个位置之间的数据是a[i]，a[i+1]，a[i+2]……，a[j-1]，a[j]。那么a[i]-a[j]=(a[i]-a[i+1])+(a[i+1]-a[i+2])+……(a[j-1]-a[j])，括号中的数据是相邻数据的差值，都已经在前面求出来了。<strong>然后这个问题就转化为了求数组中连续的子数组和最大的问题</strong>，这个问题可以通过动态规划问题求出来。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Max</span><span class="params">(firstNum,secondNum)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> firstNum&gt;=secondNum:</span><br><span class="line">		<span class="keyword">return</span> firstNum</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		<span class="keyword">return</span> secondNum</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Count</span><span class="params">(array)</span>:</span></span><br><span class="line">	gapArray=[]</span><br><span class="line">	length=len(array)</span><br><span class="line">	<span class="comment">#遍历一遍记录相邻两个之间的gap</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> xrange(length<span class="number">-1</span>):</span><br><span class="line">		gap=array[i]-array[i+<span class="number">1</span>]</span><br><span class="line">		gapArray.append(gap)</span><br><span class="line">	<span class="comment">#转化为子集合最大和问题</span></span><br><span class="line">	max=-((<span class="number">1</span>&lt;&lt;<span class="number">32</span>)<span class="number">-1</span>)</span><br><span class="line">	sum=<span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(gapArray)):</span><br><span class="line">		sum+=gapArray[i]</span><br><span class="line">		max=Max(max,sum)</span><br><span class="line">		<span class="keyword">if</span> sum&lt;<span class="number">0</span>:</span><br><span class="line">			sum=<span class="number">0</span></span><br><span class="line">	<span class="keyword">return</span> max</span><br><span class="line"> </span><br><span class="line">array=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">20</span>):</span><br><span class="line">	array.append(random.randint(<span class="number">0</span>,<span class="number">50</span>))</span><br><span class="line"><span class="keyword">print</span> array</span><br><span class="line"><span class="keyword">print</span> <span class="string">"max gap:"</span>+str(Count(array))</span><br></pre></td></tr></table></figure>
<h3 id="合并多个有序数组"><a href="#合并多个有序数组" class="headerlink" title="合并多个有序数组"></a>合并多个有序数组</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#采用归并排序算法</span></span><br><span class="line"><span class="comment">#拆解到最后，实际变成两个数组进行排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MergeSort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="comment">#请牢记传入的参数是多维数组</span></span><br><span class="line">    <span class="comment">#此处是递归出口</span></span><br><span class="line">    <span class="keyword">if</span> len(nums) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    mid = len(nums) // <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#记住此处得到的也是多维数组</span></span><br><span class="line">    Left = MergeSort(nums[:mid])</span><br><span class="line">    Right = MergeSort(nums[mid:])</span><br><span class="line"></span><br><span class="line">    <span class="comment">#print(Left[0], Right[0])</span></span><br><span class="line">    <span class="comment">#要传入的参数是数组中第一个索引处的值</span></span><br><span class="line">    <span class="keyword">return</span> Sort_list(Left[<span class="number">0</span>], Right[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Sort_list</span><span class="params">(Left, Right)</span>:</span></span><br><span class="line">    <span class="comment">#存储排序后的值</span></span><br><span class="line">    res = []</span><br><span class="line">    a = <span class="number">0</span></span><br><span class="line">    b = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> a &lt; len(Left) <span class="keyword">and</span> b &lt; len(Right):</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> Left[a] &lt; Right[b]:</span><br><span class="line">            res.append(Left[a])</span><br><span class="line">            a += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res.append(Right[b])</span><br><span class="line">            b += <span class="number">1</span></span><br><span class="line">    res = res + Left[a:] + Right[b:]</span><br><span class="line">    <span class="comment"># 转为二维数组</span></span><br><span class="line">    res = [res]</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="两个有序数组求差集"><a href="#两个有序数组求差集" class="headerlink" title="两个有序数组求差集"></a>两个有序数组求差集</h3><p>思路一：依次取出较小数组的元素，然后再另外一个数组上进行二分查找</p>
<p>思路二：用齐头并进的两个下标</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intersect</span><span class="params">(self, nums1, nums2)</span>:</span></span><br><span class="line">        nums3 = []</span><br><span class="line">        nums1.sort()</span><br><span class="line">        nums2.sort()</span><br><span class="line">        m = len(nums1)</span><br><span class="line">        n = len(nums2)</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;m <span class="keyword">and</span> j&lt;n:</span><br><span class="line">            <span class="keyword">if</span> nums1[i] == nums2[j]:</span><br><span class="line">                nums3.append(nums1[i])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums1[i] &gt; nums2[j]:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> nums3</span><br></pre></td></tr></table></figure>
<h3 id="两个集合如何求并集，交集；"><a href="#两个集合如何求并集，交集；" class="headerlink" title="两个集合如何求并集，交集；"></a>两个集合如何求并集，交集；</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">python集合支持一系列标准操作，包括并集、交集、差集和对称差集，例如：  </span><br><span class="line"></span><br><span class="line">a = t | s          <span class="comment"># t 和 s的并集  </span></span><br><span class="line">  </span><br><span class="line">b = t &amp; s          <span class="comment"># t 和 s的交集  </span></span><br><span class="line">  </span><br><span class="line">c = t – s          <span class="comment"># 求差集（项在t中，但不在s中）</span></span><br></pre></td></tr></table></figure>
<h3 id="给定一个数组求中位数"><a href="#给定一个数组求中位数" class="headerlink" title="给定一个数组求中位数"></a>给定一个数组求中位数</h3><p>(中位数，就是数组排序后处于数组最中间的那个元素)</p>
<p>思路：和TOP k问题一样，这里就不写了。（先排序再取中位数不优）</p>

          
        
      
    </div>
    
    
    
    
    
    
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/11/数据结构与算法/链表解题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mosbyllc">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mosbyllc">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/11/数据结构与算法/链表解题/" itemprop="url">链表解题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-11T17:06:13+08:00">
                2018-09-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构与算法/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构与算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3,407
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  15
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>链表相关题_python版</p>
<h3 id="在O-1-时间删除链表结点"><a href="#在O-1-时间删除链表结点" class="headerlink" title="在O(1)时间删除链表结点"></a>在O(1)时间删除链表结点</h3><p><strong>题目</strong>：给定单向链表的头指针和一个结点指针，定义一个函数在O(1)时间删除该结点。</p>
<p><strong>思路</strong>：我们要删除结点i，先把i的下一个结点i.next的内容复制到i，然后在把i的指针指向i.next结点的下一个结点即i.next.next，它的效果刚好是把结点i给删除了。<strong>需要考虑如果这个节点是链表的尾节点那么就需要从头遍历这个链表了。</strong>（通常，在单向链表中，删除一个链表的结点，都会先从表头开始遍历整个链表，找到需要删除的结点的前一个结点，然后将这个结点的(指向下一个结点的)指针元素指向需要删除结点的下一个结点，最后把需要删除的结点删除．但此过程的平均时间复杂度为 O(n)． ）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self.value = value</span><br><span class="line">        self.next_ = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span><span class="params">(self,pHead,Node)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> Node == <span class="literal">None</span> <span class="keyword">or</span> pHead == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> Node.next != <span class="literal">None</span>: <span class="comment"># else情况1：只有一个Node节点；情况2：Node节点在尾巴</span></span><br><span class="line">            Node.val = Node.next.val</span><br><span class="line">            Node.next = Node.next.next</span><br><span class="line">        <span class="keyword">elif</span> Node == pHead:<span class="comment"># 如果链表只有一个节点，那么就把头节点删掉就好了</span></span><br><span class="line">            pHead.val = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pNode = pHead  <span class="comment"># 把Node节点删除，然后接上一个None</span></span><br><span class="line">            <span class="keyword">while</span> pNode.next != Node:</span><br><span class="line">                pNode = pNode.next</span><br><span class="line">            pNode.next = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> pHead</span><br></pre></td></tr></table></figure>
<h3 id="合并两个排序的链表-要求不新建链表"><a href="#合并两个排序的链表-要求不新建链表" class="headerlink" title="合并两个排序的链表(要求不新建链表)"></a>合并两个排序的链表(要求不新建链表)</h3><p><strong>题目</strong>：输入两个递增排序的链表，合并这两个链表并使新链表中的结点仍然是按照递增排序的。</p>
<p><strong>思路</strong>：非递归情况：<strong>找到两个链表中头节点值相对更小的链表，将其作为主链表，第二个链表中的元素则不断加入到主链表中</strong>。具体策略是：主链表定义两个指针，指向两个相邻的元素。<strong>当第二个链表中的元素值小于主链表中第二个指针时，将第二个链表的当前元素插入到主链表两个指针指向的元素中间</strong>，并调整指针指向。 不要让链表断开，考虑链表为空的几种情况。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  ============非递归版本===============</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Merge</span><span class="params">(self, pHead1, pHead2)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> pHead1:</span><br><span class="line">        <span class="keyword">return</span> pHead2</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> pHead2:</span><br><span class="line">        <span class="keyword">return</span>  pHead1</span><br><span class="line">    mainHead = pHead1 <span class="keyword">if</span> pHead1.val &lt;= pHead2.val <span class="keyword">else</span> pHead2 <span class="comment"># 主链</span></span><br><span class="line">    secHead = pHead2 <span class="keyword">if</span> mainHead == pHead1 <span class="keyword">else</span> pHead1 <span class="comment"># 副链</span></span><br><span class="line">    mergeHead = mainHead</span><br><span class="line">    mainNext = mainHead.next <span class="comment"># 主链第二个指针</span></span><br><span class="line">    <span class="keyword">while</span> mainNext <span class="keyword">and</span> secHead: </span><br><span class="line">        <span class="keyword">if</span> secHead.val &lt;= mainNext.val: <span class="comment"># 副链节点插入到两个指针之间</span></span><br><span class="line">            mainHead.next = secHead <span class="comment"># 第一个指针连接到副链头指针</span></span><br><span class="line">            secHead = secHead.next <span class="comment"># 副链头指针后移</span></span><br><span class="line">            mainHead.next.next = mainNext <span class="comment"># 副链头指针连接到第二个指针</span></span><br><span class="line">            mainHead = mainHead.next <span class="comment"># 第一个指针后移（变成原副链的头指针），插入操作第二个指针不需要后移</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            mainHead = mainNext</span><br><span class="line">            mainNext = mainNext.next</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> mainNext: <span class="comment"># 副链元素都比第二个指针要大，不能插入，要拼接</span></span><br><span class="line">        mainHead.next = secHead</span><br><span class="line">    <span class="keyword">return</span> mergeHead</span><br><span class="line"><span class="comment"># ==================递归版本=================</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回合并后列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Merge</span><span class="params">(self, pHead1, pHead2)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> pHead1 <span class="keyword">is</span> <span class="literal">None</span>: <span class="comment"># 处理末尾状态，pHead1为空，要拼接的就是pHead2了</span></span><br><span class="line">            <span class="keyword">return</span> pHead2</span><br><span class="line">        <span class="keyword">if</span> pHead2 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> pHead1</span><br><span class="line">        <span class="keyword">if</span> pHead1.val &lt; pHead2.val:</span><br><span class="line">            pHead1.next = self.Merge(pHead1.next,pHead2)</span><br><span class="line">            <span class="keyword">return</span> pHead1 <span class="comment"># 返回整段拼接后的链表</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pHead2.next = self.Merge(pHead1,pHead2.next)</span><br><span class="line">            <span class="keyword">return</span> pHead2</span><br></pre></td></tr></table></figure>
<h3 id="二叉搜索树与双向链表"><a href="#二叉搜索树与双向链表" class="headerlink" title="二叉搜索树与双向链表"></a>二叉搜索树与双向链表</h3><p><strong>题目</strong>：输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向 ，例如</p>
<p><img src="/2018/09/11/数据结构与算法/链表解题/01.jpg" alt></p>
<p><strong>思路</strong>：</p>
<ol>
<li>核心算法依旧是中序遍历</li>
<li>不是从根节点开始，而是从中序遍历得到的第一个节点开始</li>
<li>定义两个辅助节点listHead(链表头节点)、listTail(链表尾节点)。事实上，二叉树只是换了种形式的链表；<strong>listHead用于记录链表的头节点，用于最后算法的返回；listTail用于定位当前需要更改指向的节点</strong>。了解了listHead和listTail的作用，代码理解起来至少顺畅80%。</li>
</ol>
<p>过程图示例</p>
<p><img src="/2018/09/11/数据结构与算法/链表解题/03.png" alt></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">稍微多说一句，其实这段代码也就5行，2行是中序遍历的代码；3行是更改节点指向的代码，为if、else行。if语句段只有在中序遍历到第一个节点时调用，自此之后listHead不变，listTail跟随算法的进度。对比中序遍历可以看出来，实际上只是中序遍历中的第八行代码被上述的if-else语句替代了，仅此而已。</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line">        self.val = x</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.listHead = <span class="literal">None</span></span><br><span class="line">        self.listTail = <span class="literal">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Convert</span><span class="params">(self, pRootOfTree)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> pRootOfTree==<span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.Convert(pRootOfTree.left)</span><br><span class="line">        <span class="keyword">if</span> self.listHead==<span class="literal">None</span>:  <span class="comment"># if/else替换中序遍历存储值</span></span><br><span class="line">            self.listHead = pRootOfTree <span class="comment"># if这一段只有中序遍历的第一个节点出现，即最左子树</span></span><br><span class="line">            self.listTail = pRootOfTree <span class="comment"># 此时，链表头尾指针都指向中序第一个节点</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.listTail.right = pRootOfTree <span class="comment"># 尾指针与中序下一个节点互连，有right属性是因为上一步self.listTail和self.listHead已经指向pRootOfTree了</span></span><br><span class="line">            pRootOfTree.left = self.listTail</span><br><span class="line">            self.listTail = pRootOfTree <span class="comment"># 尾指针指向中序下一个节点</span></span><br><span class="line">        self.Convert(pRootOfTree.right)</span><br><span class="line">        <span class="keyword">return</span> self.listHead</span><br></pre></td></tr></table></figure>
<h3 id="翻转部分链表"><a href="#翻转部分链表" class="headerlink" title="翻转部分链表"></a>翻转部分链表</h3><p>题目：给定一个单链表的头指针 head， 以及两个整数 a 和 b下标，在单链表中反转 linked_list[a-b] 的结点，然后返回整个链表的头指针 。</p>
<p>思路：采用翻转单链表的思路，回顾一下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">翻转单链表</span></span><br><span class="line"><span class="string">思路很简单：1-&gt;2-&gt;3-&gt;4-&gt;5，遍历链表，把1的next置为None，2的next置为1，以此类推，5的next置为4。得到反转链表。</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回ListNode</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ReverseList</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> pHead==<span class="literal">None</span> <span class="keyword">or</span> pHead.next==<span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> pHead</span><br><span class="line">        pre = <span class="literal">None</span> <span class="comment"># 前指针</span></span><br><span class="line">        cur = pHead <span class="comment"># 当前指针</span></span><br><span class="line">        <span class="keyword">while</span> cur!=<span class="literal">None</span>:</span><br><span class="line">            tmp = cur.next <span class="comment"># 记录下一个指针，为下一步当前指针后移准备</span></span><br><span class="line">            cur.next = pre</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = tmp</span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 翻转部分链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBetween</span><span class="params">(self, head, m, n)</span>:</span></span><br><span class="line">        <span class="comment"># 计算需要逆至的节点数</span></span><br><span class="line">        reverse_length = n - m + <span class="number">1</span></span><br><span class="line">        pre_head = <span class="literal">None</span> <span class="comment"># 初始化要记录的前驱节点</span></span><br><span class="line">        result = head   <span class="comment"># 最终转换后要返回的链表头结点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将head向后移动m-1个位置</span></span><br><span class="line">        <span class="keyword">while</span> head <span class="keyword">and</span> m &gt; <span class="number">1</span>:</span><br><span class="line">            pre_head = head</span><br><span class="line">            head = head.next</span><br><span class="line">            m -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 记录翻转后的链表尾部，翻转后的尾巴即为当前head</span></span><br><span class="line">        modify_list_tail = head</span><br><span class="line">        pre = <span class="literal">None</span> <span class="comment"># 前指针</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 逆置n - m + 1个节点</span></span><br><span class="line">        <span class="keyword">while</span> head <span class="keyword">and</span> reverse_length: <span class="comment">#和翻转单链表一样，翻转后和第一、第三段是断开的</span></span><br><span class="line">            tmp = head.next </span><br><span class="line">            head.next = pre</span><br><span class="line">            pre = head</span><br><span class="line">            head = tmp</span><br><span class="line">            reverse_length -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 此时，尾巴为空， modify_list_tail指向最后一个非空元素</span></span><br><span class="line">        <span class="comment"># 连接逆置后的链表尾与第三段的头结点结合，此时head已经指向第三段正序的头结点</span></span><br><span class="line">        modify_list_tail.next = head</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果pre_head不为空，说明不是从第一个节点开始逆至，即m&gt;1</span></span><br><span class="line">        <span class="keyword">if</span> pre_head <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># pre_head指向第一段最后一个元素，连接逆序后的头结点</span></span><br><span class="line">            pre_head.next = pre <span class="comment">#pre指向逆序后头结点，head为第三段的头结点</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 此时m=1，则逆置后的头结点就是链表的头结点，即翻转整个单链表</span></span><br><span class="line">            result = pre</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h3 id="链表插入排序-leetcode-147-Insertion-Sort-List"><a href="#链表插入排序-leetcode-147-Insertion-Sort-List" class="headerlink" title="链表插入排序(leetcode 147 Insertion Sort List)"></a>链表插入排序(leetcode 147 Insertion Sort List)</h3><p>题目：利用插入排序对链表进行排序</p>
<p>思路：1-&gt;3-&gt;2-&gt;4-&gt;null，将头结点和后面的部分断开，变成1-&gt;null和3-&gt;2-&gt;4-&gt;null，1-&gt;null看做是排好序的部分，添加的时候依次取后面的那部分的节点，比如在这里，先取3，然后对前面排好序的链表从前往后遍历，找到应该插入的位置即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Definition of ListNode</span></span><br><span class="line"><span class="string">class ListNode(object):</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    def __init__(self, val, next=None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.next = next</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param: head: The first node of linked list.</span></span><br><span class="line"><span class="string">    @return: The head of linked list.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertionSortList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> head.next <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        l=ListNode(<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            node=l <span class="comment"># 每次从头开始</span></span><br><span class="line">            fol=head.next <span class="comment"># 保持下一个，防止断开</span></span><br><span class="line">            <span class="keyword">while</span> node.next <span class="keyword">and</span> node.next.val &lt; head.val: <span class="comment"># 插入到node和node.next之间</span></span><br><span class="line">                node = node.next</span><br><span class="line">            head.next = node.next  <span class="comment"># 先连接后面head-&lt;node.next</span></span><br><span class="line">            node.next = head     <span class="comment"># 再连接前面</span></span><br><span class="line">            head = fol</span><br><span class="line">        <span class="keyword">return</span> l.next</span><br></pre></td></tr></table></figure>
<h3 id="链表归并排序-leetcode-148-Sort-List"><a href="#链表归并排序-leetcode-148-Sort-List" class="headerlink" title="链表归并排序(leetcode 148 Sort List)"></a>链表归并排序(leetcode 148 Sort List)</h3><p>题目：要求我们用O(nlogn)算法对链表进行排序</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, val, next=None)</span>:</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.next = next</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 归并法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> head.next <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        pre = head</span><br><span class="line">        slow = head               <span class="comment"># 使用快慢指针来确定中点</span></span><br><span class="line">        fast = head</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">            pre = slow</span><br><span class="line">            slow = slow.next</span><br><span class="line">            fast = fast.next.next</span><br><span class="line">        </span><br><span class="line">        left = head  </span><br><span class="line">        right = pre.next  <span class="comment"># 第二段头结点</span></span><br><span class="line">        pre.next = <span class="literal">None</span>           <span class="comment"># 从中间打断链表</span></span><br><span class="line">        left = self.sortList(left)  </span><br><span class="line">        right = self.sortList(right)  </span><br><span class="line">        <span class="keyword">return</span> self.merge(left,right)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, left, right)</span>:</span> <span class="comment">#合并两个有序链表</span></span><br><span class="line">        pre = ListNode(<span class="number">-1</span>) <span class="comment"># 新链表</span></span><br><span class="line">        first = pre <span class="comment"># 新链表头结点</span></span><br><span class="line">        <span class="keyword">while</span> left <span class="keyword">and</span> right:</span><br><span class="line">            <span class="keyword">if</span> left.val &lt; right.val:</span><br><span class="line">                pre.next = left</span><br><span class="line">                pre = left</span><br><span class="line">                left = left.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre.next = right</span><br><span class="line">                pre = right</span><br><span class="line">                right = right.next</span><br><span class="line">        <span class="keyword">if</span> left:</span><br><span class="line">            pre.next = left</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pre.next = right             </span><br><span class="line">        <span class="keyword">return</span> first.next</span><br></pre></td></tr></table></figure>
<h3 id="两两交换链表中相邻的两个元素"><a href="#两两交换链表中相邻的两个元素" class="headerlink" title="两两交换链表中相邻的两个元素"></a>两两交换链表中相邻的两个元素</h3><p><strong>题目</strong>：交换链表中相邻的两个元素。 注意第一个节点与第二个节点要交换位置，而第二个节点不用与第三个节点交换位置。 如要交换链表中A-&gt;B-&gt;C-&gt;D中的B和C需要做如下操作（<strong>交换B和C</strong>）：</p>
<ul>
<li>将A指向C</li>
<li>将B指向D</li>
<li>将C指向B</li>
</ul>
<p>思路：在头节点之前加一个假节点就可以使所有的交换都符合上面的情况。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        dummy = ListNode(<span class="number">-1</span>)</span><br><span class="line">        dummy.next = head <span class="comment"># 假结点连接原链表</span></span><br><span class="line">        temp = dummy <span class="comment"># 头结点</span></span><br><span class="line">        <span class="keyword">while</span> temp.next <span class="keyword">and</span> temp.next.next:</span><br><span class="line">            node1 = temp.next  <span class="comment"># node1是B</span></span><br><span class="line">            node2 = temp.next.next  <span class="comment"># node2是C</span></span><br><span class="line">            temp.next = node2  <span class="comment"># A指向C</span></span><br><span class="line">            node1.next = node2.next  <span class="comment"># B指向D</span></span><br><span class="line">            node2.next = node1  <span class="comment"># C指向B</span></span><br><span class="line">            temp = temp.next.next  <span class="comment"># 跳过两个</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure>
<h3 id="判断两个链表相交和相交的第一个节点"><a href="#判断两个链表相交和相交的第一个节点" class="headerlink" title="判断两个链表相交和相交的第一个节点"></a>判断两个链表相交和相交的第一个节点</h3><p>思路1：链表两个链表的长度差diff，然后快指针先走diff步，然后快慢指针一起走。直到两个指针相同，否则无相交节点。（需要先遍历得到两个链表长度）</p>
<p>思路2：两个指针一起走，当一个指针p1走到终点时，说明p1所在的链表比较短，让p1指向另一个链表的头结点开始走，直到p2走到终点，让p2指向短的链表的头结点，那么，接下来两个指针要走的长度就一样了 ，然后就可以一起走，直到两个指针相同。(若无交点，可以一开始在链表尾巴的设置一个标志点)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 思路二</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindFirstCommonNode</span><span class="params">(self, pHead1, pHead2)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead1 <span class="keyword">or</span> <span class="keyword">not</span> pHead2:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        p1, p2 = pHead1, pHead2</span><br><span class="line">        <span class="keyword">while</span> p1 != p2:</span><br><span class="line">            p1 = pHead2 <span class="keyword">if</span> <span class="keyword">not</span> p1 <span class="keyword">else</span> p1.next</span><br><span class="line">            p2 = pHead1 <span class="keyword">if</span> <span class="keyword">not</span> p2 <span class="keyword">else</span> p2.next</span><br><span class="line">        <span class="keyword">return</span> p1</span><br></pre></td></tr></table></figure>
<h3 id="分隔链表"><a href="#分隔链表" class="headerlink" title="分隔链表"></a>分隔链表</h3><p><strong>题目：</strong>给定一个链表以及一个目标值，把小于该目标值的所有节点都移至链表的前端，大于或等于目标值的节点移至链表的尾端，同时要保持这两部分在原先链表中的相对位置。</p>
<p><strong>思路</strong>：两个链表指针，一个负责收集比目标小的，一个收集大于等于目标的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, head, x)</span>:</span></span><br><span class="line">        dummy = ListNode(<span class="number">-1</span>)</span><br><span class="line">        dummy.next = head</span><br><span class="line">        small_dummy = ListNode(<span class="number">-1</span>)</span><br><span class="line">        large_dummy = ListNode(<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># small_prev和large_prev往后遍历增加，small_dummy和large_dummy则负责最后作为返回头结点</span></span><br><span class="line">        small_prev = small_dummy</span><br><span class="line">        large_prev = large_dummy</span><br><span class="line">        <span class="keyword">while</span> dummy.next:  <span class="comment"># head第一个节点</span></span><br><span class="line">            curr = dummy.next</span><br><span class="line">            <span class="keyword">if</span> curr.val &lt; x:</span><br><span class="line">                small_prev.next = curr</span><br><span class="line">                small_prev = small_prev.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                large_prev.next = curr</span><br><span class="line">                large_prev = large_prev.next</span><br><span class="line">            dummy = dummy.next</span><br><span class="line"></span><br><span class="line">        large_prev.next = <span class="literal">None</span>  <span class="comment"># 最后指针置为none</span></span><br><span class="line">        small_prev.next = large_dummy.next  <span class="comment"># large_dummy对应的是大链表的第一个数</span></span><br><span class="line">        <span class="keyword">return</span> small_dummy.next  <span class="comment"># 返回的是small_dummy</span></span><br></pre></td></tr></table></figure>
<h3 id="重排链表"><a href="#重排链表" class="headerlink" title="重排链表"></a>重排链表</h3><p>将单向链表L0→L1→…→Ln-1→Ln转化为L0→Ln→L1→Ln-1→L2→Ln-2→…的形式，也就是从头部取一个节点，从尾部取一个节点，直到将原链表转化成新的链表。</p>
<p>思路：</p>
<ol>
<li>去中间节点，将链表分为两段.</li>
<li>翻转后一段</li>
<li>拼接</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reorderList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># split &#123;1,2,3,4,5&#125; to &#123;1,2,3&#125;&#123;4,5&#125;</span></span><br><span class="line">        fast = slow = head </span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">            slow = slow.next</span><br><span class="line">            fast = fast.next.next</span><br><span class="line">        head1 = head</span><br><span class="line">        head2 = slow.next</span><br><span class="line">        slow.next = <span class="literal">None</span></span><br><span class="line">        <span class="comment"># reverse the second &#123;4,5&#125; to &#123;5,4&#125;</span></span><br><span class="line">        cur, pre = head2, <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            tmp = cur.next <span class="comment"># 标记下一个</span></span><br><span class="line">            cur.next = pre</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = tmp</span><br><span class="line">        <span class="comment"># merge</span></span><br><span class="line">        cur1, cur2 = head1, pre</span><br><span class="line">        <span class="keyword">while</span> cur2:</span><br><span class="line">            nex1, nex2 = cur1.next, cur2.next</span><br><span class="line">            cur1.next = cur2</span><br><span class="line">            cur2.next = nex1</span><br><span class="line">            cur1, cur2 = nex1, nex2</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    
    
    
    
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Mosbyllc">
            
              <p class="site-author-name" itemprop="name">Mosbyllc</p>
              <p class="site-description motion-element" itemprop="description">Sometimes thing have to fall apart to make way for better things.</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">62</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">74</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/kugua233" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:1499913789@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Recommended reading
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://wulc.me/" title="Wulc" target="_blank">Wulc</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://blog.csdn.net/qq_15262671/article/details/78481922" title="Pinard" target="_blank">Pinard</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://donche.github.io/" title="Donche" target="_blank">Donche</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://xtf615.com/" title="XFT" target="_blank">XFT</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://seawaylee.github.io/" title="Seawaylee" target="_blank">Seawaylee</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-star"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mosbyllc</span>

  
</div>











        







        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  


  

  

</body>
</html>
